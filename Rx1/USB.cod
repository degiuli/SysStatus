; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	e:\Tools\SysStatus\USB.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_08GGFKNFHG@?5?5?5?5?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_06GGLIPOFD@?5?5?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_04PFOHOKJK@?5?5?5?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0BC@BOFHLGPH@DeviceInLegacyHub?$AA@	; `string'
PUBLIC	??_C@_0BJ@CHELPMAC@DeviceHubNestedTooDeeply?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DBBHPJJC@DeviceNotEnoughBandwidth?$AA@ ; `string'
PUBLIC	??_C@_0BF@KCIAFGBC@DeviceNotEnoughPower?$AA@	; `string'
PUBLIC	??_C@_0BI@FHCONGJI@DeviceCausedOvercurrent?$AA@	; `string'
PUBLIC	??_C@_0BF@FIJIOADB@DeviceGeneralFailure?$AA@	; `string'
PUBLIC	??_C@_0BI@LKBNFKJE@DeviceFailedEnumeration?$AA@	; `string'
PUBLIC	??_C@_0BA@LIPCCNEI@DeviceConnected?$AA@		; `string'
PUBLIC	??_C@_0BC@CFJFKPGC@NoDeviceConnected?$AA@	; `string'
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BI@GFKFEIAL@?9?9?5USB?4PushBackDets?0?5?$CFs?$AA@ ; `string'
PUBLIC	?ConnectionStatuses@@3PAPADA			; ConnectionStatuses
PUBLIC	?UsbViewIndent@@3PAPADA				; UsbViewIndent
PUBLIC	??_C@_0P@JPOMJBKJ@?$DO?$DO?5USB?4EnumUSB?$AA@	; `string'
PUBLIC	??_C@_0N@JNFFEOEJ@cfgmgr32?4dll?$AA@		; `string'
PUBLIC	??_C@_0DE@MNEBEEPL@?$DM?$DM?5USB?4EnumUSB?0?5LoadLib?5cfgmgr32@ ; `string'
PUBLIC	??_C@_0O@CIKLALFP@CM_Get_Parent?$AA@		; `string'
PUBLIC	??_C@_0DI@OFIMABNG@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ ; `string'
PUBLIC	??_C@_0P@OOIACNHP@CM_Get_Sibling?$AA@		; `string'
PUBLIC	??_C@_0DJ@MMFCGNCK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ ; `string'
PUBLIC	??_C@_0N@EKPGFMC@CM_Get_Child?$AA@		; `string'
PUBLIC	??_C@_0DH@HAEGCLCE@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ ; `string'
PUBLIC	??_C@_0CC@NHFCMMFN@CM_Get_DevNode_Registry_Property@ ; `string'
PUBLIC	??_C@_0EL@DLHLJOM@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ ; `string'
PUBLIC	??_C@_0BD@FFDOPOAJ@CM_Locate_DevNodeA?$AA@	; `string'
PUBLIC	??_C@_0DM@DIBECLHK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Lo@ ; `string'
PUBLIC	??_C@_0O@BMIBGHPI@Enumerate?5USB?$AA@		; `string'
PUBLIC	??_C@_09PEILPPNA@?2?2?4?2HCD?$CFd?$AA@		; `string'
PUBLIC	??_C@_0N@BEFNEIBE@RootHub?5?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_07FOIBMAON@RootHub?$AA@			; `string'
PUBLIC	??_C@_0BL@FOIGIFIJ@Total?5Devices?5Connected?5?$CFu?$AA@ ; `string'
PUBLIC	??_C@_0P@NGAEOEJF@?$DM?$DM?5USB?4EnumUSB?$AA@	; `string'
PUBLIC	??_C@_0BA@EBIECMOG@?$DO?$DO?5USB?4DevsDets?$AA@	; `string'
PUBLIC	??_C@_0BD@HNIJLKOP@USB?5Device?5Details?$AA@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BA@GOKCLIBE@?$DM?$DM?5USB?4DevsDets?$AA@	; `string'
PUBLIC	??_C@_0BC@OBKJMAF@?$DO?$DO?5USB?4GetStrDesc?$AA@ ; `string'
PUBLIC	??_C@_0CJ@MLNPNNOJ@?$DM?$DM?5USB?4GetStrDesc?0?5DeviceIoContr@ ; `string'
PUBLIC	??_C@_0CA@JKPBCDKN@?$DM?$DM?5USB?4GetStrDesc?0?5Bytes?5Ret?5?$CFu?$AA@ ; `string'
PUBLIC	??_C@_0CH@ELGGMNKC@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Descripto@ ; `string'
PUBLIC	??_C@_0CD@CHKNKAPD@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Sz?5?$CFd?5?$DM?$DO?5@ ; `string'
PUBLIC	??_C@_0BN@ILBIFDNN@?$DM?$DM?5USB?4GetStrDesc?0?5Odd?5Sz?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CF@BKJLPKEL@?$DM?$DM?5USB?4GetStrDesc?0?5new?5DescNode?5@ ; `string'
PUBLIC	??_C@_0DF@ICOPDODD@?9?9?5USB?4GetStrDesc?0?5WideCharToMul@ ; `string'
PUBLIC	??_C@_0BP@BCHFPFAE@?$DM?$DM?5USB?4GetStrDesc?0?5DescNode?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0BF@IPAKKGGO@?$DO?$DO?5USB?4AreThrStrDesc?$AA@ ; `string'
PUBLIC	??_C@_0DC@KIEGOLFL@?$DM?$DM?5USB?4AreThrStrDesc?0?5Manufact?5?$CF@ ; `string'
PUBLIC	??_C@_0BN@DEJJKGAD@?$DM?$DM?5USB?4AreThrStrDesc?0?5Cfg?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CD@NAENOJMA@?$DM?$DM?5USB?4AreThrStrDesc?0?5Interface?5@ ; `string'
PUBLIC	??_C@_0CA@JFAJNON@?$DM?$DM?5USB?4AreThrStrDesc?0?5Ret?5False?$AA@ ; `string'
PUBLIC	??_C@_0BG@PLIGAJPI@?$DO?$DO?5USB?4GetAllStrDescs?$AA@ ; `string'
PUBLIC	??_C@_0CJ@HBMGBPGH@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@ ; `string'
PUBLIC	??_C@_0CH@IFDPMHNA@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@ ; `string'
PUBLIC	??_C@_0BF@GLJHIDAC@?$DO?$DO?5USB?4GetDrvKeyName?$AA@ ; `string'
PUBLIC	??_C@_0DA@OGKODAJE@?9?9?5USB?4GetDriverKeyName?0?5new?5Key@ ; `string'
PUBLIC	??_C@_0BP@IAFNNICI@?$DM?$DM?5USB?4GetDrvKeyName?0?5AName?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0BE@BDIOPGJF@?$DO?$DO?5USB?4GetExternHub?$AA@ ; `string'
PUBLIC	??_C@_0DA@HJNGPFIB@?9?9?5USB?4GetExtHubName?0?5new?5extHub@ ; `string'
PUBLIC	??_C@_0CA@PKLCHKGO@?$DM?$DM?5USB?4GetExternHub?0?5HubName?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0BE@CPBFJJJ@?$DO?$DO?5USB?4EnumHubPorts?$AA@ ; `string'
PUBLIC	??_C@_0DE@EKAJALEI@?9?9?5USB?4EnumHubPorts?0?5new?5Port?5?$CFd@ ; `string'
PUBLIC	??_C@_0M@PONEPIOA@?$CFs?$FLPort?$CFd?$FN?5?$AA@	; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_09IBNJMOOD@?$FLPort?$CFd?$FN?5?$AA@	; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@		; `string'
PUBLIC	??_C@_04PKDHFCJF@HIGH?$AA@			; `string'
PUBLIC	??_C@_03IBEFMGAI@LOW?$AA@			; `string'
PUBLIC	??_C@_04DHPBCODG@FULL?$AA@			; `string'
PUBLIC	??_C@_0CF@LGIDNAEF@?$CFs?5?$FLVID?3?$CF?44X?5PID?3?$CF?44X?5SN?3?$CFs?5Spd?3@ ; `string'
PUBLIC	??_C@_0BA@CGBIAJFO@Not?5Initialized?$AA@	; `string'
PUBLIC	??_C@_09CFCBFJND@Not?5Found?$AA@		; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BE@LMILCJOE@?$DM?$DM?5USB?4EnumHubPorts?$AA@ ; `string'
PUBLIC	??_C@_0BP@KMJAGKHH@?$DO?$DO?5USB?4DrvName2DevDesc?0?5Drv?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PHHANNLH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5LocateDe@ ; `string'
PUBLIC	??_C@_0BP@BAEOHBIH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5ret?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0CO@BAPAALJK@?$DM?$DM?5USB?4DrvName2DevDesc?0?5GetDevNo@ ; `string'
PUBLIC	??_C@_0CB@OFAOPKJL@?$DM?$DM?5USB?4DrvName2DevDesc?0?5Ret?5Null@ ; `string'
PUBLIC	??_C@_0P@JENLAABL@?$DO?$DO?5USB?4EnumHub?$AA@	; `string'
PUBLIC	??_C@_04GBDIODIA@?2?2?4?2?$AA@			; `string'
PUBLIC	??_C@_0DB@MFBNHHNK@?9?9?5USB?4EnumHub?0?5new?5Pntr?5for?5Dev@ ; `string'
PUBLIC	??_C@_04MKEDFNGB@?5?3?5?5?$AA@			; `string'
PUBLIC	??_C@_0CG@FMONKKAG@?9?9?5USB?4EnumHub?0?5new?5HubInfo?5?$CI?$CFu?$CJ@ ; `string'
PUBLIC	??_C@_0CD@EDMNKMD@?9?9?5USB?4EnumHub?0?5new?5Info?5?$CI?$CFu?$CJ?5nu@ ; `string'
PUBLIC	??_C@_0P@NNDDHFCH@?$DM?$DM?5USB?4EnumHub?$AA@	; `string'
PUBLIC	??_C@_0BC@PGMOMHHM@?$DO?$DO?5USB?4GetRootHub?$AA@ ; `string'
PUBLIC	??_C@_0BO@LDLFLMCA@?$DM?$DM?5USB?4GetRootHub?0?5HubName?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0BI@LFJMJGOI@?$DO?$DO?5USB?4GetHCDDrvKeyName?$AA@ ; `string'
PUBLIC	??_C@_0CH@BGNGLHKH@?$DM?$DM?5USB?4GetHCDDrvKeyName?0?5DrvKeyN@ ; `string'
PUBLIC	??_C@_0BD@HEHGMECG@?$DO?$DO?5USB?4GetStrDescs?$AA@ ; `string'
PUBLIC	??_C@_0CH@BBKGOLN@?$DM?$DM?5USB?4GetStrDescs?0?5StrDescNodeT@ ; `string'
PUBLIC	??_C@_0BC@NBPLLDOB@?$DO?$DO?5USB?4GetCfgDesc?$AA@ ; `string'
PUBLIC	??_C@_0CJ@JPCNJMBL@?$DM?$DM?5USB?4GetCfgDesc?0?5DeviceIoContr@ ; `string'
PUBLIC	??_C@_0CL@CHLLBENA@?$DM?$DM?5USB?4GetCfgDesc?0?5Bytes?5?$CFu?5?$DM?$DO?5B@ ; `string'
PUBLIC	??_C@_0CL@LLJEBADN@?$DM?$DM?5USB?4GetCfgDesc?0?5Total?5?$CFd?5?$DM?5Sz@ ; `string'
PUBLIC	??_C@_0CN@FDNPACDH@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5DeviceIoC@ ; `string'
PUBLIC	??_C@_0CP@JDNANMP@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Bytes?5?$CFu?5@ ; `string'
PUBLIC	??_C@_0CI@LMLHDIHD@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Total?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CL@LPDCGPEM@?9?9?5USB?4GetCfgDescriptor?0?5new?5Buf@ ; `string'
PUBLIC	??_C@_0BG@INDEEKLB@?$DM?$DM?5USB?4GetCfgDesc?0?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0P@GOACPFJP@?$DO?$DO?5USB?4HubInfo?$AA@	; `string'
PUBLIC	??_C@_09GDHNALJA@Bus?5Power?$AA@		; `string'
PUBLIC	??_C@_0L@JDJFLKOD@Self?5Power?$AA@		; `string'
PUBLIC	??_C@_0BA@KPNNFMHH@?$DO?5Hub?5Power?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BG@IOHBDCFM@?$DO?5Number?5of?5Ports?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BK@CEEHKAND@?$DO?5Power?5switching?3?5Ganged?$AA@ ; `string'
PUBLIC	??_C@_0BO@BHNNAPDB@?$DO?5Power?5switching?3?5Individual?$AA@ ; `string'
PUBLIC	??_C@_0BI@FICFFJGB@?$DO?5Power?5switching?3?5None?$AA@ ; `string'
PUBLIC	??_C@_0BG@FBGEODEL@?$DO?5Compound?5device?3?5No?$AA@ ; `string'
PUBLIC	??_C@_0BH@CFBEDMDO@?$DO?5Compound?5device?3?5Yes?$AA@ ; `string'
PUBLIC	??_C@_0CC@ELIAJJDL@?$DO?5Over?9current?5Protection?3?5Globa@ ; `string'
PUBLIC	??_C@_0CG@MEGDLCFA@?$DO?5Over?9current?5Protection?3?5Indiv@ ; `string'
PUBLIC	??_C@_0CO@FGJIHOLC@?$DO?5No?5Over?9current?5Protection?5?$CIBu@ ; `string'
PUBLIC	??_C@_0P@CHOKIAKD@?$DM?$DM?5USB?4HubInfo?$AA@	; `string'
PUBLIC	??_C@_0P@ICANHPPH@?$DO?$DO?5USB?4HubCaps?$AA@	; `string'
PUBLIC	??_C@_0CI@KPNJBEAB@?$DO?5Extended?5Hub?5Capability?5Flags?3@ ; `string'
PUBLIC	??_C@_0BL@GGCJII@?$DO?5?5?5High?5speed?5Capable?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BD@FCCHMOKD@?$DO?5?5?5High?5speed?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CC@CJLCKEMN@?$DO?5?5?5Mulit?9transaction?5Capable?3?5?$CF@ ; `string'
PUBLIC	??_C@_02IAAGKKDJ@On?$AA@			; `string'
PUBLIC	??_C@_03GCDBBDDL@Off?$AA@			; `string'
PUBLIC	??_C@_0BK@JNPMKCLE@?$DO?5?5?5Mulit?9transaction?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BB@BIGCJPGA@?$DO?5?5?5Root?5hub?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CC@EBPNDPBD@?$DO?5?5?5Armed?5for?5wake?5on?5connect?3?5?$CF@ ; `string'
PUBLIC	??_C@_0BP@LBBGDALG@?$DO?5?5?5Reserved?5?$CI26?5bits?$CJ?3?5?$CF0?$CD6lx?$AA@ ; `string'
PUBLIC	??_C@_0CG@OCCHEKHL@Extended?5Hub?5Capabilities?5UNAVAI@ ; `string'
PUBLIC	??_C@_0L@BGKBMIAF@High?5speed?$AA@		; `string'
PUBLIC	??_C@_0P@LDNEGAOE@Not?5high?5speed?$AA@		; `string'
PUBLIC	??_C@_0CA@BJAEENFA@?$DO?5Hub?5Capabilities?3?5?$CF0?$CD8lx?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BN@HMIILDFE@Hub?5Capabilities?5UNAVAILABLE?$AA@ ; `string'
PUBLIC	??_C@_0P@MLOFAKML@?$DM?$DM?5USB?4HubCaps?$AA@	; `string'
PUBLIC	??_C@_0BA@IJBIPHPI@?$DO?$DO?5USB?4ConnInfo?$AA@	; `string'
PUBLIC	??_C@_0BM@GIKFEJKI@?$DM?$DM?5USB?4ConnInfo?0?5Input?5null?$AA@ ; `string'
PUBLIC	??_C@_0CG@KIPJNEMD@?$DO?5ConnectionStatus?3?5NoDeviceConn@ ; `string'
PUBLIC	??_C@_0BF@EPIIACIH@?$DO?5Device?5Descriptor?3?$AA@ ; `string'
PUBLIC	??_C@_0BD@EOGCPDGC@?$DO?5?5?5bcdUSB?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BBNICMHO@?$DO?5?5?5bDeviceClass?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BM@IBBMEPAK@?$DO?5?5?5bDeviceSubClass?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BM@DONCAOLL@?$DO?5?5?5bDeviceProtocol?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0CB@KJHHAJF@?$DO?5?5?5bMaxPacketSize0?3?50x?$CF02X?5?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0BK@FCNKAGPN@?$DO?5?5?5idVendor?3?50x?$CF04X?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BG@FEBFICPG@?$DO?5?5?5idProduct?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BG@IFDGHCDF@?$DO?5?5?5bcdDevice?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BK@IFOFIIGL@?$DO?5?5?5iManufacturer?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BF@JLHEPLOO@?$DO?5?5?5iProduct?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BK@LAPCHIKM@?$DO?5?5?5iSerialNumber?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BP@EFEAMJPP@?$DO?5?5?5bNumConfigurations?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BJ@POKCFGAN@?$DO?5?5?5ConnectionStatus?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CB@CNIJGGK@?$DO?5?5?5Current?5Config?5Value?3?50x?$CF02X@ ; `string'
PUBLIC	??_C@_0BK@CLDGMCFC@?$DO?5?5?5Device?5Bus?5Speed?3?5Low?$AA@ ; `string'
PUBLIC	??_C@_0BL@CJGBMBHK@?$DO?5?5?5Device?5Bus?5Speed?3?5Full?$AA@ ; `string'
PUBLIC	??_C@_0BL@OEKHLNNJ@?$DO?5?5?5Device?5Bus?5Speed?3?5High?$AA@ ; `string'
PUBLIC	??_C@_0BO@IIJPBIOD@?$DO?5?5?5Device?5Bus?5Speed?3?5Unknown?$AA@ ; `string'
PUBLIC	??_C@_0BL@DEBOODEI@?$DO?5?5?5Device?5Address?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BF@BAEOANMA@?$DO?5?5?5Open?5Pipes?3?5?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0BA@KGDOGDAK@?$DM?$DM?5USB?4ConnInfo?$AA@	; `string'
PUBLIC	??_C@_0BE@MPHLOHIN@?$DO?$DO?5USB?4PipeInfo?0?5?$CFu?$AA@ ; `string'
PUBLIC	??_C@_0BA@KIDKADGJ@?$DM?$DM?5USB?4PipeInfo?$AA@	; `string'
PUBLIC	??_C@_0BA@BANBJKNP@?$DO?$DO?5USB?4ConnDesc?$AA@	; `string'
PUBLIC	??_C@_0BM@HNNAHBOO@?$DM?$DM?5USB?4ConnDesc?0?5Input?5null?$AA@ ; `string'
PUBLIC	??_C@_0BA@DPPHAOCN@?$DM?$DM?5USB?4ConnDesc?$AA@	; `string'
PUBLIC	??_C@_0P@KMFKJDAO@?$DO?$DO?5USB?4CfgDesc?$AA@	; `string'
PUBLIC	??_C@_0BM@PCIMCBFD@?$DO?5Configuration?5Descriptor?3?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JBGKFDNL@?$DO?5?5?5wTotalLength?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BL@JNHEPBEN@?$DO?5?5?5bNumInterfaces?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0CA@KHMLNGHE@?$DO?5?5?5bConfigurationValue?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BL@MGNBONG@?$DO?5?5?5iConfiguration?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0M@KJBOJHIH@Bus?5Powered?$AA@		; `string'
PUBLIC	??_C@_0N@BBGKMOEA@Self?5Powered?$AA@		; `string'
PUBLIC	??_C@_0O@CEMJPFOE@Remote?5Wakeup?$AA@		; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@			; `string'
PUBLIC	??_C@_0BO@GBBHCHCO@?$DO?5?5?5bmAttributes?3?50x?$CF02X?5?$CI?$CFs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BN@BADCCJC@?$DO?5?5?5MaxPower?3?50x?$CF02X?5?$CI?$CFd?5mA?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0P@OFLCOGDC@?$DM?$DM?5USB?4CfgDesc?$AA@	; `string'
PUBLIC	??_C@_0BF@FGFFFEAJ@?$DO?$DO?5USB?4InterfaceDesc?$AA@ ; `string'
PUBLIC	??_C@_0BI@FGHPJGGP@?$DO?5Interface?5Descriptor?3?$AA@ ; `string'
PUBLIC	??_C@_0BN@ONGOLDBE@?$DO?5?5?5bInterfaceNumber?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BO@JANOLKEO@?$DO?5?5?5bAlternateSetting?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BK@EHJBAMGD@?$DO?5?5?5bNumEndpoints?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_05KKCMAPLJ@Audio?$AA@			; `string'
PUBLIC	??_C@_03GLEFGMHP@HID?$AA@			; `string'
PUBLIC	??_C@_03IFOKPDKP@Hub?$AA@			; `string'
PUBLIC	??_C@_0CB@KPEKNPLO@?$DO?5?5?5bInterfaceClass?3?50x?$CF02X?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0O@FIEMGMDK@Audio?5Control?$AA@		; `string'
PUBLIC	??_C@_0BA@CCICINDB@Audio?5Streaming?$AA@	; `string'
PUBLIC	??_C@_0P@ODBCJCKO@MIDI?5Streaming?$AA@		; `string'
PUBLIC	??_C@_0CE@PEKAFJHJ@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?5?$CI@ ; `string'
PUBLIC	??_C@_0BP@MCCALMMN@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BP@HNOOPNHM@?$DO?5?5?5bInterfaceProtocol?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BH@JAJKJCLD@?$DO?5?5?5iInterface?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BI@MFPCCAIN@?$DO?5?5?5wNumClasses?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BF@HIFPCDPI@?$DM?$DM?5USB?4InterfaceDesc?$AA@ ; `string'
PUBLIC	??_C@_0BE@BNJCNLHH@?$DO?$DO?5USB?4EndpointDesc?$AA@ ; `string'
PUBLIC	??_C@_0BH@NNPPCJHP@?$DO?5Endpoint?5Descriptor?3?$AA@ ; `string'
PUBLIC	??_C@_0CA@IMJGHBI@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5IN?$AA@ ; `string'
PUBLIC	??_C@_0CB@PIKLNKCM@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5OUT@ ; `string'
PUBLIC	??_C@_0BL@ICIOMPJC@?$DO?5?5?5Transfer?5Type?3?5Control?$AA@ ; `string'
PUBLIC	??_C@_0BP@DMDNFJME@?$DO?5?5?5Transfer?5Type?3?5Isochronous?$AA@ ; `string'
PUBLIC	??_C@_0BI@ELEHNLID@?$DO?5?5?5Transfer?5Type?3?5Bulk?$AA@ ; `string'
PUBLIC	??_C@_0BN@MOOEBEKA@?$DO?5?5?5Transfer?5Type?3?5Interrupt?$AA@ ; `string'
PUBLIC	??_C@_0CA@OFHICAPC@?$DO?5?5?5wMaxPacketSize?3?50x?$CF04X?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BG@LPGMHCMJ@?$DO?5?5?5bInterval?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BG@HBLIDDIE@?$DO?5?5?5wInterval?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CECFOBBD@?$DO?5?5?5bSyncAddress?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BE@KDOIKLAK@?$DM?$DM?5USB?4EndpointDesc?$AA@ ; `string'
PUBLIC	??_C@_0P@IBOMINBP@?$DO?$DO?5USB?4HidDesc?$AA@	; `string'
PUBLIC	??_C@_0BC@FKMEKGFJ@?$DO?5HID?5Descriptor?3?$AA@	; `string'
PUBLIC	??_C@_0BD@JNJCPDHI@?$DO?5?5?5bcdHID?3?50x?$CF04X?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CKIDJFBI@?$DO?5?5?5bCountryCode?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BM@MKJBFMNP@?$DO?5?5?5bNumDescriptors?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0DN@JAEDHMBE@?$DO?5?5?5?$CF?43i?0?5bDescriptorType?3?50x?$CF02@ ; `string'
PUBLIC	??_C@_0P@MIAEPICD@?$DM?$DM?5USB?4HidDesc?$AA@	; `string'
PUBLIC	??_C@_0BH@LCHICFEL@?$DO?$DO?5USB?4StrDesc?0?5Idx?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0P@CCEKBNHE@?$DO?5?5?50x?$CF04X?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0P@DKFDMJNG@?$DM?$DM?5USB?4StrDesc?$AA@	; `string'
PUBLIC	??_C@_0BD@LEEGFGLN@?$DO?$DO?5USB?4UnknownDesc?$AA@ ; `string'
PUBLIC	??_C@_0BG@FBFGEGLK@?$DO?5Unknown?5Descriptor?3?$AA@ ; `string'
PUBLIC	??_C@_0BM@HOMJLHIG@?$DO?5?5?5bDescriptorType?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_0BE@PKPADJND@?$DO?5?5?5bLength?3?50x?$CF02X?$AA@ ; `string'
PUBLIC	??_C@_04CKDHMDHJ@?$DO?5?5?5?$AA@		; `string'
PUBLIC	??_C@_07GHOKFMCD@?$CFs?4?$CF02X?$AA@		; `string'
PUBLIC	??_C@_0BD@MFCGDLMP@?$DM?$DM?5USB?4UnknownDesc?$AA@ ; `string'
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
;	COMDAT ??_C@_0BD@MFCGDLMP@?$DM?$DM?5USB?4UnknownDesc?$AA@
CONST	SEGMENT
??_C@_0BD@MFCGDLMP@?$DM?$DM?5USB?4UnknownDesc?$AA@ DB '<< USB.UnknownDesc'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHOKFMCD@?$CFs?4?$CF02X?$AA@
CONST	SEGMENT
??_C@_07GHOKFMCD@?$CFs?4?$CF02X?$AA@ DB '%s.%02X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKDHMDHJ@?$DO?5?5?5?$AA@
CONST	SEGMENT
??_C@_04CKDHMDHJ@?$DO?5?5?5?$AA@ DB '>   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PKPADJND@?$DO?5?5?5bLength?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BE@PKPADJND@?$DO?5?5?5bLength?3?50x?$CF02X?$AA@ DB '>   bLength: 0'
	DB	'x%02X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HOMJLHIG@?$DO?5?5?5bDescriptorType?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BM@HOMJLHIG@?$DO?5?5?5bDescriptorType?3?50x?$CF02X?$AA@ DB '>   bD'
	DB	'escriptorType: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FBFGEGLK@?$DO?5Unknown?5Descriptor?3?$AA@
CONST	SEGMENT
??_C@_0BG@FBFGEGLK@?$DO?5Unknown?5Descriptor?3?$AA@ DB '> Unknown Descrip'
	DB	'tor:', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LEEGFGLN@?$DO?$DO?5USB?4UnknownDesc?$AA@
CONST	SEGMENT
??_C@_0BD@LEEGFGLN@?$DO?$DO?5USB?4UnknownDesc?$AA@ DB '>> USB.UnknownDesc'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKFDMJNG@?$DM?$DM?5USB?4StrDesc?$AA@
CONST	SEGMENT
??_C@_0P@DKFDMJNG@?$DM?$DM?5USB?4StrDesc?$AA@ DB '<< USB.StrDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CCEKBNHE@?$DO?5?5?50x?$CF04X?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@CCEKBNHE@?$DO?5?5?50x?$CF04X?3?5?$CFs?$AA@ DB '>   0x%04X: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LCHICFEL@?$DO?$DO?5USB?4StrDesc?0?5Idx?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BH@LCHICFEL@?$DO?$DO?5USB?4StrDesc?0?5Idx?5?$CFd?$AA@ DB '>> USB.S'
	DB	'trDesc, Idx %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIAEPICD@?$DM?$DM?5USB?4HidDesc?$AA@
CONST	SEGMENT
??_C@_0P@MIAEPICD@?$DM?$DM?5USB?4HidDesc?$AA@ DB '<< USB.HidDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JAEDHMBE@?$DO?5?5?5?$CF?43i?0?5bDescriptorType?3?50x?$CF02@
CONST	SEGMENT
??_C@_0DN@JAEDHMBE@?$DO?5?5?5?$CF?43i?0?5bDescriptorType?3?50x?$CF02@ DB '>'
	DB	'   %.3i, bDescriptorType: 0x%02X, wDescriptorLength: 0x%04X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MKJBFMNP@?$DO?5?5?5bNumDescriptors?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BM@MKJBFMNP@?$DO?5?5?5bNumDescriptors?3?50x?$CF02X?$AA@ DB '>   bN'
	DB	'umDescriptors: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CKIDJFBI@?$DO?5?5?5bCountryCode?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BJ@CKIDJFBI@?$DO?5?5?5bCountryCode?3?50x?$CF02X?$AA@ DB '>   bCoun'
	DB	'tryCode: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JNJCPDHI@?$DO?5?5?5bcdHID?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BD@JNJCPDHI@?$DO?5?5?5bcdHID?3?50x?$CF04X?$AA@ DB '>   bcdHID: 0x%'
	DB	'04X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKMEKGFJ@?$DO?5HID?5Descriptor?3?$AA@
CONST	SEGMENT
??_C@_0BC@FKMEKGFJ@?$DO?5HID?5Descriptor?3?$AA@ DB '> HID Descriptor:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IBOMINBP@?$DO?$DO?5USB?4HidDesc?$AA@
CONST	SEGMENT
??_C@_0P@IBOMINBP@?$DO?$DO?5USB?4HidDesc?$AA@ DB '>> USB.HidDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDOIKLAK@?$DM?$DM?5USB?4EndpointDesc?$AA@
CONST	SEGMENT
??_C@_0BE@KDOIKLAK@?$DM?$DM?5USB?4EndpointDesc?$AA@ DB '<< USB.EndpointDe'
	DB	'sc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CECFOBBD@?$DO?5?5?5bSyncAddress?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BJ@CECFOBBD@?$DO?5?5?5bSyncAddress?3?50x?$CF02X?$AA@ DB '>   bSync'
	DB	'Address: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HBLIDDIE@?$DO?5?5?5wInterval?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BG@HBLIDDIE@?$DO?5?5?5wInterval?3?50x?$CF04X?$AA@ DB '>   wInterva'
	DB	'l: 0x%04X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LPGMHCMJ@?$DO?5?5?5bInterval?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BG@LPGMHCMJ@?$DO?5?5?5bInterval?3?50x?$CF02X?$AA@ DB '>   bInterva'
	DB	'l: 0x%02X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OFHICAPC@?$DO?5?5?5wMaxPacketSize?3?50x?$CF04X?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@OFHICAPC@?$DO?5?5?5wMaxPacketSize?3?50x?$CF04X?5?$CI?$CFd?$CJ?$AA@ DB '>'
	DB	'   wMaxPacketSize: 0x%04X (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MOOEBEKA@?$DO?5?5?5Transfer?5Type?3?5Interrupt?$AA@
CONST	SEGMENT
??_C@_0BN@MOOEBEKA@?$DO?5?5?5Transfer?5Type?3?5Interrupt?$AA@ DB '>   Tra'
	DB	'nsfer Type: Interrupt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ELEHNLID@?$DO?5?5?5Transfer?5Type?3?5Bulk?$AA@
CONST	SEGMENT
??_C@_0BI@ELEHNLID@?$DO?5?5?5Transfer?5Type?3?5Bulk?$AA@ DB '>   Transfer'
	DB	' Type: Bulk', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DMDNFJME@?$DO?5?5?5Transfer?5Type?3?5Isochronous?$AA@
CONST	SEGMENT
??_C@_0BP@DMDNFJME@?$DO?5?5?5Transfer?5Type?3?5Isochronous?$AA@ DB '>   T'
	DB	'ransfer Type: Isochronous', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ICIOMPJC@?$DO?5?5?5Transfer?5Type?3?5Control?$AA@
CONST	SEGMENT
??_C@_0BL@ICIOMPJC@?$DO?5?5?5Transfer?5Type?3?5Control?$AA@ DB '>   Trans'
	DB	'fer Type: Control', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PIKLNKCM@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5OUT@
CONST	SEGMENT
??_C@_0CB@PIKLNKCM@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5OUT@ DB '>   '
	DB	'bEndpointAddress: 0x%02X OUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IMJGHBI@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5IN?$AA@
CONST	SEGMENT
??_C@_0CA@IMJGHBI@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5IN?$AA@ DB '> '
	DB	'  bEndpointAddress: 0x%02X IN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NNPPCJHP@?$DO?5Endpoint?5Descriptor?3?$AA@
CONST	SEGMENT
??_C@_0BH@NNPPCJHP@?$DO?5Endpoint?5Descriptor?3?$AA@ DB '> Endpoint Descr'
	DB	'iptor:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNJCNLHH@?$DO?$DO?5USB?4EndpointDesc?$AA@
CONST	SEGMENT
??_C@_0BE@BNJCNLHH@?$DO?$DO?5USB?4EndpointDesc?$AA@ DB '>> USB.EndpointDe'
	DB	'sc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HIFPCDPI@?$DM?$DM?5USB?4InterfaceDesc?$AA@
CONST	SEGMENT
??_C@_0BF@HIFPCDPI@?$DM?$DM?5USB?4InterfaceDesc?$AA@ DB '<< USB.Interface'
	DB	'Desc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFPCCAIN@?$DO?5?5?5wNumClasses?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BI@MFPCCAIN@?$DO?5?5?5wNumClasses?3?50x?$CF04X?$AA@ DB '>   wNumCl'
	DB	'asses: 0x%04X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JAJKJCLD@?$DO?5?5?5iInterface?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BH@JAJKJCLD@?$DO?5?5?5iInterface?3?50x?$CF02X?$AA@ DB '>   iInterf'
	DB	'ace: 0x%02X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HNOOPNHM@?$DO?5?5?5bInterfaceProtocol?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BP@HNOOPNHM@?$DO?5?5?5bInterfaceProtocol?3?50x?$CF02X?$AA@ DB '>  '
	DB	' bInterfaceProtocol: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MCCALMMN@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BP@MCCALMMN@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?$AA@ DB '>  '
	DB	' bInterfaceSubClass: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PEKAFJHJ@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?5?$CI@
CONST	SEGMENT
??_C@_0CE@PEKAFJHJ@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?5?$CI@ DB '>'
	DB	'   bInterfaceSubClass: 0x%02X (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ODBCJCKO@MIDI?5Streaming?$AA@
CONST	SEGMENT
??_C@_0P@ODBCJCKO@MIDI?5Streaming?$AA@ DB 'MIDI Streaming', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CCICINDB@Audio?5Streaming?$AA@
CONST	SEGMENT
??_C@_0BA@CCICINDB@Audio?5Streaming?$AA@ DB 'Audio Streaming', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FIEMGMDK@Audio?5Control?$AA@
CONST	SEGMENT
??_C@_0O@FIEMGMDK@Audio?5Control?$AA@ DB 'Audio Control', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KPEKNPLO@?$DO?5?5?5bInterfaceClass?3?50x?$CF02X?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0CB@KPEKNPLO@?$DO?5?5?5bInterfaceClass?3?50x?$CF02X?5?$CI?$CFs?$CJ@ DB '>'
	DB	'   bInterfaceClass: 0x%02X (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFOKPDKP@Hub?$AA@
CONST	SEGMENT
??_C@_03IFOKPDKP@Hub?$AA@ DB 'Hub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GLEFGMHP@HID?$AA@
CONST	SEGMENT
??_C@_03GLEFGMHP@HID?$AA@ DB 'HID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCMAPLJ@Audio?$AA@
CONST	SEGMENT
??_C@_05KKCMAPLJ@Audio?$AA@ DB 'Audio', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EHJBAMGD@?$DO?5?5?5bNumEndpoints?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BK@EHJBAMGD@?$DO?5?5?5bNumEndpoints?3?50x?$CF02X?$AA@ DB '>   bNum'
	DB	'Endpoints: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JANOLKEO@?$DO?5?5?5bAlternateSetting?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BO@JANOLKEO@?$DO?5?5?5bAlternateSetting?3?50x?$CF02X?$AA@ DB '>   '
	DB	'bAlternateSetting: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ONGOLDBE@?$DO?5?5?5bInterfaceNumber?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BN@ONGOLDBE@?$DO?5?5?5bInterfaceNumber?3?50x?$CF02X?$AA@ DB '>   b'
	DB	'InterfaceNumber: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FGHPJGGP@?$DO?5Interface?5Descriptor?3?$AA@
CONST	SEGMENT
??_C@_0BI@FGHPJGGP@?$DO?5Interface?5Descriptor?3?$AA@ DB '> Interface Des'
	DB	'criptor:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FGFFFEAJ@?$DO?$DO?5USB?4InterfaceDesc?$AA@
CONST	SEGMENT
??_C@_0BF@FGFFFEAJ@?$DO?$DO?5USB?4InterfaceDesc?$AA@ DB '>> USB.Interface'
	DB	'Desc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OFLCOGDC@?$DM?$DM?5USB?4CfgDesc?$AA@
CONST	SEGMENT
??_C@_0P@OFLCOGDC@?$DM?$DM?5USB?4CfgDesc?$AA@ DB '<< USB.CfgDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BADCCJC@?$DO?5?5?5MaxPower?3?50x?$CF02X?5?$CI?$CFd?5mA?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@BADCCJC@?$DO?5?5?5MaxPower?3?50x?$CF02X?5?$CI?$CFd?5mA?$CJ?$AA@ DB '>'
	DB	'   MaxPower: 0x%02X (%d mA)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GBBHCHCO@?$DO?5?5?5bmAttributes?3?50x?$CF02X?5?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@GBBHCHCO@?$DO?5?5?5bmAttributes?3?50x?$CF02X?5?$CI?$CFs?$CJ?$AA@ DB '>'
	DB	'   bmAttributes: 0x%02X (%s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CEMJPFOE@Remote?5Wakeup?$AA@
CONST	SEGMENT
??_C@_0O@CEMJPFOE@Remote?5Wakeup?$AA@ DB 'Remote Wakeup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBGKMOEA@Self?5Powered?$AA@
CONST	SEGMENT
??_C@_0N@BBGKMOEA@Self?5Powered?$AA@ DB 'Self Powered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KJBOJHIH@Bus?5Powered?$AA@
CONST	SEGMENT
??_C@_0M@KJBOJHIH@Bus?5Powered?$AA@ DB 'Bus Powered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MGNBONG@?$DO?5?5?5iConfiguration?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BL@MGNBONG@?$DO?5?5?5iConfiguration?3?50x?$CF02X?$AA@ DB '>   iCon'
	DB	'figuration: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KHMLNGHE@?$DO?5?5?5bConfigurationValue?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0CA@KHMLNGHE@?$DO?5?5?5bConfigurationValue?3?50x?$CF02X?$AA@ DB '> '
	DB	'  bConfigurationValue: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JNHEPBEN@?$DO?5?5?5bNumInterfaces?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BL@JNHEPBEN@?$DO?5?5?5bNumInterfaces?3?50x?$CF02X?$AA@ DB '>   bNu'
	DB	'mInterfaces: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JBGKFDNL@?$DO?5?5?5wTotalLength?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BJ@JBGKFDNL@?$DO?5?5?5wTotalLength?3?50x?$CF04X?$AA@ DB '>   wTota'
	DB	'lLength: 0x%04X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PCIMCBFD@?$DO?5Configuration?5Descriptor?3?$AA@
CONST	SEGMENT
??_C@_0BM@PCIMCBFD@?$DO?5Configuration?5Descriptor?3?$AA@ DB '> Configura'
	DB	'tion Descriptor:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMFKJDAO@?$DO?$DO?5USB?4CfgDesc?$AA@
CONST	SEGMENT
??_C@_0P@KMFKJDAO@?$DO?$DO?5USB?4CfgDesc?$AA@ DB '>> USB.CfgDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPPHAOCN@?$DM?$DM?5USB?4ConnDesc?$AA@
CONST	SEGMENT
??_C@_0BA@DPPHAOCN@?$DM?$DM?5USB?4ConnDesc?$AA@ DB '<< USB.ConnDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HNNAHBOO@?$DM?$DM?5USB?4ConnDesc?0?5Input?5null?$AA@
CONST	SEGMENT
??_C@_0BM@HNNAHBOO@?$DM?$DM?5USB?4ConnDesc?0?5Input?5null?$AA@ DB '<< USB'
	DB	'.ConnDesc, Input null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BANBJKNP@?$DO?$DO?5USB?4ConnDesc?$AA@
CONST	SEGMENT
??_C@_0BA@BANBJKNP@?$DO?$DO?5USB?4ConnDesc?$AA@ DB '>> USB.ConnDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KIDKADGJ@?$DM?$DM?5USB?4PipeInfo?$AA@
CONST	SEGMENT
??_C@_0BA@KIDKADGJ@?$DM?$DM?5USB?4PipeInfo?$AA@ DB '<< USB.PipeInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPHLOHIN@?$DO?$DO?5USB?4PipeInfo?0?5?$CFu?$AA@
CONST	SEGMENT
??_C@_0BE@MPHLOHIN@?$DO?$DO?5USB?4PipeInfo?0?5?$CFu?$AA@ DB '>> USB.PipeI'
	DB	'nfo, %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KGDOGDAK@?$DM?$DM?5USB?4ConnInfo?$AA@
CONST	SEGMENT
??_C@_0BA@KGDOGDAK@?$DM?$DM?5USB?4ConnInfo?$AA@ DB '<< USB.ConnInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BAEOANMA@?$DO?5?5?5Open?5Pipes?3?5?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BF@BAEOANMA@?$DO?5?5?5Open?5Pipes?3?5?$CF02d?$AA@ DB '>   Open Pip'
	DB	'es: %02d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DEBOODEI@?$DO?5?5?5Device?5Address?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BL@DEBOODEI@?$DO?5?5?5Device?5Address?3?50x?$CF02X?$AA@ DB '>   De'
	DB	'vice Address: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IIJPBIOD@?$DO?5?5?5Device?5Bus?5Speed?3?5Unknown?$AA@
CONST	SEGMENT
??_C@_0BO@IIJPBIOD@?$DO?5?5?5Device?5Bus?5Speed?3?5Unknown?$AA@ DB '>   D'
	DB	'evice Bus Speed: Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OEKHLNNJ@?$DO?5?5?5Device?5Bus?5Speed?3?5High?$AA@
CONST	SEGMENT
??_C@_0BL@OEKHLNNJ@?$DO?5?5?5Device?5Bus?5Speed?3?5High?$AA@ DB '>   Devi'
	DB	'ce Bus Speed: High', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CJGBMBHK@?$DO?5?5?5Device?5Bus?5Speed?3?5Full?$AA@
CONST	SEGMENT
??_C@_0BL@CJGBMBHK@?$DO?5?5?5Device?5Bus?5Speed?3?5Full?$AA@ DB '>   Devi'
	DB	'ce Bus Speed: Full', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CLDGMCFC@?$DO?5?5?5Device?5Bus?5Speed?3?5Low?$AA@
CONST	SEGMENT
??_C@_0BK@CLDGMCFC@?$DO?5?5?5Device?5Bus?5Speed?3?5Low?$AA@ DB '>   Devic'
	DB	'e Bus Speed: Low', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CNIJGGK@?$DO?5?5?5Current?5Config?5Value?3?50x?$CF02X@
CONST	SEGMENT
??_C@_0CB@CNIJGGK@?$DO?5?5?5Current?5Config?5Value?3?50x?$CF02X@ DB '>   '
	DB	'Current Config Value: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@POKCFGAN@?$DO?5?5?5ConnectionStatus?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@POKCFGAN@?$DO?5?5?5ConnectionStatus?3?5?$CFs?$AA@ DB '>   Conne'
	DB	'ctionStatus: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EFEAMJPP@?$DO?5?5?5bNumConfigurations?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BP@EFEAMJPP@?$DO?5?5?5bNumConfigurations?3?50x?$CF02X?$AA@ DB '>  '
	DB	' bNumConfigurations: 0x%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LAPCHIKM@?$DO?5?5?5iSerialNumber?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BK@LAPCHIKM@?$DO?5?5?5iSerialNumber?3?50x?$CF02X?$AA@ DB '>   iSer'
	DB	'ialNumber: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JLHEPLOO@?$DO?5?5?5iProduct?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BF@JLHEPLOO@?$DO?5?5?5iProduct?3?50x?$CF02X?$AA@ DB '>   iProduct:'
	DB	' 0x%02X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IFOFIIGL@?$DO?5?5?5iManufacturer?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BK@IFOFIIGL@?$DO?5?5?5iManufacturer?3?50x?$CF02X?$AA@ DB '>   iMan'
	DB	'ufacturer: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IFDGHCDF@?$DO?5?5?5bcdDevice?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BG@IFDGHCDF@?$DO?5?5?5bcdDevice?3?50x?$CF04X?$AA@ DB '>   bcdDevic'
	DB	'e: 0x%04X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FEBFICPG@?$DO?5?5?5idProduct?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BG@FEBFICPG@?$DO?5?5?5idProduct?3?50x?$CF04X?$AA@ DB '>   idProduc'
	DB	't: 0x%04X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FCNKAGPN@?$DO?5?5?5idVendor?3?50x?$CF04X?5?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@FCNKAGPN@?$DO?5?5?5idVendor?3?50x?$CF04X?5?$CI?$CFs?$CJ?$AA@ DB '>'
	DB	'   idVendor: 0x%04X (%s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KJHHAJF@?$DO?5?5?5bMaxPacketSize0?3?50x?$CF02X?5?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0CB@KJHHAJF@?$DO?5?5?5bMaxPacketSize0?3?50x?$CF02X?5?$CI?$CFd?$CJ@ DB '>'
	DB	'   bMaxPacketSize0: 0x%02X (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DONCAOLL@?$DO?5?5?5bDeviceProtocol?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BM@DONCAOLL@?$DO?5?5?5bDeviceProtocol?3?50x?$CF02X?$AA@ DB '>   bD'
	DB	'eviceProtocol: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IBBMEPAK@?$DO?5?5?5bDeviceSubClass?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BM@IBBMEPAK@?$DO?5?5?5bDeviceSubClass?3?50x?$CF02X?$AA@ DB '>   bD'
	DB	'eviceSubClass: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BBNICMHO@?$DO?5?5?5bDeviceClass?3?50x?$CF02X?$AA@
CONST	SEGMENT
??_C@_0BJ@BBNICMHO@?$DO?5?5?5bDeviceClass?3?50x?$CF02X?$AA@ DB '>   bDevi'
	DB	'ceClass: 0x%02X', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EOGCPDGC@?$DO?5?5?5bcdUSB?3?50x?$CF04X?$AA@
CONST	SEGMENT
??_C@_0BD@EOGCPDGC@?$DO?5?5?5bcdUSB?3?50x?$CF04X?$AA@ DB '>   bcdUSB: 0x%'
	DB	'04X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EPIIACIH@?$DO?5Device?5Descriptor?3?$AA@
CONST	SEGMENT
??_C@_0BF@EPIIACIH@?$DO?5Device?5Descriptor?3?$AA@ DB '> Device Descripto'
	DB	'r:', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KIPJNEMD@?$DO?5ConnectionStatus?3?5NoDeviceConn@
CONST	SEGMENT
??_C@_0CG@KIPJNEMD@?$DO?5ConnectionStatus?3?5NoDeviceConn@ DB '> Connecti'
	DB	'onStatus: NoDeviceConnected', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GIKFEJKI@?$DM?$DM?5USB?4ConnInfo?0?5Input?5null?$AA@
CONST	SEGMENT
??_C@_0BM@GIKFEJKI@?$DM?$DM?5USB?4ConnInfo?0?5Input?5null?$AA@ DB '<< USB'
	DB	'.ConnInfo, Input null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IJBIPHPI@?$DO?$DO?5USB?4ConnInfo?$AA@
CONST	SEGMENT
??_C@_0BA@IJBIPHPI@?$DO?$DO?5USB?4ConnInfo?$AA@ DB '>> USB.ConnInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MLOFAKML@?$DM?$DM?5USB?4HubCaps?$AA@
CONST	SEGMENT
??_C@_0P@MLOFAKML@?$DM?$DM?5USB?4HubCaps?$AA@ DB '<< USB.HubCaps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HMIILDFE@Hub?5Capabilities?5UNAVAILABLE?$AA@
CONST	SEGMENT
??_C@_0BN@HMIILDFE@Hub?5Capabilities?5UNAVAILABLE?$AA@ DB 'Hub Capabiliti'
	DB	'es UNAVAILABLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BJAEENFA@?$DO?5Hub?5Capabilities?3?5?$CF0?$CD8lx?5?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@BJAEENFA@?$DO?5Hub?5Capabilities?3?5?$CF0?$CD8lx?5?$CI?$CFs?$CJ?$AA@ DB '>'
	DB	' Hub Capabilities: %0#8lx (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDNEGAOE@Not?5high?5speed?$AA@
CONST	SEGMENT
??_C@_0P@LDNEGAOE@Not?5high?5speed?$AA@ DB 'Not high speed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BGKBMIAF@High?5speed?$AA@
CONST	SEGMENT
??_C@_0L@BGKBMIAF@High?5speed?$AA@ DB 'High speed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OCCHEKHL@Extended?5Hub?5Capabilities?5UNAVAI@
CONST	SEGMENT
??_C@_0CG@OCCHEKHL@Extended?5Hub?5Capabilities?5UNAVAI@ DB 'Extended Hub '
	DB	'Capabilities UNAVAILABLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LBBGDALG@?$DO?5?5?5Reserved?5?$CI26?5bits?$CJ?3?5?$CF0?$CD6lx?$AA@
CONST	SEGMENT
??_C@_0BP@LBBGDALG@?$DO?5?5?5Reserved?5?$CI26?5bits?$CJ?3?5?$CF0?$CD6lx?$AA@ DB '>'
	DB	'   Reserved (26 bits): %0#6lx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EBPNDPBD@?$DO?5?5?5Armed?5for?5wake?5on?5connect?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@EBPNDPBD@?$DO?5?5?5Armed?5for?5wake?5on?5connect?3?5?$CF@ DB '>'
	DB	'   Armed for wake on connect: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIGCJPGA@?$DO?5?5?5Root?5hub?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@BIGCJPGA@?$DO?5?5?5Root?5hub?3?5?$CFs?$AA@ DB '>   Root hub: %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JNPMKCLE@?$DO?5?5?5Mulit?9transaction?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@JNPMKCLE@?$DO?5?5?5Mulit?9transaction?3?5?$CFs?$AA@ DB '>   Mul'
	DB	'it-transaction: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCDBBDDL@Off?$AA@
CONST	SEGMENT
??_C@_03GCDBBDDL@Off?$AA@ DB 'Off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IAAGKKDJ@On?$AA@
CONST	SEGMENT
??_C@_02IAAGKKDJ@On?$AA@ DB 'On', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CJLCKEMN@?$DO?5?5?5Mulit?9transaction?5Capable?3?5?$CF@
CONST	SEGMENT
??_C@_0CC@CJLCKEMN@?$DO?5?5?5Mulit?9transaction?5Capable?3?5?$CF@ DB '>  '
	DB	' Mulit-transaction Capable: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FCCHMOKD@?$DO?5?5?5High?5speed?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@FCCHMOKD@?$DO?5?5?5High?5speed?3?5?$CFs?$AA@ DB '>   High speed'
	DB	': %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GGCJII@?$DO?5?5?5High?5speed?5Capable?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@GGCJII@?$DO?5?5?5High?5speed?5Capable?3?5?$CFs?$AA@ DB '>   Hig'
	DB	'h speed Capable: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KPNJBEAB@?$DO?5Extended?5Hub?5Capability?5Flags?3@
CONST	SEGMENT
??_C@_0CI@KPNJBEAB@?$DO?5Extended?5Hub?5Capability?5Flags?3@ DB '> Extend'
	DB	'ed Hub Capability Flags: %0#8lx', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ICANHPPH@?$DO?$DO?5USB?4HubCaps?$AA@
CONST	SEGMENT
??_C@_0P@ICANHPPH@?$DO?$DO?5USB?4HubCaps?$AA@ DB '>> USB.HubCaps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CHOKIAKD@?$DM?$DM?5USB?4HubInfo?$AA@
CONST	SEGMENT
??_C@_0P@CHOKIAKD@?$DM?$DM?5USB?4HubInfo?$AA@ DB '<< USB.HubInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FGJIHOLC@?$DO?5No?5Over?9current?5Protection?5?$CIBu@
CONST	SEGMENT
??_C@_0CO@FGJIHOLC@?$DO?5No?5Over?9current?5Protection?5?$CIBu@ DB '> No '
	DB	'Over-current Protection (Bus Power Only)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MEGDLCFA@?$DO?5Over?9current?5Protection?3?5Indiv@
CONST	SEGMENT
??_C@_0CG@MEGDLCFA@?$DO?5Over?9current?5Protection?3?5Indiv@ DB '> Over-c'
	DB	'urrent Protection: Individual', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ELIAJJDL@?$DO?5Over?9current?5Protection?3?5Globa@
CONST	SEGMENT
??_C@_0CC@ELIAJJDL@?$DO?5Over?9current?5Protection?3?5Globa@ DB '> Over-c'
	DB	'urrent Protection: Global', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFBEDMDO@?$DO?5Compound?5device?3?5Yes?$AA@
CONST	SEGMENT
??_C@_0BH@CFBEDMDO@?$DO?5Compound?5device?3?5Yes?$AA@ DB '> Compound devi'
	DB	'ce: Yes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FBGEODEL@?$DO?5Compound?5device?3?5No?$AA@
CONST	SEGMENT
??_C@_0BG@FBGEODEL@?$DO?5Compound?5device?3?5No?$AA@ DB '> Compound devic'
	DB	'e: No', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FICFFJGB@?$DO?5Power?5switching?3?5None?$AA@
CONST	SEGMENT
??_C@_0BI@FICFFJGB@?$DO?5Power?5switching?3?5None?$AA@ DB '> Power switch'
	DB	'ing: None', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BHNNAPDB@?$DO?5Power?5switching?3?5Individual?$AA@
CONST	SEGMENT
??_C@_0BO@BHNNAPDB@?$DO?5Power?5switching?3?5Individual?$AA@ DB '> Power '
	DB	'switching: Individual', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CEEHKAND@?$DO?5Power?5switching?3?5Ganged?$AA@
CONST	SEGMENT
??_C@_0BK@CEEHKAND@?$DO?5Power?5switching?3?5Ganged?$AA@ DB '> Power swit'
	DB	'ching: Ganged', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IOHBDCFM@?$DO?5Number?5of?5Ports?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BG@IOHBDCFM@?$DO?5Number?5of?5Ports?3?5?$CFd?$AA@ DB '> Number of '
	DB	'Ports: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPNNFMHH@?$DO?5Hub?5Power?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@KPNNFMHH@?$DO?5Hub?5Power?3?5?$CFs?$AA@ DB '> Hub Power: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JDJFLKOD@Self?5Power?$AA@
CONST	SEGMENT
??_C@_0L@JDJFLKOD@Self?5Power?$AA@ DB 'Self Power', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDHNALJA@Bus?5Power?$AA@
CONST	SEGMENT
??_C@_09GDHNALJA@Bus?5Power?$AA@ DB 'Bus Power', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GOACPFJP@?$DO?$DO?5USB?4HubInfo?$AA@
CONST	SEGMENT
??_C@_0P@GOACPFJP@?$DO?$DO?5USB?4HubInfo?$AA@ DB '>> USB.HubInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@INDEEKLB@?$DM?$DM?5USB?4GetCfgDesc?0?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BG@INDEEKLB@?$DM?$DM?5USB?4GetCfgDesc?0?5?$CFX?$AA@ DB '<< USB.Get'
	DB	'CfgDesc, %X', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LPDCGPEM@?9?9?5USB?4GetCfgDescriptor?0?5new?5Buf@
CONST	SEGMENT
??_C@_0CL@LPDCGPEM@?9?9?5USB?4GetCfgDescriptor?0?5new?5Buf@ DB '-- USB.Ge'
	DB	'tCfgDescriptor, new Buf (%u) null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LMLHDIHD@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Total?5?$CFd?5@
CONST	SEGMENT
??_C@_0CI@LMLHDIHD@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Total?5?$CFd?5@ DB '<'
	DB	'< USB.GetCfgDesc, Req Total %d < Sz %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JDNANMP@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Bytes?5?$CFu?5@
CONST	SEGMENT
??_C@_0CP@JDNANMP@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Bytes?5?$CFu?5@ DB '<'
	DB	'< USB.GetCfgDesc, Req Bytes %u <> BytesRet %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FDNPACDH@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5DeviceIoC@
CONST	SEGMENT
??_C@_0CN@FDNPACDH@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5DeviceIoC@ DB '<< US'
	DB	'B.GetCfgDesc, Req DeviceIoControl False', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LLJEBADN@?$DM?$DM?5USB?4GetCfgDesc?0?5Total?5?$CFd?5?$DM?5Sz@
CONST	SEGMENT
??_C@_0CL@LLJEBADN@?$DM?$DM?5USB?4GetCfgDesc?0?5Total?5?$CFd?5?$DM?5Sz@ DB '<'
	DB	'< USB.GetCfgDesc, Total %d < Sz struct %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CHLLBENA@?$DM?$DM?5USB?4GetCfgDesc?0?5Bytes?5?$CFu?5?$DM?$DO?5B@
CONST	SEGMENT
??_C@_0CL@CHLLBENA@?$DM?$DM?5USB?4GetCfgDesc?0?5Bytes?5?$CFu?5?$DM?$DO?5B@ DB '<'
	DB	'< USB.GetCfgDesc, Bytes %u <> BytesRet %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JPCNJMBL@?$DM?$DM?5USB?4GetCfgDesc?0?5DeviceIoContr@
CONST	SEGMENT
??_C@_0CJ@JPCNJMBL@?$DM?$DM?5USB?4GetCfgDesc?0?5DeviceIoContr@ DB '<< USB'
	DB	'.GetCfgDesc, DeviceIoControl False', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBPLLDOB@?$DO?$DO?5USB?4GetCfgDesc?$AA@
CONST	SEGMENT
??_C@_0BC@NBPLLDOB@?$DO?$DO?5USB?4GetCfgDesc?$AA@ DB '>> USB.GetCfgDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BBKGOLN@?$DM?$DM?5USB?4GetStrDescs?0?5StrDescNodeT@
CONST	SEGMENT
??_C@_0CH@BBKGOLN@?$DM?$DM?5USB?4GetStrDescs?0?5StrDescNodeT@ DB '<< USB.'
	DB	'GetStrDescs, StrDescNodeTail %X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HEHGMECG@?$DO?$DO?5USB?4GetStrDescs?$AA@
CONST	SEGMENT
??_C@_0BD@HEHGMECG@?$DO?$DO?5USB?4GetStrDescs?$AA@ DB '>> USB.GetStrDescs'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BGNGLHKH@?$DM?$DM?5USB?4GetHCDDrvKeyName?0?5DrvKeyN@
CONST	SEGMENT
??_C@_0CH@BGNGLHKH@?$DM?$DM?5USB?4GetHCDDrvKeyName?0?5DrvKeyN@ DB '<< USB'
	DB	'.GetHCDDrvKeyName, DrvKeyName %X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LFJMJGOI@?$DO?$DO?5USB?4GetHCDDrvKeyName?$AA@
CONST	SEGMENT
??_C@_0BI@LFJMJGOI@?$DO?$DO?5USB?4GetHCDDrvKeyName?$AA@ DB '>> USB.GetHCD'
	DB	'DrvKeyName', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LDLFLMCA@?$DM?$DM?5USB?4GetRootHub?0?5HubName?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BO@LDLFLMCA@?$DM?$DM?5USB?4GetRootHub?0?5HubName?5?$CFX?$AA@ DB '<'
	DB	'< USB.GetRootHub, HubName %X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGMOMHHM@?$DO?$DO?5USB?4GetRootHub?$AA@
CONST	SEGMENT
??_C@_0BC@PGMOMHHM@?$DO?$DO?5USB?4GetRootHub?$AA@ DB '>> USB.GetRootHub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NNDDHFCH@?$DM?$DM?5USB?4EnumHub?$AA@
CONST	SEGMENT
??_C@_0P@NNDDHFCH@?$DM?$DM?5USB?4EnumHub?$AA@ DB '<< USB.EnumHub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EDMNKMD@?9?9?5USB?4EnumHub?0?5new?5Info?5?$CI?$CFu?$CJ?5nu@
CONST	SEGMENT
??_C@_0CD@EDMNKMD@?9?9?5USB?4EnumHub?0?5new?5Info?5?$CI?$CFu?$CJ?5nu@ DB '-'
	DB	'- USB.EnumHub, new Info (%u) null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FMONKKAG@?9?9?5USB?4EnumHub?0?5new?5HubInfo?5?$CI?$CFu?$CJ@
CONST	SEGMENT
??_C@_0CG@FMONKKAG@?9?9?5USB?4EnumHub?0?5new?5HubInfo?5?$CI?$CFu?$CJ@ DB '-'
	DB	'- USB.EnumHub, new HubInfo (%u) null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKEDFNGB@?5?3?5?5?$AA@
CONST	SEGMENT
??_C@_04MKEDFNGB@?5?3?5?5?$AA@ DB ' :  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MFBNHHNK@?9?9?5USB?4EnumHub?0?5new?5Pntr?5for?5Dev@
CONST	SEGMENT
??_C@_0DB@MFBNHHNK@?9?9?5USB?4EnumHub?0?5new?5Pntr?5for?5Dev@ DB '-- USB.'
	DB	'EnumHub, new Pntr for DevName \\.\%s null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBDIODIA@?2?2?4?2?$AA@
CONST	SEGMENT
??_C@_04GBDIODIA@?2?2?4?2?$AA@ DB '\\.\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JENLAABL@?$DO?$DO?5USB?4EnumHub?$AA@
CONST	SEGMENT
??_C@_0P@JENLAABL@?$DO?$DO?5USB?4EnumHub?$AA@ DB '>> USB.EnumHub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OFAOPKJL@?$DM?$DM?5USB?4DrvName2DevDesc?0?5Ret?5Null@
CONST	SEGMENT
??_C@_0CB@OFAOPKJL@?$DM?$DM?5USB?4DrvName2DevDesc?0?5Ret?5Null@ DB '<< US'
	DB	'B.DrvName2DevDesc, Ret Null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BAPAALJK@?$DM?$DM?5USB?4DrvName2DevDesc?0?5GetDevNo@
CONST	SEGMENT
??_C@_0CO@BAPAALJK@?$DM?$DM?5USB?4DrvName2DevDesc?0?5GetDevNo@ DB '<< USB'
	DB	'.DrvName2DevDesc, GetDevNodeRegProps %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BAEOHBIH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5ret?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BP@BAEOHBIH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5ret?5?$CFX?$AA@ DB '<'
	DB	'< USB.DrvName2DevDesc, ret %X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PHHANNLH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5LocateDe@
CONST	SEGMENT
??_C@_0CJ@PHHANNLH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5LocateDe@ DB '<< USB'
	DB	'.DrvName2DevDesc, LocateDevNote %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KMJAGKHH@?$DO?$DO?5USB?4DrvName2DevDesc?0?5Drv?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BP@KMJAGKHH@?$DO?$DO?5USB?4DrvName2DevDesc?0?5Drv?5?$CFs?$AA@ DB '>'
	DB	'> USB.DrvName2DevDesc, Drv %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMILCJOE@?$DM?$DM?5USB?4EnumHubPorts?$AA@
CONST	SEGMENT
??_C@_0BE@LMILCJOE@?$DM?$DM?5USB?4EnumHubPorts?$AA@ DB '<< USB.EnumHubPor'
	DB	'ts', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CFCBFJND@Not?5Found?$AA@
CONST	SEGMENT
??_C@_09CFCBFJND@Not?5Found?$AA@ DB 'Not Found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGBIAJFO@Not?5Initialized?$AA@
CONST	SEGMENT
??_C@_0BA@CGBIAJFO@Not?5Initialized?$AA@ DB 'Not Initialized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LGIDNAEF@?$CFs?5?$FLVID?3?$CF?44X?5PID?3?$CF?44X?5SN?3?$CFs?5Spd?3@
CONST	SEGMENT
??_C@_0CF@LGIDNAEF@?$CFs?5?$FLVID?3?$CF?44X?5PID?3?$CF?44X?5SN?3?$CFs?5Spd?3@ DB '%'
	DB	's [VID:%.4X PID:%.4X SN:%s Spd: %s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHPBCODG@FULL?$AA@
CONST	SEGMENT
??_C@_04DHPBCODG@FULL?$AA@ DB 'FULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IBEFMGAI@LOW?$AA@
CONST	SEGMENT
??_C@_03IBEFMGAI@LOW?$AA@ DB 'LOW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PKDHFCJF@HIGH?$AA@
CONST	SEGMENT
??_C@_04PKDHFCJF@HIGH?$AA@ DB 'HIGH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP?$AA@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBNJMOOD@?$FLPort?$CFd?$FN?5?$AA@
CONST	SEGMENT
??_C@_09IBNJMOOD@?$FLPort?$CFd?$FN?5?$AA@ DB '[Port%d] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PONEPIOA@?$CFs?$FLPort?$CFd?$FN?5?$AA@
CONST	SEGMENT
??_C@_0M@PONEPIOA@?$CFs?$FLPort?$CFd?$FN?5?$AA@ DB '%s[Port%d] ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EKAJALEI@?9?9?5USB?4EnumHubPorts?0?5new?5Port?5?$CFd@
CONST	SEGMENT
??_C@_0DE@EKAJALEI@?9?9?5USB?4EnumHubPorts?0?5new?5Port?5?$CFd@ DB '-- US'
	DB	'B.EnumHubPorts, new Port %d ConnInfo (%u) null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPBFJJJ@?$DO?$DO?5USB?4EnumHubPorts?$AA@
CONST	SEGMENT
??_C@_0BE@CPBFJJJ@?$DO?$DO?5USB?4EnumHubPorts?$AA@ DB '>> USB.EnumHubPort'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PKLCHKGO@?$DM?$DM?5USB?4GetExternHub?0?5HubName?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0CA@PKLCHKGO@?$DM?$DM?5USB?4GetExternHub?0?5HubName?5?$CFX?$AA@ DB '<'
	DB	'< USB.GetExternHub, HubName %X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HJNGPFIB@?9?9?5USB?4GetExtHubName?0?5new?5extHub@
CONST	SEGMENT
??_C@_0DA@HJNGPFIB@?9?9?5USB?4GetExtHubName?0?5new?5extHub@ DB '-- USB.Ge'
	DB	'tExtHubName, new extHubNameW (%u) null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BDIOPGJF@?$DO?$DO?5USB?4GetExternHub?$AA@
CONST	SEGMENT
??_C@_0BE@BDIOPGJF@?$DO?$DO?5USB?4GetExternHub?$AA@ DB '>> USB.GetExternH'
	DB	'ub', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IAFNNICI@?$DM?$DM?5USB?4GetDrvKeyName?0?5AName?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BP@IAFNNICI@?$DM?$DM?5USB?4GetDrvKeyName?0?5AName?5?$CFX?$AA@ DB '<'
	DB	'< USB.GetDrvKeyName, AName %X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OGKODAJE@?9?9?5USB?4GetDriverKeyName?0?5new?5Key@
CONST	SEGMENT
??_C@_0DA@OGKODAJE@?9?9?5USB?4GetDriverKeyName?0?5new?5Key@ DB '-- USB.Ge'
	DB	'tDriverKeyName, new KeyNameW (%u) null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GLJHIDAC@?$DO?$DO?5USB?4GetDrvKeyName?$AA@
CONST	SEGMENT
??_C@_0BF@GLJHIDAC@?$DO?$DO?5USB?4GetDrvKeyName?$AA@ DB '>> USB.GetDrvKey'
	DB	'Name', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IFDPMHNA@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@
CONST	SEGMENT
??_C@_0CH@IFDPMHNA@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@ DB '<< USB'
	DB	'.GetAllStrDescs, SuppLangsStr %X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HBMGBPGH@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@
CONST	SEGMENT
??_C@_0CJ@HBMGBPGH@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@ DB '<< USB'
	DB	'.GetAllStrDescs, SuppLangsStr null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PLIGAJPI@?$DO?$DO?5USB?4GetAllStrDescs?$AA@
CONST	SEGMENT
??_C@_0BG@PLIGAJPI@?$DO?$DO?5USB?4GetAllStrDescs?$AA@ DB '>> USB.GetAllSt'
	DB	'rDescs', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JFAJNON@?$DM?$DM?5USB?4AreThrStrDesc?0?5Ret?5False?$AA@
CONST	SEGMENT
??_C@_0CA@JFAJNON@?$DM?$DM?5USB?4AreThrStrDesc?0?5Ret?5False?$AA@ DB '<< '
	DB	'USB.AreThrStrDesc, Ret False', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NAENOJMA@?$DM?$DM?5USB?4AreThrStrDesc?0?5Interface?5@
CONST	SEGMENT
??_C@_0CD@NAENOJMA@?$DM?$DM?5USB?4AreThrStrDesc?0?5Interface?5@ DB '<< US'
	DB	'B.AreThrStrDesc, Interface %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DEJJKGAD@?$DM?$DM?5USB?4AreThrStrDesc?0?5Cfg?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@DEJJKGAD@?$DM?$DM?5USB?4AreThrStrDesc?0?5Cfg?5?$CFd?$AA@ DB '<<'
	DB	' USB.AreThrStrDesc, Cfg %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KIEGOLFL@?$DM?$DM?5USB?4AreThrStrDesc?0?5Manufact?5?$CF@
CONST	SEGMENT
??_C@_0DC@KIEGOLFL@?$DM?$DM?5USB?4AreThrStrDesc?0?5Manufact?5?$CF@ DB '<<'
	DB	' USB.AreThrStrDesc, Manufact %d, Prod %d, SN %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPAKKGGO@?$DO?$DO?5USB?4AreThrStrDesc?$AA@
CONST	SEGMENT
??_C@_0BF@IPAKKGGO@?$DO?$DO?5USB?4AreThrStrDesc?$AA@ DB '>> USB.AreThrStr'
	DB	'Desc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BCHFPFAE@?$DM?$DM?5USB?4GetStrDesc?0?5DescNode?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BP@BCHFPFAE@?$DM?$DM?5USB?4GetStrDesc?0?5DescNode?5?$CFX?$AA@ DB '<'
	DB	'< USB.GetStrDesc, DescNode %X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ICOPDODD@?9?9?5USB?4GetStrDesc?0?5WideCharToMul@
CONST	SEGMENT
??_C@_0DF@ICOPDODD@?9?9?5USB?4GetStrDesc?0?5WideCharToMul@ DB '-- USB.Get'
	DB	'StrDesc, WideCharToMultiByte failed %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BKJLPKEL@?$DM?$DM?5USB?4GetStrDesc?0?5new?5DescNode?5@
CONST	SEGMENT
??_C@_0CF@BKJLPKEL@?$DM?$DM?5USB?4GetStrDesc?0?5new?5DescNode?5@ DB '<< U'
	DB	'SB.GetStrDesc, new DescNode null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ILBIFDNN@?$DM?$DM?5USB?4GetStrDesc?0?5Odd?5Sz?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BN@ILBIFDNN@?$DM?$DM?5USB?4GetStrDesc?0?5Odd?5Sz?5?$CFd?$AA@ DB '<'
	DB	'< USB.GetStrDesc, Odd Sz %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CHKNKAPD@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Sz?5?$CFd?5?$DM?$DO?5@
CONST	SEGMENT
??_C@_0CD@CHKNKAPD@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Sz?5?$CFd?5?$DM?$DO?5@ DB '<'
	DB	'< USB.GetStrDesc, Inv Sz %d <> %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ELGGMNKC@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Descripto@
CONST	SEGMENT
??_C@_0CH@ELGGMNKC@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Descripto@ DB '<< US'
	DB	'B.GetStrDesc, Inv DescriptorTp %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JKPBCDKN@?$DM?$DM?5USB?4GetStrDesc?0?5Bytes?5Ret?5?$CFu?$AA@
CONST	SEGMENT
??_C@_0CA@JKPBCDKN@?$DM?$DM?5USB?4GetStrDesc?0?5Bytes?5Ret?5?$CFu?$AA@ DB '<'
	DB	'< USB.GetStrDesc, Bytes Ret %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MLNPNNOJ@?$DM?$DM?5USB?4GetStrDesc?0?5DeviceIoContr@
CONST	SEGMENT
??_C@_0CJ@MLNPNNOJ@?$DM?$DM?5USB?4GetStrDesc?0?5DeviceIoContr@ DB '<< USB'
	DB	'.GetStrDesc, DeviceIoControl False', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OBKJMAF@?$DO?$DO?5USB?4GetStrDesc?$AA@
CONST	SEGMENT
??_C@_0BC@OBKJMAF@?$DO?$DO?5USB?4GetStrDesc?$AA@ DB '>> USB.GetStrDesc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOKCLIBE@?$DM?$DM?5USB?4DevsDets?$AA@
CONST	SEGMENT
??_C@_0BA@GOKCLIBE@?$DM?$DM?5USB?4DevsDets?$AA@ DB '<< USB.DevsDets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HNIJLKOP@USB?5Device?5Details?$AA@
CONST	SEGMENT
??_C@_0BD@HNIJLKOP@USB?5Device?5Details?$AA@ DB 'USB Device Details', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBIECMOG@?$DO?$DO?5USB?4DevsDets?$AA@
CONST	SEGMENT
??_C@_0BA@EBIECMOG@?$DO?$DO?5USB?4DevsDets?$AA@ DB '>> USB.DevsDets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NGAEOEJF@?$DM?$DM?5USB?4EnumUSB?$AA@
CONST	SEGMENT
??_C@_0P@NGAEOEJF@?$DM?$DM?5USB?4EnumUSB?$AA@ DB '<< USB.EnumUSB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FOIGIFIJ@Total?5Devices?5Connected?5?$CFu?$AA@
CONST	SEGMENT
??_C@_0BL@FOIGIFIJ@Total?5Devices?5Connected?5?$CFu?$AA@ DB 'Total Device'
	DB	's Connected %u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOIBMAON@RootHub?$AA@
CONST	SEGMENT
??_C@_07FOIBMAON@RootHub?$AA@ DB 'RootHub', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEFNEIBE@RootHub?5?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0N@BEFNEIBE@RootHub?5?3?5?$CFs?$AA@ DB 'RootHub : %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PEILPPNA@?2?2?4?2HCD?$CFd?$AA@
CONST	SEGMENT
??_C@_09PEILPPNA@?2?2?4?2HCD?$CFd?$AA@ DB '\\.\HCD%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BMIBGHPI@Enumerate?5USB?$AA@
CONST	SEGMENT
??_C@_0O@BMIBGHPI@Enumerate?5USB?$AA@ DB 'Enumerate USB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DIBECLHK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Lo@
CONST	SEGMENT
??_C@_0DM@DIBECLHK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Lo@ DB '<< US'
	DB	'B.EnumUSB, GetProcAdr CM_Locate_DevNode failed: %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFDOPOAJ@CM_Locate_DevNodeA?$AA@
CONST	SEGMENT
??_C@_0BD@FFDOPOAJ@CM_Locate_DevNodeA?$AA@ DB 'CM_Locate_DevNodeA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@DLHLJOM@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
CONST	SEGMENT
??_C@_0EL@DLHLJOM@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ DB '<< USB'
	DB	'.EnumUSB, GetProcAdr CM_Get_DevNode_Registry_Property failed:'
	DB	' %u, %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NHFCMMFN@CM_Get_DevNode_Registry_Property@
CONST	SEGMENT
??_C@_0CC@NHFCMMFN@CM_Get_DevNode_Registry_Property@ DB 'CM_Get_DevNode_R'
	DB	'egistry_PropertyA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HAEGCLCE@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
CONST	SEGMENT
??_C@_0DH@HAEGCLCE@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ DB '<< US'
	DB	'B.EnumUSB, GetProcAdr CM_Get_Child failed: %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKPGFMC@CM_Get_Child?$AA@
CONST	SEGMENT
??_C@_0N@EKPGFMC@CM_Get_Child?$AA@ DB 'CM_Get_Child', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MMFCGNCK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
CONST	SEGMENT
??_C@_0DJ@MMFCGNCK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ DB '<< US'
	DB	'B.EnumUSB, GetProcAdr CM_Get_Sibling failed: %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOIACNHP@CM_Get_Sibling?$AA@
CONST	SEGMENT
??_C@_0P@OOIACNHP@CM_Get_Sibling?$AA@ DB 'CM_Get_Sibling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OFIMABNG@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
CONST	SEGMENT
??_C@_0DI@OFIMABNG@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@ DB '<< US'
	DB	'B.EnumUSB, GetProcAdr CM_Get_Parent failed: %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIKLALFP@CM_Get_Parent?$AA@
CONST	SEGMENT
??_C@_0O@CIKLALFP@CM_Get_Parent?$AA@ DB 'CM_Get_Parent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MNEBEEPL@?$DM?$DM?5USB?4EnumUSB?0?5LoadLib?5cfgmgr32@
CONST	SEGMENT
??_C@_0DE@MNEBEEPL@?$DM?$DM?5USB?4EnumUSB?0?5LoadLib?5cfgmgr32@ DB '<< US'
	DB	'B.EnumUSB, LoadLib cfgmgr32.dll failed: %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNFFEOEJ@cfgmgr32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@JNFFEOEJ@cfgmgr32?4dll?$AA@ DB 'cfgmgr32.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPOMJBKJ@?$DO?$DO?5USB?4EnumUSB?$AA@
CONST	SEGMENT
??_C@_0P@JPOMJBKJ@?$DO?$DO?5USB?4EnumUSB?$AA@ DB '>> USB.EnumUSB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@ DB '          ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GGFKNFHG@?5?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_08GGFKNFHG@?5?5?5?5?5?5?5?5?$AA@ DB '        ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGLIPOFD@?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_06GGLIPOFD@?5?5?5?5?5?5?$AA@ DB '      ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFOHOKJK@?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_04PFOHOKJK@?5?5?5?5?$AA@ DB '    ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BOFHLGPH@DeviceInLegacyHub?$AA@
CONST	SEGMENT
??_C@_0BC@BOFHLGPH@DeviceInLegacyHub?$AA@ DB 'DeviceInLegacyHub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CHELPMAC@DeviceHubNestedTooDeeply?$AA@
CONST	SEGMENT
??_C@_0BJ@CHELPMAC@DeviceHubNestedTooDeeply?$AA@ DB 'DeviceHubNestedTooDe'
	DB	'eply', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBBHPJJC@DeviceNotEnoughBandwidth?$AA@
CONST	SEGMENT
??_C@_0BJ@DBBHPJJC@DeviceNotEnoughBandwidth?$AA@ DB 'DeviceNotEnoughBandw'
	DB	'idth', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCIAFGBC@DeviceNotEnoughPower?$AA@
CONST	SEGMENT
??_C@_0BF@KCIAFGBC@DeviceNotEnoughPower?$AA@ DB 'DeviceNotEnoughPower', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FHCONGJI@DeviceCausedOvercurrent?$AA@
CONST	SEGMENT
??_C@_0BI@FHCONGJI@DeviceCausedOvercurrent?$AA@ DB 'DeviceCausedOvercurre'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FIJIOADB@DeviceGeneralFailure?$AA@
CONST	SEGMENT
??_C@_0BF@FIJIOADB@DeviceGeneralFailure?$AA@ DB 'DeviceGeneralFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LKBNFKJE@DeviceFailedEnumeration?$AA@
CONST	SEGMENT
??_C@_0BI@LKBNFKJE@DeviceFailedEnumeration?$AA@ DB 'DeviceFailedEnumerati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LIPCCNEI@DeviceConnected?$AA@
CONST	SEGMENT
??_C@_0BA@LIPCCNEI@DeviceConnected?$AA@ DB 'DeviceConnected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CFJFKPGC@NoDeviceConnected?$AA@
CONST	SEGMENT
??_C@_0BC@CFJFKPGC@NoDeviceConnected?$AA@ DB 'NoDeviceConnected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GFKFEIAL@?9?9?5USB?4PushBackDets?0?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BI@GFKFEIAL@?9?9?5USB?4PushBackDets?0?5?$CFs?$AA@ DB '-- USB.PushB'
	DB	'ackDets, %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
?ConnectionStatuses@@3PAPADA DD FLAT:??_C@_0BC@CFJFKPGC@NoDeviceConnected?$AA@ ; ConnectionStatuses
	DD	FLAT:??_C@_0BA@LIPCCNEI@DeviceConnected?$AA@
	DD	FLAT:??_C@_0BI@LKBNFKJE@DeviceFailedEnumeration?$AA@
	DD	FLAT:??_C@_0BF@FIJIOADB@DeviceGeneralFailure?$AA@
	DD	FLAT:??_C@_0BI@FHCONGJI@DeviceCausedOvercurrent?$AA@
	DD	FLAT:??_C@_0BF@KCIAFGBC@DeviceNotEnoughPower?$AA@
	DD	FLAT:??_C@_0BJ@DBBHPJJC@DeviceNotEnoughBandwidth?$AA@
	DD	FLAT:??_C@_0BJ@CHELPMAC@DeviceHubNestedTooDeeply?$AA@
	DD	FLAT:??_C@_0BC@BOFHLGPH@DeviceInLegacyHub?$AA@
_USBVendorIDs DW 03ebH
	ORG $+2
	DD	FLAT:??_C@_0BC@ELLAHEBO@Atmel?5Corporation?$AA@
	DW	03f0H
	ORG $+2
	DD	FLAT:??_C@_0BA@GKDJMMLL@Hewlett?5Packard?$AA@
	DW	03f4H
	ORG $+2
	DD	FLAT:??_C@_0O@EJFJAJAK@Diebold?0?5Inc?4?$AA@
	DW	03fcH
	ORG $+2
	DD	FLAT:??_C@_0BM@MEJFLCNJ@Elitegroup?5Computer?5Systems?$AA@
	DW	0403H
	ORG $+2
	DD	FLAT:??_C@_0DA@NLEDAFLA@Future?5Technology?5Devices?5Intern@
	DW	0408H
	ORG $+2
	DD	FLAT:??_C@_0BF@PKMDPELO@Quanta?5Computer?5Inc?4?$AA@
	DW	0409H
	ORG $+2
	DD	FLAT:??_C@_0BA@KPLBOCAE@NEC?5Corporation?$AA@
	DW	040aH
	ORG $+2
	DD	FLAT:??_C@_0BG@DEIKAEKL@Eastman?5Kodak?5Company?$AA@
	DW	040bH
	ORG $+2
	DD	FLAT:??_C@_0BH@JCNGEJDK@Weltrend?5Semiconductor?$AA@
	DW	040dH
	ORG $+2
	DD	FLAT:??_C@_0BH@LEHBDMGE@VIA?5Technologies?0?5Inc?4?$AA@
	DW	040eH
	ORG $+2
	DD	FLAT:??_C@_0BB@DMJKNCDK@MCCI?5Corporation?$AA@
	DW	0411H
	ORG $+2
	DD	FLAT:??_C@_0N@HBBMPLAJ@BUFFALO?5INC?4?$AA@
	DW	0414H
	ORG $+2
	DD	FLAT:??_C@_0BP@EJPGPDCC@Giga?9Byte?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0416H
	ORG $+2
	DD	FLAT:??_C@_0BJ@BBLEBCKI@Nuvoton?5Technology?5Corp?4?$AA@
	DW	041eH
	ORG $+2
	DD	FLAT:??_C@_0O@CDIDDBG@Creative?5Labs?$AA@
	DW	0421H
	ORG $+2
	DD	FLAT:??_C@_0BC@LOIKONEK@Nokia?5Corporation?$AA@
	DW	0424H
	ORG $+2
	DD	FLAT:??_C@_04JKLOLBDG@SMSC?$AA@
	DW	042fH
	ORG $+2
	DD	FLAT:??_C@_0L@JMLDMEEO@Molex?5Inc?4?$AA@
	DW	0430H
	ORG $+2
	DD	FLAT:??_C@_0BK@BGJHIBOH@Fujitsu?5Component?5Limited?$AA@
	DW	0438H
	ORG $+2
	DD	FLAT:??_C@_0BH@PDGAJDKJ@Advanced?5Micro?5Devices?$AA@
	DW	043dH
	ORG $+2
	DD	FLAT:??_C@_0BL@KCFEHCNK@Lexmark?5International?5Inc?4?$AA@
	DW	0440H
	ORG $+2
	DD	FLAT:??_C@_0BH@LFBOMFGA@EIZO?5NANAO?5CORPORATION?$AA@
	DW	044eH
	ORG $+2
	DD	FLAT:??_C@_0BI@LOPMEJIG@Alps?5Electric?5Co?4?0?5Ltd?4?$AA@
	DW	0451H
	ORG $+2
	DD	FLAT:??_C@_0BC@NEDOGEDE@Texas?5Instruments?$AA@
	DW	0457H
	ORG $+2
	DD	FLAT:??_C@_0CB@JOFOMFLH@Silicon?5Integrated?5Systems?5Corp?4@
	DW	0458H
	ORG $+2
	DD	FLAT:??_C@_0BC@CIDHCDNI@KYE?5Systems?5Corp?4?$AA@
	DW	045bH
	ORG $+2
	DD	FLAT:??_C@_0BK@EAFCJGLH@Renesas?5Electronics?5Corp?4?$AA@
	DW	045eH
	ORG $+2
	DD	FLAT:??_C@_0BG@EOBPLLNH@Microsoft?5Corporation?$AA@
	DW	0461H
	ORG $+2
	DD	FLAT:??_C@_0BD@CABKABLN@Primax?5Electronics?$AA@
	DW	0463H
	ORG $+2
	DD	FLAT:??_C@_05CFGIIEPJ@EATON?$AA@
	DW	0468H
	ORG $+2
	DD	FLAT:??_C@_0BO@JJGMGNMK@Wieson?5Technologies?5Co?4?0?5Ltd?4?$AA@
	DW	046bH
	ORG $+2
	DD	FLAT:??_C@_0BE@JEFPHDAK@American?5Megatrends?$AA@
	DW	046dH
	ORG $+2
	DD	FLAT:??_C@_0O@NMJDEFAN@Logitech?5Inc?4?$AA@
	DW	047eH
	ORG $+2
	DD	FLAT:??_C@_0BA@JMLOFGEB@LSI?5Corporation?$AA@
	DW	047fH
	ORG $+2
	DD	FLAT:??_C@_0BC@JKCENOI@Plantronics?0?5Inc?4?$AA@
	DW	0480H
	ORG $+2
	DD	FLAT:??_C@_0CE@MGJHDLEM@Toshiba?5America?5Info?4?5Systems?0?5I@
	DW	0482H
	ORG $+2
	DD	FLAT:??_C@_0BE@OKFLBHJF@Kyocera?5Corporation?$AA@
	DW	0483H
	ORG $+2
	DD	FLAT:??_C@_0BD@KBJBCOHP@STMicroelectronics?$AA@
	DW	0489H
	ORG $+2
	DD	FLAT:??_C@_0BC@OEHDDJBP@Foxconn?5?1?5Hon?5Hai?$AA@
	DW	048dH
	ORG $+2
	DD	FLAT:??_C@_0O@KONCBIDB@ITE?5Tech?5Inc?4?$AA@
	DW	0499H
	ORG $+2
	DD	FLAT:??_C@_0BD@LBNNEMMM@Yamaha?5Corporation?$AA@
	DW	04a4H
	ORG $+2
	DD	FLAT:??_C@_0O@EDCNNFOI@Hitachi?0?5Ltd?4?$AA@
	DW	04a7H
	ORG $+2
	DD	FLAT:??_C@_09OEADKIBB@Visioneer?$AA@
	DW	04a9H
	ORG $+2
	DD	FLAT:??_C@_0L@GLDEECEB@Canon?5Inc?4?$AA@
	DW	04b0H
	ORG $+2
	DD	FLAT:??_C@_0BC@GNNADKEG@Nikon?5Corporation?$AA@
	DW	04b1H
	ORG $+2
	DD	FLAT:??_C@_0BC@HJPMHLJH@Pan?5International?$AA@
	DW	04b4H
	ORG $+2
	DD	FLAT:??_C@_0BG@FGCLJBBL@Cypress?5Semiconductor?$AA@
	DW	04b5H
	ORG $+2
	DD	FLAT:??_C@_0P@POFNKNIM@ROHM?5Co?4?0?5Ltd?4?$AA@
	DW	04b7H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IBBFBLCL@Compal?5Electronics?0?5Inc?4?$AA@
	DW	04b8H
	ORG $+2
	DD	FLAT:??_C@_0BC@LODEJCJJ@Seiko?5Epson?5Corp?4?$AA@
	DW	04bbH
	ORG $+2
	DD	FLAT:??_C@_0BG@NAOBNEME@I?9O?5Data?5Device?0?5Inc?4?$AA@
	DW	04c5H
	ORG $+2
	DD	FLAT:??_C@_0N@MFGIPGKK@Fujitsu?5Ltd?4?$AA@
	DW	04caH
	ORG $+2
	DD	FLAT:??_C@_0BJ@CAOGFALO@Lite?9On?5Technology?5Corp?4?$AA@
	DW	04cbH
	ORG $+2
	DD	FLAT:??_C@_0BF@DGJHAIHG@FUJIFILM?5Corporation?$AA@
	DW	04ccH
	ORG $+2
	DD	FLAT:??_C@_0M@CIDIGMJE@ST?9Ericsson?$AA@
	DW	04d8H
	ORG $+2
	DD	FLAT:??_C@_0BK@GLLPJAAH@Microchip?5Technology?5Inc?4?$AA@
	DW	04d9H
	ORG $+2
	DD	FLAT:??_C@_0BL@BJMPMCDF@Holtek?5Semiconductor?0?5Inc?4?$AA@
	DW	04daH
	ORG $+2
	DD	FLAT:??_C@_0BG@HPBJICLA@Panasonic?5Corporation?$AA@
	DW	04ddH
	ORG $+2
	DD	FLAT:??_C@_0BC@NGIIFMHF@Sharp?5Corporation?$AA@
	DW	04e2H
	ORG $+2
	DD	FLAT:??_C@_0BB@LFOEADKM@Exar?5Corporation?$AA@
	DW	04e6H
	ORG $+2
	DD	FLAT:??_C@_0BB@LGJOJJNH@SCM?5Microsystems?$AA@
	DW	04e8H
	ORG $+2
	DD	FLAT:??_C@_0BO@CGAOADOO@Samsung?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	04ebH
	ORG $+2
	DD	FLAT:??_C@_0BI@BJLCCIIK@Northstar?5Systems?5Corp?4?$AA@
	DW	04ecH
	ORG $+2
	DD	FLAT:??_C@_0BO@EFCPDDGG@Tokyo?5Electron?5Device?5Limited?$AA@
	DW	04f2H
	ORG $+2
	DD	FLAT:??_C@_0BO@DEPAFADD@Chicony?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	04f7H
	ORG $+2
	DD	FLAT:??_C@_0BI@JIJDPPMO@Newnex?5Technology?5Corp?4?$AA@
	DW	04f9H
	ORG $+2
	DD	FLAT:??_C@_0BJ@LIIOOGBH@Brother?5Industries?0?5Ltd?4?$AA@
	DW	04fcH
	ORG $+2
	DD	FLAT:??_C@_0BN@EENPEENP@SUNPLUS?5TECHNOLOGY?5CO?4?0?5LTD?4?$AA@
	DW	04feH
	ORG $+2
	DD	FLAT:??_C@_0M@LAOEDIBA@PFU?5Limited?$AA@
	DW	0501H
	ORG $+2
	DD	FLAT:??_C@_0N@HPKDLJPE@Fujikura?1DDK?$AA@
	DW	0507H
	ORG $+2
	DD	FLAT:??_C@_0BE@OMIFCFDP@Hosiden?5Corporation?$AA@
	DW	050dH
	ORG $+2
	DD	FLAT:??_C@_0BD@JPLKCFJN@Belkin?5Corporation?$AA@
	DW	0514H
	ORG $+2
	DD	FLAT:??_C@_0BA@MNHCACLA@FCI?5Electronics?$AA@
	DW	0516H
	ORG $+2
	DD	FLAT:??_C@_0CG@MHMGALMF@Longwell?5Electronics?1Longwell?5Co@
	DW	0519H
	ORG $+2
	DD	FLAT:??_C@_0BI@IEJECICL@Star?5Micronics?5Co?4?0?5LTD?$AA@
	DW	051dH
	ORG $+2
	DD	FLAT:??_C@_0BK@CJECLAIC@American?5Power?5Conversion?$AA@
	DW	0520H
	ORG $+2
	DD	FLAT:??_C@_0CH@IKHGDMKC@Taiwan?5Semiconductor?5Manufacturi@
	DW	0522H
	ORG $+2
	DD	FLAT:??_C@_0BP@MPHIFDML@ACON?0?5Advanced?9Connectek?0?5Inc?4?$AA@
	DW	0525H
	ORG $+2
	DD	FLAT:??_C@_0BF@OEIMDHJB@PLX?5Technology?0?5Inc?4?$AA@
	DW	0529H
	ORG $+2
	DD	FLAT:??_C@_0BK@EAHBAECN@Aladdin?5Knowledge?5Systems?$AA@
	DW	0531H
	ORG $+2
	DD	FLAT:??_C@_0BH@OKBFFENA@Wacom?5Technology?5Corp?4?$AA@
	DW	053fH
	ORG $+2
	DD	FLAT:??_C@_0P@JMAENH@Synopsys?0?5Inc?4?$AA@
	DW	054cH
	ORG $+2
	DD	FLAT:??_C@_0BB@FOPBDEC@Sony?5Corporation?$AA@
	DW	0550H
	ORG $+2
	DD	FLAT:??_C@_0BF@BLKLAKEJ@Fuji?5Xerox?5Co?4?0?5Ltd?4?$AA@
	DW	0557H
	ORG $+2
	DD	FLAT:??_C@_0BM@FGPDBDMF@ATEN?5International?5Co?4?5Ltd?4?$AA@
	DW	0559H
	ORG $+2
	DD	FLAT:??_C@_0BN@LLCBPJLE@Cadence?5Design?5Systems?0?5Inc?4?$AA@
	DW	056aH
	ORG $+2
	DD	FLAT:??_C@_0BA@PCAMLHGM@WACOM?5Co?4?0?5Ltd?4?$AA@
	DW	0572H
	ORG $+2
	DD	FLAT:??_C@_0BH@BPNCPPJL@Conexant?5Systems?0?5Inc?4?$AA@
	DW	0573H
	ORG $+2
	DD	FLAT:??_C@_0BC@DJMACOGF@Zoran?5Corporation?$AA@
	DW	0576H
	ORG $+2
	DD	FLAT:??_C@_0CC@JDHIHHMP@BAFO?1Quality?5Computer?5Accessorie@
	DW	057bH
	ORG $+2
	DD	FLAT:??_C@_0P@DLENFJNK@Y?9E?5Data?0?5Inc?4?$AA@
	DW	057cH
	ORG $+2
	DD	FLAT:??_C@_08DBEKGGBP@AVM?5GmbH?$AA@
	DW	0582H
	ORG $+2
	DD	FLAT:??_C@_0BD@CDPILELF@Roland?5Corporation?$AA@
	DW	0584H
	ORG $+2
	DD	FLAT:??_C@_0BE@PNCFOBBM@RATOC?5Systems?0?5Inc?4?$AA@
	DW	058fH
	ORG $+2
	DD	FLAT:??_C@_0BD@CKEFINHN@Alcor?5Micro?0?5Corp?4?$AA@
	DW	0590H
	ORG $+2
	DD	FLAT:??_C@_0BC@LGOLJEOJ@OMRON?5Corporation?$AA@
	DW	059bH
	ORG $+2
	DD	FLAT:??_C@_0BD@DLALOKFF@Iomega?5Corporation?$AA@
	DW	059fH
	ORG $+2
	DD	FLAT:??_C@_05EENIFCCI@LaCie?$AA@
	DW	05a9H
	ORG $+2
	DD	FLAT:??_C@_0BO@PALNNPFJ@OmniVision?5Technologies?0?5Inc?4?$AA@
	DW	05acH
	ORG $+2
	DD	FLAT:??_C@_05EBJDGKGA@Apple?$AA@
	DW	05adH
	ORG $+2
	DD	FLAT:??_C@_0BH@BEKADALE@Y?4C?4?5Cable?5U?4S?4A?4?0?5Inc?$AA@
	DW	03923H
	ORG $+2
	DD	FLAT:??_C@_0BF@DJDIGDEG@National?5Instruments?$AA@
	DW	05beH
	ORG $+2
	DD	FLAT:??_C@_0BB@BDKIEMDH@Tyco?5Electronics?$AA@
	DW	05c1H
	ORG $+2
	DD	FLAT:??_C@_0CA@ILGCAFHO@Kawasaki?5Microelectronics?0?5Inc?4?$AA@
	DW	05c6H
	ORG $+2
	DD	FLAT:??_C@_0O@JJANANCF@Qualcomm?0?5Inc?$AA@
	DW	05c8H
	ORG $+2
	DD	FLAT:??_C@_0CP@IMDHJGED@Foxlink?1Cheng?5Uei?5Precision?5Indu@
	DW	05caH
	ORG $+2
	DD	FLAT:??_C@_0BD@DNOMCPDN@Ricoh?5Company?5Ltd?4?$AA@
	DW	05daH
	ORG $+2
	DD	FLAT:??_C@_0BM@OADDMKLB@Microtek?5International?5Inc?4?$AA@
	DW	05dcH
	ORG $+2
	DD	FLAT:??_C@_0BC@CNOLCDCN@Lexar?5Media?0?5Inc?4?$AA@
	DW	05e0H
	ORG $+2
	DD	FLAT:??_C@_0BE@JPKFBBCH@Symbol?5Technologies?$AA@
	DW	05e3H
	ORG $+2
	DD	FLAT:??_C@_0BE@CKIEML@Genesys?5Logic?0?5Inc?4?$AA@
	DW	05e5H
	ORG $+2
	DD	FLAT:??_C@_0BI@KBGKOOGJ@Fuji?5Electric?5Co?4?0?5Ltd?4?$AA@
	DW	05f5H
	ORG $+2
	DD	FLAT:??_C@_0BI@NBAANMIA@Unixtar?5Technology?5Inc?4?$AA@
	DW	05f9H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IOEIJMCL@Datalogic?5Scanning?0?5Inc?4?$AA@
	DW	05ffH
	ORG $+2
	DD	FLAT:??_C@_0BD@PJDPEADK@LeCroy?5Corporation?$AA@
	DW	0603H
	ORG $+2
	DD	FLAT:??_C@_0BP@HAMNADII@Novatek?5Microelectronics?5Corp?4?$AA@
	DW	0609H
	ORG $+2
	DD	FLAT:??_C@_0BH@LJAJLGJE@SMK?5Manufacturing?5Inc?4?$AA@
	DW	060fH
	ORG $+2
	DD	FLAT:??_C@_0CE@IBGJKEKA@Joinsoon?5Electronics?5Mfg?4?5Co?4?0?5L@
	DW	0611H
	ORG $+2
	DD	FLAT:??_C@_0BK@EHGAEDDA@Totoku?5Electric?5Co?4?0?5LTD?4?$AA@
	DW	0613H
	ORG $+2
	DD	FLAT:??_C@_0CD@BNDJFIFN@TransAct?5Technologies?5Incorporat@
	DW	0619H
	ORG $+2
	DD	FLAT:??_C@_0BH@OFHNPHHH@Seiko?5Instruments?5Inc?4?$AA@
	DW	0623H
	ORG $+2
	DD	FLAT:??_C@_0BB@GCAKJIAA@Littelfuse?0?5Inc?4?$AA@
	DW	062eH
	ORG $+2
	DD	FLAT:??_C@_0CA@POFLHCFC@MAIN?5SUPER?5ENTERPRISES?5CO?4?0LTD?4?$AA@
	DW	0638H
	ORG $+2
	DD	FLAT:??_C@_0O@JBKMBCEI@Avision?0?5Inc?4?$AA@
	DW	0639H
	ORG $+2
	DD	FLAT:??_C@_0P@GAMNDPPF@Chrontel?0?5Inc?4?$AA@
	DW	064bH
	ORG $+2
	DD	FLAT:??_C@_0CH@PMGKCBAF@Analog?5Devices?0?5Inc?4?5Development@
	DW	064cH
	ORG $+2
	DD	FLAT:??_C@_0BL@EBDNAMPI@Ji?9Haw?5Industrial?5Co?4?0?5Ltd?$AA@
	DW	064eH
	ORG $+2
	DD	FLAT:??_C@_0BC@HBOMJHJG@Suyin?5Corporation?$AA@
	DW	064fH
	ORG $+2
	DD	FLAT:??_C@_0BA@BPHBIEFO@WIBU?9Systems?5AG?$AA@
	DW	0655H
	ORG $+2
	DD	FLAT:??_C@_0BP@BBNBDGIM@Space?5Shuttle?5Hi?9Tech?5Co?4?0Ltd?4?$AA@
	DW	0656H
	ORG $+2
	DD	FLAT:??_C@_0BL@JPOIGLAH@Glory?5Mark?5Electronic?5Ltd?4?$AA@
	DW	0657H
	ORG $+2
	DD	FLAT:??_C@_0BJ@HLMOOHDB@Tekcon?5Electronics?5Corp?4?$AA@
	DW	0658H
	ORG $+2
	DD	FLAT:??_C@_0BE@DBNMJIBL@Sigma?5Designs?0?5Inc?4?$AA@
	DW	065fH
	ORG $+2
	DD	FLAT:??_C@_0DD@MJJJJEAM@Good?5Way?5Technology?5Co?4?0?5Ltd?4?5?$CG?5@
	DW	0660H
	ORG $+2
	DD	FLAT:??_C@_0CA@PAFBBAIH@TSAY?9E?5?$CIBVI?$CJ?5International?5Inc?4?$AA@
	DW	0661H
	ORG $+2
	DD	FLAT:??_C@_0BJ@PKNBNCAJ@Hamamatsu?5Photonics?5K?4K?4?$AA@
	DW	066aH
	ORG $+2
	DD	FLAT:??_C@_0BJ@BPDLABPC@Total?5Technologies?0?5Ltd?4?$AA@
	DW	0678H
	ORG $+2
	DD	FLAT:??_C@_0BH@GHMCMJEK@ACARD?5Technology?5Corp?4?$AA@
	DW	067bH
	ORG $+2
	DD	FLAT:??_C@_0BK@PDKHMLGO@Prolific?5Technology?0?5Inc?4?$AA@
	DW	0413cH
	ORG $+2
	DD	FLAT:??_C@_09JOKCKELG@Dell?5Inc?4?$AA@
	DW	0690H
	ORG $+2
	DD	FLAT:??_C@_0BM@LFPCEBHN@Golden?5Bridge?5Electech?5Inc?4?$AA@
	DW	0693H
	ORG $+2
	DD	FLAT:??_C@_0BN@HLLIJJKK@Hagiwara?5Solutions?5Co?4?0?5Ltd?4?$AA@
	DW	0699H
	ORG $+2
	DD	FLAT:??_C@_0BA@EMAGANPI@Tektronix?0?5Inc?4?$AA@
	DW	06a3H
	ORG $+2
	DD	FLAT:??_C@_0BE@KEFLECEP@MadCatz?5Europe?5Ltd?4?$AA@
	DW	06a4H
	ORG $+2
	DD	FLAT:??_C@_0CC@KJLDAPCA@Xiamen?5Doowell?5Electron?5Co?4?0?5Ltd@
	DW	06adH
	ORG $+2
	DD	FLAT:??_C@_0CC@NHGJCBNO@Greatland?5Electronics?5Taiwan?5Ltd@
	DW	06aeH
	ORG $+2
	DD	FLAT:??_C@_0P@DFEICALO@Testronic?5Labs?$AA@
	DW	06b8H
	ORG $+2
	DD	FLAT:??_C@_0BD@MFHNCDAI@Pixela?5Corporation?$AA@
	DW	06bcH
	ORG $+2
	DD	FLAT:??_C@_0BF@KBMIOCIB@Oki?5Data?5Corporation?$AA@
	DW	06bfH
	ORG $+2
	DD	FLAT:??_C@_0BC@PBNHDNIB@Leoco?5Corporation?$AA@
	DW	06c4H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IAMJELKE@Bizlink?5Technology?0?5Inc?4?$AA@
	DW	06c8H
	ORG $+2
	DD	FLAT:??_C@_0L@IGNPDHHH@SIIG?0?5Inc?4?$AA@
	DW	06d3H
	ORG $+2
	DD	FLAT:??_C@_0CA@FPPDHAGC@Mitsubishi?5Electric?5Corporation?$AA@
	DW	06deH
	ORG $+2
	DD	FLAT:??_C@_0BM@MDDCDOBA@Heisei?5Electronics?5Co?4?5Ltd?4?$AA@
	DW	070aH
	ORG $+2
	DD	FLAT:??_C@_0CA@MKILJNBK@Oki?5Electric?5Industry?5Co?4?0?5Ltd?4?$AA@
	DW	070eH
	ORG $+2
	DD	FLAT:??_C@_0CA@HDLCMAHN@Excel?5Cell?5Electronic?5Co?4?0?5Ltd?4?$AA@
	DW	0711H
	ORG $+2
	DD	FLAT:??_C@_0BP@JCFMJDGG@Magic?5Control?5Technology?5Corp?4?$AA@
	DW	0718H
	ORG $+2
	DD	FLAT:??_C@_0O@NNOCEOFA@Imation?5Corp?4?$AA@
	DW	072eH
	ORG $+2
	DD	FLAT:??_C@_0BA@IFGJOCOG@Sunix?5Co?4?0?5Ltd?4?$AA@
	DW	0736H
	ORG $+2
	DD	FLAT:??_C@_0BL@PJBMJABB@Lorom?5Industrial?5Co?4?0?5Ltd?4?$AA@
	DW	0764H
	ORG $+2
	DD	FLAT:??_C@_0BK@PCICHEDF@Cyber?5Power?5Systems?0?5Inc?4?$AA@
	DW	0766H
	ORG $+2
	DD	FLAT:??_C@_0CD@HFGLNKOO@Jess?9Link?5Products?5Co?4?0?5Ltd?4?5?$CIJP@
	DW	076bH
	ORG $+2
	DD	FLAT:??_C@_0BA@FCBANMAL@HID?5Global?5GmbH?$AA@
	DW	0777H
	ORG $+2
	DD	FLAT:??_C@_0CG@IKDDLBBP@Comda?5Advanced?5Technology?5Corpor@
	DW	0779H
	ORG $+2
	DD	FLAT:??_C@_0BI@OBNCJIEM@Fairchild?5Semiconductor?$AA@
	DW	0781H
	ORG $+2
	DD	FLAT:??_C@_0BE@KACIGGGG@SanDisk?5Corporation?$AA@
	DW	0791H
	ORG $+2
	DD	FLAT:??_C@_0CB@LGBOFDFN@Copartner?5Technology?5Corporation@
	DW	07a2H
	ORG $+2
	DD	FLAT:??_C@_0BL@MPFKAMGD@National?5Technical?5Systems?$AA@
	DW	07b3H
	ORG $+2
	DD	FLAT:??_C@_0O@OCMFCBHB@Plustek?0?5Inc?4?$AA@
	DW	07b4H
	ORG $+2
	DD	FLAT:??_C@_0BE@NJLEDFOB@OLYMPUS?5CORPORATION?$AA@
	DW	07b7H
	ORG $+2
	DD	FLAT:??_C@_0BH@MGBHEDBN@TIME?5Interconnect?5Ltd?4?$AA@
	DW	07caH
	ORG $+2
	DD	FLAT:??_C@_0BN@EGFACLDP@AVerMedia?5Technologies?0?5Inc?4?$AA@
	DW	07ccH
	ORG $+2
	DD	FLAT:??_C@_0BL@FNDINGLK@Carry?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	07cfH
	ORG $+2
	DD	FLAT:??_C@_0BJ@JKHOIPCI@Casio?5Computer?5Co?4?0?5Ltd?4?$AA@
	DW	07daH
	ORG $+2
	DD	FLAT:??_C@_0BJ@ODMCNPPD@Arasan?5Chip?5Systems?5Inc?4?$AA@
	DW	07dfH
	ORG $+2
	DD	FLAT:??_C@_0CA@BNLONGOH@David?5Electronics?5Company?0?5Ltd?4?$AA@
	DW	07f6H
	ORG $+2
	DD	FLAT:??_C@_0BH@NBGJMCGE@Circuit?5Assembly?5Corp?4?$AA@
	DW	07f7H
	ORG $+2
	DD	FLAT:??_C@_0BE@OPFGKFFJ@Century?5Corporation?$AA@
	DW	07f9H
	ORG $+2
	DD	FLAT:??_C@_0BH@FDLEJAIK@Dotop?5Technology?0?5Inc?4?$AA@
	DW	080aH
	ORG $+2
	DD	FLAT:??_C@_0BO@CAINGGKC@Evermuch?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0835H
	ORG $+2
	DD	FLAT:??_C@_0CB@POAJBKGF@Action?5Star?5Enterprise?5Co?4?0?5Ltd?4@
	DW	0840H
	ORG $+2
	DD	FLAT:??_C@_0BF@DELPFPOB@Argosy?5Research?5Inc?4?$AA@
	DW	086fH
	ORG $+2
	DD	FLAT:??_C@_0BB@CEKEIHLM@MEC?5IMEX?5INC?1HPT?$AA@
	DW	0874H
	ORG $+2
	DD	FLAT:??_C@_0BG@FKPDHKLP@A?9Tec?5Subsystem?0?5Inc?4?$AA@
	DW	0897H
	ORG $+2
	DD	FLAT:??_C@_0BA@EMBEKEAB@Lauterbach?5GmbH?$AA@
	DW	089dH
	ORG $+2
	DD	FLAT:??_C@_0BP@PNBHHOAN@Icron?5Technologies?5Corporation?$AA@
	DW	08b9H
	ORG $+2
	DD	FLAT:??_C@_0BH@CFIMBAIC@RadioShack?5Corporation?$AA@
	DW	08bbH
	ORG $+2
	DD	FLAT:??_C@_0BI@HFFFIPIB@Texas?5Instruments?5Japan?$AA@
	DW	08c7H
	ORG $+2
	DD	FLAT:??_C@_0BO@JNLBBKDI@TAI?5TWUN?5ENTERPRISE?5CO?4?0?5LTD?4?$AA@
	DW	08e4H
	ORG $+2
	DD	FLAT:??_C@_0BE@PMKDDGDC@Pioneer?5Corporation?$AA@
	DW	08e6H
	ORG $+2
	DD	FLAT:??_C@_0L@NMFIDNE@Gemalto?5SA?$AA@
	DW	08ffH
	ORG $+2
	DD	FLAT:??_C@_0BA@ILLLPBKP@AuthenTec?0?5Inc?4?$AA@
	DW	0906H
	ORG $+2
	DD	FLAT:??_C@_0BJ@DEEADHEC@FARADAY?5Technology?5Corp?4?$AA@
	DW	0909H
	ORG $+2
	DD	FLAT:??_C@_0BF@DGGIOLK@Audio?9Technica?5Corp?4?$AA@
	DW	090cH
	ORG $+2
	DD	FLAT:??_C@_0BO@BNPBHCJB@Silicon?5Motion?0?5Inc?4?5?9?5Taiwan?$AA@
	DW	091eH
	ORG $+2
	DD	FLAT:??_C@_0BF@OCKCLCDJ@Garmin?5International?$AA@
	DW	0922H
	ORG $+2
	DD	FLAT:??_C@_0BB@IJHLMKN@Dymo?5Corporation?$AA@
	DW	0930H
	ORG $+2
	DD	FLAT:??_C@_0BE@JMAMIBAH@Toshiba?5Corporation?$AA@
	DW	093aH
	ORG $+2
	DD	FLAT:??_C@_0BF@FDMCHING@Pixart?5Imaging?0?5Inc?4?$AA@
	DW	093bH
	ORG $+2
	DD	FLAT:??_C@_0M@DPPDGGNF@Plextor?5LLC?$AA@
	DW	093eH
	ORG $+2
	DD	FLAT:??_C@_0BG@PLHGNMC@J?4S?4T?4?5Mfg?4?5Co?4?0?5Ltd?4?$AA@
	DW	0951H
	ORG $+2
	DD	FLAT:??_C@_0BM@LKMMOGNE@Kingston?5Technology?5Company?$AA@
	DW	0955H
	ORG $+2
	DD	FLAT:??_C@_06HLMMPIBG@NVIDIA?$AA@
	DW	0957H
	ORG $+2
	DD	FLAT:??_C@_0BL@KLPBIJLK@Agilent?5Technologies?0?5Inc?4?$AA@
	DW	095bH
	ORG $+2
	DD	FLAT:??_C@_0BH@DIONPOBP@Medialogic?5Corporation?$AA@
	DW	095dH
	ORG $+2
	DD	FLAT:??_C@_0O@LKCCNLNO@Polycom?0?5Inc?4?$AA@
	DW	06000H
	ORG $+2
	DD	FLAT:??_C@_0CF@DOLEFDNC@TRIDENT?5MICROSYSTEMS?5?$CIFar?5East?$CJ?5@
	DW	09a4H
	ORG $+2
	DD	FLAT:??_C@_0BH@NHOGNCFH@Contech?5Research?0?5Inc?4?$AA@
	DW	09a8H
	ORG $+2
	DD	FLAT:??_C@_0CA@NGELPCKK@Lin?5Shiung?5Enterprise?5Co?4?0?5Ltd?4?$AA@
	DW	09abH
	ORG $+2
	DD	FLAT:??_C@_0BN@OHPOFJEM@Japan?5Cash?5Machine?5Co?4?0?5Ltd?4?$AA@
	DW	09c2H
	ORG $+2
	DD	FLAT:??_C@_0BC@JHLIIJEE@NISCA?5Corporation?$AA@
	DW	09ccH
	ORG $+2
	DD	FLAT:??_C@_0BE@OJFDPOOK@Workbit?5Corporation?$AA@
	DW	09cfH
	ORG $+2
	DD	FLAT:??_C@_0CD@HNEJNPKP@Electronics?5Testing?5Center?0?5Taiw@
	DW	09d9H
	ORG $+2
	DD	FLAT:??_C@_05KFMIDCBE@Jungo?$AA@
	DW	09daH
	ORG $+2
	DD	FLAT:??_C@_0BG@LAHNEDCJ@A?9FOUR?5TECH?5CO?4?0?5LTD?4?$AA@
	DW	09e5H
	ORG $+2
	DD	FLAT:??_C@_0BL@MPNFCJBM@Jo?9Dan?5International?0?5Inc?4?$AA@
	DW	0a17H
	ORG $+2
	DD	FLAT:??_C@_0BB@HPCCBBBB@HOYA?5Corporation?$AA@
	DW	0a21H
	ORG $+2
	DD	FLAT:??_C@_0BF@EKKNDOHK@Physio?9Control?0?5Inc?4?$AA@
	DW	0a47H
	ORG $+2
	DD	FLAT:??_C@_0BK@IKEGAKKP@Hirose?5Electric?5Co?4?0?5Ltd?4?$AA@
	DW	0a48H
	ORG $+2
	DD	FLAT:??_C@_0BB@KGGFOALP@I?1O?5Interconnect?$AA@
	DW	0a4cH
	ORG $+2
	DD	FLAT:??_C@_0BD@LHJHCFAG@COMPUTEX?5Co?4?0?5Ltd?4?$AA@
	DW	0a50H
	ORG $+2
	DD	FLAT:??_C@_0BN@FBNECLJJ@Mimaki?5Engineering?5Co?4?0?5Ltd?4?$AA@
	DW	0a5cH
	ORG $+2
	DD	FLAT:??_C@_0P@KBOGHGP@Broadcom?5Corp?4?$AA@
	DW	0a6bH
	ORG $+2
	DD	FLAT:??_C@_0BG@IJFMHNNO@Green?5House?5Co?4?0?5Ltd?4?$AA@
	DW	0a7dH
	ORG $+2
	DD	FLAT:??_C@_0O@HDJGGMBN@Intertek?5NSTL?$AA@
	DW	0a81H
	ORG $+2
	DD	FLAT:??_C@_0BJ@JHAHKIDB@CHESEN?5ELECTRONICS?5CORP?4?$AA@
	DW	0a8eH
	ORG $+2
	DD	FLAT:??_C@_0CP@BLIFGEAH@Japan?5Aviation?5Electronics?5Indus@
	DW	0a8fH
	ORG $+2
	DD	FLAT:??_C@_0BF@BPGMFHBM@Young?5Chang?5Co?4?5Ltd?4?$AA@
	DW	0aa7H
	ORG $+2
	DD	FLAT:??_C@_0BM@KFMMGOHA@Wincor?5Nixdorf?5GmbH?5?$CG?5Co?5KG?$AA@
	DW	0ac3H
	ORG $+2
	DD	FLAT:??_C@_0CC@EIBHCLN@SANYO?5Semiconductor?5Company?5Micr@
	DW	0ac8H
	ORG $+2
	DD	FLAT:??_C@_0BE@HMAJKJ@Vimicro?5Corporation?$AA@
	DW	0ae3H
	ORG $+2
	DD	FLAT:??_C@_0BH@CELKNPMM@Allion?5Test?5Labs?0?5Inc?4?$AA@
	DW	0af0H
	ORG $+2
	DD	FLAT:??_C@_09FMCEBPKI@Option?5NV?$AA@
	DW	0b05H
	ORG $+2
	DD	FLAT:??_C@_0BG@HEOGBEPO@ASUSTek?5Computer?5Inc?4?$AA@
	DW	0b1eH
	ORG $+2
	DD	FLAT:??_C@_0CK@PLBMIBK@Electronic?5Warfare?5Associates?0?5I@
	DW	0b21H
	ORG $+2
	DD	FLAT:??_C@_0BO@KKOFHFLP@Yokogawa?5Electric?5Corporation?$AA@
	DW	0b23H
	ORG $+2
	DD	FLAT:??_C@_0BP@IGDJFEE@Pan?9Asia?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	0b3cH
	ORG $+2
	DD	FLAT:??_C@_0P@GFHEPPBN@Olivetti?5S?4p?4A?$AA@
	DW	0b4eH
	ORG $+2
	DD	FLAT:??_C@_0BJ@MJIIIHDL@Musical?5Electronics?5Ltd?4?$AA@
	DW	0b54H
	ORG $+2
	DD	FLAT:??_C@_0BN@IGCLCEEO@Sinbon?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	0b6aH
	ORG $+2
	DD	FLAT:??_C@_0BK@DICOBJHO@Maxim?5Integrated?5Products?$AA@
	DW	0b95H
	ORG $+2
	DD	FLAT:??_C@_0BN@DBGBIANO@ASIX?5Electronics?5Corporation?$AA@
	DW	0b97H
	ORG $+2
	DD	FLAT:??_C@_0O@PGGKPFEM@O2Micro?0?5Inc?4?$AA@
	DW	0bb4H
	ORG $+2
	DD	FLAT:??_C@_0BA@BLJMPEH@HTC?5Corporation?$AA@
	DW	0bb5H
	ORG $+2
	DD	FLAT:??_C@_0BP@JGDEFBDO@Murata?5Manufacturing?5Co?4?0?5Ltd?4?$AA@
	DW	0bc2H
	ORG $+2
	DD	FLAT:??_C@_0BH@PKPGHPEE@Seagate?5Technology?5LLC?$AA@
	DW	0bdaH
	ORG $+2
	DD	FLAT:??_C@_0BM@OODBLDMG@Realtek?5Semiconductor?5Corp?4?$AA@
	DW	0bdbH
	ORG $+2
	DD	FLAT:??_C@_0M@PBGCMNLB@Ericsson?5AB?$AA@
	DW	0be4H
	ORG $+2
	DD	FLAT:??_C@_0BI@GAPKJOJF@Elka?5International?5Ltd?4?$AA@
	DW	0beeH
	ORG $+2
	DD	FLAT:??_C@_0BK@EBNIPBJG@LTK?5International?5Limited?$AA@
	DW	0c06H
	ORG $+2
	DD	FLAT:??_C@_0N@BIDPCKE@Hasbro?0?5Inc?4?$AA@
	DW	0c0bH
	ORG $+2
	DD	FLAT:??_C@_0BB@BJDBAEPG@Dura?5Micro?0?5Inc?4?$AA@
	DW	0c24H
	ORG $+2
	DD	FLAT:??_C@_0BG@BDCJOHPC@Taiyo?5Yuden?5Co?4?0?5Ltd?4?$AA@
	DW	0c39H
	ORG $+2
	DD	FLAT:??_C@_08EDJBOCE@Aeroflex?$AA@
	DW	0c45H
	ORG $+2
	DD	FLAT:??_C@_0BL@IIBBHDLP@Sonix?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0c56H
	ORG $+2
	DD	FLAT:??_C@_0BH@GADMIKAO@Billion?5Bright?5Limited?$AA@
	DW	0c59H
	ORG $+2
	DD	FLAT:??_C@_0CA@KMAKLJKD@Dong?5Guan?5Shinko?5Wire?5Co?4?0?5Ltd?4?$AA@
	DW	0c62H
	ORG $+2
	DD	FLAT:??_C@_0BH@FHGKBINA@Chant?5Sincere?5Co?4?0?5Ltd?$AA@
	DW	0c68H
	ORG $+2
	DD	FLAT:??_C@_0BN@KANEMGNF@Whanam?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	0c76H
	ORG $+2
	DD	FLAT:??_C@_0BN@PNHCHLDH@Solid?5State?5System?5Co?4?0?5Ltd?4?$AA@
	DW	0c89H
	ORG $+2
	DD	FLAT:??_C@_0BN@KPNGPOOH@Honda?5Tsushin?5Kogyo?5Co?4?0?5Ltd?$AA@
	DW	0cadH
	ORG $+2
	DD	FLAT:??_C@_0BD@PCKEPBKO@Motorola?5Solutions?$AA@
	DW	0cb7H
	ORG $+2
	DD	FLAT:??_C@_0BO@DKFGFGHA@Singatron?5Enterprise?5Co?4?5Ltd?4?$AA@
	DW	0cc4H
	ORG $+2
	DD	FLAT:??_C@_0BM@NGPEIKDH@emsys?5Embedded?5Systems?5GmbH?$AA@
	DW	0cd9H
	ORG $+2
	DD	FLAT:??_C@_0BE@DLHFEAFK@Shin?5Din?5Cable?5Ltd?4?$AA@
	DW	08086H
	ORG $+2
	DD	FLAT:??_C@_0BC@ECMAKMHG@Intel?5Corporation?$AA@
	DW	0cdeH
	ORG $+2
	DD	FLAT:??_C@_0L@OACAMJJG@Z?9Com?5INC?4?$AA@
	DW	0cf1H
	ORG $+2
	DD	FLAT:??_C@_0BM@OOCFEMN@e?9CONN?5ELECTRONIC?5CO?4?0?5LTD?4?$AA@
	DW	0cf2H
	ORG $+2
	DD	FLAT:??_C@_0BE@KPNEJJKA@ENE?5Technology?5Inc?4?$AA@
	DW	0cf3H
	ORG $+2
	DD	FLAT:??_C@_0BH@IIKDMMBP@Qualcomm?5Atheros?0?5Inc?4?$AA@
	DW	0d17H
	ORG $+2
	DD	FLAT:??_C@_0N@IDKBGBCG@NALTEC?0?5Inc?4?$AA@
	DW	0d19H
	ORG $+2
	DD	FLAT:??_C@_0CD@IJEJHEOO@Shanghai?5Hank?5Connection?5Co?4?0?5Lt@
	DW	0d4aH
	ORG $+2
	DD	FLAT:??_C@_0P@MAHCGCHE@NF?5Corporation?$AA@
	DW	0d4bH
	ORG $+2
	DD	FLAT:??_C@_0BD@KEPOILEK@Grape?5Systems?5Inc?4?$AA@
	DW	0d51H
	ORG $+2
	DD	FLAT:??_C@_0BF@GHDJEHFK@Volex?5?$CIAsia?$CJ?5Pte?5Ltd?$AA@
	DW	0d61H
	ORG $+2
	DD	FLAT:??_C@_0CH@DILBGHLF@MEILU?5ELECTRONICS?5?$CISHENZHEN?$CJ?5CO?4@
	DW	0d71H
	ORG $+2
	DD	FLAT:??_C@_0BH@JNDMIFOJ@Hirakawa?5Hewtech?5Corp?4?$AA@
	DW	0d7cH
	ORG $+2
	DD	FLAT:??_C@_0CF@DEKDBPDL@Taiwan?5Line?5Tek?5Electronic?5Co?4?0?5@
	DW	0d87H
	ORG $+2
	DD	FLAT:??_C@_0BI@BKFMOADO@Dolby?5Laboratories?5Inc?4?$AA@
	DW	0d8cH
	ORG $+2
	DD	FLAT:??_C@_0BJ@ICKBMN@C?9MEDIA?5ELECTRONICS?5INC?4?$AA@
	DW	0d8fH
	ORG $+2
	DD	FLAT:??_C@_0N@ECGNEKML@Pitney?5Bowes?$AA@
	DW	0d90H
	ORG $+2
	DD	FLAT:??_C@_0CB@CBEHKKIA@Sure?9Fire?5Electrical?5Corporation@
	DW	0da7H
	ORG $+2
	DD	FLAT:??_C@_0N@BBFDLJEL@IOGEAR?0?5Inc?4?$AA@
	DW	0db0H
	ORG $+2
	DD	FLAT:??_C@_0CD@LDGCJJON@Micro?9Star?5International?5Co?4?0?5Lt@
	DW	0dc4H
	ORG $+2
	DD	FLAT:??_C@_0O@PIGMBEOG@inXtron?0?5Inc?4?$AA@
	DW	0dc5H
	ORG $+2
	DD	FLAT:??_C@_0N@BBHIMAGO@SDK?5Co?0?5Ltd?4?$AA@
	DW	0dd1H
	ORG $+2
	DD	FLAT:??_C@_0BN@MEJNGPFO@Contek?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	0dd2H
	ORG $+2
	DD	FLAT:??_C@_0CH@HKHHADBM@Power?5Quotient?5International?5Co?4@
	DW	0dd4H
	ORG $+2
	DD	FLAT:??_C@_0BH@JAOPMIJP@Custom?5Engineering?5SPA?$AA@
	DW	0e23H
	ORG $+2
	DD	FLAT:??_C@_0BO@MECAJMAF@Liou?5Yuane?5International?5Ltd?4?$AA@
	DW	0e39H
	ORG $+2
	DD	FLAT:??_C@_0CB@BNIAIBOP@Smart?5Modular?5Technologies?0?5Inc?4@
	DW	0e3aH
	ORG $+2
	DD	FLAT:??_C@_0BN@MDHILMJA@Neostar?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0e5bH
	ORG $+2
	DD	FLAT:??_C@_0CN@LHINEDL@Union?5Power?5Information?5Industri@
	DW	0e5dH
	ORG $+2
	DD	FLAT:??_C@_0BN@DKLMDFEK@Neltron?5Industrial?5Co?4?0?5Ltd?4?$AA@
	DW	0e6aH
	ORG $+2
	DD	FLAT:??_C@_0BN@PNJNPPHF@Megawin?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0e72H
	ORG $+2
	DD	FLAT:??_C@_0BP@FIEIALAE@Hsi?9Chin?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	0e8cH
	ORG $+2
	DD	FLAT:??_C@_0BP@BAFJGBFA@Well?5Force?5Electronic?5Co?4?0?5Ltd?$AA@
	DW	0e8dH
	ORG $+2
	DD	FLAT:??_C@_0O@DBHJNIK@MediaTek?5Inc?4?$AA@
	DW	0e9bH
	ORG $+2
	DD	FLAT:??_C@_0BC@PLHJNEDE@ADTEC?5CORPORATION?$AA@
	DW	0ea0H
	ORG $+2
	DD	FLAT:??_C@_0BF@LFNPLID@Ours?5Technology?5Inc?4?$AA@
	DW	0eb2H
	ORG $+2
	DD	FLAT:??_C@_0BJ@FFOINCNP@Y?9S?5ELECTRONIC?5CO?4?0?5LTD?4?$AA@
	DW	0ec2H
	ORG $+2
	DD	FLAT:??_C@_0BJ@EEJFEJAC@Sweetray?5Industrial?5Ltd?4?$AA@
	DW	0ec3H
	ORG $+2
	DD	FLAT:??_C@_0BC@NLMJJEGP@Axell?5Corporation?$AA@
	DW	0ec6H
	ORG $+2
	DD	FLAT:??_C@_0BO@HGLIFDP@InnoVISION?5Multimedia?5Limited?$AA@
	DW	0ecdH
	ORG $+2
	DD	FLAT:??_C@_0BB@FPOIDBI@Lite?9On?5IT?5Corp?4?$AA@
	DW	0ee4H
	ORG $+2
	DD	FLAT:??_C@_0BP@OLFMJOLO@Sunrich?5Technology?5?$CIH?4K?4?$CJ?5Ltd?4?$AA@
	DW	0f08H
	ORG $+2
	DD	FLAT:??_C@_0CE@LHKAEIDJ@CSL?5Wire?5?$CG?5Plug?5?$CIShen?5Zhen?$CJ?5Comp@
	DW	0f2eH
	ORG $+2
	DD	FLAT:??_C@_0BF@HHKPOBJN@Good?5Man?5Corporation?$AA@
	DW	0f32H
	ORG $+2
	DD	FLAT:??_C@_0CA@JKBEBDIB@YFC?9BonEagle?5Electric?5Co?4?0?5Ltd?4?$AA@
	DW	0f4cH
	ORG $+2
	DD	FLAT:??_C@_0BL@PCHAGLHO@WORLDWIDE?5CABLE?5OPTO?5CORP?4?$AA@
	DW	0f52H
	ORG $+2
	DD	FLAT:??_C@_0BO@NDDFJIHH@WING?5KEI?5ELECTRICAL?5CO?4?0?5LTD?4?$AA@
	DW	0f53H
	ORG $+2
	DD	FLAT:??_C@_0CA@JJBCDJBC@Taiyo?5Cable?5?$CIDongguan?$CJ?5Co?4?5Ltd?4?$AA@
	DW	0f54H
	ORG $+2
	DD	FLAT:??_C@_0CJ@GLJCMOOM@Kawai?5Musical?5Instruments?5Mfg?4?5C@
	DW	0f60H
	ORG $+2
	DD	FLAT:??_C@_0DE@KCDILGEE@GuangZhou?5Chief?5Tech?5Electronic?5@
	DW	0f68H
	ORG $+2
	DD	FLAT:??_C@_0BD@CAOPHLDB@TEPCO?5UQUEST?0?5LTD?4?$AA@
	DW	0f69H
	ORG $+2
	DD	FLAT:??_C@_0BD@HLMPAKPJ@DIONEX?5CORPORATION?$AA@
	DW	0f8bH
	ORG $+2
	DD	FLAT:??_C@_0BD@KEDKNNLF@Yazaki?5Corporation?$AA@
	DW	0f97H
	ORG $+2
	DD	FLAT:??_C@_0BD@NPCAKEK@CviLux?5Corporation?$AA@
	DW	0fb8H
	ORG $+2
	DD	FLAT:??_C@_0BE@DKFGOFCL@Wistron?5Corporation?$AA@
	DW	0fbaH
	ORG $+2
	DD	FLAT:??_C@_0CB@KMPGIMLP@SAN?5SHING?5ELECTRONICS?5CO?4?0?5LTD?4?4@
	DW	0fceH
	ORG $+2
	DD	FLAT:??_C@_0CH@JMIKCMLI@Sony?5Ericsson?5Mobile?5Communicati@
	DW	0ff7H
	ORG $+2
	DD	FLAT:??_C@_0CJ@MNOHKIGC@CHI?5SHING?5COMPUTER?5ACCESSORIES?5C@
	DW	01000H
	ORG $+2
	DD	FLAT:??_C@_0BB@FNNKEBO@Speed?5Tech?5Corp?4?$AA@
	DW	01004H
	ORG $+2
	DD	FLAT:??_C@_0BE@PPCAGGEP@LG?5Electronics?5Inc?4?$AA@
	DW	01026H
	ORG $+2
	DD	FLAT:??_C@_0BC@KLMPEDJE@Newly?5Corporation?$AA@
	DW	0102fH
	ORG $+2
	DD	FLAT:??_C@_0CP@MHAOCCHA@WENZHOU?5YIHUA?5COMMUNICATED?5CONNE@
	DW	01038H
	ORG $+2
	DD	FLAT:??_C@_0BA@PMFKJABH@SteelSeries?5ApS?$AA@
	DW	01048H
	ORG $+2
	DD	FLAT:??_C@_0BL@DIDNCHDM@Targus?5Group?5International?$AA@
	DW	01057H
	ORG $+2
	DD	FLAT:??_C@_0BB@MCAPDOMI@ON?5Semiconductor?$AA@
	DW	01058H
	ORG $+2
	DD	FLAT:??_C@_0CD@OEFJDFLG@Western?5Digital?5Technologies?0?5In@
	DW	01059H
	ORG $+2
	DD	FLAT:??_C@_0BJ@HPGECAIP@Giesecke?5?$CG?5Devrient?5GmbH?$AA@
	DW	0105cH
	ORG $+2
	DD	FLAT:??_C@_0DF@EJNCJCJN@Freeway?5Electronic?5Wire?5?$CG?5Cable?5@
	DW	01083H
	ORG $+2
	DD	FLAT:??_C@_0BH@GGINDOFM@CANON?5ELECTRONICS?5INC?4?$AA@
	DW	01084H
	ORG $+2
	DD	FLAT:??_C@_0BC@JLIOEOBP@PANTECH?5CO?4?0?5LTD?4?$AA@
	DW	0108bH
	ORG $+2
	DD	FLAT:??_C@_0BP@HEECLKMJ@Grand?9tek?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0108cH
	ORG $+2
	DD	FLAT:??_C@_0BC@MMEHCLPH@Robert?5Bosch?5GmbH?$AA@
	DW	0108eH
	ORG $+2
	DD	FLAT:??_C@_0BA@JBGEKCBJ@Lotes?5Co?4?0?5Ltd?4?$AA@
	DW	010aaH
	ORG $+2
	DD	FLAT:??_C@_0N@MADBCNBC@Cables?5To?5Go?$AA@
	DW	010abH
	ORG $+2
	DD	FLAT:??_C@_0O@DKGHEGPO@USI?5Co?4?0?5Ltd?4?$AA@
	DW	010aeH
	ORG $+2
	DD	FLAT:??_C@_0BL@GMIJPDAF@Princeton?5Technology?5Corp?4?$AA@
	DW	010bbH
	ORG $+2
	DD	FLAT:??_C@_0BD@BNHNDFDJ@TM?5Technology?5Inc?4?$AA@
	DW	010cdH
	ORG $+2
	DD	FLAT:??_C@_0L@BEMBIFEP@Kycon?5Inc?4?$AA@
	DW	010d6H
	ORG $+2
	DD	FLAT:??_C@_0CA@BFJDJKMK@Actions?5Semiconductor?5Co?4?0?5Ltd?4?$AA@
	DW	01112H
	ORG $+2
	DD	FLAT:??_C@_0DF@NDHMOMGK@Golden?5Bright?5?$CISichuan?$CJ?5Electron@
	DW	01113H
	ORG $+2
	DD	FLAT:??_C@_09JKLIJNKN@Medion?5AG?$AA@
	DW	0111eH
	ORG $+2
	DD	FLAT:??_C@_0BK@DEMMBJPB@VSO?5ELECTRONICS?5CO?4?0?5LTD?4?$AA@
	DW	0112eH
	ORG $+2
	DD	FLAT:??_C@_0CO@HLACDLIC@Master?5Hill?5Electric?5Wire?5and?5Ca@
	DW	01130H
	ORG $+2
	DD	FLAT:??_C@_0BG@JFAAFJPO@Tenx?5Technology?0?5Inc?4?$AA@
	DW	01146H
	ORG $+2
	DD	FLAT:??_C@_0CB@BPPANFMB@Shimane?5SANYO?5Electric?5Co?4?0?5Ltd?4@
	DW	0114dH
	ORG $+2
	DD	FLAT:??_C@_0BP@NKCLDENL@Alpha?5Imaging?5Technology?5Corp?4?$AA@
	DW	0115bH
	ORG $+2
	DD	FLAT:??_C@_0BL@HCIAKFOP@Salix?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	01175H
	ORG $+2
	DD	FLAT:??_C@_0CB@BGNNABKD@Sheng?5Yih?5Technologies?5Co?4?0?5Ltd?4@
	DW	01199H
	ORG $+2
	DD	FLAT:??_C@_0BF@FDIEEFFD@Sierra?5Wireless?5Inc?4?$AA@
	DW	0119aH
	ORG $+2
	DD	FLAT:??_C@_0CG@JCFADKIE@DONG?5GUAN?5JALINK?5ELECTRONICES?5CO@
	DW	011aaH
	ORG $+2
	DD	FLAT:??_C@_0BH@LNLMLHPJ@GlobalMedia?5Group?0?5LLC?$AA@
	DW	011b0H
	ORG $+2
	DD	FLAT:??_C@_0BH@HFAICOFB@ATECH?5FLASH?5TECHNOLOGY?$AA@
	DW	011e6H
	ORG $+2
	DD	FLAT:??_C@_0BJ@GJMOHKID@K?4I?4?5Technology?5Co?4?5Ltd?4?$AA@
	DW	0120eH
	ORG $+2
	DD	FLAT:??_C@_0BG@MJAIIBOP@HUDSON?5SOFT?5CO?4?0?5LTD?4?$AA@
	DW	01223H
	ORG $+2
	DD	FLAT:??_C@_0BP@DHPBBMCB@SKYCABLE?5ENTERPRISE?4?5CO?4?0?5LTD?4?$AA@
	DW	0124bH
	ORG $+2
	DD	FLAT:??_C@_0BI@KKGDFIOD@NYKO?5Technologies?0?5Inc?4?$AA@
	DW	0125fH
	ORG $+2
	DD	FLAT:??_C@_0BL@FCGNNKPJ@ADATA?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	01262H
	ORG $+2
	DD	FLAT:??_C@_0BH@CNPFBGCM@MICRO?5VISION?5CO?4?0?5LTD?4?$AA@
	DW	0126cH
	ORG $+2
	DD	FLAT:??_C@_0BI@BANJHMOB@Aristocrat?5Technologies?$AA@
	DW	0126dH
	ORG $+2
	DD	FLAT:??_C@_0M@HPCCHOFJ@Bel?5Stewart?$AA@
	DW	01281H
	ORG $+2
	DD	FLAT:??_C@_0BO@EMLGGAIJ@Gean?5Sen?5Electronic?5Co?4?0?5Ltd?4?$AA@
	DW	01286H
	ORG $+2
	DD	FLAT:??_C@_0BM@FDHCJPEM@MARVELL?5SEMICONDUCTOR?0?5INC?4?$AA@
	DW	01294H
	ORG $+2
	DD	FLAT:??_C@_0BC@CDINJBKA@RISO?5KAGAKU?5CORP?4?$AA@
	DW	012abH
	ORG $+2
	DD	FLAT:??_C@_0CI@LMINHIGA@Honey?5Bee?5Electronic?5Internation@
	DW	012b8H
	ORG $+2
	DD	FLAT:??_C@_0CP@OPCIAOPO@Zhejiang?5Xinya?5Electronic?5Techno@
	DW	012d2H
	ORG $+2
	DD	FLAT:??_C@_0BP@JPNNFCKE@LINE?5TECH?5INDUSTRIAL?5CO?4?0?5LTD?4?$AA@
	DW	012d7H
	ORG $+2
	DD	FLAT:??_C@_0BN@DKNOJINI@Better?5Holdings?5?$CIHK?$CJ?5Limited?$AA@
	DW	0132bH
	ORG $+2
	DD	FLAT:??_C@_0BO@KIELHJB@Konica?5Minolta?5Holdings?0?5Inc?4?$AA@
	DW	01348H
	ORG $+2
	DD	FLAT:??_C@_0BP@ODBMNHOP@Katsuragawa?5Electric?5Co?4?0?5Ltd?4?$AA@
	DW	01370H
	ORG $+2
	DD	FLAT:??_C@_0M@IPAHGEJP@Swissbit?5AG?$AA@
	DW	0137dH
	ORG $+2
	DD	FLAT:??_C@_0BM@DKMEKHIM@Pericom?5Semiconductor?5Corp?4?$AA@
	DW	01390H
	ORG $+2
	DD	FLAT:??_C@_0BK@LJKDAPJK@TomTom?5International?5B?4V?4?$AA@
	DW	013caH
	ORG $+2
	DD	FLAT:??_C@_0CG@BGIJPEKA@JyeTai?5Precision?5Industrial?5Co?4?0@
	DW	013cfH
	ORG $+2
	DD	FLAT:??_C@_0M@DPEOBOCF@Wisair?5Ltd?4?$AA@
	DW	013d3H
	ORG $+2
	DD	FLAT:??_C@_0BN@BNPLLCII@AzureWave?5Technologies?0?5Inc?4?$AA@
	DW	013dcH
	ORG $+2
	DD	FLAT:??_C@_0O@EADKLFFK@ALEREON?0?5INC?4?$AA@
	DW	013fdH
	ORG $+2
	DD	FLAT:??_C@_0BD@MJPGJJIB@Initio?5Corporation?$AA@
	DW	013feH
	ORG $+2
	DD	FLAT:??_C@_0BJ@PODMPDKE@Phison?5Electronics?5Corp?4?$AA@
	DW	0140eH
	ORG $+2
	DD	FLAT:??_C@_0BA@EBAJJPHC@Telechips?0?5Inc?4?$AA@
	DW	01410H
	ORG $+2
	DD	FLAT:??_C@_0BH@BHONNEDH@Novatel?5Wireless?0?5Inc?4?$AA@
	DW	01419H
	ORG $+2
	DD	FLAT:??_C@_0BN@KECIKNAF@ABILITY?5ENTERPRISE?5CO?4?0?5LTD?4?$AA@
	DW	01421H
	ORG $+2
	DD	FLAT:??_C@_0CC@KOGJPFE@Sensor?5Technologies?5America?0?5Inc@
	DW	01429H
	ORG $+2
	DD	FLAT:??_C@_0CL@DCCPGNCP@Vega?5Technologies?5Industrial?5?$CIAu@
	DW	01439H
	ORG $+2
	DD	FLAT:??_C@_0BI@EBFAHIJA@Wind?5River?5Systems?5Inc?4?$AA@
	DW	0143cH
	ORG $+2
	DD	FLAT:??_C@_0BC@OEGADIHN@Altek?5Corporation?$AA@
	DW	0147aH
	ORG $+2
	DD	FLAT:??_C@_0P@OCKHDMGO@Formosa21?5Inc?4?$AA@
	DW	01487H
	ORG $+2
	DD	FLAT:??_C@_0BA@EJBEDMD@DSP?5Group?0?5Ltd?4?$AA@
	DW	0148eH
	ORG $+2
	DD	FLAT:??_C@_0N@JLOFKNJM@EVATRONIX?5SA?$AA@
	DW	014adH
	ORG $+2
	DD	FLAT:??_C@_0BA@GIDLPKMM@CTK?5Corporation?$AA@
	DW	014afH
	ORG $+2
	DD	FLAT:??_C@_0BF@POKLDLPA@ATP?5Electronics?5Inc?4?$AA@
	DW	014b0H
	ORG $+2
	DD	FLAT:??_C@_0BC@LNFIEHCE@StarTech?4com?5Ltd?4?$AA@
	DW	014cdH
	ORG $+2
	DD	FLAT:??_C@_0BN@OBOFFJMJ@MOAI?5ELECTRONICS?5CORPORATION?$AA@
	DW	01500H
	ORG $+2
	DD	FLAT:??_C@_07HKBKGGAL@Ellisys?$AA@
	DW	01516H
	ORG $+2
	DD	FLAT:??_C@_0BE@MEIKBKHJ@Skymedi?5Corporation?$AA@
	DW	0151cH
	ORG $+2
	DD	FLAT:??_C@_0BP@NFMNNPJJ@VeriSilicon?5Holdings?5Co?4?0?5Ltd?4?$AA@
	DW	0152dH
	ORG $+2
	DD	FLAT:??_C@_0BJ@NNBEAIKI@JMicron?5Technology?5Corp?4?$AA@
	DW	0152eH
	ORG $+2
	DD	FLAT:??_C@_0CF@KFFNHPKK@HLDS?5?$CIHitachi?9LG?5Data?5Storage?0?5I@
	DW	01540H
	ORG $+2
	DD	FLAT:??_C@_0BN@PJAMMHJM@Phihong?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0154bH
	ORG $+2
	DD	FLAT:??_C@_0BG@FDFFBPKH@PNY?5Technologies?5Inc?4?$AA@
	DW	0154dH
	ORG $+2
	DD	FLAT:??_C@_0CI@PJGLCGBH@Rapid?5Conn?0?5Connect?5County?5Holdi@
	DW	0154eH
	ORG $+2
	DD	FLAT:??_C@_0BF@KCLHJFIN@D?5?$CG?5M?5Holdings?0?5Inc?4?$AA@
	DW	01568H
	ORG $+2
	DD	FLAT:??_C@_0BM@MLLCLJKN@Sunf?5Pu?5Technology?5Co?4?0?5Ltd?$AA@
	DW	01570H
	ORG $+2
	DD	FLAT:??_C@_0BM@PJFBNPPK@ALLTOP?5TECHNOLOGY?5CO?4?0?5LTD?4?$AA@
	DW	0157bH
	ORG $+2
	DD	FLAT:??_C@_0L@HBGIDMAB@Ketron?5SRL?$AA@
	DW	01586H
	ORG $+2
	DD	FLAT:??_C@_0BN@MGGPMLNL@Palconn?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	01598H
	ORG $+2
	DD	FLAT:??_C@_0CE@PGJPGLLG@Kunshan?5Guoji?5Electronics?5Co?4?0?5L@
	DW	015a2H
	ORG $+2
	DD	FLAT:??_C@_0BO@KPCEMMAE@Freescale?5Semiconductor?0?5Inc?4?$AA@
	DW	015a8H
	ORG $+2
	DD	FLAT:??_C@_0CL@HBACFJJO@Shen?5Zhen?5Teamspower?5Electronics@
	DW	015aaH
	ORG $+2
	DD	FLAT:??_C@_0CI@HNEJDFII@Hong?5Kong?5Gearway?5Electronics?5Co@
	DW	015c9H
	ORG $+2
	DD	FLAT:??_C@_0BD@GIDCGAKL@D?9Box?5Technologies?$AA@
	DW	015e0H
	ORG $+2
	DD	FLAT:??_C@_0BO@FIJNAGLJ@Seong?5Ji?5Industrial?5Co?4?0?5Ltd?4?$AA@
	DW	0160dH
	ORG $+2
	DD	FLAT:??_C@_06DGDFLKMM@Samtec?$AA@
	DW	01612H
	ORG $+2
	DD	FLAT:??_C@_0N@GNFMIBKN@Soft?5DB?5Inc?4?$AA@
	DW	0163eH
	ORG $+2
	DD	FLAT:??_C@_0BO@CCKIBDCK@HongLin?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	01660H
	ORG $+2
	DD	FLAT:??_C@_0BH@OFEECAGA@Creatix?5Polymedia?5GmbH?$AA@
	DW	01679H
	ORG $+2
	DD	FLAT:??_C@_0M@OMFDOLIG@Total?5Phase?$AA@
	DW	01682H
	ORG $+2
	DD	FLAT:??_C@_0CD@NDNOFCGN@Maxwise?5Production?5Enterprise?5Lt@
	DW	016a5H
	ORG $+2
	DD	FLAT:??_C@_0CI@LPNLCPKP@Shenzhen?5Zhengerya?5Technology?5Co@
	DW	016acH
	ORG $+2
	DD	FLAT:??_C@_0CK@GHEMOGNO@Dongguan?5ChingLung?5Wire?5?$CG?5Cable?5@
	DW	016ccH
	ORG $+2
	DD	FLAT:??_C@_0BH@EKGKEMKL@silex?5technology?0?5Inc?4?$AA@
	DW	01736H
	ORG $+2
	DD	FLAT:??_C@_0BL@MBCLBNK@CANON?5IMAGING?5SYSTEMS?5INC?4?$AA@
	DW	0173aH
	ORG $+2
	DD	FLAT:??_C@_0BC@LFEKPOAD@Roche?5Diagnostics?$AA@
	DW	01748H
	ORG $+2
	DD	FLAT:??_C@_0BF@BACBMICM@MQP?5Electronics?5Ltd?4?$AA@
	DW	0174cH
	ORG $+2
	DD	FLAT:??_C@_0BI@EFCFBFPB@ASMedia?5Technology?5Inc?4?$AA@
	DW	01759H
	ORG $+2
	DD	FLAT:??_C@_0BL@PGPGIHGN@LucidPort?5Technology?0?5Inc?4?$AA@
	DW	0176eH
	ORG $+2
	DD	FLAT:??_C@_0BE@LLHADAIP@UD?5electronic?5corp?4?$AA@
	DW	01771H
	ORG $+2
	DD	FLAT:??_C@_0CC@KBPLCNPO@Shenzhen?5Alex?5Connector?5Co?4?0?5Ltd@
	DW	01772H
	ORG $+2
	DD	FLAT:??_C@_0BN@MGLGHCII@System?5Level?5Solutions?0?5Inc?4?$AA@
	DW	01782H
	ORG $+2
	DD	FLAT:??_C@_0BP@PDCKJENN@Spreadtrum?5Communications?5Inc?4?$AA@
	DW	01788H
	ORG $+2
	DD	FLAT:??_C@_0CH@GLPFKNO@ShenZhen?5Litkconn?5Technology?5Co?4@
	DW	01796H
	ORG $+2
	DD	FLAT:??_C@_0P@PAIKKKPL@Printrex?0?5Inc?4?$AA@
	DW	017a5H
	ORG $+2
	DD	FLAT:??_C@_0CE@FMNDGFCO@Advanced?5Connection?5Technology?5I@
	DW	017beH
	ORG $+2
	DD	FLAT:??_C@_0DI@IPLEGMCC@Dongguan?5Yangming?5Precision?5of?5P@
	DW	017cfH
	ORG $+2
	DD	FLAT:??_C@_0CA@FKGCAAGK@Hip?5Hing?5Cable?5?$CG?5Plug?5Mfy?4?5Ltd?4?$AA@
	DW	017e1H
	ORG $+2
	DD	FLAT:??_C@_08FCLKDPPD@ORTHOFIX?$AA@
	DW	017e9H
	ORG $+2
	DD	FLAT:??_C@_0BG@PLILAAEO@DisplayLink?5?$CIUK?$CJ?5Ltd?4?$AA@
	DW	017efH
	ORG $+2
	DD	FLAT:??_C@_06EOFPOMJG@Lenovo?$AA@
	DW	017f5H
	ORG $+2
	DD	FLAT:??_C@_0L@IGMLMAAK@K?4K?4?5Rocky?$AA@
	DW	01829H
	ORG $+2
	DD	FLAT:??_C@_0CF@KAKIFJIN@Dongguan?5YuQiu?5Electronics?5Co?4?0?5@
	DW	01831H
	ORG $+2
	DD	FLAT:??_C@_0BO@DPMJHMBK@Gwo?5Jinn?5Industries?5Co?4?0?5Ltd?4?$AA@
	DW	01898H
	ORG $+2
	DD	FLAT:??_C@_0BI@EGKCPMHF@Summit?5Microelectronics?$AA@
	DW	01899H
	ORG $+2
	DD	FLAT:??_C@_0BC@HBKKPCPF@Linkiss?5Co?4?0?5Ltd?4?$AA@
	DW	0189bH
	ORG $+2
	DD	FLAT:??_C@_0BN@LHNKNBIM@Trimax?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	018d1H
	ORG $+2
	DD	FLAT:??_C@_0M@INPJKDFM@Google?5Inc?4?$AA@
	DW	018e3H
	ORG $+2
	DD	FLAT:??_C@_0CF@DABKNPLD@Fitilink?5Integrated?5Technology?0?5@
	DW	018faH
	ORG $+2
	DD	FLAT:??_C@_0CI@NCCLCDI@Kuang?5Ying?5Computer?5Equipment?5Co@
	DW	018fdH
	ORG $+2
	DD	FLAT:??_C@_0O@HPIJIONJ@FineArch?5Inc?4?$AA@
	DW	01914H
	ORG $+2
	DD	FLAT:??_C@_0BN@LFCPLAAL@Alco?5Digital?5Devices?5Limited?$AA@
	DW	01915H
	ORG $+2
	DD	FLAT:??_C@_0BJ@FNMFPLIK@Nordic?5Semiconductor?5ASA?$AA@
	DW	0192fH
	ORG $+2
	DD	FLAT:??_C@_0BJ@CDJNPBB@Avago?5Technologies?0?5Pte?4?$AA@
	DW	01930H
	ORG $+2
	DD	FLAT:??_C@_0CF@NLNPHLHC@Shenzhen?5Xianhe?5Technology?5Co?4?0?5@
	DW	01931H
	ORG $+2
	DD	FLAT:??_C@_0CJ@FJMLIAEB@Ningbo?5Broad?5Telecommunication?5C@
	DW	01946H
	ORG $+2
	DD	FLAT:??_C@_0BB@PCAKKDFD@Irisguard?5UK?5Ltd?$AA@
	DW	01949H
	ORG $+2
	DD	FLAT:??_C@_06CHAGPIBB@Lab126?$AA@
	DW	01953H
	ORG $+2
	DD	FLAT:??_C@_0N@PJANIMFN@Ironkey?5Inc?4?$AA@
	DW	01957H
	ORG $+2
	DD	FLAT:??_C@_0BB@PPNLBENA@BIOS?5Corporation?$AA@
	DW	01958H
	ORG $+2
	DD	FLAT:??_C@_0BD@JFCNKMCG@Office?5Depot?0?5Inc?4?$AA@
	DW	01989H
	ORG $+2
	DD	FLAT:??_C@_0BI@EPIBIIDM@Nuconn?5Technology?5Corp?4?$AA@
	DW	0198dH
	ORG $+2
	DD	FLAT:??_C@_0BC@JJOAHPPC@Fairchild?5Imaging?$AA@
	DW	0199cH
	ORG $+2
	DD	FLAT:??_C@_0CF@CFPPMAFK@Richnex?5Microelectronics?5Corpora@
	DW	0199dH
	ORG $+2
	DD	FLAT:??_C@_06FFDCAGEL@Dexxon?$AA@
	DW	019d2H
	ORG $+2
	DD	FLAT:??_C@_0BA@JIPMJPAM@ZTE?5Corporation?$AA@
	DW	019e8H
	ORG $+2
	DD	FLAT:??_C@_0CJ@HAKCLNCA@Industrial?5Technology?5Research?5I@
	DW	019ffH
	ORG $+2
	DD	FLAT:??_C@_08GALBDMNI@Best?5Buy?$AA@
	DW	01a0aH
	ORG $+2
	DD	FLAT:??_C@_0BE@BIONMJOM@USB?9IF?5non?9workshop?$AA@
	DW	01a25H
	ORG $+2
	DD	FLAT:??_C@_0BI@PPNCKFLJ@Amphenol?5East?5Asia?5Ltd?4?$AA@
	DW	01a35H
	ORG $+2
	DD	FLAT:??_C@_0DB@NGACLDBO@Astec?5Power?0?5a?5division?5of?5Emers@
	DW	01a36H
	ORG $+2
	DD	FLAT:??_C@_0BG@DLODCOOG@Biwin?5Technology?5Ltd?4?$AA@
	DW	01a40H
	ORG $+2
	DD	FLAT:??_C@_0BJ@KAKHDDLA@TERMINUS?5TECHNOLOGY?5INC?4?$AA@
	DW	01a4aH
	ORG $+2
	DD	FLAT:??_C@_0O@NGCCHBJG@Silicon?5Image?$AA@
	DW	01a5aH
	ORG $+2
	DD	FLAT:??_C@_0O@IHDBJOFK@Tandberg?5Data?$AA@
	DW	01a6eH
	ORG $+2
	DD	FLAT:??_C@_0BF@IBCFPAGK@Global?5Unichip?5Corp?4?$AA@
	DW	01a79H
	ORG $+2
	DD	FLAT:??_C@_0BG@IOFCBCHK@Bayer?5Health?5Care?5LLC?$AA@
	DW	01a7bH
	ORG $+2
	DD	FLAT:??_C@_0BF@HMENCDPO@Lumberg?5Connect?5GmbH?$AA@
	DW	01a82H
	ORG $+2
	DD	FLAT:??_C@_0BN@GMHKDAOP@Proconn?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	01a8aH
	ORG $+2
	DD	FLAT:??_C@_0BH@HJFKHBGL@Simula?5Technology?5Inc?4?$AA@
	DW	01a8bH
	ORG $+2
	DD	FLAT:??_C@_0BA@KBMPMKDN@SGS?5Taiwan?5Ltd?4?$AA@
	DW	01aaeH
	ORG $+2
	DD	FLAT:??_C@_0CJ@EENODCNA@Johnson?5Component?5?$CG?5Equipments?5C@
	DW	01acbH
	ORG $+2
	DD	FLAT:??_C@_0M@BNPJBJHO@Salcomp?5Plc?$AA@
	DW	01ad1H
	ORG $+2
	DD	FLAT:??_C@_0BF@FJNJCEIJ@Desan?5Wire?5Co?4?0?5Ltd?4?$AA@
	DW	01aedH
	ORG $+2
	DD	FLAT:??_C@_0CI@ENEIOO@High?5Top?5Precision?5Electronic?5Co@
	DW	01aeeH
	ORG $+2
	DD	FLAT:??_C@_0CD@KCEJLGKF@SHEN?5ZHEN?5REX?5TECHNOLOGY?5CO?4?0?5LT@
	DW	01aefH
	ORG $+2
	DD	FLAT:??_C@_0BI@BAHHJBOM@Octekconn?5Incorporation?$AA@
	DW	01b20H
	ORG $+2
	DD	FLAT:??_C@_0BK@FLEFAHEK@MStar?5Semiconductor?0?5Inc?4?$AA@
	DW	01b36H
	ORG $+2
	DD	FLAT:??_C@_0BD@DPNOIOGL@ViXS?5Systems?0?5Inc?4?$AA@
	DW	01b48H
	ORG $+2
	DD	FLAT:??_C@_0BN@ODKKJGBD@Plastron?5Precision?5Co?4?0?5Ltd?4?$AA@
	DW	01b65H
	ORG $+2
	DD	FLAT:??_C@_0DA@EOOOBNLE@The?5Hong?5Kong?5Standards?5and?5Test@
	DW	01b88H
	ORG $+2
	DD	FLAT:??_C@_0CI@GNFBMNPP@ShenMing?5Electron?5?$CIDong?5Guan?$CJ?5Co@
	DW	01b8eH
	ORG $+2
	DD	FLAT:??_C@_0O@IPLHGMF@Amlogic?0?5Inc?4?$AA@
	DW	01b8fH
	ORG $+2
	DD	FLAT:??_C@_0BO@MCHPBGAI@Super?5Talent?5Technology?0?5Inc?4?$AA@
	DW	01b99H
	ORG $+2
	DD	FLAT:??_C@_0BO@IHCMPCEB@Shenzhen?5Yuanchuan?5Electronic?$AA@
	DW	01bc4H
	ORG $+2
	DD	FLAT:??_C@_0P@JGHIOJAI@Ford?5Motor?5Co?4?$AA@
	DW	01bceH
	ORG $+2
	DD	FLAT:??_C@_0CA@FCJOHAEE@Contac?5Cable?5Industrial?5Limited?$AA@
	DW	01bcfH
	ORG $+2
	DD	FLAT:??_C@_0CD@HFOIMFJ@Sunplus?5Innovation?5Technology?5In@
	DW	01bf6H
	ORG $+2
	DD	FLAT:??_C@_0CH@KIMIGBPK@Orient?5Semiconductor?5Electronics@
	DW	01c10H
	ORG $+2
	DD	FLAT:??_C@_0BO@IHAPHGGJ@Lanterra?5Industrial?5Co?4?0?5Ltd?4?$AA@
	DW	01c27H
	ORG $+2
	DD	FLAT:??_C@_0CA@MAOFGAIM@SHENZHEN?5D?$CGS?5INDUSTRIES?5LIMITED?$AA@
	DW	01c31H
	ORG $+2
	DD	FLAT:??_C@_08PDBDCLGF@LS?5Mtron?$AA@
	DW	01c6bH
	ORG $+2
	DD	FLAT:??_C@_0DA@PPLCBMMB@Philips?5?$CG?5Lite?9ON?5Digital?5Soluti@
	DW	01c77H
	ORG $+2
	DD	FLAT:??_C@_0BM@KDIOKGMF@Kaetat?5Industrial?5Co?4?0?5Ltd?4?$AA@
	DW	01c78H
	ORG $+2
	DD	FLAT:??_C@_0BF@DNKPBOCD@Mindray?5DS?5USA?0?5Inc?4?$AA@
	DW	01c7aH
	ORG $+2
	DD	FLAT:??_C@_0BG@IEKIELLN@Egis?5Technology?0?5Inc?4?$AA@
	DW	01c7bH
	ORG $+2
	DD	FLAT:??_C@_0CP@DAEKMFBI@Shenzhen?5Luxshare?5Precision?5Indu@
	DW	01c8eH
	ORG $+2
	DD	FLAT:??_C@_0BL@NCJEDCIM@ASTRON?5INTERNATIONAL?5CORP?4?$AA@
	DW	01c98H
	ORG $+2
	DD	FLAT:??_C@_0BJ@GEGPHPDK@ALPINE?5ELECTRONICS?0?5INC?4?$AA@
	DW	01cb3H
	ORG $+2
	DD	FLAT:??_C@_0BL@CHCFPHFA@Aces?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	01cb4H
	ORG $+2
	DD	FLAT:??_C@_0BB@EIGDHDFJ@OPEX?5CORPORATION?$AA@
	DW	01cbeH
	ORG $+2
	DD	FLAT:??_C@_0BO@JLIFAMG@Texas?5Instruments?5?9?5Stellaris?$AA@
	DW	01cdeH
	ORG $+2
	DD	FLAT:??_C@_0DA@BKKOBFJG@Telecommunications?5Technology?5As@
	DW	01ce1H
	ORG $+2
	DD	FLAT:??_C@_0N@LKKAKDAC@Amphenol?5KAE?$AA@
	DW	01d08H
	ORG $+2
	DD	FLAT:??_C@_0CL@OJLMBANN@NINGBO?5HENTEK?5DRAGON?5ELECTRONICS@
	DW	01d0aH
	ORG $+2
	DD	FLAT:??_C@_0BH@GIIFDIFG@Johnson?5Controls?0?5Inc?4?$AA@
	DW	01d29H
	ORG $+2
	DD	FLAT:??_C@_0CA@GDMPIAIK@Horng?5Tong?5Enterprise?5Co?4?0?5Ltd?4?$AA@
	DW	01d42H
	ORG $+2
	DD	FLAT:??_C@_0BD@JJOGFDJ@DRAGON?5JOY?5LIMITED?$AA@
	DW	01d43H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IKAGMPGB@Montage?5Technology?0?5Inc?4?$AA@
	DW	01d45H
	ORG $+2
	DD	FLAT:??_C@_0BC@KIFIHBOP@Qisda?5Corporation?$AA@
	DW	01d49H
	ORG $+2
	DD	FLAT:??_C@_0CI@PCPBKJFB@SHENZHEN?5LINKCONN?5ELECTRONICS?5CO@
	DW	01d4dH
	ORG $+2
	DD	FLAT:??_C@_0BF@EEHMEIJP@Pegatron?5Corporation?$AA@
	DW	01d5cH
	ORG $+2
	DD	FLAT:??_C@_0BC@HAMMCKPN@Fresco?5Logic?5Inc?4?$AA@
	DW	01d5dH
	ORG $+2
	DD	FLAT:??_C@_0BL@MMCBELAO@QIXING?5INDUSTRIAL?5?$CIHK?$CJ?5CO?4?$AA@
	DW	01d60H
	ORG $+2
	DD	FLAT:??_C@_0BN@EBGBPGPI@ASAP?5International?5Co?4?0?5Ltd?4?$AA@
	DW	01d69H
	ORG $+2
	DD	FLAT:??_C@_0BL@NKBOOFNF@Walta?5Electronic?5Co?4?0?5Ltd?4?$AA@
	DW	01d6bH
	ORG $+2
	DD	FLAT:??_C@_0BF@JDCHKKGB@The?5Linux?5Foundation?$AA@
	DW	01d77H
	ORG $+2
	DD	FLAT:??_C@_0DE@IMGLKMI@Yueqing?5Changling?5Electronic?5Ins@
	DW	01d79H
	ORG $+2
	DD	FLAT:??_C@_0CH@EKHHMHEC@Shenzhen?5My?9Power?5Technology?5Co?4@
	DW	01d80H
	ORG $+2
	DD	FLAT:??_C@_04EOPNHLPE@PLDA?$AA@
	DW	01da0H
	ORG $+2
	DD	FLAT:??_C@_0BK@FNCNBIIF@Parade?5Technologies?0?5Inc?4?$AA@
	DW	01dbeH
	ORG $+2
	DD	FLAT:??_C@_0BD@GCMMCDEJ@S?4R?4N?4?5Corporation?$AA@
	DW	01dccH
	ORG $+2
	DD	FLAT:??_C@_0CE@EGHGGAJG@Document?5Capture?5Technologies?0?5I@
	DW	01dd8H
	ORG $+2
	DD	FLAT:??_C@_0BL@NACGMHGM@BUFFALO?5KOKUYO?5SUPPLY?5INC?4?$AA@
	DW	01ddfH
	ORG $+2
	DD	FLAT:??_C@_0BH@NMLKIBDM@GDA?5Technologies?0?5Inc?4?$AA@
	DW	01df2H
	ORG $+2
	DD	FLAT:??_C@_0CK@INFLCDIC@Telecommunication?5Metrology?5Cent@
	DW	01e08H
	ORG $+2
	DD	FLAT:??_C@_0BA@FHOGIFBC@Inventure?0?5Inc?4?$AA@
	DW	01e10H
	ORG $+2
	DD	FLAT:??_C@_0BJ@FEMBFAJG@Point?5Grey?5Research?5Inc?4?$AA@
	DW	01e33H
	ORG $+2
	DD	FLAT:??_C@_0BD@LIIMMKIN@KOBIAN?5CANADA?5INC?4?$AA@
	DW	01e3aH
	ORG $+2
	DD	FLAT:??_C@_0CE@BIOHJJL@Continental?5Automotive?5Systems?5I@
	DW	01e47H
	ORG $+2
	DD	FLAT:??_C@_0CB@BKOLJNN@HUNG?5TA?5H?4T?4ENTERPRISE?5CO?4?0?5LTD?4@
	DW	01e4eH
	ORG $+2
	DD	FLAT:??_C@_0BH@JAAJJDAF@Etron?5Technology?0?5Inc?4?$AA@
	DW	01e6dH
	ORG $+2
	DD	FLAT:??_C@_0CF@GIBECCII@WAN?5SHIH?5ELECTRONIC?5?$CIH?4K?4?$CJ?5CO?4?0?5@
	DW	01e73H
	ORG $+2
	DD	FLAT:??_C@_0BO@OPAJPFGF@COMLINK?5ELECTRONICS?5CO?4?0?5LTD?4?$AA@
	DW	01e89H
	ORG $+2
	DD	FLAT:??_C@_0DA@GFKEDMJF@Vtion?5Information?5Technology?5?$CIFu@
	DW	01ea3H
	ORG $+2
	DD	FLAT:??_C@_0BL@BINCEHIC@Concraft?5Holding?5Co?4?0?5Ltd?4?$AA@
	DW	01eb7H
	ORG $+2
	DD	FLAT:??_C@_0CH@IFPLLPOK@WIN?5WIN?5PRECISION?5INDUSTRIAL?5CO?4@
	DW	01ec9H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IADLJBAM@MOSER?5BAER?5INDIA?5LIMITED?$AA@
	DW	01ed4H
	ORG $+2
	DD	FLAT:??_C@_0BJ@HDEECJAH@Transwitch?5?$CIIsrael?$CJ?5Ltd?4?$AA@
	DW	01f1dH
	ORG $+2
	DD	FLAT:??_C@_0DC@MLCJGJKA@How?5Weih?5Precision?5Technology?5?$CIS@
	DW	01f20H
	ORG $+2
	DD	FLAT:??_C@_0CG@BIKNKPGD@Shenzhen?5Tenwei?5Electronics?5Co?4?0@
	DW	01f28H
	ORG $+2
	DD	FLAT:??_C@_0CG@LKIHKKAD@Cal?9Comp?5Electronics?5?$CG?5Communica@
	DW	01f29H
	ORG $+2
	DD	FLAT:??_C@_0BN@COMGKDHO@Analogix?5Semiconductor?0?5Inc?4?$AA@
	DW	01f31H
	ORG $+2
	DD	FLAT:??_C@_0BP@DOFDLEGP@SASKEN?5COMMUNICATION?5TECH?5LTD?4?$AA@
	DW	01f3cH
	ORG $+2
	DD	FLAT:??_C@_0CE@MEDMJIF@Chang?5Yang?5Electronics?5Company?5L@
	DW	01f75H
	ORG $+2
	DD	FLAT:??_C@_0BD@GGCBPHPK@Innostor?5Co?4?0?5Ltd?4?$AA@
	DW	01f89H
	ORG $+2
	DD	FLAT:??_C@_0CI@NHHBKKBH@Dongguan?5Goldconn?5Electronics?5Co@
	DW	01f8aH
	ORG $+2
	DD	FLAT:??_C@_0CC@LPIGCLDE@Morning?5Star?5Industrial?5Co?4?0?5Ltd@
	DW	01facH
	ORG $+2
	DD	FLAT:??_C@_0BJ@OBPDBGLK@Franklin?5Technology?5Inc?4?$AA@
	DW	01fadH
	ORG $+2
	DD	FLAT:??_C@_0BH@OKNGIEAK@Cresta?5Technology?5Inc?4?$AA@
	DW	01fb4H
	ORG $+2
	DD	FLAT:??_C@_0CB@EHEKJNGP@Owl?5Computing?5Technologies?0?5Inc?4@
	DW	01fb5H
	ORG $+2
	DD	FLAT:??_C@_0DA@LDONKOKE@Siemens?5Enterprise?5Communication@
	DW	01fc9H
	ORG $+2
	DD	FLAT:??_C@_0BD@GMPBKEIC@NXP?5Semiconductors?$AA@
	DW	01fecH
	ORG $+2
	DD	FLAT:??_C@_0CA@CAPPIABK@NIAN?5YEONG?5ENTERPRISE?5CO?4?0?5LTD?4?$AA@
	DW	01ff5H
	ORG $+2
	DD	FLAT:??_C@_0DB@KONADFN@Changzhou?5Wujin?5BEST?5Electronic?5@
	DW	02001H
	ORG $+2
	DD	FLAT:??_C@_0BD@BJBLIGAM@D?9Link?5Corporation?$AA@
	DW	0200dH
	ORG $+2
	DD	FLAT:??_C@_0CI@GOBPPKNF@Belkin?5Electronic?5?$CIChangzhou?$CJ?5Co@
	DW	0200eH
	ORG $+2
	DD	FLAT:??_C@_0BN@KHNMKBEO@DAIICHI?5PARTS?5?$CIHK?$CJ?5CO?4?0?5LTD?4?$AA@
	DW	0201cH
	ORG $+2
	DD	FLAT:??_C@_0CF@DHGBCKNB@Freeport?5Resources?5Enterprises?5C@
	DW	02028H
	ORG $+2
	DD	FLAT:??_C@_0BG@PIIFGLBL@DETAS?5TECHNOLOGY?5LTD?4?$AA@
	DW	0205cH
	ORG $+2
	DD	FLAT:??_C@_0CI@FBHBCILE@Shenzhen?5Tronixin?5Electronics?5Co@
	DW	02066H
	ORG $+2
	DD	FLAT:??_C@_0CJ@OEPJLPBL@Unicorn?5Electronics?5Components?5C@
	DW	0207dH
	ORG $+2
	DD	FLAT:??_C@_0BK@DJALMDKA@CESI?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	0208eH
	ORG $+2
	DD	FLAT:??_C@_0N@JJLIGBFN@Luxshare?9ICT?$AA@
	DW	02095H
	ORG $+2
	DD	FLAT:??_C@_0BA@CFCNDLPN@CE?5LINK?5LIMITED?$AA@
	DW	02096H
	ORG $+2
	DD	FLAT:??_C@_0BP@FNHFFJPK@Microconn?5Electronic?5Co?4?0?5Ltd?4?$AA@
	DW	020afH
	ORG $+2
	DD	FLAT:??_C@_0CF@MCDKIGNK@Shenzhen?5CARVE?5Electronics?5Co?4?0?5@
	DW	020c0H
	ORG $+2
	DD	FLAT:??_C@_0BK@EIBNNPGD@FENGHUA?5KINGSUN?5CO?4?0?5LTD?4?$AA@
	DW	020c2H
	ORG $+2
	DD	FLAT:??_C@_0DE@EMOPPBDG@Sumitomo?5Electric?5Ind?4?0?5Ltd?4?0?5Op@
	DW	020f7H
	ORG $+2
	DD	FLAT:??_C@_0BJ@PMOEHKIK@SOFTHARD?5Technology?5Ltd?4?$AA@
	DW	02109H
	ORG $+2
	DD	FLAT:??_C@_0P@GBIKBMAL@VIA?5Labs?0?5Inc?4?$AA@
	DW	02116H
	ORG $+2
	DD	FLAT:??_C@_0N@JLDIPNLJ@KT?5Tech?5Inc?4?$AA@
	DW	0212cH
	ORG $+2
	DD	FLAT:??_C@_0CF@GAGJPPB@Shenzhen?5Linoya?5Electronic?5Co?4?0?5@
	DW	0212eH
	ORG $+2
	DD	FLAT:??_C@_0CJ@CNOJBLBI@Amphenol?5AssembleTech?5?$CIXiamen?$CJ?5C@
	DW	02147H
	ORG $+2
	DD	FLAT:??_C@_0CF@JOALJALB@Chin?9Ban?5Electronics?5?$CIHong?5Kong?$CJ@
	DW	02148H
	ORG $+2
	DD	FLAT:??_C@_0CD@KDAPKLEA@Visteon?5Sistemas?5Automotives?5Ltd@
	DW	0214cH
	ORG $+2
	DD	FLAT:??_C@_0BD@LDDEGFID@Y?5Soft?5Corporation?$AA@
	DW	02166H
	ORG $+2
	DD	FLAT:??_C@_0BI@FBCKNBLM@JVC?5KENWOOD?5Corporation?$AA@
	DW	02173H
	ORG $+2
	DD	FLAT:??_C@_0DH@EJJEPBOI@HUIZHOU?5HUANGJI?5PRECISIONS?5FLEX?5@
	DW	02174H
	ORG $+2
	DD	FLAT:??_C@_0BM@BKHGEKPK@Transcend?5Information?0?5Inc?4?$AA@
	DW	02176H
	ORG $+2
	DD	FLAT:??_C@_0BF@BAPBHHHN@TMC?1Allion?5Test?5Labs?$AA@
	DW	02188H
	ORG $+2
	DD	FLAT:??_C@_08EPBIMIG@CalDigit?$AA@
	DW	021b5H
	ORG $+2
	DD	FLAT:??_C@_0CF@DANJAKAE@SHENZHEN?5JASON?5ELECTRONICS?5CO?4?0?5@
	DW	021c4H
	ORG $+2
	DD	FLAT:??_C@_0BP@PBMDMJMJ@Netcom?5Technology?5?$CIHK?$CJ?5Limited?$AA@
	DW	021d3H
	ORG $+2
	DD	FLAT:??_C@_0BP@FAJGPKNC@Compupack?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	021e9H
	ORG $+2
	DD	FLAT:??_C@_0CM@MMCEPGGG@Jiafuh?5Metal?5?$CG?5Plastic?5?$CIShenZhen@
	DW	021f7H
	ORG $+2
	DD	FLAT:??_C@_0CG@OHNMOHEM@Wuerth?9Elektronik?5eiSos?5GmbH?5?$CG?5C@
	DW	02205H
	ORG $+2
	DD	FLAT:??_C@_0CB@CHMCCAAM@3eYamaichi?5Electronics?5Co?4?0?5Ltd?4@
	DW	02206H
	ORG $+2
	DD	FLAT:??_C@_0CG@NEPAELKJ@Wiretek?5International?5Investment@
	DW	02250H
	ORG $+2
	DD	FLAT:??_C@_0BP@OIDAFMJB@Evernew?5Wire?5?$CG?5Cable?5Co?4?0?5Ltd?4?$AA@
	DW	02270H
	ORG $+2
	DD	FLAT:??_C@_0CH@BNMEADNA@XiaMen?5GaoLuChang?5Electronics?5Co@
	DW	0227fH
	ORG $+2
	DD	FLAT:??_C@_0BD@PEIOBOIA@Granite?5River?5Labs?$AA@
	DW	02289H
	ORG $+2
	DD	FLAT:??_C@_0CO@GPGEJOEG@Sun?5Fair?5Electric?5Wire?5?$CG?5Cable?5?$CI@
	DW	0228aH
	ORG $+2
	DD	FLAT:??_C@_0CH@JIBHMNOD@Hotron?5Precision?5Electronic?5Ind?4@
	DW	0228bH
	ORG $+2
	DD	FLAT:??_C@_0CO@EAFKPNFN@Shenzhen?5DLK?5Electronics?5Technol@
	DW	02297H
	ORG $+2
	DD	FLAT:??_C@_0CD@FPBFIKDM@Grain?5Media?5Technology?5Corporati@
	DW	022a9H
	ORG $+2
	DD	FLAT:??_C@_0BK@OFJMDPCF@Valor?5Communication?0?5Inc?4?$AA@
	DW	022abH
	ORG $+2
	DD	FLAT:??_C@_0BN@LAOLKJDB@Trigence?5Semiconductor?0?5Inc?4?$AA@
	DW	022b8H
	ORG $+2
	DD	FLAT:??_C@_0BH@JCNJIDNH@Motorola?5Mobility?5Inc?4?$AA@
	DW	022dbH
	ORG $+2
	DD	FLAT:??_C@_0O@PFEHLJC@Phase?5One?5A?1S?$AA@
	DW	022fdH
	ORG $+2
	DD	FLAT:??_C@_0O@LJFFELIC@Miltope?5Corp?4?$AA@
	DW	022ffH
	ORG $+2
	DD	FLAT:??_C@_05CCBNKHPD@Avnet?$AA@
	DW	02313H
	ORG $+2
	DD	FLAT:??_C@_0CF@DNEMFNPO@Kunshan?5Jiahua?5Electronics?5Co?4?0?5@
	DW	02315H
	ORG $+2
	DD	FLAT:??_C@_0BL@CONNOJEO@Avery?5Design?5Systems?0?5Inc?4?$AA@
	DW	02317H
	ORG $+2
	DD	FLAT:??_C@_0BI@LPLOPAA@Huawei?5Device?5Co?4?0?5Ltd?4?$AA@
	DW	02326H
	ORG $+2
	DD	FLAT:??_C@_0BK@MFDKEFFA@CKM?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	02330H
	ORG $+2
	DD	FLAT:??_C@_09GCGEMCFF@Tensorcom?$AA@
	DW	02358H
	ORG $+2
	DD	FLAT:??_C@_0BG@JCFEOFFG@Greenconn?5Corporation?$AA@
	DW	02359H
	ORG $+2
	DD	FLAT:??_C@_0CM@MLMJGOMM@Shenzhen?5Autone?9Tronic?5Technolog@
	DW	0235bH
	ORG $+2
	DD	FLAT:??_C@_0BP@GJOKBILK@KangXiang?5Electronic?5Co?4?0?5Ltd?4?$AA@
	DW	023acH
	ORG $+2
	DD	FLAT:??_C@_0BJ@OHNJGPJN@Marunix?5Electron?5Limited?$AA@
	DW	023dcH
	ORG $+2
	DD	FLAT:??_C@_0CD@NDCLAIIH@Phonic?5Ear?0?5Inc?4?5Frontrow?5Divisi@
	DW	023e0H
	ORG $+2
	DD	FLAT:??_C@_0CF@CFJNEAJP@BitifEye?5Digital?5Test?5Solutions?5@
	DW	023f4H
	ORG $+2
	DD	FLAT:??_C@_07CEDODHPO@NXT?5Plc?$AA@
	DW	023f5H
	ORG $+2
	DD	FLAT:??_C@_0BE@BMBKAED@SpeedConn?5Co?4?0?5Ltd?4?$AA@
	DW	023fdH
	ORG $+2
	DD	FLAT:??_C@_0M@MGCPLAOJ@AWare?0?5Inc?4?$AA@
	DW	023feH
	ORG $+2
	DD	FLAT:??_C@_0BE@CNAOMOBO@Express?5Way?5Limited?$AA@
	DW	02400H
	ORG $+2
	DD	FLAT:??_C@_0CN@EJBOGONI@ChuangYi?5Hardware?5Precision?5Moul@
	DW	02406H
	ORG $+2
	DD	FLAT:??_C@_0O@BNIKCMOM@INSIDE?5Secure?$AA@
	DW	02407H
	ORG $+2
	DD	FLAT:??_C@_0BH@KJMMFBKI@Incasolution?5Co?4?0?5Ltd?4?$AA@
	DW	0240fH
	ORG $+2
	DD	FLAT:??_C@_0BO@GNFPHMGK@Trantek?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	0241aH
	ORG $+2
	DD	FLAT:??_C@_0BM@GMFHMCEF@The?5Silanna?5Group?5Pty?4?5Ltd?4?$AA@
	DW	0241bH
	ORG $+2
	DD	FLAT:??_C@_0CK@PEDMBLOK@Dongguan?5City?5Qirui?5Electronics?5@
	DW	02438H
	ORG $+2
	DD	FLAT:??_C@_0CB@GILKPBEO@Innopower?5Technology?5Corporation@
	DW	0244cH
	ORG $+2
	DD	FLAT:??_C@_0BC@MIHCGNOI@Minebea?5Co?4?0?5Ltd?4?$AA@
	DW	02452H
	ORG $+2
	DD	FLAT:??_C@_0BO@OPKCBFPL@Speeder?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	02453H
	ORG $+2
	DD	FLAT:??_C@_06HHAPBGEJ@BAANTO?$AA@
	DW	02454H
	ORG $+2
	DD	FLAT:??_C@_0BL@LPJGBHEM@Velosti?5Technology?5Limited?$AA@
	DW	02455H
	ORG $+2
	DD	FLAT:??_C@_0BC@FEINIIOM@Anton?1Bauer?0?5Inc?4?$AA@
	DW	0246aH
	ORG $+2
	DD	FLAT:??_C@_0CA@OBJDCDKL@UNH?5Interoperability?5Laboratory?$AA@
	DW	0246bH
	ORG $+2
	DD	FLAT:??_C@_0DI@DKAFDFAC@Perfect?5Fortune?5Electric?5Wire?5?$CG?5@
	DW	02477H
	ORG $+2
	DD	FLAT:??_C@_08PDELGFBH@UbiVelox?$AA@
	DW	0247bH
	ORG $+2
	DD	FLAT:??_C@_0CB@POEOBKIH@Digibras?5Industria?5do?5Brasil?5S?4A@
	DW	0247cH
	ORG $+2
	DD	FLAT:??_C@_0BH@EHAGJFEE@Fullconn?5Industry?5Inc?4?$AA@
	DW	0247dH
	ORG $+2
	DD	FLAT:??_C@_0P@BCJJHJDJ@JARGY?5CO?4?5LTD?4?$AA@
	DW	02488H
	ORG $+2
	DD	FLAT:??_C@_0BB@MDEMAKAA@SuperD?5Co?4?0?5Ltd?4?$AA@
	DW	02489H
	ORG $+2
	DD	FLAT:??_C@_0BL@MHJFMACI@Irvine?5Sensors?5Corporation?$AA@
	DW	0248aH
	ORG $+2
	DD	FLAT:??_C@_0CK@KHHEAIMH@TeLink?5Semiconductor?5?$CIShanghai?$CJ?5@
	DW	0248bH
	ORG $+2
	DD	FLAT:??_C@_0BK@CFHJHDDG@SYNCONN?5INTERCONNECT?5INC?4?$AA@
	DW	02495H
	ORG $+2
	DD	FLAT:??_C@_0BJ@MAPFGIK@Summit?5Semiconductor?5LLC?$AA@
	DW	02496H
	ORG $+2
	DD	FLAT:??_C@_0DA@CGBDOBCP@Dongguan?5DaTang?5Industrial?5Inves@
	DW	02497H
	ORG $+2
	DD	FLAT:??_C@_0BO@GKPDCPNP@HyunWoo?5Electronics?5Co?4?0?5Ltd?4?$AA@
	DW	024a6H
	ORG $+2
	DD	FLAT:??_C@_0CH@IDDOGDKP@Shenzhen?5Pangngai?5Industrial?5Co?4@
	DW	024aeH
	ORG $+2
	DD	FLAT:??_C@_0CE@EAHJMINJ@Shenzhen?5Rapoo?5Technology?5Co?4?0?5L@
	DW	024b5H
	ORG $+2
	DD	FLAT:??_C@_0N@EBDJACPJ@3C?5TEK?5CORP?4?$AA@
	DW	024b6H
	ORG $+2
	DD	FLAT:??_C@_0CK@CLEDKDEL@Shenzhen?5New?9Conn?5International?5@
	DW	024ceH
	ORG $+2
	DD	FLAT:??_C@_0CE@JOMBCIJH@Shenzhen?5Deren?5Electronic?5Co?4?0?5L@
	DW	024cfH
	ORG $+2
	DD	FLAT:??_C@_0M@NMCNEDLC@Lytro?0?5Inc?4?$AA@
	DW	024d0H
	ORG $+2
	DD	FLAT:??_C@_0BL@DEJKGIMK@Smith?5Micro?5Software?0?5Inc?4?$AA@
	DW	024daH
	ORG $+2
	DD	FLAT:??_C@_0BN@HAAHPMIC@KYOCERA?5ELCO?5Korea?5Co?4?0?5Ltd?4?$AA@
	DW	024dbH
	ORG $+2
	DD	FLAT:??_C@_0BB@PGAFDCCK@DDUSB?5Technology?$AA@
	DW	024edH
	ORG $+2
	DD	FLAT:??_C@_0BO@ONHDIMLP@ZEN?5FACTORY?5GROUP?5?$CIASIA?$CJ?5LTD?4?$AA@
	DW	024f7H
	ORG $+2
	DD	FLAT:??_C@_0M@GHCMHPKC@Seneye?5Ltd?4?$AA@
	DW	024fbH
	ORG $+2
	DD	FLAT:??_C@_0BC@HBLEADPM@GTECH?5Corporation?$AA@
	DW	02509H
	ORG $+2
	DD	FLAT:??_C@_0BO@KGBBCJH@Chain?9In?5Electronic?5Co?4?0?5Ltd?4?$AA@
	DW	02529H
	ORG $+2
	DD	FLAT:??_C@_0CO@JCAFCPHA@SUZHOU?5XINYA?5ELECTRIC?5COMMUNICAT@
	DW	0252bH
	ORG $+2
	DD	FLAT:??_C@_0CN@BNJPCKEF@TOP?5Exactitude?5Industry?5?$CIShenZhe@
	DW	02535H
	ORG $+2
	DD	FLAT:??_C@_0DD@CFLDKGBD@Shenzhen?5Hong?5Junde?5Precision?5Te@
	DW	02536H
	ORG $+2
	DD	FLAT:??_C@_0BM@PDILJJBJ@Ubisys?5Technology?5Co?4?0?5Ltd?4?$AA@
	DW	02537H
	ORG $+2
	DD	FLAT:??_C@_0BD@PLHJJNHE@Norel?5Systems?5Ltd?4?$AA@
	DW	02558H
	ORG $+2
	DD	FLAT:??_C@_0BJ@KIEOKLMB@INTECH?5ELECTRONICS?5CORP?4?$AA@
	DW	02567H
	ORG $+2
	DD	FLAT:??_C@_0CG@NMMKCBIB@DongGuan?5LongTao?5Electronic?5Co?4?0@
	DW	02568H
	ORG $+2
	DD	FLAT:??_C@_0CA@CFAALAJE@ALL?5LINK?5CONN?4?5TECHNOLOGY?5CORP?4?$AA@
	DW	02569H
	ORG $+2
	DD	FLAT:??_C@_0CL@DMEHNIKM@DongGuan?5City?5MingJi?5Electronics@
	DW	02574H
	ORG $+2
	DD	FLAT:??_C@_0BG@OBILOFPF@AVer?5Information?5Inc?4?$AA@
	DW	02575H
	ORG $+2
	DD	FLAT:??_C@_0BI@MHBLLANG@Weida?5Hi?9Tech?5Co?4?0?5Ltd?4?$AA@
	DW	02579H
	ORG $+2
	DD	FLAT:??_C@_0CF@JLNODIAF@Dongguan?5Kowell?5Electronic?5Co?4?0?5@
	DW	02587H
	ORG $+2
	DD	FLAT:??_C@_0CE@MEBHAOHC@Ningbo?5Jiatang?5Electronic?5Co?4?0?5L@
	DW	02588H
	ORG $+2
	DD	FLAT:??_C@_0BC@EPMKAPFK@Infinitegra?0?5Inc?4?$AA@
	DW	02591H
	ORG $+2
	DD	FLAT:??_C@_0BL@GPGPDPPI@Optimus?5Semiconductor?5Inc?4?$AA@
	DW	0259bH
	ORG $+2
	DD	FLAT:??_C@_06JAGNIOHH@INUVIO?$AA@
	DW	0259cH
	ORG $+2
	DD	FLAT:??_C@_0BL@PDKHOHKG@Immedia?5Semiconductor?5Inc?4?$AA@
	DW	0259dH
	ORG $+2
	DD	FLAT:??_C@_0BF@GEOEIPEL@RCA?5DA?5AMAZONIA?5LTDA?$AA@
	DW	025a4H
	ORG $+2
	DD	FLAT:??_C@_0P@GGHEMJJH@ALGOLTEK?0?5INC?4?$AA@
	DW	025abH
	ORG $+2
	DD	FLAT:??_C@_0P@KJGACBOE@Carmanah?5Signs?$AA@
	DW	025b2H
	ORG $+2
	DD	FLAT:??_C@_0P@OEFFHHLL@DRS?9RSTA?0?5Inc?4?$AA@
	DW	025b3H
	ORG $+2
	DD	FLAT:??_C@_0CF@LHOCOHOF@DongGuan?5Elinke?5Industrial?5Co?4?0?5@
	DW	025c3H
	ORG $+2
	DD	FLAT:??_C@_06CJJNEMAE@Phorus?$AA@
	DW	025c7H
	ORG $+2
	DD	FLAT:??_C@_0BN@PKAIGMCM@MEGATRON?5Elektronik?5AG?5?$CG?5Co?4?$AA@
	DW	025d3H
	ORG $+2
	DD	FLAT:??_C@_0CI@EJBKCNKI@Zhe?5Jiang?5Huasheng?5Technology?5Co@
	DW	025e1H
	ORG $+2
	DD	FLAT:??_C@_0L@IOINFDHJ@Daimler?5AG?$AA@
	DW	025f2H
	ORG $+2
	DD	FLAT:??_C@_0CG@OAMKINAC@Dongguan?5Jinyue?5Electronics?5Co?4?0@
	DW	025fbH
	ORG $+2
	DD	FLAT:??_C@_0CD@JGKEGNMJ@PENTAX?5RICOH?5IMAGING?5COMPANY?0?5LT@
	DW	025fcH
	ORG $+2
	DD	FLAT:??_C@_0BI@NCIPEGB@RWA?5?$CIHong?5Kong?$CJ?5Limited?$AA@
	DW	0260eH
	ORG $+2
	DD	FLAT:??_C@_0CC@GLDMKJH@DongGuan?5HYX?5Industrial?5Co?4?0?5Ltd@
	DW	02614H
	ORG $+2
	DD	FLAT:??_C@_0BL@MKIOGMIA@VMC?5Consulting?5Corporation?$AA@
	DW	0261aH
	ORG $+2
	DD	FLAT:??_C@_0DD@JFHBCIAC@Shandong?5Synthesis?5Electronic?5Te@
	DW	0261bH
	ORG $+2
	DD	FLAT:??_C@_0BJ@FPNGMFON@INTELLIGENT?5ENERGY?0?5LTD?4?$AA@
	DW	0261cH
	ORG $+2
	DD	FLAT:??_C@_0O@KCHFFECA@EISST?5Limited?$AA@
	DW	0262bH
	ORG $+2
	DD	FLAT:??_C@_0CO@FNFDMCAN@JXT?5Precision?5Electronics?5Techni@
	DW	0707H
	ORG $+2
	DD	FLAT:??_C@_0N@OGJAAGP@Vendor?5x0707?$AA@
	DW	077aH
	ORG $+2
	DD	FLAT:??_C@_06NMEADBLN@Sankio?$AA@
	DW	07c0H
	ORG $+2
	DD	FLAT:??_C@_0N@BHJPEAKB@Vendor?5x07C0?$AA@
	DW	07d1H
	ORG $+2
	DD	FLAT:??_C@_0N@LMLGHGF@Vendor?5x07D1?$AA@
	DW	08a6H
	ORG $+2
	DD	FLAT:??_C@_0M@LKDAPJIF@Toshiba?5TEC?$AA@
	DW	0b8bH
	ORG $+2
	DD	FLAT:??_C@_0N@OEOECLEK@TMD?5Security?$AA@
	DW	0bedH
	ORG $+2
	DD	FLAT:??_C@_0N@EKANAEP@Vendor?5x0BED?$AA@
	DW	0c94H
	ORG $+2
	DD	FLAT:??_C@_0BC@GGOFANFE@SAGEM?5Denmark?5A?1S?$AA@
	DW	01046H
	ORG $+2
	DD	FLAT:??_C@_0O@EDCNNFOI@Hitachi?0?5Ltd?4?$AA@
	DW	01051H
	ORG $+2
	DD	FLAT:??_C@_0BC@GAEDCENO@Star?5Microsystems?$AA@
	DW	01427H
	ORG $+2
	DD	FLAT:??_C@_0N@CCDIFCFP@Vendor?5x1427?$AA@
	DW	01e2cH
	ORG $+2
	DD	FLAT:??_C@_0N@OEOECLEK@TMD?5Security?$AA@
	DW	01d5fH
	ORG $+2
	DD	FLAT:??_C@_08HHHILLLH@VIVOtech?$AA@
	DW	00H
	ORG $+2
	DD	FLAT:??_C@_07NFANNNEC@UNKNOWN?$AA@
?UsbViewIndent@@3PAPADA DD FLAT:??_C@_00CNPNBAHC@?$AA@	; UsbViewIndent
	DD	FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
	DD	FLAT:??_C@_04PFOHOKJK@?5?5?5?5?$AA@
	DD	FLAT:??_C@_06GGLIPOFD@?5?5?5?5?5?5?$AA@
	DD	FLAT:??_C@_08GGFKNFHG@?5?5?5?5?5?5?5?5?$AA@
	DD	FLAT:??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00003	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  00006	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0000b	f7 e9		 imul	 ecx
  0000d	03 d1		 add	 edx, ecx
  0000f	c1 fa 04	 sar	 edx, 4
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx
  00019	3b f8		 cmp	 edi, eax
  0001b	72 05		 jb	 SHORT $LN3@operator@24
  0001d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@24:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00022	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  00025	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  0002c	2b cf		 sub	 ecx, edi
  0002e	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 786  : 		}

  00031	c3		 ret	 0
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	__$ArrayPad$
PUBLIC	?GetConfigDescriptor@USB@@IAEPAU_USB_DESCRIPTOR_REQUEST@@PAXKE@Z ; USB::GetConfigDescriptor
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
;	COMDAT ?GetConfigDescriptor@USB@@IAEPAU_USB_DESCRIPTOR_REQUEST@@PAXKE@Z
_TEXT	SEGMENT
_nBytesReturned$ = -32					; size = 4
_configDescReqBuf$ = -28				; size = 21
__$ArrayPad$ = -4					; size = 4
_ConnectionIndex$ = 8					; size = 4
?GetConfigDescriptor@USB@@IAEPAU_USB_DESCRIPTOR_REQUEST@@PAXKE@Z PROC ; USB::GetConfigDescriptor, COMDAT
; _hHubDevice$ = ebx

; 1329 : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 1c	 mov	 DWORD PTR __$ArrayPad$[esp+32], eax
  0000e	55		 push	 ebp
  0000f	8b 6c 24 28	 mov	 ebp, DWORD PTR _ConnectionIndex$[esp+32]
  00013	56		 push	 esi
  00014	57		 push	 edi

; 1330 :     BOOL    success;
; 1331 :     ULONG   nBytes = 0;
; 1332 :     ULONG   nBytesReturned = 0;
; 1333 : 
; 1334 :     UCHAR   configDescReqBuf[sizeof(USB_DESCRIPTOR_REQUEST) + sizeof(USB_CONFIGURATION_DESCRIPTOR)];
; 1335 : 
; 1336 :     PUSB_DESCRIPTOR_REQUEST         configDescReq = NULL;
; 1337 :     PUSB_CONFIGURATION_DESCRIPTOR   configDesc = NULL;
; 1338 : 
; 1339 :     Log(LOG_DEBUG,__LINE__,">> USB.GetCfgDesc");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NBPLLDOB@?$DO?$DO?5USB?4GetCfgDesc?$AA@
  0001a	68 3b 05 00 00	 push	 1339			; 0000053bH
  0001f	6a 10		 push	 16			; 00000010H
  00021	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _nBytesReturned$[esp+56], 0
  00029	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1340 : 
; 1341 :     // Request the Configuration Descriptor the first time using our
; 1342 :     // local buffer, which is just big enough for the Cofiguration
; 1343 :     // Descriptor itself.
; 1344 :     //
; 1345 :     nBytes = sizeof(configDescReqBuf);
; 1346 : 
; 1347 :     configDescReq = (PUSB_DESCRIPTOR_REQUEST)configDescReqBuf;
; 1348 :     configDesc = (PUSB_CONFIGURATION_DESCRIPTOR)(configDescReq+1);
; 1349 : 
; 1350 :     // Zero fill the entire request structure
; 1351 :     //
; 1352 :     memset(configDescReq, 0x00, nBytes);

  00031	33 c0		 xor	 eax, eax

; 1353 : 
; 1354 :     // Indicate the port from which the descriptor will be requested
; 1355 :     //
; 1356 :     configDescReq->ConnectionIndex = ConnectionIndex;
; 1357 : 
; 1358 :     //
; 1359 :     // USBHUB uses URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE to process this
; 1360 :     // IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION request.
; 1361 :     //
; 1362 :     // USBD will automatically initialize these fields:
; 1363 :     //     bmRequest = 0x80
; 1364 :     //     bRequest  = 0x06
; 1365 :     //
; 1366 :     // We must inititialize these fields:
; 1367 :     //     wValue    = Descriptor Type (high) and Descriptor Index (low byte)
; 1368 :     //     wIndex    = Zero (or Language ID for String Descriptors)
; 1369 :     //     wLength   = Length of descriptor buffer
; 1370 :     //
; 1371 :     configDescReq->SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE << 8)
; 1372 :                                         | DescriptorIndex;
; 1373 : 
; 1374 :     configDescReq->SetupPacket.wLength = (USHORT)(nBytes - sizeof(USB_DESCRIPTOR_REQUEST));
; 1375 : 
; 1376 :     // Now issue the get descriptor request.
; 1377 :     //
; 1378 :     success = DeviceIoControl(hHubDevice,
; 1379 :                               IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,
; 1380 :                               configDescReq,
; 1381 :                               nBytes,
; 1382 :                               configDescReq,
; 1383 :                               nBytes,
; 1384 :                               &nBytesReturned,
; 1385 :                               NULL);

  00033	6a 00		 push	 0
  00035	89 44 24 14	 mov	 DWORD PTR _configDescReqBuf$[esp+48], eax
  00039	89 44 24 18	 mov	 DWORD PTR _configDescReqBuf$[esp+52], eax
  0003d	89 44 24 1c	 mov	 DWORD PTR _configDescReqBuf$[esp+56], eax
  00041	89 44 24 20	 mov	 DWORD PTR _configDescReqBuf$[esp+60], eax
  00045	89 44 24 24	 mov	 DWORD PTR _configDescReqBuf$[esp+64], eax
  00049	88 44 24 28	 mov	 BYTE PTR _configDescReqBuf$[esp+68], al
  0004d	8d 54 24 10	 lea	 edx, DWORD PTR _nBytesReturned$[esp+48]
  00051	52		 push	 edx
  00052	6a 15		 push	 21			; 00000015H
  00054	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00059	66 89 44 24 22	 mov	 WORD PTR _configDescReqBuf$[esp+62], ax
  0005e	8d 44 24 1c	 lea	 eax, DWORD PTR _configDescReqBuf$[esp+56]
  00062	50		 push	 eax
  00063	b9 09 00 00 00	 mov	 ecx, 9
  00068	6a 15		 push	 21			; 00000015H
  0006a	66 89 4c 24 2e	 mov	 WORD PTR _configDescReqBuf$[esp+74], cx
  0006f	8b c8		 mov	 ecx, eax
  00071	51		 push	 ecx
  00072	68 10 04 22 00	 push	 2229264			; 00220410H
  00077	53		 push	 ebx
  00078	89 6c 24 30	 mov	 DWORD PTR _configDescReqBuf$[esp+76], ebp
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 1386 :     if (!success)

  00082	85 c0		 test	 eax, eax
  00084	75 2a		 jne	 SHORT $LN8@GetConfigD

; 1387 :     {
; 1388 :         Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, DeviceIoControl False");

  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@JPCNJMBL@?$DM?$DM?5USB?4GetCfgDesc?0?5DeviceIoContr@
  0008b	68 6c 05 00 00	 push	 1388			; 0000056cH
  00090	6a 10		 push	 16			; 00000010H
  00092	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1389 :         return NULL;

  0009a	33 c0		 xor	 eax, eax

; 1474 :     return configDescReq;
; 1475 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5d		 pop	 ebp
  0009f	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  000a3	33 cc		 xor	 ecx, esp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	83 c4 20	 add	 esp, 32			; 00000020H
  000ad	c2 04 00	 ret	 4
$LN8@GetConfigD:

; 1390 :     }
; 1391 : 
; 1392 :     if (nBytes != nBytesReturned)

  000b0	8b 44 24 0c	 mov	 eax, DWORD PTR _nBytesReturned$[esp+44]
  000b4	83 f8 15	 cmp	 eax, 21			; 00000015H
  000b7	74 2d		 je	 SHORT $LN7@GetConfigD

; 1393 :     {
; 1394 :         Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, Bytes %u <> BytesRet %u",nBytes,nBytesReturned);

  000b9	50		 push	 eax
  000ba	6a 15		 push	 21			; 00000015H
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@CHLLBENA@?$DM?$DM?5USB?4GetCfgDesc?0?5Bytes?5?$CFu?5?$DM?$DO?5B@
  000c1	68 72 05 00 00	 push	 1394			; 00000572H
  000c6	6a 10		 push	 16			; 00000010H
  000c8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000cd	83 c4 14	 add	 esp, 20			; 00000014H

; 1395 :         return NULL;

  000d0	33 c0		 xor	 eax, eax

; 1474 :     return configDescReq;
; 1475 : }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp
  000d5	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  000d9	33 cc		 xor	 ecx, esp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	83 c4 20	 add	 esp, 32			; 00000020H
  000e3	c2 04 00	 ret	 4
$LN7@GetConfigD:

; 1396 :     }
; 1397 : 
; 1398 :     if (configDesc->wTotalLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))

  000e6	66 8b 44 24 1e	 mov	 ax, WORD PTR _configDescReqBuf$[esp+58]
  000eb	66 83 f8 09	 cmp	 ax, 9
  000ef	73 30		 jae	 SHORT $LN6@GetConfigD

; 1399 :     {
; 1400 :         Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, Total %d < Sz struct %d",configDesc->wTotalLength,sizeof(USB_CONFIGURATION_DESCRIPTOR));

  000f1	6a 09		 push	 9
  000f3	0f b7 d0	 movzx	 edx, ax
  000f6	52		 push	 edx
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LLJEBADN@?$DM?$DM?5USB?4GetCfgDesc?0?5Total?5?$CFd?5?$DM?5Sz@
  000fc	68 78 05 00 00	 push	 1400			; 00000578H
  00101	6a 10		 push	 16			; 00000010H
  00103	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00108	83 c4 14	 add	 esp, 20			; 00000014H

; 1401 :         return NULL;

  0010b	33 c0		 xor	 eax, eax

; 1474 :     return configDescReq;
; 1475 : }

  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5d		 pop	 ebp
  00110	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  00114	33 cc		 xor	 ecx, esp
  00116	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011b	83 c4 20	 add	 esp, 32			; 00000020H
  0011e	c2 04 00	 ret	 4
$LN6@GetConfigD:

; 1402 :     }
; 1403 : 
; 1404 :     // Now request the entire Configuration Descriptor using a dynamically
; 1405 :     // allocated buffer which is sized big enough to hold the entire descriptor
; 1406 :     //
; 1407 :     nBytes = sizeof(USB_DESCRIPTOR_REQUEST) + configDesc->wTotalLength;

  00121	0f b7 f8	 movzx	 edi, ax
  00124	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1408 : 
; 1409 :     configDescReq = (PUSB_DESCRIPTOR_REQUEST)malloc(nBytes);

  00127	57		 push	 edi
  00128	e8 00 00 00 00	 call	 _malloc
  0012d	83 c4 04	 add	 esp, 4
  00130	8b f0		 mov	 esi, eax

; 1410 :     if(configDescReq)
; 1411 :     {
; 1412 :         memset(configDescReq,0x00,nBytes);

  00132	57		 push	 edi
  00133	85 f6		 test	 esi, esi
  00135	0f 84 bb 00 00
	00		 je	 $LN5@GetConfigD
  0013b	6a 00		 push	 0
  0013d	56		 push	 esi
  0013e	e8 00 00 00 00	 call	 _memset
  00143	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1413 : 
; 1414 :         configDesc = (PUSB_CONFIGURATION_DESCRIPTOR)(configDescReq+1);
; 1415 : 
; 1416 :         // Indicate the port from which the descriptor will be requested
; 1417 :         //
; 1418 :         configDescReq->ConnectionIndex = ConnectionIndex;
; 1419 : 
; 1420 :         //
; 1421 :         // USBHUB uses URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE to process this
; 1422 :         // IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION request.
; 1423 :         //
; 1424 :         // USBD will automatically initialize these fields:
; 1425 :         //     bmRequest = 0x80
; 1426 :         //     bRequest  = 0x06
; 1427 :         //
; 1428 :         // We must inititialize these fields:
; 1429 :         //     wValue    = Descriptor Type (high) and Descriptor Index (low byte)
; 1430 :         //     wIndex    = Zero (or Language ID for String Descriptors)
; 1431 :         //     wLength   = Length of descriptor buffer
; 1432 :         //
; 1433 :         configDescReq->SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE << 8)
; 1434 :                                             | DescriptorIndex;
; 1435 : 
; 1436 :         configDescReq->SetupPacket.wLength = (USHORT)(nBytes - sizeof(USB_DESCRIPTOR_REQUEST));
; 1437 : 
; 1438 :         // Now issue the get descriptor request.
; 1439 :         //
; 1440 :         success = DeviceIoControl(hHubDevice,
; 1441 :                                   IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,
; 1442 :                                   configDescReq,
; 1443 :                                   nBytes,
; 1444 :                                   configDescReq,
; 1445 :                                   nBytes,
; 1446 :                                   &nBytesReturned,
; 1447 :                                   NULL);

  00146	6a 00		 push	 0
  00148	8d 54 24 10	 lea	 edx, DWORD PTR _nBytesReturned$[esp+48]
  0014c	52		 push	 edx
  0014d	57		 push	 edi
  0014e	56		 push	 esi
  0014f	57		 push	 edi
  00150	56		 push	 esi
  00151	68 10 04 22 00	 push	 2229264			; 00220410H
  00156	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0015b	8d 4f f4	 lea	 ecx, DWORD PTR [edi-12]
  0015e	53		 push	 ebx
  0015f	89 2e		 mov	 DWORD PTR [esi], ebp
  00161	66 89 46 06	 mov	 WORD PTR [esi+6], ax
  00165	66 89 4e 0a	 mov	 WORD PTR [esi+10], cx
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 1448 :         if (!success)

  0016f	85 c0		 test	 eax, eax
  00171	75 30		 jne	 SHORT $LN4@GetConfigD

; 1449 :         {
; 1450 :             Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, Req DeviceIoControl False");

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FDNPACDH@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5DeviceIoC@
  00178	68 aa 05 00 00	 push	 1450			; 000005aaH
  0017d	6a 10		 push	 16			; 00000010H
  0017f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1451 :             free(configDescReq);

  00184	56		 push	 esi
  00185	e8 00 00 00 00	 call	 _free
  0018a	83 c4 10	 add	 esp, 16			; 00000010H

; 1452 :             return NULL;

  0018d	33 c0		 xor	 eax, eax

; 1474 :     return configDescReq;
; 1475 : }

  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5d		 pop	 ebp
  00192	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  00196	33 cc		 xor	 ecx, esp
  00198	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019d	83 c4 20	 add	 esp, 32			; 00000020H
  001a0	c2 04 00	 ret	 4
$LN4@GetConfigD:

; 1453 :         }
; 1454 : 
; 1455 :         if (nBytes != nBytesReturned)

  001a3	8b 44 24 0c	 mov	 eax, DWORD PTR _nBytesReturned$[esp+44]
  001a7	3b f8		 cmp	 edi, eax
  001a9	74 32		 je	 SHORT $LN3@GetConfigD

; 1456 :         {
; 1457 :             Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, Req Bytes %u <> BytesRet %u",nBytes,nBytesReturned);

  001ab	50		 push	 eax
  001ac	57		 push	 edi
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JDNANMP@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Bytes?5?$CFu?5@
  001b2	68 b1 05 00 00	 push	 1457			; 000005b1H
$LN12@GetConfigD:
  001b7	6a 10		 push	 16			; 00000010H
  001b9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1458 :             free(configDescReq);

  001be	56		 push	 esi
  001bf	e8 00 00 00 00	 call	 _free
  001c4	83 c4 18	 add	 esp, 24			; 00000018H

; 1459 :             return NULL;

  001c7	33 c0		 xor	 eax, eax

; 1474 :     return configDescReq;
; 1475 : }

  001c9	5f		 pop	 edi
  001ca	5e		 pop	 esi
  001cb	5d		 pop	 ebp
  001cc	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  001d0	33 cc		 xor	 ecx, esp
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	83 c4 20	 add	 esp, 32			; 00000020H
  001da	c2 04 00	 ret	 4
$LN3@GetConfigD:

; 1460 :         }
; 1461 : 
; 1462 :         if (configDesc->wTotalLength != (nBytes - sizeof(USB_DESCRIPTOR_REQUEST)))

  001dd	0f b7 46 0e	 movzx	 eax, WORD PTR [esi+14]
  001e1	8d 4f f4	 lea	 ecx, DWORD PTR [edi-12]
  001e4	3b c1		 cmp	 eax, ecx
  001e6	74 22		 je	 SHORT $LN1@GetConfigD

; 1463 :         {
; 1464 :             Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, Req Total %d < Sz %d",configDesc->wTotalLength,(nBytes - sizeof(USB_DESCRIPTOR_REQUEST)));

  001e8	51		 push	 ecx
  001e9	50		 push	 eax
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@LMLHDIHD@?$DM?$DM?5USB?4GetCfgDesc?0?5Req?5Total?5?$CFd?5@
  001ef	68 b8 05 00 00	 push	 1464			; 000005b8H

; 1465 :             free(configDescReq);
; 1466 :             return NULL;

  001f4	eb c1		 jmp	 SHORT $LN12@GetConfigD
$LN5@GetConfigD:

; 1467 :         }
; 1468 :     }
; 1469 :     else
; 1470 :     {
; 1471 :         Log(LOG_DEBUG,__LINE__,"-- USB.GetCfgDescriptor, new Buf (%u) null",nBytes);

  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LPDCGPEM@?9?9?5USB?4GetCfgDescriptor?0?5new?5Buf@
  001fb	68 bf 05 00 00	 push	 1471			; 000005bfH
  00200	6a 10		 push	 16			; 00000010H
  00202	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00207	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GetConfigD:

; 1472 :     }
; 1473 :     Log(LOG_DEBUG,__LINE__,"<< USB.GetCfgDesc, %X",configDescReq);

  0020a	56		 push	 esi
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@INDEEKLB@?$DM?$DM?5USB?4GetCfgDesc?0?5?$CFX?$AA@
  00210	68 c1 05 00 00	 push	 1473			; 000005c1H
  00215	6a 10		 push	 16			; 00000010H
  00217	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1474 :     return configDescReq;
; 1475 : }

  0021c	8b 4c 24 38	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+60]
  00220	83 c4 10	 add	 esp, 16			; 00000010H
  00223	5f		 pop	 edi
  00224	8b c6		 mov	 eax, esi
  00226	5e		 pop	 esi
  00227	5d		 pop	 ebp
  00228	33 cc		 xor	 ecx, esp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	83 c4 20	 add	 esp, 32			; 00000020H
  00232	c2 04 00	 ret	 4
?GetConfigDescriptor@USB@@IAEPAU_USB_DESCRIPTOR_REQUEST@@PAXKE@Z ENDP ; USB::GetConfigDescriptor
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetHCDDriverKeyName@USB@@IAEPADPAX@Z		; USB::GetHCDDriverKeyName
; Function compile flags: /Ogtpy
;	COMDAT ?GetHCDDriverKeyName@USB@@IAEPADPAX@Z
_TEXT	SEGMENT
_nBytes$ = -16						; size = 4
_driverKeyName$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
?GetHCDDriverKeyName@USB@@IAEPADPAX@Z PROC		; USB::GetHCDDriverKeyName, COMDAT
; _HCD$ = edi

; 1243 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax
  0000e	53		 push	 ebx
  0000f	55		 push	 ebp
  00010	56		 push	 esi

; 1244 :     BOOL                    success;
; 1245 :     ULONG                   nBytes = 0;
; 1246 :     USB_HCD_DRIVERKEY_NAME  driverKeyName;
; 1247 :     PUSB_HCD_DRIVERKEY_NAME driverKeyNameW = NULL;
; 1248 :     PCHAR                   driverKeyNameA = NULL;
; 1249 : 
; 1250 :     Log(LOG_DEBUG,__LINE__,">> USB.GetHCDDrvKeyName");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LFJMJGOI@?$DO?$DO?5USB?4GetHCDDrvKeyName?$AA@
  00016	68 e2 04 00 00	 push	 1250			; 000004e2H
  0001b	33 ed		 xor	 ebp, ebp
  0001d	6a 10		 push	 16			; 00000010H
  0001f	89 6c 24 18	 mov	 DWORD PTR _nBytes$[esp+40], ebp
  00023	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1251 : 
; 1252 :     // Get the length of the name of the driver key of the HCD
; 1253 :     //
; 1254 : 	memset (&driverKeyName, 0, sizeof(driverKeyName));
; 1255 :     success = DeviceIoControl(HCD,
; 1256 :                               IOCTL_GET_HCD_DRIVERKEY_NAME,
; 1257 :                               &driverKeyName,
; 1258 :                               sizeof(driverKeyName),
; 1259 :                               &driverKeyName,
; 1260 :                               sizeof(driverKeyName),
; 1261 :                               &nBytes,
; 1262 :                               NULL);

  00028	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeviceIoControl@32
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	55		 push	 ebp
  00032	33 c0		 xor	 eax, eax
  00034	89 44 24 14	 mov	 DWORD PTR _driverKeyName$[esp+32], eax
  00038	66 89 44 24 18	 mov	 WORD PTR _driverKeyName$[esp+36], ax
  0003d	8d 44 24 10	 lea	 eax, DWORD PTR _nBytes$[esp+32]
  00041	50		 push	 eax
  00042	6a 06		 push	 6
  00044	8d 4c 24 1c	 lea	 ecx, DWORD PTR _driverKeyName$[esp+40]
  00048	51		 push	 ecx
  00049	6a 06		 push	 6
  0004b	8b d1		 mov	 edx, ecx
  0004d	52		 push	 edx
  0004e	68 24 04 22 00	 push	 2229284			; 00220424H
  00053	57		 push	 edi
  00054	ff d3		 call	 ebx

; 1263 :     if (success)

  00056	85 c0		 test	 eax, eax
  00058	74 58		 je	 SHORT $LN2@GetHCDDriv

; 1264 :     {
; 1265 : 
; 1266 : 		// Allocate space to hold the driver key name
; 1267 : 		//
; 1268 : 		nBytes = driverKeyName.ActualLength;

  0005a	8b 44 24 10	 mov	 eax, DWORD PTR _driverKeyName$[esp+28]
  0005e	89 44 24 0c	 mov	 DWORD PTR _nBytes$[esp+28], eax

; 1269 : 
; 1270 : 		if (nBytes > sizeof(driverKeyName))

  00062	83 f8 06	 cmp	 eax, 6
  00065	76 4b		 jbe	 SHORT $LN2@GetHCDDriv

; 1271 : 		{
; 1272 : 			driverKeyNameW = (struct _USB_HCD_DRIVERKEY_NAME *)malloc(nBytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _malloc
  0006d	8b f0		 mov	 esi, eax
  0006f	83 c4 04	 add	 esp, 4

; 1273 :             if(driverKeyNameW)

  00072	3b f5		 cmp	 esi, ebp
  00074	74 3c		 je	 SHORT $LN2@GetHCDDriv

; 1274 :             {
; 1275 :                 memset(driverKeyNameW,0x00,nBytes);

  00076	8b 44 24 0c	 mov	 eax, DWORD PTR _nBytes$[esp+28]
  0007a	50		 push	 eax
  0007b	55		 push	 ebp
  0007c	56		 push	 esi
  0007d	e8 00 00 00 00	 call	 _memset

; 1276 : 
; 1277 : 			    // Get the name of the driver key of the device attached to
; 1278 : 			    // the specified port.
; 1279 : 			    //
; 1280 : 			    success = DeviceIoControl(HCD,
; 1281 : 									      IOCTL_GET_HCD_DRIVERKEY_NAME,
; 1282 : 									      driverKeyNameW,
; 1283 : 									      nBytes,
; 1284 : 									      driverKeyNameW,
; 1285 : 									      nBytes,
; 1286 : 									      &nBytes,
; 1287 : 									      NULL);

  00082	8b 44 24 18	 mov	 eax, DWORD PTR _nBytes$[esp+40]
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	55		 push	 ebp
  0008a	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBytes$[esp+32]
  0008e	51		 push	 ecx
  0008f	50		 push	 eax
  00090	56		 push	 esi
  00091	50		 push	 eax
  00092	56		 push	 esi
  00093	68 24 04 22 00	 push	 2229284			; 00220424H
  00098	57		 push	 edi
  00099	ff d3		 call	 ebx

; 1288 : 
; 1289 : 			    if (success)

  0009b	85 c0		 test	 eax, eax
  0009d	74 0a		 je	 SHORT $LN1@GetHCDDriv

; 1290 : 			    {
; 1291 : 				    // Convert the driver key name
; 1292 : 				    //
; 1293 : 				    driverKeyNameA = WideStrToMultiStr(driverKeyNameW->DriverKeyName);

  0009f	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  000a2	e8 00 00 00 00	 call	 ?WideStrToMultiStr@@YAPADPA_W@Z ; WideStrToMultiStr
  000a7	8b e8		 mov	 ebp, eax
$LN1@GetHCDDriv:

; 1294 : 			    }
; 1295 : 			    free(driverKeyNameW);

  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _free
  000af	83 c4 04	 add	 esp, 4
$LN2@GetHCDDriv:

; 1296 : 		    }
; 1297 :         }
; 1298 : 	}
; 1299 :     Log(LOG_DEBUG,__LINE__,"<< USB.GetHCDDrvKeyName, DrvKeyName %X",driverKeyNameA);

  000b2	55		 push	 ebp
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BGNGLHKH@?$DM?$DM?5USB?4GetHCDDrvKeyName?0?5DrvKeyN@
  000b8	68 13 05 00 00	 push	 1299			; 00000513H
  000bd	6a 10		 push	 16			; 00000010H
  000bf	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1300 : 	return driverKeyNameA;
; 1301 : }

  000c4	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  000c8	83 c4 10	 add	 esp, 16			; 00000010H
  000cb	5e		 pop	 esi
  000cc	8b c5		 mov	 eax, ebp
  000ce	5d		 pop	 ebp
  000cf	5b		 pop	 ebx
  000d0	33 cc		 xor	 ecx, esp
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	83 c4 10	 add	 esp, 16			; 00000010H
  000da	c3		 ret	 0
?GetHCDDriverKeyName@USB@@IAEPADPAX@Z ENDP		; USB::GetHCDDriverKeyName
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetRootHubName@USB@@IAEPADPAX@Z		; USB::GetRootHubName
; Function compile flags: /Ogtpy
;	COMDAT ?GetRootHubName@USB@@IAEPADPAX@Z
_TEXT	SEGMENT
_nBytes$ = -16						; size = 4
_rootHubName$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
?GetRootHubName@USB@@IAEPADPAX@Z PROC			; USB::GetRootHubName, COMDAT
; _HostController$ = esi

; 1185 : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax
  0000e	53		 push	 ebx
  0000f	55		 push	 ebp
  00010	57		 push	 edi

; 1186 :     BOOL                success;
; 1187 :     ULONG               nBytes = 0;
; 1188 :     USB_ROOT_HUB_NAME   rootHubName;
; 1189 :     PUSB_ROOT_HUB_NAME  rootHubNameW = NULL;
; 1190 :     PCHAR               rootHubNameA = NULL;
; 1191 : 
; 1192 :     Log(LOG_DEBUG,__LINE__,">> USB.GetRootHub");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PGMOMHHM@?$DO?$DO?5USB?4GetRootHub?$AA@
  00016	68 a8 04 00 00	 push	 1192			; 000004a8H
  0001b	33 ed		 xor	 ebp, ebp
  0001d	6a 10		 push	 16			; 00000010H
  0001f	89 6c 24 18	 mov	 DWORD PTR _nBytes$[esp+40], ebp
  00023	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1193 : 
; 1194 :     memset(&rootHubName,0x00,sizeof(rootHubName));
; 1195 : 
; 1196 :     // Get the length of the name of the Root Hub attached to the
; 1197 :     // Host Controller
; 1198 :     //
; 1199 :     success = DeviceIoControl(HostController,
; 1200 :                               IOCTL_USB_GET_ROOT_HUB_NAME,
; 1201 :                               0,
; 1202 :                               0,
; 1203 :                               &rootHubName,
; 1204 :                               sizeof(rootHubName),
; 1205 :                               &nBytes,
; 1206 :                               NULL);

  00028	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__DeviceIoControl@32
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	55		 push	 ebp
  00032	33 c0		 xor	 eax, eax
  00034	89 44 24 14	 mov	 DWORD PTR _rootHubName$[esp+32], eax
  00038	66 89 44 24 18	 mov	 WORD PTR _rootHubName$[esp+36], ax
  0003d	8d 44 24 10	 lea	 eax, DWORD PTR _nBytes$[esp+32]
  00041	50		 push	 eax
  00042	6a 06		 push	 6
  00044	8d 4c 24 1c	 lea	 ecx, DWORD PTR _rootHubName$[esp+40]
  00048	51		 push	 ecx
  00049	55		 push	 ebp
  0004a	55		 push	 ebp
  0004b	68 08 04 22 00	 push	 2229256			; 00220408H
  00050	56		 push	 esi
  00051	ff d3		 call	 ebx

; 1207 :     if (success)

  00053	85 c0		 test	 eax, eax
  00055	74 53		 je	 SHORT $LN2@GetRootHub

; 1208 :     {
; 1209 : 		// Allocate space to hold the Root Hub name
; 1210 : 		//
; 1211 : 		nBytes = rootHubName.ActualLength;

  00057	8b 44 24 10	 mov	 eax, DWORD PTR _rootHubName$[esp+28]

; 1212 : 
; 1213 : 		rootHubNameW = (struct _USB_ROOT_HUB_NAME *)malloc(nBytes);

  0005b	50		 push	 eax
  0005c	89 44 24 10	 mov	 DWORD PTR _nBytes$[esp+32], eax
  00060	e8 00 00 00 00	 call	 _malloc
  00065	8b f8		 mov	 edi, eax
  00067	83 c4 04	 add	 esp, 4

; 1214 :         if(rootHubNameW)

  0006a	3b fd		 cmp	 edi, ebp
  0006c	74 3c		 je	 SHORT $LN2@GetRootHub

; 1215 :         {
; 1216 :             memset(rootHubNameW,0x00,nBytes);

  0006e	8b 54 24 0c	 mov	 edx, DWORD PTR _nBytes$[esp+28]
  00072	52		 push	 edx
  00073	55		 push	 ebp
  00074	57		 push	 edi
  00075	e8 00 00 00 00	 call	 _memset

; 1217 : 
; 1218 : 		    // Get the name of the Root Hub attached to the Host Controller
; 1219 : 		    //
; 1220 : 		    success = DeviceIoControl(HostController,
; 1221 : 								      IOCTL_USB_GET_ROOT_HUB_NAME,
; 1222 : 								      NULL,
; 1223 : 								      0,
; 1224 : 								      rootHubNameW,
; 1225 : 								      nBytes,
; 1226 : 								      &nBytes,
; 1227 : 								      NULL);

  0007a	8b 4c 24 18	 mov	 ecx, DWORD PTR _nBytes$[esp+40]
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	55		 push	 ebp
  00082	8d 44 24 10	 lea	 eax, DWORD PTR _nBytes$[esp+32]
  00086	50		 push	 eax
  00087	51		 push	 ecx
  00088	57		 push	 edi
  00089	55		 push	 ebp
  0008a	55		 push	 ebp
  0008b	68 08 04 22 00	 push	 2229256			; 00220408H
  00090	56		 push	 esi
  00091	ff d3		 call	 ebx

; 1228 : 
; 1229 : 		    if (success)

  00093	85 c0		 test	 eax, eax
  00095	74 0a		 je	 SHORT $LN1@GetRootHub

; 1230 : 		    {
; 1231 : 			    // Convert the Root Hub name
; 1232 : 			    //
; 1233 : 			    rootHubNameA = WideStrToMultiStr(rootHubNameW->RootHubName);

  00097	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  0009a	e8 00 00 00 00	 call	 ?WideStrToMultiStr@@YAPADPA_W@Z ; WideStrToMultiStr
  0009f	8b e8		 mov	 ebp, eax
$LN1@GetRootHub:

; 1234 : 		    }
; 1235 : 		    free(rootHubNameW);

  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 _free
  000a7	83 c4 04	 add	 esp, 4
$LN2@GetRootHub:

; 1236 :         }
; 1237 : 	}
; 1238 :     Log(LOG_DEBUG,__LINE__,"<< USB.GetRootHub, HubName %X",rootHubNameA);

  000aa	55		 push	 ebp
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LDLFLMCA@?$DM?$DM?5USB?4GetRootHub?0?5HubName?5?$CFX?$AA@
  000b0	68 d6 04 00 00	 push	 1238			; 000004d6H
  000b5	6a 10		 push	 16			; 00000010H
  000b7	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1239 : 	return rootHubNameA;
; 1240 : }

  000bc	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  000c0	83 c4 10	 add	 esp, 16			; 00000010H
  000c3	5f		 pop	 edi
  000c4	8b c5		 mov	 eax, ebp
  000c6	5d		 pop	 ebp
  000c7	5b		 pop	 ebx
  000c8	33 cc		 xor	 ecx, esp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	83 c4 10	 add	 esp, 16			; 00000010H
  000d2	c3		 ret	 0
?GetRootHubName@USB@@IAEPADPAX@Z ENDP			; USB::GetRootHubName
_TEXT	ENDS
PUBLIC	?DriverNameToDeviceDesc@USB@@IAEPADPAD@Z	; USB::DriverNameToDeviceDesc
; Function compile flags: /Ogtpy
;	COMDAT ?DriverNameToDeviceDesc@USB@@IAEPADPAD@Z
_TEXT	SEGMENT
_devInst$ = -12						; size = 4
_devInstNext$ = -8					; size = 4
_len$ = -4						; size = 4
_DriverName$ = 8					; size = 4
?DriverNameToDeviceDesc@USB@@IAEPADPAD@Z PROC		; USB::DriverNameToDeviceDesc, COMDAT
; _this$ = esi

; 954  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 955  :     DEVINST     devInst = 0;
; 956  :     DEVINST     devInstNext = 0;
; 957  :     CONFIGRET   cr = 0;
; 958  :     ULONG       walkDone = 0;
; 959  :     ULONG       len = 0;
; 960  : 
; 961  :     Log(LOG_DEBUG,__LINE__,">> USB.DrvName2DevDesc, Drv %s",DriverName);

  00003	8b 44 24 10	 mov	 eax, DWORD PTR _DriverName$[esp+8]
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@KMJAGKHH@?$DO?$DO?5USB?4DrvName2DevDesc?0?5Drv?5?$CFs?$AA@
  0000e	68 c1 03 00 00	 push	 961			; 000003c1H
  00013	6a 10		 push	 16			; 00000010H
  00015	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _devInst$[esp+32], 0
  0001d	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _devInstNext$[esp+32], 0
  00025	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _len$[esp+32], 0
  0002d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 962  : 
; 963  :     // Get Root DevNode
; 964  :     //
; 965  :     cr = (*lpfnCM_Locate_DevNodeA)(&devInst,NULL,0);

  00032	8b 96 34 02 00
	00		 mov	 edx, DWORD PTR [esi+564]
  00038	83 c4 10	 add	 esp, 16			; 00000010H
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _devInst$[esp+24]
  00043	51		 push	 ecx
  00044	ff d2		 call	 edx

; 966  :     if (cr != CR_SUCCESS)

  00046	85 c0		 test	 eax, eax
  00048	74 1e		 je	 SHORT $LN22@DriverName

; 967  :     {
; 968  :         Log(LOG_DEBUG,__LINE__,"<< USB.DrvName2DevDesc, LocateDevNote %u",cr);

  0004a	50		 push	 eax
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@PHHANNLH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5LocateDe@
  00050	68 c8 03 00 00	 push	 968			; 000003c8H
  00055	6a 10		 push	 16			; 00000010H
  00057	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0005c	83 c4 10	 add	 esp, 16			; 00000010H

; 1048 :     return NULL;

  0005f	33 c0		 xor	 eax, eax

; 1049 : }

  00061	5f		 pop	 edi
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	c2 04 00	 ret	 4
$LN22@DriverName:

; 969  :         return NULL;

  00068	8b 44 24 04	 mov	 eax, DWORD PTR _devInst$[esp+16]
  0006c	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  0006f	90		 npad	 1
$LL11@DriverName:

; 970  :     }
; 971  : 
; 972  :     // Do a depth first search for the DevNode with a matching
; 973  :     // DriverName value
; 974  :     //
; 975  :     while (!walkDone)
; 976  :     {
; 977  :         // Get the DriverName value
; 978  :         //
; 979  :         len = sizeof(buf);
; 980  :         cr = (*lpfnCM_Get_DevNode_Registry_PropertyA)(devInst,
; 981  :                                               CM_DRP_DRIVER,
; 982  :                                               NULL,
; 983  :                                               buf,
; 984  :                                               &len,
; 985  :                                               0);

  00070	8b 96 30 02 00
	00		 mov	 edx, DWORD PTR [esi+560]
  00076	6a 00		 push	 0
  00078	8d 4c 24 10	 lea	 ecx, DWORD PTR _len$[esp+20]
  0007c	51		 push	 ecx
  0007d	57		 push	 edi
  0007e	6a 00		 push	 0
  00080	6a 0a		 push	 10			; 0000000aH
  00082	50		 push	 eax
  00083	c7 44 24 24 00
	02 00 00	 mov	 DWORD PTR _len$[esp+40], 512 ; 00000200H
  0008b	ff d2		 call	 edx

; 986  : 
; 987  :         // If the DriverName value matches, return the DeviceDescription
; 988  :         //
; 989  :         if (cr == CR_SUCCESS && strcmp(DriverName, buf) == 0)

  0008d	85 c0		 test	 eax, eax
  0008f	75 33		 jne	 SHORT $LN7@DriverName
  00091	8b 44 24 14	 mov	 eax, DWORD PTR _DriverName$[esp+12]
  00095	8b cf		 mov	 ecx, edi
$LL25@DriverName:
  00097	8a 10		 mov	 dl, BYTE PTR [eax]
  00099	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0009b	75 1a		 jne	 SHORT $LN26@DriverName
  0009d	84 d2		 test	 dl, dl
  0009f	74 12		 je	 SHORT $LN27@DriverName
  000a1	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000a4	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000a7	75 0e		 jne	 SHORT $LN26@DriverName
  000a9	83 c0 02	 add	 eax, 2
  000ac	83 c1 02	 add	 ecx, 2
  000af	84 d2		 test	 dl, dl
  000b1	75 e4		 jne	 SHORT $LL25@DriverName
$LN27@DriverName:
  000b3	33 c0		 xor	 eax, eax
  000b5	eb 05		 jmp	 SHORT $LN28@DriverName
$LN26@DriverName:
  000b7	1b c0		 sbb	 eax, eax
  000b9	83 d8 ff	 sbb	 eax, -1
$LN28@DriverName:
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 81 00 00
	00		 je	 $LN19@DriverName
$LN7@DriverName:

; 1007 :                 return NULL;
; 1008 :             }
; 1009 :         }
; 1010 : 
; 1011 :         // This DevNode didn't match, go down a level to the first child.
; 1012 :         //
; 1013 :         cr = (*lpfnCM_Get_Child)(&devInstNext,devInst,0);

  000c4	8b 44 24 04	 mov	 eax, DWORD PTR _devInst$[esp+16]
  000c8	8b 96 2c 02 00
	00		 mov	 edx, DWORD PTR [esi+556]
  000ce	6a 00		 push	 0
  000d0	50		 push	 eax
  000d1	8d 4c 24 10	 lea	 ecx, DWORD PTR _devInstNext$[esp+24]
  000d5	51		 push	 ecx
  000d6	ff d2		 call	 edx

; 1014 :         if (cr == CR_SUCCESS)

  000d8	85 c0		 test	 eax, eax
  000da	75 0a		 jne	 SHORT $LN17@DriverName

; 1015 :         {
; 1016 :             devInst = devInstNext;

  000dc	8b 44 24 08	 mov	 eax, DWORD PTR _devInstNext$[esp+16]
  000e0	89 44 24 04	 mov	 DWORD PTR _devInst$[esp+16], eax

; 1017 :             continue;

  000e4	eb 8a		 jmp	 SHORT $LL11@DriverName
$LN17@DriverName:

; 1018 :         }
; 1019 : 
; 1020 :         // Can't go down any further, go across to the next sibling.  If
; 1021 :         // there are no more siblings, go back up until there is a sibling.
; 1022 :         // If we can't go up any further, we're back at the root and we're
; 1023 :         // done.
; 1024 :         //
; 1025 :         for (;;)
; 1026 :         {
; 1027 :             cr = (*lpfnCM_Get_Sibling)(&devInstNext,devInst,0);

  000e6	8b 44 24 04	 mov	 eax, DWORD PTR _devInst$[esp+16]
  000ea	8b 96 28 02 00
	00		 mov	 edx, DWORD PTR [esi+552]
  000f0	6a 00		 push	 0
  000f2	50		 push	 eax
  000f3	8d 4c 24 10	 lea	 ecx, DWORD PTR _devInstNext$[esp+24]
  000f7	51		 push	 ecx
  000f8	ff d2		 call	 edx

; 1028 :             if (cr == CR_SUCCESS)

  000fa	85 c0		 test	 eax, eax
  000fc	74 3a		 je	 SHORT $LN18@DriverName
  000fe	8b ff		 npad	 2
$LL5@DriverName:

; 1031 :                 break;
; 1032 :             }
; 1033 : 
; 1034 :             cr = (*lpfnCM_Get_Parent)(&devInstNext,devInst,0);

  00100	8b 44 24 04	 mov	 eax, DWORD PTR _devInst$[esp+16]
  00104	8b 96 24 02 00
	00		 mov	 edx, DWORD PTR [esi+548]
  0010a	6a 00		 push	 0
  0010c	50		 push	 eax
  0010d	8d 4c 24 10	 lea	 ecx, DWORD PTR _devInstNext$[esp+24]
  00111	51		 push	 ecx
  00112	ff d2		 call	 edx

; 1035 :             if (cr == CR_SUCCESS)

  00114	85 c0		 test	 eax, eax
  00116	0f 85 8a 00 00
	00		 jne	 $LN10@DriverName

; 1036 :             {
; 1037 :                 devInst = devInstNext;

  0011c	8b 44 24 08	 mov	 eax, DWORD PTR _devInstNext$[esp+16]
  00120	8b 8e 28 02 00
	00		 mov	 ecx, DWORD PTR [esi+552]
  00126	6a 00		 push	 0
  00128	50		 push	 eax
  00129	89 44 24 0c	 mov	 DWORD PTR _devInst$[esp+24], eax
  0012d	8d 44 24 10	 lea	 eax, DWORD PTR _devInstNext$[esp+24]
  00131	50		 push	 eax
  00132	ff d1		 call	 ecx
  00134	85 c0		 test	 eax, eax
  00136	75 c8		 jne	 SHORT $LL5@DriverName
$LN18@DriverName:

; 1029 :             {
; 1030 :                 devInst = devInstNext;

  00138	8b 44 24 08	 mov	 eax, DWORD PTR _devInstNext$[esp+16]
  0013c	89 44 24 04	 mov	 DWORD PTR _devInst$[esp+16], eax
  00140	e9 2b ff ff ff	 jmp	 $LL11@DriverName
$LN19@DriverName:

; 990  :         {
; 991  :             len = sizeof(buf);
; 992  :             cr = (*lpfnCM_Get_DevNode_Registry_PropertyA)(devInst,
; 993  :                                                   CM_DRP_DEVICEDESC,
; 994  :                                                   NULL,
; 995  :                                                   buf,
; 996  :                                                   &len,
; 997  :                                                   0);

  00145	8b 44 24 04	 mov	 eax, DWORD PTR _devInst$[esp+16]
  00149	8b 8e 30 02 00
	00		 mov	 ecx, DWORD PTR [esi+560]
  0014f	6a 00		 push	 0
  00151	8d 54 24 10	 lea	 edx, DWORD PTR _len$[esp+20]
  00155	52		 push	 edx
  00156	57		 push	 edi
  00157	6a 00		 push	 0
  00159	6a 01		 push	 1
  0015b	50		 push	 eax
  0015c	c7 44 24 24 00
	02 00 00	 mov	 DWORD PTR _len$[esp+40], 512 ; 00000200H
  00164	ff d1		 call	 ecx

; 998  : 
; 999  :             if (cr == CR_SUCCESS)

  00166	85 c0		 test	 eax, eax
  00168	75 1e		 jne	 SHORT $LN8@DriverName

; 1000 :             {
; 1001 :                 Log(LOG_DEBUG,__LINE__,"<< USB.DrvName2DevDesc, ret %X",buf);

  0016a	57		 push	 edi
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BAEOHBIH@?$DM?$DM?5USB?4DrvName2DevDesc?0?5ret?5?$CFX?$AA@
  00170	68 e9 03 00 00	 push	 1001			; 000003e9H
  00175	6a 10		 push	 16			; 00000010H
  00177	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0017c	83 c4 10	 add	 esp, 16			; 00000010H

; 1002 :                 return buf;

  0017f	8b c7		 mov	 eax, edi

; 1049 : }

  00181	5f		 pop	 edi
  00182	83 c4 0c	 add	 esp, 12			; 0000000cH
  00185	c2 04 00	 ret	 4
$LN8@DriverName:

; 1003 :             }
; 1004 :             else
; 1005 :             {
; 1006 :                 Log(LOG_DEBUG,__LINE__,"<< USB.DrvName2DevDesc, GetDevNodeRegProps %u",cr);

  00188	50		 push	 eax
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@BAPAALJK@?$DM?$DM?5USB?4DrvName2DevDesc?0?5GetDevNo@
  0018e	68 ee 03 00 00	 push	 1006			; 000003eeH
  00193	6a 10		 push	 16			; 00000010H
  00195	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 1048 :     return NULL;

  0019d	33 c0		 xor	 eax, eax

; 1049 : }

  0019f	5f		 pop	 edi
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a3	c2 04 00	 ret	 4
$LN10@DriverName:

; 1038 :             }
; 1039 :             else
; 1040 :             {
; 1041 :                 walkDone = 1;
; 1042 :                 break;
; 1043 :             }
; 1044 :         }
; 1045 :     }
; 1046 : 
; 1047 :     Log(LOG_DEBUG,__LINE__,"<< USB.DrvName2DevDesc, Ret Null");

  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OFAOPKJL@?$DM?$DM?5USB?4DrvName2DevDesc?0?5Ret?5Null@
  001ab	68 17 04 00 00	 push	 1047			; 00000417H
  001b0	6a 10		 push	 16			; 00000010H
  001b2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1048 :     return NULL;

  001ba	33 c0		 xor	 eax, eax

; 1049 : }

  001bc	5f		 pop	 edi
  001bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c0	c2 04 00	 ret	 4
?DriverNameToDeviceDesc@USB@@IAEPADPAD@Z ENDP		; USB::DriverNameToDeviceDesc
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetExternalHubName@USB@@IAEPADPAXK@Z		; USB::GetExternalHubName
; Function compile flags: /Ogtpy
;	COMDAT ?GetExternalHubName@USB@@IAEPADPAXK@Z
_TEXT	SEGMENT
_nBytes$ = -24						; size = 4
_extHubNameA$ = -20					; size = 4
_extHubName$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?GetExternalHubName@USB@@IAEPADPAXK@Z PROC		; USB::GetExternalHubName, COMDAT
; _Hub$ = edi
; _ConnectionIndex$ = ecx

; 614  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax
  0000e	53		 push	 ebx
  0000f	55		 push	 ebp
  00010	56		 push	 esi

; 615  :     BOOL                        success;
; 616  :     ULONG                       nBytes = 0;
; 617  :     USB_NODE_CONNECTION_NAME    extHubName;
; 618  :     PUSB_NODE_CONNECTION_NAME   extHubNameW = NULL;
; 619  :     PCHAR                       extHubNameA = NULL;
; 620  : 
; 621  :     Log(LOG_DEBUG,__LINE__,">> USB.GetExternHub");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BDIOPGJF@?$DO?$DO?5USB?4GetExternHub?$AA@
  00016	33 f6		 xor	 esi, esi
  00018	68 6d 02 00 00	 push	 621			; 0000026dH
  0001d	6a 10		 push	 16			; 00000010H
  0001f	8b d9		 mov	 ebx, ecx
  00021	89 74 24 18	 mov	 DWORD PTR _nBytes$[esp+48], esi
  00025	89 74 24 1c	 mov	 DWORD PTR _extHubNameA$[esp+48], esi
  00029	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 622  : 
; 623  :     // Get the length of the name of the external hub attached to the
; 624  :     // specified port.
; 625  :     //
; 626  : 	memset (&extHubName, 0, sizeof(extHubName));
; 627  :     extHubName.ConnectionIndex = ConnectionIndex;
; 628  : 
; 629  :     success = DeviceIoControl(Hub,
; 630  :                               IOCTL_USB_GET_NODE_CONNECTION_NAME,
; 631  :                               &extHubName,
; 632  :                               sizeof(extHubName),
; 633  :                               &extHubName,
; 634  :                               sizeof(extHubName),
; 635  :                               &nBytes,
; 636  :                               NULL);

  0002e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__DeviceIoControl@32
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	33 c0		 xor	 eax, eax
  00039	56		 push	 esi
  0003a	89 44 24 18	 mov	 DWORD PTR _extHubName$[esp+40], eax
  0003e	89 44 24 1c	 mov	 DWORD PTR _extHubName$[esp+44], eax
  00042	66 89 44 24 20	 mov	 WORD PTR _extHubName$[esp+48], ax
  00047	8d 44 24 10	 lea	 eax, DWORD PTR _nBytes$[esp+40]
  0004b	50		 push	 eax
  0004c	6a 0a		 push	 10			; 0000000aH
  0004e	8d 4c 24 20	 lea	 ecx, DWORD PTR _extHubName$[esp+48]
  00052	51		 push	 ecx
  00053	6a 0a		 push	 10			; 0000000aH
  00055	8b d1		 mov	 edx, ecx
  00057	52		 push	 edx
  00058	68 14 04 22 00	 push	 2229268			; 00220414H
  0005d	57		 push	 edi
  0005e	89 5c 24 34	 mov	 DWORD PTR _extHubName$[esp+68], ebx
  00062	ff d5		 call	 ebp

; 637  : 
; 638  :     if (success)

  00064	85 c0		 test	 eax, eax
  00066	74 79		 je	 SHORT $LN1@GetExterna

; 639  :     {
; 640  : 		// Allocate space to hold the external hub name
; 641  : 		//
; 642  : 		nBytes = extHubName.ActualLength;

  00068	8b 44 24 18	 mov	 eax, DWORD PTR _extHubName$[esp+40]
  0006c	89 44 24 0c	 mov	 DWORD PTR _nBytes$[esp+36], eax

; 643  : 
; 644  : 		if (nBytes > sizeof(extHubName))

  00070	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00073	76 6c		 jbe	 SHORT $LN1@GetExterna

; 645  : 		{
; 646  : 			extHubNameW = (struct _USB_NODE_CONNECTION_NAME *)malloc(nBytes);

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _malloc
  0007b	8b f0		 mov	 esi, eax
  0007d	83 c4 04	 add	 esp, 4

; 647  :             if(extHubNameW)

  00080	85 f6		 test	 esi, esi
  00082	74 44		 je	 SHORT $LN3@GetExterna

; 648  :             {
; 649  :                 memset(extHubNameW,0x00,nBytes);

  00084	8b 44 24 0c	 mov	 eax, DWORD PTR _nBytes$[esp+36]
  00088	50		 push	 eax
  00089	6a 00		 push	 0
  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 _memset
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 
; 651  : 			    // Get the name of the external hub attached to the specified port
; 652  : 			    //
; 653  : 			    extHubNameW->ConnectionIndex = ConnectionIndex;
; 654  : 
; 655  : 			    success = DeviceIoControl(Hub,
; 656  : 									      IOCTL_USB_GET_NODE_CONNECTION_NAME,
; 657  : 									      extHubNameW,
; 658  : 									      nBytes,
; 659  : 									      extHubNameW,
; 660  : 									      nBytes,
; 661  : 									      &nBytes,
; 662  : 									      NULL);

  00094	6a 00		 push	 0
  00096	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBytes$[esp+40]
  0009a	51		 push	 ecx
  0009b	89 1e		 mov	 DWORD PTR [esi], ebx
  0009d	8b 44 24 14	 mov	 eax, DWORD PTR _nBytes$[esp+44]
  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	68 14 04 22 00	 push	 2229268			; 00220414H
  000aa	57		 push	 edi
  000ab	ff d5		 call	 ebp

; 663  : 
; 664  : 			    if (success)

  000ad	85 c0		 test	 eax, eax
  000af	74 0c		 je	 SHORT $LN2@GetExterna

; 665  : 			    {
; 666  : 				    // Convert the External Hub name
; 667  : 				    //
; 668  : 				    extHubNameA = WideStrToMultiStr(extHubNameW->NodeName);

  000b1	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  000b4	e8 00 00 00 00	 call	 ?WideStrToMultiStr@@YAPADPA_W@Z ; WideStrToMultiStr
  000b9	89 44 24 10	 mov	 DWORD PTR _extHubNameA$[esp+36], eax
$LN2@GetExterna:

; 669  : 			    }
; 670  : 			    free(extHubNameW);

  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 _free
  000c3	83 c4 04	 add	 esp, 4

; 671  :             }
; 672  :             else

  000c6	eb 19		 jmp	 SHORT $LN1@GetExterna
$LN3@GetExterna:

; 673  :             {
; 674  :                 Log(LOG_DEBUG,__LINE__,"-- USB.GetExtHubName, new extHubNameW (%u) null",nBytes);

  000c8	8b 54 24 0c	 mov	 edx, DWORD PTR _nBytes$[esp+36]
  000cc	52		 push	 edx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@HJNGPFIB@?9?9?5USB?4GetExtHubName?0?5new?5extHub@
  000d2	68 a2 02 00 00	 push	 674			; 000002a2H
  000d7	6a 10		 push	 16			; 00000010H
  000d9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000de	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GetExterna:

; 675  :             }
; 676  : 		}
; 677  : 	}
; 678  :     Log(LOG_DEBUG,__LINE__,"<< USB.GetExternHub, HubName %X",extHubNameA);

  000e1	8b 74 24 10	 mov	 esi, DWORD PTR _extHubNameA$[esp+36]
  000e5	56		 push	 esi
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@PKLCHKGO@?$DM?$DM?5USB?4GetExternHub?0?5HubName?5?$CFX?$AA@
  000eb	68 a6 02 00 00	 push	 678			; 000002a6H
  000f0	6a 10		 push	 16			; 00000010H
  000f2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 679  : 	return extHubNameA;
; 680  : }

  000f7	8b 4c 24 30	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+52]
  000fb	83 c4 10	 add	 esp, 16			; 00000010H
  000fe	8b c6		 mov	 eax, esi
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5b		 pop	 ebx
  00103	33 cc		 xor	 ecx, esp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	83 c4 18	 add	 esp, 24			; 00000018H
  0010d	c3		 ret	 0
?GetExternalHubName@USB@@IAEPADPAXK@Z ENDP		; USB::GetExternalHubName
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetDriverKeyName@USB@@IAEPADPAXK@Z		; USB::GetDriverKeyName
; Function compile flags: /Ogtpy
;	COMDAT ?GetDriverKeyName@USB@@IAEPADPAXK@Z
_TEXT	SEGMENT
_nBytes$ = -24						; size = 4
_driverKeyNameA$ = -20					; size = 4
_driverKeyName$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?GetDriverKeyName@USB@@IAEPADPAXK@Z PROC		; USB::GetDriverKeyName, COMDAT
; _Hub$ = edi
; _ConnectionIndex$ = ecx

; 544  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax
  0000e	53		 push	 ebx
  0000f	55		 push	 ebp
  00010	56		 push	 esi

; 545  :     BOOL                                success;
; 546  :     ULONG                               nBytes = 0;
; 547  :     USB_NODE_CONNECTION_DRIVERKEY_NAME  driverKeyName;
; 548  :     PUSB_NODE_CONNECTION_DRIVERKEY_NAME driverKeyNameW = NULL;
; 549  :     PCHAR                               driverKeyNameA = NULL;
; 550  : 
; 551  :     Log(LOG_DEBUG,__LINE__,">> USB.GetDrvKeyName");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GLJHIDAC@?$DO?$DO?5USB?4GetDrvKeyName?$AA@
  00016	33 f6		 xor	 esi, esi
  00018	68 27 02 00 00	 push	 551			; 00000227H
  0001d	6a 10		 push	 16			; 00000010H
  0001f	8b d9		 mov	 ebx, ecx
  00021	89 74 24 18	 mov	 DWORD PTR _nBytes$[esp+48], esi
  00025	89 74 24 1c	 mov	 DWORD PTR _driverKeyNameA$[esp+48], esi
  00029	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 552  : 
; 553  :     // Get the length of the name of the driver key of the device attached to
; 554  :     // the specified port.
; 555  :     //
; 556  : 	memset (&driverKeyName, 0, sizeof(driverKeyName));
; 557  :     driverKeyName.ConnectionIndex = ConnectionIndex;
; 558  : 
; 559  :     success = DeviceIoControl(Hub,
; 560  :                               IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,
; 561  :                               &driverKeyName,
; 562  :                               sizeof(driverKeyName),
; 563  :                               &driverKeyName,
; 564  :                               sizeof(driverKeyName),
; 565  :                               &nBytes,
; 566  :                               NULL);

  0002e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__DeviceIoControl@32
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	33 c0		 xor	 eax, eax
  00039	56		 push	 esi
  0003a	89 44 24 18	 mov	 DWORD PTR _driverKeyName$[esp+40], eax
  0003e	89 44 24 1c	 mov	 DWORD PTR _driverKeyName$[esp+44], eax
  00042	66 89 44 24 20	 mov	 WORD PTR _driverKeyName$[esp+48], ax
  00047	8d 44 24 10	 lea	 eax, DWORD PTR _nBytes$[esp+40]
  0004b	50		 push	 eax
  0004c	6a 0a		 push	 10			; 0000000aH
  0004e	8d 4c 24 20	 lea	 ecx, DWORD PTR _driverKeyName$[esp+48]
  00052	51		 push	 ecx
  00053	6a 0a		 push	 10			; 0000000aH
  00055	8b d1		 mov	 edx, ecx
  00057	52		 push	 edx
  00058	68 20 04 22 00	 push	 2229280			; 00220420H
  0005d	57		 push	 edi
  0005e	89 5c 24 34	 mov	 DWORD PTR _driverKeyName$[esp+68], ebx
  00062	ff d5		 call	 ebp

; 567  : 
; 568  :     if (success)

  00064	85 c0		 test	 eax, eax
  00066	74 79		 je	 SHORT $LN1@GetDriverK

; 569  :     {
; 570  : 		// Allocate space to hold the driver key name
; 571  : 		//
; 572  : 		nBytes = driverKeyName.ActualLength;

  00068	8b 44 24 18	 mov	 eax, DWORD PTR _driverKeyName$[esp+40]
  0006c	89 44 24 0c	 mov	 DWORD PTR _nBytes$[esp+36], eax

; 573  : 
; 574  : 		if (nBytes > sizeof(driverKeyName))

  00070	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00073	76 6c		 jbe	 SHORT $LN1@GetDriverK

; 575  : 		{
; 576  : 			driverKeyNameW = (struct _USB_NODE_CONNECTION_DRIVERKEY_NAME *)malloc(nBytes);

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _malloc
  0007b	8b f0		 mov	 esi, eax
  0007d	83 c4 04	 add	 esp, 4

; 577  :             if(driverKeyNameW)

  00080	85 f6		 test	 esi, esi
  00082	74 44		 je	 SHORT $LN3@GetDriverK

; 578  :             {
; 579  :                 memset(driverKeyNameW,0x00,nBytes);

  00084	8b 44 24 0c	 mov	 eax, DWORD PTR _nBytes$[esp+36]
  00088	50		 push	 eax
  00089	6a 00		 push	 0
  0008b	56		 push	 esi
  0008c	e8 00 00 00 00	 call	 _memset
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 580  : 
; 581  : 			    // Get the name of the driver key of the device attached to
; 582  : 			    // the specified port.
; 583  : 			    //
; 584  : 			    driverKeyNameW->ConnectionIndex = ConnectionIndex;
; 585  : 
; 586  : 			    success = DeviceIoControl(Hub,
; 587  : 									      IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME,
; 588  : 									      driverKeyNameW,
; 589  : 									      nBytes,
; 590  : 									      driverKeyNameW,
; 591  : 									      nBytes,
; 592  : 									      &nBytes,
; 593  : 									      NULL);

  00094	6a 00		 push	 0
  00096	8d 4c 24 10	 lea	 ecx, DWORD PTR _nBytes$[esp+40]
  0009a	51		 push	 ecx
  0009b	89 1e		 mov	 DWORD PTR [esi], ebx
  0009d	8b 44 24 14	 mov	 eax, DWORD PTR _nBytes$[esp+44]
  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	68 20 04 22 00	 push	 2229280			; 00220420H
  000aa	57		 push	 edi
  000ab	ff d5		 call	 ebp

; 594  : 
; 595  : 			    if (success)

  000ad	85 c0		 test	 eax, eax
  000af	74 0c		 je	 SHORT $LN2@GetDriverK

; 596  : 			    {
; 597  : 				    // Convert the driver key name
; 598  : 				    //
; 599  : 				    driverKeyNameA = WideStrToMultiStr(driverKeyNameW->DriverKeyName);

  000b1	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  000b4	e8 00 00 00 00	 call	 ?WideStrToMultiStr@@YAPADPA_W@Z ; WideStrToMultiStr
  000b9	89 44 24 10	 mov	 DWORD PTR _driverKeyNameA$[esp+36], eax
$LN2@GetDriverK:

; 600  : 			    }
; 601  : 			    free(driverKeyNameW);

  000bd	56		 push	 esi
  000be	e8 00 00 00 00	 call	 _free
  000c3	83 c4 04	 add	 esp, 4

; 602  :             }
; 603  :             else

  000c6	eb 19		 jmp	 SHORT $LN1@GetDriverK
$LN3@GetDriverK:

; 604  :             {
; 605  :                 Log(LOG_DEBUG,__LINE__,"-- USB.GetDriverKeyName, new KeyNameW (%u) null",nBytes);

  000c8	8b 54 24 0c	 mov	 edx, DWORD PTR _nBytes$[esp+36]
  000cc	52		 push	 edx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OGKODAJE@?9?9?5USB?4GetDriverKeyName?0?5new?5Key@
  000d2	68 5d 02 00 00	 push	 605			; 0000025dH
  000d7	6a 10		 push	 16			; 00000010H
  000d9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000de	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@GetDriverK:

; 606  :             }
; 607  : 		}
; 608  : 	}
; 609  :     Log(LOG_DEBUG,__LINE__,"<< USB.GetDrvKeyName, AName %X",driverKeyNameA);

  000e1	8b 74 24 10	 mov	 esi, DWORD PTR _driverKeyNameA$[esp+36]
  000e5	56		 push	 esi
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IAFNNICI@?$DM?$DM?5USB?4GetDrvKeyName?0?5AName?5?$CFX?$AA@
  000eb	68 61 02 00 00	 push	 609			; 00000261H
  000f0	6a 10		 push	 16			; 00000010H
  000f2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 610  : 	return driverKeyNameA;
; 611  : }

  000f7	8b 4c 24 30	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+52]
  000fb	83 c4 10	 add	 esp, 16			; 00000010H
  000fe	8b c6		 mov	 eax, esi
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5b		 pop	 ebx
  00103	33 cc		 xor	 ecx, esp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	83 c4 18	 add	 esp, 24			; 00000018H
  0010d	c3		 ret	 0
?GetDriverKeyName@USB@@IAEPADPAXK@Z ENDP		; USB::GetDriverKeyName
_TEXT	ENDS
PUBLIC	?AreThereStringDescriptors@USB@@IAEHPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z ; USB::AreThereStringDescriptors
; Function compile flags: /Ogtpy
;	COMDAT ?AreThereStringDescriptors@USB@@IAEHPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z
_TEXT	SEGMENT
?AreThereStringDescriptors@USB@@IAEHPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z PROC ; USB::AreThereStringDescriptors, COMDAT
; _DeviceDesc$ = eax
; _ConfigDesc$ = edi

; 350  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 351  :     PUCHAR descEnd = NULL;
; 352  : //    PUSB_COMMON_DESCRIPTOR commonDesc = NULL;
; 353  :     PUCHAR commonDesc = NULL;
; 354  : 
; 355  :     Log(LOG_DEBUG,__LINE__,">> USB.AreThrStrDesc");

  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IPAKKGGO@?$DO?$DO?5USB?4AreThrStrDesc?$AA@
  00007	68 63 01 00 00	 push	 355			; 00000163H
  0000c	6a 10		 push	 16			; 00000010H
  0000e	8b f0		 mov	 esi, eax
  00010	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 356  : 
; 357  :     //
; 358  :     // Check Device Descriptor strings
; 359  :     //
; 360  :     if (DeviceDesc->iManufacturer || DeviceDesc->iProduct || DeviceDesc->iSerialNumber)

  00015	8a 46 0e	 mov	 al, BYTE PTR [esi+14]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	84 c0		 test	 al, al
  0001d	0f 85 b4 00 00
	00		 jne	 $LN12@AreThereSt
  00023	38 46 0f	 cmp	 BYTE PTR [esi+15], al
  00026	0f 85 ab 00 00
	00		 jne	 $LN12@AreThereSt
  0002c	38 46 10	 cmp	 BYTE PTR [esi+16], al
  0002f	0f 85 a2 00 00
	00		 jne	 $LN12@AreThereSt

; 363  :         return TRUE;
; 364  :     }
; 365  : 
; 366  :     //
; 367  :     // Check the Configuration and Interface Descriptor strings
; 368  :     //
; 369  :     descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

  00035	0f b7 5f 02	 movzx	 ebx, WORD PTR [edi+2]
  00039	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  0003c	03 df		 add	 ebx, edi

; 370  : 
; 371  : //    (USB_COMMON_DESCRIPTOR far *)commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;
; 372  :     commonDesc = (PUCHAR)ConfigDesc;

  0003e	8b c7		 mov	 eax, edi

; 373  : 
; 374  :     while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
; 375  :            (PUCHAR)commonDesc + ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength <= descEnd)

  00040	3b cb		 cmp	 ecx, ebx
  00042	73 59		 jae	 SHORT $LN10@AreThereSt
$LL11@AreThereSt:
  00044	8a 10		 mov	 dl, BYTE PTR [eax]
  00046	0f b6 ca	 movzx	 ecx, dl
  00049	8d 34 01	 lea	 esi, DWORD PTR [ecx+eax]
  0004c	3b f3		 cmp	 esi, ebx
  0004e	77 4d		 ja	 SHORT $LN10@AreThereSt

; 376  :     {
; 377  :         switch (((PUSB_COMMON_DESCRIPTOR)commonDesc)->bDescriptorType)

  00050	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00054	83 e9 02	 sub	 ecx, 2
  00057	74 30		 je	 SHORT $LN7@AreThereSt
  00059	83 e9 02	 sub	 ecx, 2

; 402  :                     return TRUE;
; 403  :                 }
; 404  :                 (PUCHAR)commonDesc += ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength;
; 405  :                 continue;
; 406  : 
; 407  :             default:
; 408  :                 (PUCHAR)commonDesc += ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength;
; 409  :                 continue;

  0005c	75 36		 jne	 SHORT $LN24@AreThereSt

; 390  :                 continue;
; 391  : 
; 392  :             case USB_INTERFACE_DESCRIPTOR_TYPE:
; 393  : //                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR) &&
; 394  : //                    commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR2))
; 395  :                 if (((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))

  0005e	80 fa 09	 cmp	 dl, 9
  00061	75 3a		 jne	 SHORT $LN10@AreThereSt

; 396  :                 {
; 397  :                     break;
; 398  :                 }
; 399  :                 if (((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->iInterface)

  00063	38 48 08	 cmp	 BYTE PTR [eax+8], cl
  00066	74 2c		 je	 SHORT $LN24@AreThereSt

; 400  :                 {
; 401  :                     Log(LOG_DEBUG,__LINE__,"<< USB.AreThrStrDesc, Interface %d",(int)((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->iInterface);

  00068	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0006c	50		 push	 eax
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NAENOJMA@?$DM?$DM?5USB?4AreThrStrDesc?0?5Interface?5@
  00072	68 91 01 00 00	 push	 401			; 00000191H
  00077	6a 10		 push	 16			; 00000010H
  00079	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
  00081	b8 01 00 00 00	 mov	 eax, 1

; 416  : }

  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	c3		 ret	 0
$LN7@AreThereSt:

; 378  :         {
; 379  :             case USB_CONFIGURATION_DESCRIPTOR_TYPE:
; 380  :                 if (((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))

  00089	80 fa 09	 cmp	 dl, 9
  0008c	75 0f		 jne	 SHORT $LN10@AreThereSt

; 381  :                 {
; 382  :                     break;
; 383  :                 }
; 384  :                 if (((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc)->iConfiguration)

  0008e	80 78 06 00	 cmp	 BYTE PTR [eax+6], 0
  00092	75 22		 jne	 SHORT $LN22@AreThereSt
$LN24@AreThereSt:

; 387  :                     return TRUE;
; 388  :                 }
; 389  :                 (PUCHAR)commonDesc += ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength;

  00094	8b c6		 mov	 eax, esi
  00096	8d 50 02	 lea	 edx, DWORD PTR [eax+2]
  00099	3b d3		 cmp	 edx, ebx
  0009b	72 a7		 jb	 SHORT $LL11@AreThereSt
$LN10@AreThereSt:

; 410  :         }
; 411  :         break;
; 412  :     }
; 413  : 
; 414  :     Log(LOG_DEBUG,__LINE__,"<< USB.AreThrStrDesc, Ret False");

  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JFAJNON@?$DM?$DM?5USB?4AreThrStrDesc?0?5Ret?5False?$AA@
  000a2	68 9e 01 00 00	 push	 414			; 0000019eH
  000a7	6a 10		 push	 16			; 00000010H
  000a9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  :     return FALSE;

  000b1	33 c0		 xor	 eax, eax

; 416  : }

  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	c3		 ret	 0
$LN22@AreThereSt:

; 385  :                 {
; 386  :                     Log(LOG_DEBUG,__LINE__,"<< USB.AreThrStrDesc, Cfg %d",(int)((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc)->iConfiguration);

  000b6	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  000ba	51		 push	 ecx
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@DEJJKGAD@?$DM?$DM?5USB?4AreThrStrDesc?0?5Cfg?5?$CFd?$AA@
  000c0	68 82 01 00 00	 push	 386			; 00000182H
  000c5	6a 10		 push	 16			; 00000010H
  000c7	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000cc	83 c4 10	 add	 esp, 16			; 00000010H
  000cf	b8 01 00 00 00	 mov	 eax, 1

; 416  : }

  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	c3		 ret	 0
$LN12@AreThereSt:

; 361  :     {
; 362  :         Log(LOG_DEBUG,__LINE__,"<< USB.AreThrStrDesc, Manufact %d, Prod %d, SN %d",(int)DeviceDesc->iManufacturer,(int)DeviceDesc->iProduct,(int)DeviceDesc->iSerialNumber);

  000d7	0f b6 56 10	 movzx	 edx, BYTE PTR [esi+16]
  000db	0f b6 4e 0f	 movzx	 ecx, BYTE PTR [esi+15]
  000df	52		 push	 edx
  000e0	51		 push	 ecx
  000e1	0f b6 d0	 movzx	 edx, al
  000e4	52		 push	 edx
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KIEGOLFL@?$DM?$DM?5USB?4AreThrStrDesc?0?5Manufact?5?$CF@
  000ea	68 6a 01 00 00	 push	 362			; 0000016aH
  000ef	6a 10		 push	 16			; 00000010H
  000f1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000f6	83 c4 18	 add	 esp, 24			; 00000018H

; 416  : }

  000f9	5e		 pop	 esi
  000fa	b8 01 00 00 00	 mov	 eax, 1
  000ff	5b		 pop	 ebx
  00100	c3		 ret	 0
?AreThereStringDescriptors@USB@@IAEHPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z ENDP ; USB::AreThereStringDescriptors
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetStringDescriptor@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEG@Z ; USB::GetStringDescriptor
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetStringDescriptor@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEG@Z
_TEXT	SEGMENT
_nBytesReturned$ = -1312				; size = 4
_stringDescReqBuf$ = -1308				; size = 267
_szLastError$136249 = -1036				; size = 1024
__$ArrayPad$ = -8					; size = 4
_ConnectionIndex$ = 8					; size = 4
_DescriptorIndex$ = 12					; size = 1
?GetStringDescriptor@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEG@Z PROC ; USB::GetStringDescriptor, COMDAT
; _hHubDevice$ = edx
; _LanguageID$ = ecx

; 210  : {

  00000	81 ec 24 05 00
	00		 sub	 esp, 1316		; 00000524H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 1c 05
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1316], eax
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	56		 push	 esi
  00017	57		 push	 edi

; 211  :     BOOL    success;
; 212  :     ULONG   nBytes = 0;
; 213  :     ULONG   nBytesReturned = 0;
; 214  : 
; 215  : 	Log(LOG_DEBUG,__LINE__,">> USB.GetStrDesc");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OBKJMAF@?$DO?$DO?5USB?4GetStrDesc?$AA@
  0001d	68 d7 00 00 00	 push	 215			; 000000d7H
  00022	6a 10		 push	 16			; 00000010H
  00024	66 8b d9	 mov	 bx, cx
  00027	8b f2		 mov	 esi, edx
  00029	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _nBytesReturned$[esp+1344], 0
  00031	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 216  : 
; 217  :     UCHAR   stringDescReqBuf[sizeof(USB_DESCRIPTOR_REQUEST) + MAXIMUM_USB_STRING_LENGTH];
; 218  : 
; 219  :     PUSB_DESCRIPTOR_REQUEST stringDescReq = NULL;
; 220  :     PUSB_STRING_DESCRIPTOR  stringDesc = NULL;
; 221  :     PSTRING_DESCRIPTOR_NODE stringDescNode = NULL;
; 222  : 
; 223  :     nBytes = sizeof(stringDescReqBuf);
; 224  : 
; 225  :     stringDescReq = (PUSB_DESCRIPTOR_REQUEST)stringDescReqBuf;
; 226  :     stringDesc = (PUSB_STRING_DESCRIPTOR)(stringDescReq+1);
; 227  : 
; 228  :     // Zero fill the entire request structure
; 229  :     //
; 230  :     memset(stringDescReq, 0, nBytes);

  00036	68 0b 01 00 00	 push	 267			; 0000010bH
  0003b	8d 44 24 28	 lea	 eax, DWORD PTR _stringDescReqBuf$[esp+1348]
  0003f	6a 00		 push	 0
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _memset

; 231  : 
; 232  :     // Indicate the port from which the descriptor will be requested
; 233  :     //
; 234  :     stringDescReq->ConnectionIndex = ConnectionIndex;
; 235  : 
; 236  :     //
; 237  :     // USBHUB uses URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE to process this
; 238  :     // IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION request.
; 239  :     //
; 240  :     // USBD will automatically initialize these fields:
; 241  :     //     bmRequest = 0x80
; 242  :     //     bRequest  = 0x06
; 243  :     //
; 244  :     // We must inititialize these fields:
; 245  :     //     wValue    = Descriptor Type (high) and Descriptor Index (low byte)
; 246  :     //     wIndex    = Zero (or Language ID for String Descriptors)
; 247  :     //     wLength   = Length of descriptor buffer
; 248  :     //
; 249  :     stringDescReq->SetupPacket.wValue = (USB_STRING_DESCRIPTOR_TYPE << 8)
; 250  :                                         | DescriptorIndex;

  00047	66 0f b6 94 24
	54 05 00 00	 movzx	 dx, BYTE PTR _DescriptorIndex$[esp+1352]
  00050	8b 8c 24 50 05
	00 00		 mov	 ecx, DWORD PTR _ConnectionIndex$[esp+1352]
  00057	83 c4 18	 add	 esp, 24			; 00000018H

; 251  : 
; 252  :     stringDescReq->SetupPacket.wIndex = LanguageID;
; 253  : 
; 254  :     stringDescReq->SetupPacket.wLength = (USHORT)(nBytes - sizeof(USB_DESCRIPTOR_REQUEST));
; 255  : 
; 256  :     // Now issue the get descriptor request.
; 257  :     //
; 258  :     success = DeviceIoControl(hHubDevice,
; 259  :                               IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,
; 260  :                               stringDescReq,
; 261  :                               nBytes,
; 262  :                               stringDescReq,
; 263  :                               nBytes,
; 264  :                               &nBytesReturned,
; 265  :                               NULL);

  0005a	6a 00		 push	 0
  0005c	b8 00 03 00 00	 mov	 eax, 768		; 00000300H
  00061	66 0b d0	 or	 dx, ax
  00064	66 89 54 24 22	 mov	 WORD PTR _stringDescReqBuf$[esp+1342], dx
  00069	8d 54 24 18	 lea	 edx, DWORD PTR _nBytesReturned$[esp+1336]
  0006d	52		 push	 edx
  0006e	68 0b 01 00 00	 push	 267			; 0000010bH
  00073	89 4c 24 24	 mov	 DWORD PTR _stringDescReqBuf$[esp+1344], ecx
  00077	8d 44 24 24	 lea	 eax, DWORD PTR _stringDescReqBuf$[esp+1344]
  0007b	50		 push	 eax
  0007c	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00081	68 0b 01 00 00	 push	 267			; 0000010bH
  00086	66 89 4c 24 36	 mov	 WORD PTR _stringDescReqBuf$[esp+1362], cx
  0008b	8b c8		 mov	 ecx, eax
  0008d	51		 push	 ecx
  0008e	68 10 04 22 00	 push	 2229264			; 00220410H
  00093	56		 push	 esi
  00094	66 89 5c 24 40	 mov	 WORD PTR _stringDescReqBuf$[esp+1372], bx
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 266  : 
; 267  :     //
; 268  :     // Do some sanity checks on the return from the get descriptor request.
; 269  :     //
; 270  : 
; 271  :     if (!success)

  0009f	85 c0		 test	 eax, eax
  000a1	75 1b		 jne	 SHORT $LN9@GetStringD

; 272  :     {
; 273  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, DeviceIoControl False");

  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MLNPNNOJ@?$DM?$DM?5USB?4GetStrDesc?0?5DeviceIoContr@
  000a8	68 11 01 00 00	 push	 273			; 00000111H
  000ad	6a 10		 push	 16			; 00000010H
  000af	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 274  :         return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	e9 c1 01 00 00	 jmp	 $LN10@GetStringD
$LN9@GetStringD:

; 275  :     }
; 276  : 
; 277  :     if (nBytesReturned < 2)

  000be	8b 44 24 14	 mov	 eax, DWORD PTR _nBytesReturned$[esp+1332]
  000c2	83 f8 02	 cmp	 eax, 2
  000c5	73 1c		 jae	 SHORT $LN8@GetStringD

; 278  :     {
; 279  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, Bytes Ret %u",nBytesReturned);

  000c7	50		 push	 eax
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JKPBCDKN@?$DM?$DM?5USB?4GetStrDesc?0?5Bytes?5Ret?5?$CFu?$AA@
  000cd	68 17 01 00 00	 push	 279			; 00000117H
  000d2	6a 10		 push	 16			; 00000010H
  000d4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 280  :         return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 9c 01 00 00	 jmp	 $LN10@GetStringD
$LN8@GetStringD:

; 281  :     }
; 282  : 
; 283  :     if (stringDesc->bDescriptorType != USB_STRING_DESCRIPTOR_TYPE)

  000e3	8a 4c 24 25	 mov	 cl, BYTE PTR _stringDescReqBuf$[esp+1345]
  000e7	80 f9 03	 cmp	 cl, 3
  000ea	74 1f		 je	 SHORT $LN7@GetStringD

; 284  :     {
; 285  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, Inv DescriptorTp %d",stringDesc->bDescriptorType);

  000ec	0f b6 d1	 movzx	 edx, cl
  000ef	52		 push	 edx
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@ELGGMNKC@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Descripto@
  000f5	68 1d 01 00 00	 push	 285			; 0000011dH
  000fa	6a 10		 push	 16			; 00000010H
  000fc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00101	83 c4 10	 add	 esp, 16			; 00000010H

; 286  :         return NULL;

  00104	33 c0		 xor	 eax, eax
  00106	e9 74 01 00 00	 jmp	 $LN10@GetStringD
$LN7@GetStringD:

; 287  :     }
; 288  : 
; 289  :     if (stringDesc->bLength != nBytesReturned - sizeof(USB_DESCRIPTOR_REQUEST))

  0010b	8d 48 f4	 lea	 ecx, DWORD PTR [eax-12]
  0010e	0f b6 44 24 24	 movzx	 eax, BYTE PTR _stringDescReqBuf$[esp+1344]
  00113	3b c1		 cmp	 eax, ecx
  00115	74 1d		 je	 SHORT $LN6@GetStringD

; 290  :     {
; 291  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, Inv Sz %d <> %d",(int)stringDesc->bLength,nBytesReturned - sizeof(USB_DESCRIPTOR_REQUEST));

  00117	51		 push	 ecx
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@CHKNKAPD@?$DM?$DM?5USB?4GetStrDesc?0?5Inv?5Sz?5?$CFd?5?$DM?$DO?5@
  0011e	68 23 01 00 00	 push	 291			; 00000123H
  00123	6a 10		 push	 16			; 00000010H
  00125	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0012a	83 c4 14	 add	 esp, 20			; 00000014H

; 292  :         return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	e9 4b 01 00 00	 jmp	 $LN10@GetStringD
$LN6@GetStringD:

; 293  :     }
; 294  : 
; 295  :     if (stringDesc->bLength % 2 != 0)

  00134	8b c8		 mov	 ecx, eax
  00136	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; 80000001H
  0013c	79 05		 jns	 SHORT $LN12@GetStringD
  0013e	49		 dec	 ecx
  0013f	83 c9 fe	 or	 ecx, -2			; fffffffeH
  00142	41		 inc	 ecx
$LN12@GetStringD:
  00143	74 1c		 je	 SHORT $LN5@GetStringD

; 296  :     {
; 297  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, Odd Sz %d",(int)stringDesc->bLength);

  00145	50		 push	 eax
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@ILBIFDNN@?$DM?$DM?5USB?4GetStrDesc?0?5Odd?5Sz?5?$CFd?$AA@
  0014b	68 29 01 00 00	 push	 297			; 00000129H
  00150	6a 10		 push	 16			; 00000010H
  00152	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00157	83 c4 10	 add	 esp, 16			; 00000010H

; 298  :         return NULL;

  0015a	33 c0		 xor	 eax, eax
  0015c	e9 1e 01 00 00	 jmp	 $LN10@GetStringD
$LN5@GetStringD:

; 299  :     }
; 300  : 
; 301  :     //
; 302  :     // Looks good, allocate some (zero filled) space for the string descriptor
; 303  :     // node and copy the string descriptor to it.
; 304  :     //
; 305  : 
; 306  :     stringDescNode = (PSTRING_DESCRIPTOR_NODE)malloc(sizeof(STRING_DESCRIPTOR_NODE)+stringDesc->bLength);

  00161	83 c0 08	 add	 eax, 8
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _malloc
  0016a	8b f8		 mov	 edi, eax
  0016c	83 c4 04	 add	 esp, 4

; 307  : 
; 308  :     if (stringDescNode == NULL)

  0016f	85 ff		 test	 edi, edi
  00171	75 1b		 jne	 SHORT $LN4@GetStringD

; 309  :     {
; 310  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, new DescNode null");

  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BKJLPKEL@?$DM?$DM?5USB?4GetStrDesc?0?5new?5DescNode?5@
  00178	68 36 01 00 00	 push	 310			; 00000136H
  0017d	6a 10		 push	 16			; 00000010H
  0017f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 311  :         return NULL;

  00187	33 c0		 xor	 eax, eax
  00189	e9 f1 00 00 00	 jmp	 $LN10@GetStringD
$LN4@GetStringD:

; 312  :     }
; 313  : 
; 314  :     memset(stringDescNode,0x00,sizeof(STRING_DESCRIPTOR_NODE)+stringDesc->bLength);

  0018e	0f b6 54 24 24	 movzx	 edx, BYTE PTR _stringDescReqBuf$[esp+1344]
  00193	83 c2 08	 add	 edx, 8
  00196	52		 push	 edx
  00197	6a 00		 push	 0
  00199	57		 push	 edi
  0019a	e8 00 00 00 00	 call	 _memset

; 315  : 
; 316  :     stringDescNode->DescriptorIndex = DescriptorIndex;

  0019f	8a 84 24 48 05
	00 00		 mov	 al, BYTE PTR _DescriptorIndex$[esp+1340]
  001a6	88 47 04	 mov	 BYTE PTR [edi+4], al

; 317  :     stringDescNode->LanguageID = LanguageID;

  001a9	66 89 5f 06	 mov	 WORD PTR [edi+6], bx

; 318  : 
; 319  :     memcpy(stringDescNode->StringDescriptor,stringDesc,stringDesc->bLength);

  001ad	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR _stringDescReqBuf$[esp+1356]
  001b2	51		 push	 ecx
  001b3	8d 54 24 34	 lea	 edx, DWORD PTR _stringDescReqBuf$[esp+1360]
  001b7	52		 push	 edx
  001b8	8d 6f 08	 lea	 ebp, DWORD PTR [edi+8]
  001bb	55		 push	 ebp
  001bc	e8 00 00 00 00	 call	 _memcpy
  001c1	83 c4 18	 add	 esp, 24			; 00000018H

; 320  : 
; 321  : 	if(LanguageID)

  001c4	66 85 db	 test	 bx, bx
  001c7	0f 84 9b 00 00
	00		 je	 $LN1@GetStringD

; 322  : 	{
; 323  : 		nBytes = WideCharToMultiByte(
; 324  : 					CP_ACP,     // CodePage
; 325  : 					0,          // CodePage
; 326  : 					stringDescNode->StringDescriptor->bString,
; 327  : 					(stringDescNode->StringDescriptor->bLength - 2) / 2,
; 328  : 					(char *)stringDescReqBuf,
; 329  : 					sizeof(USB_DESCRIPTOR_REQUEST) + MAXIMUM_USB_STRING_LENGTH,
; 330  : 					NULL,       // lpDefaultChar
; 331  : 					NULL);      // pUsedDefaultChar

  001cd	6a 00		 push	 0
  001cf	6a 00		 push	 0
  001d1	68 0b 01 00 00	 push	 267			; 0000010bH
  001d6	8d 44 24 24	 lea	 eax, DWORD PTR _stringDescReqBuf$[esp+1344]
  001da	50		 push	 eax
  001db	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  001df	83 e8 02	 sub	 eax, 2
  001e2	99		 cdq
  001e3	2b c2		 sub	 eax, edx
  001e5	d1 f8		 sar	 eax, 1
  001e7	50		 push	 eax
  001e8	8d 77 0a	 lea	 esi, DWORD PTR [edi+10]
  001eb	56		 push	 esi
  001ec	6a 00		 push	 0
  001ee	6a 00		 push	 0
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  001f6	8b d8		 mov	 ebx, eax

; 332  : 		if (!nBytes)

  001f8	85 db		 test	 ebx, ebx
  001fa	75 4d		 jne	 SHORT $LN2@GetStringD

; 333  :         {
; 334  :             char szLastError[1024] = {0};

  001fc	68 ff 03 00 00	 push	 1023			; 000003ffH
  00201	50		 push	 eax
  00202	8d 8c 24 31 01
	00 00		 lea	 ecx, DWORD PTR _szLastError$136249[esp+1341]
  00209	51		 push	 ecx
  0020a	88 84 24 34 01
	00 00		 mov	 BYTE PTR _szLastError$136249[esp+1344], al
  00211	e8 00 00 00 00	 call	 _memset
  00216	83 c4 0c	 add	 esp, 12			; 0000000cH

; 335  :             DWORD dwLastError = GetLastError();

  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0021f	8b d8		 mov	 ebx, eax

; 336  :             GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  00221	68 00 04 00 00	 push	 1024			; 00000400H
  00226	8d b4 24 2c 01
	00 00		 lea	 esi, DWORD PTR _szLastError$136249[esp+1336]
  0022d	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage

; 337  :             Log(LOG_DEBUG,__LINE__,"-- USB.GetStrDesc, WideCharToMultiByte failed %u, %s",dwLastError,szLastError);

  00232	8b d6		 mov	 edx, esi
  00234	52		 push	 edx
  00235	53		 push	 ebx
  00236	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@ICOPDODD@?9?9?5USB?4GetStrDesc?0?5WideCharToMul@
  0023b	68 51 01 00 00	 push	 337			; 00000151H
  00240	6a 10		 push	 16			; 00000010H
  00242	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 338  :         }
; 339  : 		else 

  00247	eb 1c		 jmp	 SHORT $LN13@GetStringD
$LN2@GetStringD:

; 340  : 		{
; 341  : 			memset(stringDescNode->StringDescriptor->bString, 0x00, (stringDescNode->StringDescriptor->bLength - 2));

  00249	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  0024d	83 e8 02	 sub	 eax, 2
  00250	50		 push	 eax
  00251	6a 00		 push	 0
  00253	56		 push	 esi
  00254	e8 00 00 00 00	 call	 _memset

; 342  : 			memcpy(stringDescNode->StringDescriptor->bString, stringDescReqBuf, nBytes);

  00259	53		 push	 ebx
  0025a	8d 4c 24 28	 lea	 ecx, DWORD PTR _stringDescReqBuf$[esp+1348]
  0025e	51		 push	 ecx
  0025f	56		 push	 esi
  00260	e8 00 00 00 00	 call	 _memcpy
$LN13@GetStringD:
  00265	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@GetStringD:

; 343  : 		}
; 344  : 	}
; 345  :     Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDesc, DescNode %X",stringDescNode);

  00268	57		 push	 edi
  00269	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BCHFPFAE@?$DM?$DM?5USB?4GetStrDesc?0?5DescNode?5?$CFX?$AA@
  0026e	68 59 01 00 00	 push	 345			; 00000159H
  00273	6a 10		 push	 16			; 00000010H
  00275	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0027a	83 c4 10	 add	 esp, 16			; 00000010H

; 346  :     return stringDescNode;

  0027d	8b c7		 mov	 eax, edi
$LN10@GetStringD:

; 347  : }

  0027f	8b 8c 24 2c 05
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1332]
  00286	5f		 pop	 edi
  00287	5e		 pop	 esi
  00288	5d		 pop	 ebp
  00289	5b		 pop	 ebx
  0028a	33 cc		 xor	 ecx, esp
  0028c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00291	81 c4 24 05 00
	00		 add	 esp, 1316		; 00000524H
  00297	c2 08 00	 ret	 8
?GetStringDescriptor@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEG@Z ENDP ; USB::GetStringDescriptor
PUBLIC	?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z ; USB::GetStringDescriptors
; Function compile flags: /Ogtpy
;	COMDAT ?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z
_TEXT	SEGMENT
_hHubDevice$ = 8					; size = 4
_ConnectionIndex$ = 12					; size = 4
_DescriptorIndex$ = 16					; size = 1
?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z PROC ; USB::GetStringDescriptors, COMDAT
; _NumLanguageIDs$ = edx
; _LanguageIDs$ = ecx
; _StringDescNodeTail$ = eax

; 1304 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 14	 mov	 ebp, DWORD PTR _DescriptorIndex$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1305 :     ULONG i;
; 1306 : 
; 1307 :     Log(LOG_DEBUG,__LINE__,">> USB.GetStrDescs");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HEHGMECG@?$DO?$DO?5USB?4GetStrDescs?$AA@
  0000d	68 1b 05 00 00	 push	 1307			; 0000051bH
  00012	6a 10		 push	 16			; 00000010H
  00014	8b f8		 mov	 edi, eax
  00016	8b f1		 mov	 esi, ecx
  00018	8b da		 mov	 ebx, edx
  0001a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1308 : 
; 1309 :     for (i=0; i<NumLanguageIDs; i++)

  00022	85 db		 test	 ebx, ebx
  00024	76 2c		 jbe	 SHORT $LN2@GetStringD@2
  00026	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL4@GetStringD@2:

; 1310 :     {
; 1311 :         StringDescNodeTail->Next = GetStringDescriptor(hHubDevice,
; 1312 :                                                        ConnectionIndex,
; 1313 :                                                        DescriptorIndex,
; 1314 :                                                        *LanguageIDs);

  00030	8b 44 24 18	 mov	 eax, DWORD PTR _ConnectionIndex$[esp+12]
  00034	66 8b 0e	 mov	 cx, WORD PTR [esi]
  00037	8b 54 24 14	 mov	 edx, DWORD PTR _hHubDevice$[esp+12]
  0003b	55		 push	 ebp
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?GetStringDescriptor@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEG@Z ; USB::GetStringDescriptor
  00042	89 07		 mov	 DWORD PTR [edi], eax

; 1315 : 
; 1316 :         if (StringDescNodeTail->Next)

  00044	85 c0		 test	 eax, eax
  00046	74 02		 je	 SHORT $LN1@GetStringD@2

; 1317 :         {
; 1318 :             StringDescNodeTail = StringDescNodeTail->Next;

  00048	8b f8		 mov	 edi, eax
$LN1@GetStringD@2:

; 1319 :         }
; 1320 : 
; 1321 :         LanguageIDs++;

  0004a	83 c6 02	 add	 esi, 2
  0004d	83 eb 01	 sub	 ebx, 1
  00050	75 de		 jne	 SHORT $LL4@GetStringD@2
$LN2@GetStringD@2:

; 1322 :     }
; 1323 : 
; 1324 :     Log(LOG_DEBUG,__LINE__,"<< USB.GetStrDescs, StrDescNodeTail %X",StringDescNodeTail);

  00052	57		 push	 edi
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@BBKGOLN@?$DM?$DM?5USB?4GetStrDescs?0?5StrDescNodeT@
  00058	68 2c 05 00 00	 push	 1324			; 0000052cH
  0005d	6a 10		 push	 16			; 00000010H
  0005f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00064	83 c4 10	 add	 esp, 16			; 00000010H

; 1325 :     return StringDescNodeTail;

  00067	8b c7		 mov	 eax, edi

; 1326 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5d		 pop	 ebp
  0006c	5b		 pop	 ebx
  0006d	c2 0c 00	 ret	 12			; 0000000cH
?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z ENDP ; USB::GetStringDescriptors
_TEXT	ENDS
PUBLIC	?GetAllStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z ; USB::GetAllStringDescriptors
; Function compile flags: /Ogtpy
;	COMDAT ?GetAllStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z
_TEXT	SEGMENT
_supportedLanguagesString$ = -4				; size = 4
_hHubDevice$ = 8					; size = 4
tv254 = 12						; size = 4
_ConnectionIndex$ = 12					; size = 4
_descEnd$ = 16						; size = 4
_DeviceDesc$ = 16					; size = 4
_ConfigDesc$ = 20					; size = 4
?GetAllStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z PROC ; USB::GetAllStringDescriptors, COMDAT

; 419  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	8b 6c 24 14	 mov	 ebp, DWORD PTR _ConnectionIndex$[esp+8]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 420  :     PSTRING_DESCRIPTOR_NODE supportedLanguagesString = NULL;
; 421  :     PSTRING_DESCRIPTOR_NODE stringDescNodeTail = NULL;
; 422  :     ULONG                   numLanguageIDs = 0;
; 423  :     USHORT                  *languageIDs = NULL;
; 424  : 
; 425  :     PUCHAR                  descEnd = NULL;
; 426  : //    PUSB_COMMON_DESCRIPTOR  commonDesc = NULL;
; 427  :     PUCHAR  commonDesc = NULL;
; 428  : 
; 429  :     Log(LOG_DEBUG,__LINE__,">> USB.GetAllStrDescs");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PLIGAJPI@?$DO?$DO?5USB?4GetAllStrDescs?$AA@
  0000e	68 ad 01 00 00	 push	 429			; 000001adH
  00013	6a 10		 push	 16			; 00000010H
  00015	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 430  : 
; 431  :     //
; 432  :     // Get the array of supported Language IDs, which is returned
; 433  :     // in String Descriptor 0
; 434  :     //
; 435  :     supportedLanguagesString = GetStringDescriptor(hHubDevice,ConnectionIndex,0,0);

  0001a	8b 54 24 24	 mov	 edx, DWORD PTR _hHubDevice$[esp+28]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	6a 00		 push	 0
  00023	55		 push	 ebp
  00024	33 c9		 xor	 ecx, ecx
  00026	e8 00 00 00 00	 call	 ?GetStringDescriptor@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEG@Z ; USB::GetStringDescriptor
  0002b	8b f8		 mov	 edi, eax
  0002d	89 7c 24 10	 mov	 DWORD PTR _supportedLanguagesString$[esp+20], edi

; 436  :     if (supportedLanguagesString == NULL)

  00031	85 ff		 test	 edi, edi
  00033	75 1e		 jne	 SHORT $LN15@GetAllStri

; 437  :     {
; 438  :         Log(LOG_DEBUG,__LINE__,"<< USB.GetAllStrDescs, SuppLangsStr null");

  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HBMGBPGH@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@
  0003a	68 b6 01 00 00	 push	 438			; 000001b6H
  0003f	6a 10		 push	 16			; 00000010H
  00041	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 439  :         return NULL;

  00049	33 c0		 xor	 eax, eax

; 540  :     return supportedLanguagesString;
; 541  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	5b		 pop	 ebx
  0004f	59		 pop	 ecx
  00050	c2 10 00	 ret	 16			; 00000010H
$LN15@GetAllStri:

; 440  :     }
; 441  : 
; 442  :     numLanguageIDs = (supportedLanguagesString->StringDescriptor->bLength - 2) / 2;

  00053	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]

; 443  : 
; 444  :     languageIDs = (USHORT*)&supportedLanguagesString->StringDescriptor->bString[0];
; 445  : 
; 446  :     stringDescNodeTail = supportedLanguagesString;
; 447  : 
; 448  :     //
; 449  :     // Get the Device Descriptor strings
; 450  :     //
; 451  :     if (DeviceDesc->iManufacturer)

  00057	8b 4c 24 20	 mov	 ecx, DWORD PTR _DeviceDesc$[esp+16]
  0005b	0f b6 49 0e	 movzx	 ecx, BYTE PTR [ecx+14]
  0005f	83 e8 02	 sub	 eax, 2
  00062	99		 cdq
  00063	2b c2		 sub	 eax, edx
  00065	8b f0		 mov	 esi, eax
  00067	d1 fe		 sar	 esi, 1
  00069	8d 5f 0a	 lea	 ebx, DWORD PTR [edi+10]
  0006c	8b c7		 mov	 eax, edi
  0006e	84 c9		 test	 cl, cl
  00070	74 10		 je	 SHORT $LN14@GetAllStri

; 452  :     {
; 453  :         stringDescNodeTail = GetStringDescriptors(hHubDevice,
; 454  :                                                   ConnectionIndex,
; 455  :                                                   DeviceDesc->iManufacturer,
; 456  :                                                   numLanguageIDs,
; 457  :                                                   languageIDs,
; 458  :                                                   stringDescNodeTail);

  00072	8b 54 24 18	 mov	 edx, DWORD PTR _hHubDevice$[esp+16]
  00076	51		 push	 ecx
  00077	55		 push	 ebp
  00078	52		 push	 edx
  00079	8b cb		 mov	 ecx, ebx
  0007b	8b d6		 mov	 edx, esi
  0007d	e8 00 00 00 00	 call	 ?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z ; USB::GetStringDescriptors
$LN14@GetAllStri:

; 459  :     }
; 460  : 
; 461  :     if (DeviceDesc->iProduct)

  00082	8b 4c 24 20	 mov	 ecx, DWORD PTR _DeviceDesc$[esp+16]
  00086	0f b6 49 0f	 movzx	 ecx, BYTE PTR [ecx+15]
  0008a	84 c9		 test	 cl, cl
  0008c	74 10		 je	 SHORT $LN13@GetAllStri

; 462  :     {
; 463  :         stringDescNodeTail = GetStringDescriptors(hHubDevice,
; 464  :                                                   ConnectionIndex,
; 465  :                                                   DeviceDesc->iProduct,
; 466  :                                                   numLanguageIDs,
; 467  :                                                   languageIDs,
; 468  :                                                   stringDescNodeTail);

  0008e	8b 54 24 18	 mov	 edx, DWORD PTR _hHubDevice$[esp+16]
  00092	51		 push	 ecx
  00093	55		 push	 ebp
  00094	52		 push	 edx
  00095	8b cb		 mov	 ecx, ebx
  00097	8b d6		 mov	 edx, esi
  00099	e8 00 00 00 00	 call	 ?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z ; USB::GetStringDescriptors
$LN13@GetAllStri:

; 469  :     }
; 470  : 
; 471  :     if (DeviceDesc->iSerialNumber)

  0009e	8b 4c 24 20	 mov	 ecx, DWORD PTR _DeviceDesc$[esp+16]
  000a2	0f b6 49 10	 movzx	 ecx, BYTE PTR [ecx+16]
  000a6	84 c9		 test	 cl, cl
  000a8	74 10		 je	 SHORT $LN12@GetAllStri

; 472  :     {
; 473  :         stringDescNodeTail = GetStringDescriptors(hHubDevice,
; 474  :                                                   ConnectionIndex,
; 475  :                                                   DeviceDesc->iSerialNumber,
; 476  :                                                   numLanguageIDs,
; 477  :                                                   languageIDs,
; 478  :                                                   stringDescNodeTail);

  000aa	8b 54 24 18	 mov	 edx, DWORD PTR _hHubDevice$[esp+16]
  000ae	51		 push	 ecx
  000af	55		 push	 ebp
  000b0	52		 push	 edx
  000b1	8b cb		 mov	 ecx, ebx
  000b3	8b d6		 mov	 edx, esi
  000b5	e8 00 00 00 00	 call	 ?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z ; USB::GetStringDescriptors
$LN12@GetAllStri:

; 479  :     }
; 480  : 
; 481  : 
; 482  :     //
; 483  :     // Get the Configuration and Interface Descriptor strings
; 484  :     //
; 485  :     descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

  000ba	8b 7c 24 24	 mov	 edi, DWORD PTR _ConfigDesc$[esp+16]
  000be	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  000c2	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
  000c5	03 cf		 add	 ecx, edi
  000c7	89 4c 24 20	 mov	 DWORD PTR _descEnd$[esp+16], ecx

; 486  : //    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;
; 487  :     commonDesc = (PUCHAR)ConfigDesc;
; 488  : 
; 489  :     while ((DWORD)((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR)) < (DWORD)descEnd &&
; 490  :            (DWORD)((PUCHAR)commonDesc + ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength) <= (DWORD)descEnd)

  000cb	3b d1		 cmp	 edx, ecx
  000cd	73 5c		 jae	 SHORT $LN21@GetAllStri
  000cf	90		 npad	 1
$LL11@GetAllStri:
  000d0	8a 17		 mov	 dl, BYTE PTR [edi]
  000d2	0f b6 ca	 movzx	 ecx, dl
  000d5	03 cf		 add	 ecx, edi
  000d7	89 4c 24 1c	 mov	 DWORD PTR tv254[esp+16], ecx
  000db	3b 4c 24 20	 cmp	 ecx, DWORD PTR _descEnd$[esp+16]
  000df	77 4a		 ja	 SHORT $LN21@GetAllStri

; 491  :     {
; 492  :         switch (((PUSB_COMMON_DESCRIPTOR)commonDesc)->bDescriptorType)

  000e1	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  000e5	83 e9 02	 sub	 ecx, 2
  000e8	74 16		 je	 SHORT $LN7@GetAllStri
  000ea	83 e9 02	 sub	 ecx, 2
  000ed	74 06		 je	 SHORT $LN4@GetAllStri

; 531  : 
; 532  :             default:
; 533  :                 (PUCHAR)commonDesc += ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength;

  000ef	8b 7c 24 1c	 mov	 edi, DWORD PTR tv254[esp+16]

; 534  :                 continue;

  000f3	eb 2d		 jmp	 SHORT $LN23@GetAllStri
$LN4@GetAllStri:

; 510  :                 continue;
; 511  : 
; 512  :             case USB_INTERFACE_DESCRIPTOR_TYPE:
; 513  : //                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR) &&
; 514  : //                    commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR2))
; 515  :                 if (((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))

  000f5	80 fa 09	 cmp	 dl, 9
  000f8	75 31		 jne	 SHORT $LN21@GetAllStri

; 516  :                 {
; 517  :                     break;
; 518  :                 }
; 519  :                 if (((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->iInterface)

  000fa	0f b6 4f 08	 movzx	 ecx, BYTE PTR [edi+8]

; 520  :                 {
; 521  :                     stringDescNodeTail = GetStringDescriptors(
; 522  :                                              hHubDevice,
; 523  :                                              ConnectionIndex,
; 524  :                                              ((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->iInterface,
; 525  :                                              numLanguageIDs,
; 526  :                                              languageIDs,
; 527  :                                              stringDescNodeTail);
; 528  :                 }
; 529  :                 (PUCHAR)commonDesc += ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength;
; 530  :                 continue;

  000fe	eb 09		 jmp	 SHORT $LN28@GetAllStri
$LN7@GetAllStri:

; 493  :         {
; 494  :             case USB_CONFIGURATION_DESCRIPTOR_TYPE:
; 495  :                 if (((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))

  00100	80 fa 09	 cmp	 dl, 9
  00103	75 26		 jne	 SHORT $LN21@GetAllStri

; 496  :                 {
; 497  :                     break;
; 498  :                 }
; 499  :                 if (((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc)->iConfiguration)

  00105	0f b6 4f 06	 movzx	 ecx, BYTE PTR [edi+6]
$LN28@GetAllStri:
  00109	84 c9		 test	 cl, cl
  0010b	74 10		 je	 SHORT $LN5@GetAllStri

; 500  :                 {
; 501  :                     stringDescNodeTail = GetStringDescriptors(
; 502  :                                              hHubDevice,
; 503  :                                              ConnectionIndex,
; 504  :                                              ((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc)->iConfiguration,
; 505  :                                              numLanguageIDs,
; 506  :                                              languageIDs,
; 507  :                                              stringDescNodeTail);

  0010d	8b 54 24 18	 mov	 edx, DWORD PTR _hHubDevice$[esp+16]
  00111	51		 push	 ecx
  00112	55		 push	 ebp
  00113	52		 push	 edx
  00114	8b cb		 mov	 ecx, ebx
  00116	8b d6		 mov	 edx, esi
  00118	e8 00 00 00 00	 call	 ?GetStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKEKPAGPAU2@@Z ; USB::GetStringDescriptors
$LN5@GetAllStri:

; 508  :                 }
; 509  :                 (PUCHAR)commonDesc += ((PUSB_COMMON_DESCRIPTOR)commonDesc)->bLength;

  0011d	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00120	03 f9		 add	 edi, ecx
$LN23@GetAllStri:
  00122	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
  00125	3b 54 24 20	 cmp	 edx, DWORD PTR _descEnd$[esp+16]
  00129	72 a5		 jb	 SHORT $LL11@GetAllStri
$LN21@GetAllStri:

; 535  :         }
; 536  :         break;
; 537  :     }
; 538  : 
; 539  :     Log(LOG_DEBUG,__LINE__,"<< USB.GetAllStrDescs, SuppLangsStr %X",supportedLanguagesString);

  0012b	8b 74 24 10	 mov	 esi, DWORD PTR _supportedLanguagesString$[esp+20]
  0012f	56		 push	 esi
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@IFDPMHNA@?$DM?$DM?5USB?4GetAllStrDescs?0?5SuppLangs@
  00135	68 1b 02 00 00	 push	 539			; 0000021bH
  0013a	6a 10		 push	 16			; 00000010H
  0013c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00141	83 c4 10	 add	 esp, 16			; 00000010H

; 540  :     return supportedLanguagesString;
; 541  : }

  00144	5f		 pop	 edi
  00145	8b c6		 mov	 eax, esi
  00147	5e		 pop	 esi
  00148	5d		 pop	 ebp
  00149	5b		 pop	 ebx
  0014a	59		 pop	 ecx
  0014b	c2 10 00	 ret	 16			; 00000010H
?GetAllStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z ENDP ; USB::GetAllStringDescriptors
_TEXT	ENDS
PUBLIC	?USBDevicesDetails@USB@@QAEXXZ			; USB::USBDevicesDetails
; Function compile flags: /Ogtpy
;	COMDAT ?USBDevicesDetails@USB@@QAEXXZ
_TEXT	SEGMENT
_seconds$191853 = -20					; size = 4
_timeElapsed$191852 = -16				; size = 4
_tickStart$ = -16					; size = 8
_tickEnd$191851 = -8					; size = 8
?USBDevicesDetails@USB@@QAEXXZ PROC			; USB::USBDevicesDetails, COMDAT
; _this$ = eax

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 188  : 	Log(LOG_DEBUG,__LINE__,">> USB.DevsDets");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EBIECMOG@?$DO?$DO?5USB?4DevsDets?$AA@
  00011	68 bc 00 00 00	 push	 188			; 000000bcH
  00016	6a 10		 push	 16			; 00000010H
  00018	8b f0		 mov	 esi, eax
  0001a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  : 
; 190  :     unsigned __int64 tickStart = SysTick;

  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 191  : 
; 192  :     Log(LOG_HEADER,__LINE__,"USB Device Details");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HNIJLKOP@USB?5Device?5Details?$AA@
  0002d	68 c0 00 00 00	 push	 192			; 000000c0H
  00032	6a 02		 push	 2
  00034	89 44 24 3c	 mov	 DWORD PTR _tickStart$[esp+76], eax
  00038	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 193  : 
; 194  :     for(unsigned int x=0;x<usbDevDetails.size();x++)

  0003d	8b 8e 1c 02 00
	00		 mov	 ecx, DWORD PTR [esi+540]
  00043	2b 8e 18 02 00
	00		 sub	 ecx, DWORD PTR [esi+536]
  00049	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0004e	f7 e9		 imul	 ecx
  00050	03 d1		 add	 edx, ecx
  00052	c1 fa 04	 sar	 edx, 4
  00055	8b c2		 mov	 eax, edx
  00057	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	33 ff		 xor	 edi, edi
  0005f	03 c2		 add	 eax, edx
  00061	0f 84 83 00 00
	00		 je	 $LN1@USBDevices

; 188  : 	Log(LOG_DEBUG,__LINE__,">> USB.DevsDets");

  00067	33 db		 xor	 ebx, ebx
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL3@USBDevices:

; 195  :     {
; 196  :         Log(LOG_MESSAGE,__LINE__,"%s",usbDevDetails[x].c_str());

  00070	8b 8e 1c 02 00
	00		 mov	 ecx, DWORD PTR [esi+540]
  00076	2b 8e 18 02 00
	00		 sub	 ecx, DWORD PTR [esi+536]
  0007c	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00081	f7 e9		 imul	 ecx
  00083	03 d1		 add	 edx, ecx
  00085	c1 fa 04	 sar	 edx, 4
  00088	8b ca		 mov	 ecx, edx
  0008a	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008d	03 ca		 add	 ecx, edx
  0008f	3b f9		 cmp	 edi, ecx
  00091	72 05		 jb	 SHORT $LN10@USBDevices
  00093	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN10@USBDevices:
  00098	8b 86 18 02 00
	00		 mov	 eax, DWORD PTR [esi+536]
  0009e	03 c3		 add	 eax, ebx
  000a0	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  000a4	72 05		 jb	 SHORT $LN20@USBDevices
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	eb 03		 jmp	 SHORT $LN21@USBDevices
$LN20@USBDevices:
  000ab	83 c0 04	 add	 eax, 4
$LN21@USBDevices:
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000b4	68 c4 00 00 00	 push	 196			; 000000c4H
  000b9	6a 01		 push	 1
  000bb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000c0	8b 8e 1c 02 00
	00		 mov	 ecx, DWORD PTR [esi+540]
  000c6	2b 8e 18 02 00
	00		 sub	 ecx, DWORD PTR [esi+536]
  000cc	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000d1	f7 e9		 imul	 ecx
  000d3	03 d1		 add	 edx, ecx
  000d5	c1 fa 04	 sar	 edx, 4
  000d8	8b c2		 mov	 eax, edx
  000da	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000dd	47		 inc	 edi
  000de	03 c2		 add	 eax, edx
  000e0	83 c4 10	 add	 esp, 16			; 00000010H
  000e3	83 c3 1c	 add	 ebx, 28			; 0000001cH
  000e6	3b f8		 cmp	 edi, eax
  000e8	72 86		 jb	 SHORT $LL3@USBDevices
$LN1@USBDevices:

; 197  :     }
; 198  : 
; 199  :     LogElapsedTime(__LINE__,tickStart);

  000ea	8d 4c 24 2c	 lea	 ecx, DWORD PTR _seconds$191853[esp+64]
  000ee	51		 push	 ecx
  000ef	8d 54 24 34	 lea	 edx, DWORD PTR _timeElapsed$191852[esp+68]
  000f3	52		 push	 edx
  000f4	33 c0		 xor	 eax, eax
  000f6	50		 push	 eax
  000f7	8b 44 24 3c	 mov	 eax, DWORD PTR _tickStart$[esp+76]
  000fb	50		 push	 eax
  000fc	8d 74 24 48	 lea	 esi, DWORD PTR _tickEnd$191851[esp+80]
  00100	e8 00 00 00 00	 call	 ?CalcElapsedTime@@YAX_KAA_KAAMAAK@Z ; CalcElapsedTime
  00105	d9 44 24 40	 fld	 DWORD PTR _timeElapsed$191852[esp+80]
  00109	8b 4c 24 3c	 mov	 ecx, DWORD PTR _seconds$191853[esp+80]
  0010d	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  00111	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  00116	f7 e1		 mul	 ecx
  00118	8b f2		 mov	 esi, edx
  0011a	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0011f	f7 e1		 mul	 ecx
  00121	c1 ea 05	 shr	 edx, 5
  00124	8b c2		 mov	 eax, edx
  00126	c1 e0 04	 shl	 eax, 4
  00129	2b c2		 sub	 eax, edx
  0012b	03 c0		 add	 eax, eax
  0012d	03 c0		 add	 eax, eax
  0012f	8b d1		 mov	 edx, ecx
  00131	2b d0		 sub	 edx, eax
  00133	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  00136	8b c6		 mov	 eax, esi
  00138	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  0013e	83 c4 08	 add	 esp, 8
  00141	52		 push	 edx
  00142	2b c8		 sub	 ecx, eax
  00144	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00149	f7 e1		 mul	 ecx
  0014b	c1 ea 05	 shr	 edx, 5
  0014e	52		 push	 edx
  0014f	56		 push	 esi
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MMBEHPNG@?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf?5s?$AA@
  00155	68 c7 00 00 00	 push	 199			; 000000c7H
  0015a	6a 01		 push	 1
  0015c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 200  : 
; 201  : 	Log(LOG_DEBUG,__LINE__,"<< USB.DevsDets");

  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GOKCLIBE@?$DM?$DM?5USB?4DevsDets?$AA@
  00166	68 c9 00 00 00	 push	 201			; 000000c9H
  0016b	6a 10		 push	 16			; 00000010H
  0016d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00172	83 c4 2c	 add	 esp, 44			; 0000002cH

; 202  : }

  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	5b		 pop	 ebx
  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
?USBDevicesDetails@USB@@QAEXXZ ENDP			; USB::USBDevicesDetails
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.h
xdata$x	ENDS
;	COMDAT ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_detail$ = 8						; size = 28
?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; USB::PushBackDetails, COMDAT
; _this$ = esi

; 104  :     void PushBackDetails(string detail) {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	53		 push	 ebx
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0

; 105  :         Log(LOG_DEBUG,__LINE__,"-- USB.PushBackDets, %s",detail.c_str());

  0002a	83 7c 24 34 10	 cmp	 DWORD PTR _detail$[esp+44], 16 ; 00000010H
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR _detail$[esp+24]
  00033	73 04		 jae	 SHORT $LN9@PushBackDe
  00035	8d 44 24 20	 lea	 eax, DWORD PTR _detail$[esp+24]
$LN9@PushBackDe:
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GFKFEIAL@?9?9?5USB?4PushBackDets?0?5?$CFs?$AA@
  0003f	6a 69		 push	 105			; 00000069H
  00041	6a 10		 push	 16			; 00000010H
  00043	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00048	83 c4 10	 add	 esp, 16			; 00000010H

; 106  :         usbDevDetails.push_back(detail);

  0004b	8d 44 24 1c	 lea	 eax, DWORD PTR _detail$[esp+20]
  0004f	50		 push	 eax
  00050	8d 9e 0c 02 00
	00		 lea	 ebx, DWORD PTR [esi+524]
  00056	e8 00 00 00 00	 call	 ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 107  :     }

  0005b	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  00063	83 7c 24 34 10	 cmp	 DWORD PTR _detail$[esp+44], 16 ; 00000010H
  00068	72 0d		 jb	 SHORT $LN26@PushBackDe
  0006a	8b 4c 24 20	 mov	 ecx, DWORD PTR _detail$[esp+24]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00074	83 c4 04	 add	 esp, 4
$LN26@PushBackDe:
  00077	33 c0		 xor	 eax, eax
  00079	c7 44 24 34 0f
	00 00 00	 mov	 DWORD PTR _detail$[esp+44], 15 ; 0000000fH
  00081	89 44 24 30	 mov	 DWORD PTR _detail$[esp+40], eax
  00085	88 44 24 20	 mov	 BYTE PTR _detail$[esp+24], al
  00089	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	5b		 pop	 ebx
  00096	83 c4 10	 add	 esp, 16			; 00000010H
  00099	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 04	 lea	 ecx, DWORD PTR _detail$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; USB::PushBackDetails
PUBLIC	__$ArrayPad$
PUBLIC	?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z ; USB::UnknownDescriptor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$4
__ehfuncinfo$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z
_TEXT	SEGMENT
_i$ = -1049						; size = 1
$T223137 = -1048					; size = 4
$T223136 = -1048					; size = 4
$T223135 = -1048					; size = 4
$T223134 = -1048					; size = 4
$T223133 = -1048					; size = 4
_format$ = -1044					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z PROC ; USB::UnknownDescriptor, COMDAT
; _CommonDesc$ = edi

; 2101 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 0c 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1056], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 84 24 24 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1072]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	8b ac 24 34 04
	00 00		 mov	 ebp, DWORD PTR _this$[esp+1068]

; 2102 :     char format[1024] = {0};

  00041	33 db		 xor	 ebx, ebx
  00043	68 ff 03 00 00	 push	 1023			; 000003ffH
  00048	8d 44 24 21	 lea	 eax, DWORD PTR _format$[esp+1077]
  0004c	53		 push	 ebx
  0004d	50		 push	 eax
  0004e	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1084], bl
  00052	e8 00 00 00 00	 call	 _memset
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2103 :     UCHAR   i;
; 2104 : 
; 2105 :     Log(LOG_DEBUG,__LINE__,">> USB.UnknownDesc");

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LEEGFGLN@?$DO?$DO?5USB?4UnknownDesc?$AA@
  0005f	68 39 08 00 00	 push	 2105			; 00000839H
  00064	6a 10		 push	 16			; 00000010H
  00066	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2106 : 
; 2107 :     PushBackDetails("> Unknown Descriptor:");

  0006b	83 ec 10	 sub	 esp, 16			; 00000010H
  0006e	8b cc		 mov	 ecx, esp
  00070	89 64 24 34	 mov	 DWORD PTR $T223133[esp+1100], esp
  00074	6a 15		 push	 21			; 00000015H
  00076	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0007d	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FBFGEGLK@?$DO?5Unknown?5Descriptor?3?$AA@
  00085	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00088	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008d	89 9c 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], ebx
  00094	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0009f	8b f5		 mov	 esi, ebp
  000a1	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2108 : 
; 2109 :     _snprintf(format,sizeof(format)-1,">   bDescriptorType: 0x%02X",CommonDesc->bDescriptorType);

  000a6	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  000aa	51		 push	 ecx
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HOMJLHIG@?$DO?5?5?5bDescriptorType?3?50x?$CF02X?$AA@
  000b0	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  000b4	68 ff 03 00 00	 push	 1023			; 000003ffH
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 __snprintf

; 2110 :     PushBackDetails(format);

  000bf	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c2	8b cc		 mov	 ecx, esp
  000c4	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  000c8	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  000cf	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  000d2	89 64 24 34	 mov	 DWORD PTR $T223134[esp+1100], esp
  000d6	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  000d9	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  000dc	8d 64 24 00	 npad	 4
$LL195@UnknownDes:
  000e0	8a 10		 mov	 dl, BYTE PTR [eax]
  000e2	40		 inc	 eax
  000e3	3a d3		 cmp	 dl, bl
  000e5	75 f9		 jne	 SHORT $LL195@UnknownDes
  000e7	2b c6		 sub	 eax, esi
  000e9	50		 push	 eax
  000ea	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000f4	c7 84 24 48 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 1
  000ff	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0010a	8b f5		 mov	 esi, ebp
  0010c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2111 :     memset(format,0x00,sizeof(format));

  00111	68 00 04 00 00	 push	 1024			; 00000400H
  00116	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0011a	53		 push	 ebx
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _memset

; 2112 : 
; 2113 :     _snprintf(format,sizeof(format)-1,">   bLength: 0x%02X",CommonDesc->bLength);

  00121	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH
  00127	52		 push	 edx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@PKPADJND@?$DO?5?5?5bLength?3?50x?$CF02X?$AA@
  0012d	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00131	68 ff 03 00 00	 push	 1023			; 000003ffH
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 __snprintf

; 2114 :     PushBackDetails(format);

  0013c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0013f	8b cc		 mov	 ecx, esp
  00141	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00145	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0014c	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0014f	89 64 24 34	 mov	 DWORD PTR $T223135[esp+1100], esp
  00153	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00156	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00159	8d a4 24 00 00
	00 00		 npad	 7
$LL196@UnknownDes:
  00160	8a 10		 mov	 dl, BYTE PTR [eax]
  00162	40		 inc	 eax
  00163	3a d3		 cmp	 dl, bl
  00165	75 f9		 jne	 SHORT $LL196@UnknownDes
  00167	2b c6		 sub	 eax, esi
  00169	50		 push	 eax
  0016a	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  0016e	52		 push	 edx
  0016f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00174	c7 84 24 48 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 2
  0017f	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0018a	8b f5		 mov	 esi, ebp
  0018c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2115 :     memset(format,0x00,sizeof(format));

  00191	68 00 04 00 00	 push	 1024			; 00000400H
  00196	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  0019a	53		 push	 ebx
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 _memset
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2116 : 
; 2117 :     _snprintf(format,sizeof(format)-1,">   ");

  001a4	68 00 00 00 00	 push	 OFFSET ??_C@_04CKDHMDHJ@?$DO?5?5?5?$AA@
  001a9	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  001ad	68 ff 03 00 00	 push	 1023			; 000003ffH
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 __snprintf
  001b8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2118 :     for (i = 0; i < CommonDesc->bLength; i++)

  001bb	88 5c 24 17	 mov	 BYTE PTR _i$[esp+1072], bl
  001bf	38 1f		 cmp	 BYTE PTR [edi], bl
  001c1	0f 86 bc 00 00
	00		 jbe	 $LN3@UnknownDes
$LN5@UnknownDes:

; 2119 :     {
; 2120 :         _snprintf(format,sizeof(format)-1,"%s.%02X",format,((PUCHAR)CommonDesc)[i]);

  001c7	0f b6 74 24 17	 movzx	 esi, BYTE PTR _i$[esp+1072]
  001cc	0f b6 14 3e	 movzx	 edx, BYTE PTR [esi+edi]
  001d0	52		 push	 edx
  001d1	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  001d5	50		 push	 eax
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_07GHOKFMCD@?$CFs?4?$CF02X?$AA@
  001db	8b c8		 mov	 ecx, eax
  001dd	68 ff 03 00 00	 push	 1023			; 000003ffH
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 __snprintf
  001e8	83 c4 14	 add	 esp, 20			; 00000014H

; 2121 : 
; 2122 :         if (i % 16 == 15)

  001eb	81 e6 0f 00 00
	80		 and	 esi, -2147483633	; 8000000fH
  001f1	79 05		 jns	 SHORT $LN201@UnknownDes
  001f3	4e		 dec	 esi
  001f4	83 ce f0	 or	 esi, -16		; fffffff0H
  001f7	46		 inc	 esi
$LN201@UnknownDes:
  001f8	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  001fb	75 74		 jne	 SHORT $LN4@UnknownDes

; 2123 :         {
; 2124 :             PushBackDetails(format);

  001fd	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00200	8b cc		 mov	 ecx, esp
  00202	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  00205	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00209	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0020c	89 64 24 34	 mov	 DWORD PTR $T223136[esp+1100], esp
  00210	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00213	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL197@UnknownDes:
  00216	8a 10		 mov	 dl, BYTE PTR [eax]
  00218	40		 inc	 eax
  00219	3a d3		 cmp	 dl, bl
  0021b	75 f9		 jne	 SHORT $LL197@UnknownDes
  0021d	2b c6		 sub	 eax, esi
  0021f	50		 push	 eax
  00220	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0022a	c7 84 24 48 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 3
  00235	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  00240	8b f5		 mov	 esi, ebp
  00242	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2125 :             memset(format,0x00,sizeof(format));

  00247	68 00 04 00 00	 push	 1024			; 00000400H
  0024c	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  00250	53		 push	 ebx
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _memset
  00257	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2126 :             _snprintf(format,sizeof(format)-1,">   ");

  0025a	68 00 00 00 00	 push	 OFFSET ??_C@_04CKDHMDHJ@?$DO?5?5?5?$AA@
  0025f	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  00263	68 ff 03 00 00	 push	 1023			; 000003ffH
  00268	51		 push	 ecx
  00269	e8 00 00 00 00	 call	 __snprintf
  0026e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@UnknownDes:
  00271	8a 44 24 17	 mov	 al, BYTE PTR _i$[esp+1072]
  00275	fe c0		 inc	 al
  00277	88 44 24 17	 mov	 BYTE PTR _i$[esp+1072], al
  0027b	3a 07		 cmp	 al, BYTE PTR [edi]
  0027d	0f 82 44 ff ff
	ff		 jb	 $LN5@UnknownDes
$LN3@UnknownDes:

; 2127 :         }
; 2128 :     }
; 2129 : 
; 2130 :     if (i % 16 != 0)

  00283	0f b6 54 24 17	 movzx	 edx, BYTE PTR _i$[esp+1072]
  00288	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  0028e	79 05		 jns	 SHORT $LN202@UnknownDes
  00290	4a		 dec	 edx
  00291	83 ca f0	 or	 edx, -16		; fffffff0H
  00294	42		 inc	 edx
$LN202@UnknownDes:
  00295	74 50		 je	 SHORT $LN1@UnknownDes

; 2131 :     {
; 2132 :         PushBackDetails(format);

  00297	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0029a	8b f4		 mov	 esi, esp
  0029c	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  002a0	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  002a7	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  002aa	89 64 24 34	 mov	 DWORD PTR $T223137[esp+1100], esp
  002ae	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  002b1	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL198@UnknownDes:
  002b4	8a 08		 mov	 cl, BYTE PTR [eax]
  002b6	40		 inc	 eax
  002b7	3a cb		 cmp	 cl, bl
  002b9	75 f9		 jne	 SHORT $LL198@UnknownDes
  002bb	2b c2		 sub	 eax, edx
  002bd	50		 push	 eax
  002be	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  002c2	50		 push	 eax
  002c3	8b ce		 mov	 ecx, esi
  002c5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  002ca	c7 84 24 48 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 4
  002d5	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  002e0	8b f5		 mov	 esi, ebp
  002e2	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
$LN1@UnknownDes:

; 2133 :     }
; 2134 : 
; 2135 :     Log(LOG_DEBUG,__LINE__,"<< USB.UnknownDesc");

  002e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MFCGDLMP@?$DM?$DM?5USB?4UnknownDesc?$AA@
  002ec	68 57 08 00 00	 push	 2135			; 00000857H
  002f1	6a 10		 push	 16			; 00000010H
  002f3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2136 : }

  002fb	8b 8c 24 24 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1072]
  00302	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00309	59		 pop	 ecx
  0030a	5e		 pop	 esi
  0030b	5d		 pop	 ebp
  0030c	5b		 pop	 ebx
  0030d	8b 8c 24 0c 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1056]
  00314	33 cc		 xor	 ecx, esp
  00316	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0031b	81 c4 20 04 00
	00		 add	 esp, 1056		; 00000420H
  00321	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$0:
  00000	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T223133[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$1:
  0000b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T223134[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$2:
  00016	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T223135[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$3:
  00021	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T223136[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z$4:
  0002c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T223137[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 82 e0 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1056]
  00041	8b 8a dc fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1060]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00051	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z ENDP ; USB::UnknownDescriptor
PUBLIC	__$ArrayPad$
PUBLIC	?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::StringDescriptor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z$0
__ehfuncinfo$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z
_TEXT	SEGMENT
$T223883 = -10020					; size = 4
_format$ = -10016					; size = 10000
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_Index$ = 12						; size = 1
?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z PROC ; USB::StringDescriptor, COMDAT
; _StringDescs$ = ecx

; 2059 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	b8 1c 27 00 00	 mov	 eax, 10012		; 0000271cH
  00013	e8 00 00 00 00	 call	 __chkstk
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c4		 xor	 eax, esp
  0001f	89 84 24 18 27
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+10024], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c4		 xor	 eax, esp
  0002f	50		 push	 eax
  00030	8d 84 24 28 27
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+10036]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2060 :     char format[10000] = {0};

  0003d	33 db		 xor	 ebx, ebx
  0003f	68 0f 27 00 00	 push	 9999			; 0000270fH
  00044	8d 44 24 19	 lea	 eax, DWORD PTR _format$[esp+10041]
  00048	53		 push	 ebx
  00049	50		 push	 eax
  0004a	8b f1		 mov	 esi, ecx
  0004c	88 5c 24 20	 mov	 BYTE PTR _format$[esp+10048], bl
  00050	e8 00 00 00 00	 call	 _memset

; 2061 : 
; 2062 :     Log(LOG_DEBUG,__LINE__,">> USB.StrDesc, Idx %d",(int)Index);

  00055	0f b6 8c 24 48
	27 00 00	 movzx	 ecx, BYTE PTR _Index$[esp+10044]
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	51		 push	 ecx
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LCHICFEL@?$DO?$DO?5USB?4StrDesc?0?5Idx?5?$CFd?$AA@
  00066	68 0e 08 00 00	 push	 2062			; 0000080eH
  0006b	6a 10		 push	 16			; 00000010H
  0006d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00072	83 c4 10	 add	 esp, 16			; 00000010H

; 2063 : 
; 2064 :     // Use an actual "int" here because it's passed as a printf * precision
; 2065 :     int descChars = 0;
; 2066 : 
; 2067 :     while (StringDescs)

  00075	3b f3		 cmp	 esi, ebx
  00077	0f 84 99 00 00
	00		 je	 $LN2@StringDesc@2
  0007d	8d 49 00	 npad	 3
$LL3@StringDesc@2:

; 2068 :     {
; 2069 :         if (StringDescs->DescriptorIndex == Index)

  00080	8a 94 24 3c 27
	00 00		 mov	 dl, BYTE PTR _Index$[esp+10032]
  00087	38 56 04	 cmp	 BYTE PTR [esi+4], dl
  0008a	74 0b		 je	 SHORT $LN44@StringDesc@2

; 2090 :             break;
; 2091 :         }
; 2092 : 
; 2093 :         StringDescs = StringDescs->Next;

  0008c	8b 36		 mov	 esi, DWORD PTR [esi]
  0008e	3b f3		 cmp	 esi, ebx
  00090	75 ee		 jne	 SHORT $LL3@StringDesc@2

; 2068 :     {
; 2069 :         if (StringDescs->DescriptorIndex == Index)

  00092	e9 7f 00 00 00	 jmp	 $LN2@StringDesc@2
$LN44@StringDesc@2:

; 2070 :         {
; 2071 :             //
; 2072 :             // bString from USB_STRING_DESCRIPTOR isn't NULL-terminated, so 
; 2073 :             // calculate the number of characters.  
; 2074 :             // 
; 2075 :             // bLength is the length of the whole structure, not just the string.  
; 2076 :             // 
; 2077 :             // bLength is bytes, bString is WCHARs
; 2078 :             // 
; 2079 :             descChars = 
; 2080 :                 ( (int) StringDescs->StringDescriptor->bLength - 
; 2081 :                 offsetof(USB_STRING_DESCRIPTOR, bString) ) /
; 2082 :                 sizeof(WCHAR);
; 2083 :             //
; 2084 :             // Use the * precision and pass the number of characters just caculated.
; 2085 :             // bString is always WCHAR so specify widestring regardless of what TCHAR resolves to
; 2086 :             // 
; 2087 :             _snprintf(format,sizeof(format)-1,">   0x%04X: %s",StringDescs->LanguageID,(char const* )StringDescs->StringDescriptor->bString);

  00097	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  0009b	8d 46 0a	 lea	 eax, DWORD PTR [esi+10]
  0009e	50		 push	 eax
  0009f	51		 push	 ecx
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CCEKBNHE@?$DO?5?5?50x?$CF04X?3?5?$CFs?$AA@
  000a5	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+10048]
  000a9	68 0f 27 00 00	 push	 9999			; 0000270fH
  000ae	52		 push	 edx
  000af	e8 00 00 00 00	 call	 __snprintf

; 2088 :             PushBackDetails(format);

  000b4	83 ec 08	 sub	 esp, 8
  000b7	8b cc		 mov	 ecx, esp
  000b9	8d 44 24 30	 lea	 eax, DWORD PTR _format$[esp+10064]
  000bd	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  000c4	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  000c7	89 64 24 2c	 mov	 DWORD PTR $T223883[esp+10064], esp
  000cb	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  000ce	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL46@StringDesc@2:
  000d1	8a 10		 mov	 dl, BYTE PTR [eax]
  000d3	40		 inc	 eax
  000d4	3a d3		 cmp	 dl, bl
  000d6	75 f9		 jne	 SHORT $LL46@StringDesc@2
  000d8	2b c6		 sub	 eax, esi
  000da	50		 push	 eax
  000db	8d 44 24 34	 lea	 eax, DWORD PTR _format$[esp+10068]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000e5	89 9c 24 4c 27
	00 00		 mov	 DWORD PTR __$EHRec$[esp+10072], ebx
  000ec	c7 84 24 4c 27
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+10072], -1
  000f7	8b b4 24 54 27
	00 00		 mov	 esi, DWORD PTR _this$[esp+10060]
  000fe	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2089 :             memset(format,0x00,sizeof(format));

  00103	68 10 27 00 00	 push	 10000			; 00002710H
  00108	8d 4c 24 18	 lea	 ecx, DWORD PTR _format$[esp+10040]
  0010c	53		 push	 ebx
  0010d	51		 push	 ecx
  0010e	e8 00 00 00 00	 call	 _memset
  00113	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@StringDesc@2:

; 2094 :     }
; 2095 : 
; 2096 :     Log(LOG_DEBUG,__LINE__,"<< USB.StrDesc");

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DKFDMJNG@?$DM?$DM?5USB?4StrDesc?$AA@
  0011b	68 30 08 00 00	 push	 2096			; 00000830H
  00120	6a 10		 push	 16			; 00000010H
  00122	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2097 : }

  0012a	8b 8c 24 28 27
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+10036]
  00131	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00138	59		 pop	 ecx
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b 8c 24 18 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10024]
  00142	33 cc		 xor	 ecx, esp
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	81 c4 28 27 00
	00		 add	 esp, 10024		; 00002728H
  0014f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z$0:
  00000	8b 8d dc d8 ff
	ff		 mov	 ecx, DWORD PTR $T223883[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 82 dc d8 ff
	ff		 lea	 eax, DWORD PTR [edx-10020]
  00015	8b 8a d8 d8 ff
	ff		 mov	 ecx, DWORD PTR [edx-10024]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	83 c0 08	 add	 eax, 8
  00025	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ENDP ; USB::StringDescriptor
PUBLIC	__$ArrayPad$
PUBLIC	?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z ; USB::HidDescriptor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$4
__ehfuncinfo$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z
_TEXT	SEGMENT
_i$ = -1049						; size = 1
$T224048 = -1048					; size = 4
$T224047 = -1048					; size = 4
$T224046 = -1048					; size = 4
$T224045 = -1048					; size = 4
$T224044 = -1048					; size = 4
_format$ = -1044					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z PROC	; USB::HidDescriptor, COMDAT
; _HidDesc$ = edi

; 2025 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 0c 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1056], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 84 24 24 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1072]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	8b ac 24 34 04
	00 00		 mov	 ebp, DWORD PTR _this$[esp+1068]

; 2026 :     UCHAR i;
; 2027 :     char format[1024] = {0};

  00041	33 db		 xor	 ebx, ebx
  00043	68 ff 03 00 00	 push	 1023			; 000003ffH
  00048	8d 44 24 21	 lea	 eax, DWORD PTR _format$[esp+1077]
  0004c	53		 push	 ebx
  0004d	50		 push	 eax
  0004e	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1084], bl
  00052	e8 00 00 00 00	 call	 _memset
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2028 : 
; 2029 :     Log(LOG_DEBUG,__LINE__,">> USB.HidDesc");

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IBOMINBP@?$DO?$DO?5USB?4HidDesc?$AA@
  0005f	68 ed 07 00 00	 push	 2029			; 000007edH
  00064	6a 10		 push	 16			; 00000010H
  00066	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2030 : 
; 2031 :     PushBackDetails("> HID Descriptor:");

  0006b	83 ec 10	 sub	 esp, 16			; 00000010H
  0006e	8b cc		 mov	 ecx, esp
  00070	89 64 24 34	 mov	 DWORD PTR $T224044[esp+1100], esp
  00074	6a 11		 push	 17			; 00000011H
  00076	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0007d	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FKMEKGFJ@?$DO?5HID?5Descriptor?3?$AA@
  00085	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00088	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008d	89 9c 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], ebx
  00094	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0009f	8b f5		 mov	 esi, ebp
  000a1	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2032 : 
; 2033 :     _snprintf(format,sizeof(format)-1,">   bcdHID: 0x%04X",HidDesc->bcdHID);

  000a6	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  000aa	51		 push	 ecx
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JNJCPDHI@?$DO?5?5?5bcdHID?3?50x?$CF04X?$AA@
  000b0	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  000b4	68 ff 03 00 00	 push	 1023			; 000003ffH
  000b9	52		 push	 edx
  000ba	e8 00 00 00 00	 call	 __snprintf

; 2034 :     PushBackDetails(format);

  000bf	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c2	8b f4		 mov	 esi, esp
  000c4	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  000c8	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  000cf	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000d2	89 64 24 34	 mov	 DWORD PTR $T224045[esp+1100], esp
  000d6	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  000d9	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  000dc	8d 64 24 00	 npad	 4
$LL193@HidDescrip:
  000e0	8a 10		 mov	 dl, BYTE PTR [eax]
  000e2	40		 inc	 eax
  000e3	3a d3		 cmp	 dl, bl
  000e5	75 f9		 jne	 SHORT $LL193@HidDescrip
  000e7	2b c1		 sub	 eax, ecx
  000e9	50		 push	 eax
  000ea	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  000ee	50		 push	 eax
  000ef	8b ce		 mov	 ecx, esi
  000f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000f6	c7 84 24 48 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 1
  00101	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0010c	8b f5		 mov	 esi, ebp
  0010e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2035 :     memset(format,0x00,sizeof(format));

  00113	68 00 04 00 00	 push	 1024			; 00000400H
  00118	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0011c	53		 push	 ebx
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 _memset

; 2036 : 
; 2037 :     _snprintf(format,sizeof(format)-1,">   bCountryCode: 0x%02X",HidDesc->bCountryCode);

  00123	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012a	52		 push	 edx
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CKIDJFBI@?$DO?5?5?5bCountryCode?3?50x?$CF02X?$AA@
  00130	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00134	68 ff 03 00 00	 push	 1023			; 000003ffH
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 __snprintf

; 2038 :     PushBackDetails(format);

  0013f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00142	8b f4		 mov	 esi, esp
  00144	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00148	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0014f	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00152	89 64 24 34	 mov	 DWORD PTR $T224046[esp+1100], esp
  00156	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00159	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0015c	8d 64 24 00	 npad	 4
$LL194@HidDescrip:
  00160	8a 10		 mov	 dl, BYTE PTR [eax]
  00162	40		 inc	 eax
  00163	3a d3		 cmp	 dl, bl
  00165	75 f9		 jne	 SHORT $LL194@HidDescrip
  00167	2b c1		 sub	 eax, ecx
  00169	50		 push	 eax
  0016a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0016e	51		 push	 ecx
  0016f	8b ce		 mov	 ecx, esi
  00171	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00176	c7 84 24 48 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 2
  00181	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0018c	8b f5		 mov	 esi, ebp
  0018e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2039 :     memset(format,0x00,sizeof(format));

  00193	68 00 04 00 00	 push	 1024			; 00000400H
  00198	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0019c	53		 push	 ebx
  0019d	52		 push	 edx
  0019e	e8 00 00 00 00	 call	 _memset

; 2040 : 
; 2041 :     _snprintf(format,sizeof(format)-1,">   bNumDescriptors: 0x%02X",HidDesc->bNumDescriptors);

  001a3	0f b6 47 05	 movzx	 eax, BYTE PTR [edi+5]
  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001aa	50		 push	 eax
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MKJBFMNP@?$DO?5?5?5bNumDescriptors?3?50x?$CF02X?$AA@
  001b0	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1080]
  001b4	68 ff 03 00 00	 push	 1023			; 000003ffH
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 __snprintf

; 2042 :     PushBackDetails(format);

  001bf	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c2	8b f4		 mov	 esi, esp
  001c4	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  001c8	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  001cf	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  001d2	89 64 24 34	 mov	 DWORD PTR $T224047[esp+1100], esp
  001d6	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  001d9	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  001dc	8d 64 24 00	 npad	 4
$LL195@HidDescrip:
  001e0	8a 10		 mov	 dl, BYTE PTR [eax]
  001e2	40		 inc	 eax
  001e3	3a d3		 cmp	 dl, bl
  001e5	75 f9		 jne	 SHORT $LL195@HidDescrip
  001e7	2b c1		 sub	 eax, ecx
  001e9	50		 push	 eax
  001ea	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  001ee	52		 push	 edx
  001ef	8b ce		 mov	 ecx, esi
  001f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  001f6	c7 84 24 48 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 3
  00201	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0020c	8b f5		 mov	 esi, ebp
  0020e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2043 :     memset(format,0x00,sizeof(format));

  00213	68 00 04 00 00	 push	 1024			; 00000400H
  00218	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  0021c	53		 push	 ebx
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _memset
  00223	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2044 : 
; 2045 :     for (i=0; i<HidDesc->bNumDescriptors; i++)

  00226	88 5c 24 17	 mov	 BYTE PTR _i$[esp+1072], bl
  0022a	38 5f 05	 cmp	 BYTE PTR [edi+5], bl
  0022d	0f 86 a4 00 00
	00		 jbe	 $LN1@HidDescrip
$LN3@HidDescrip:

; 2046 :     {
; 2047 :         _snprintf(format,sizeof(format)-1,">   %.3i, bDescriptorType: 0x%02X, wDescriptorLength: 0x%04X",
; 2048 :                                           HidDesc->OptionalDescriptors[i].bDescriptorType,
; 2049 :                                           HidDesc->OptionalDescriptors[i].wDescriptorLength);

  00233	0f b6 44 24 17	 movzx	 eax, BYTE PTR _i$[esp+1072]
  00238	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  0023b	0f b7 54 08 07	 movzx	 edx, WORD PTR [eax+ecx+7]
  00240	52		 push	 edx
  00241	8d 4c 47 04	 lea	 ecx, DWORD PTR [edi+eax*2+4]
  00245	0f b6 54 08 02	 movzx	 edx, BYTE PTR [eax+ecx+2]
  0024a	52		 push	 edx
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@JAEDHMBE@?$DO?5?5?5?$CF?43i?0?5bDescriptorType?3?50x?$CF02@
  00250	8d 44 24 28	 lea	 eax, DWORD PTR _format$[esp+1084]
  00254	68 ff 03 00 00	 push	 1023			; 000003ffH
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 __snprintf

; 2050 :         PushBackDetails(format);

  0025f	83 ec 08	 sub	 esp, 8
  00262	8b cc		 mov	 ecx, esp
  00264	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00268	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0026f	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00272	89 64 24 34	 mov	 DWORD PTR $T224048[esp+1100], esp
  00276	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00279	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  0027c	8d 64 24 00	 npad	 4
$LL196@HidDescrip:
  00280	8a 10		 mov	 dl, BYTE PTR [eax]
  00282	40		 inc	 eax
  00283	3a d3		 cmp	 dl, bl
  00285	75 f9		 jne	 SHORT $LL196@HidDescrip
  00287	2b c6		 sub	 eax, esi
  00289	50		 push	 eax
  0028a	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  0028e	52		 push	 edx
  0028f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00294	c7 84 24 48 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 4
  0029f	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  002aa	8b f5		 mov	 esi, ebp
  002ac	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2051 :         memset(format,0x00,sizeof(format));

  002b1	68 00 04 00 00	 push	 1024			; 00000400H
  002b6	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  002ba	53		 push	 ebx
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 _memset
  002c1	8a 44 24 23	 mov	 al, BYTE PTR _i$[esp+1084]
  002c5	fe c0		 inc	 al
  002c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ca	88 44 24 17	 mov	 BYTE PTR _i$[esp+1072], al
  002ce	3a 47 05	 cmp	 al, BYTE PTR [edi+5]
  002d1	0f 82 5c ff ff
	ff		 jb	 $LN3@HidDescrip
$LN1@HidDescrip:

; 2052 :     }
; 2053 : 
; 2054 :     Log(LOG_DEBUG,__LINE__,"<< USB.HidDesc");

  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MIAEPICD@?$DM?$DM?5USB?4HidDesc?$AA@
  002dc	68 06 08 00 00	 push	 2054			; 00000806H
  002e1	6a 10		 push	 16			; 00000010H
  002e3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2055 : }

  002eb	8b 8c 24 24 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1072]
  002f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f9	59		 pop	 ecx
  002fa	5e		 pop	 esi
  002fb	5d		 pop	 ebp
  002fc	5b		 pop	 ebx
  002fd	8b 8c 24 0c 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1056]
  00304	33 cc		 xor	 ecx, esp
  00306	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030b	81 c4 20 04 00
	00		 add	 esp, 1056		; 00000420H
  00311	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$0:
  00000	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224044[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$1:
  0000b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224045[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$2:
  00016	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224046[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$3:
  00021	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224047[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z$4:
  0002c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224048[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 82 e0 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1056]
  00041	8b 8a dc fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1060]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00051	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z ENDP	; USB::HidDescriptor
PUBLIC	__$ArrayPad$
PUBLIC	?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z ; USB::EndpointDescriptor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$10
__ehfuncinfo$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z
_TEXT	SEGMENT
$T224802 = -1048					; size = 4
$T224801 = -1048					; size = 4
$T224800 = -1048					; size = 4
$T224799 = -1048					; size = 4
$T224798 = -1048					; size = 4
$T224797 = -1048					; size = 4
$T224796 = -1048					; size = 4
$T224795 = -1048					; size = 4
$T224794 = -1048					; size = 4
$T224793 = -1048					; size = 4
$T224792 = -1048					; size = 4
_format$ = -1044					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_EndpointDesc$ = 8					; size = 4
?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z PROC ; USB::EndpointDescriptor, COMDAT
; _this$ = ecx

; 1956 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 08 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1052], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c4		 xor	 eax, esp
  0002d	50		 push	 eax
  0002e	8d 84 24 24 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1072]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx
  0003d	8b ac 24 34 04
	00 00		 mov	 ebp, DWORD PTR _EndpointDesc$[esp+1068]

; 1957 :     char format[1024] = {0};

  00044	33 db		 xor	 ebx, ebx
  00046	68 ff 03 00 00	 push	 1023			; 000003ffH
  0004b	8d 44 24 21	 lea	 eax, DWORD PTR _format$[esp+1077]
  0004f	53		 push	 ebx
  00050	50		 push	 eax
  00051	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1084], bl
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1958 : 
; 1959 :     Log(LOG_DEBUG,__LINE__,">> USB.EndpointDesc");

  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BNJCNLHH@?$DO?$DO?5USB?4EndpointDesc?$AA@
  00062	68 a7 07 00 00	 push	 1959			; 000007a7H
  00067	6a 10		 push	 16			; 00000010H
  00069	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1960 : 
; 1961 :     PushBackDetails("> Endpoint Descriptor:");

  0006e	83 ec 10	 sub	 esp, 16			; 00000010H
  00071	8b cc		 mov	 ecx, esp
  00073	89 64 24 34	 mov	 DWORD PTR $T224792[esp+1100], esp
  00077	6a 16		 push	 22			; 00000016H
  00079	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00080	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NNPPCJHP@?$DO?5Endpoint?5Descriptor?3?$AA@
  00088	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  0008b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00090	89 9c 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], ebx
  00097	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  000a2	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1962 : 
; 1963 :     if (USB_ENDPOINT_DIRECTION_IN(EndpointDesc->bEndpointAddress))

  000a7	8a 45 02	 mov	 al, BYTE PTR [ebp+2]
  000aa	84 c0		 test	 al, al
  000ac	79 7a		 jns	 SHORT $LN10@EndpointDe

; 1964 :     {
; 1965 :         _snprintf(format,sizeof(format)-1,">   bEndpointAddress: 0x%02X IN",EndpointDesc->bEndpointAddress);

  000ae	0f b6 c8	 movzx	 ecx, al
  000b1	51		 push	 ecx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IMJGHBI@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5IN?$AA@
  000b7	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  000bb	68 ff 03 00 00	 push	 1023			; 000003ffH
  000c0	52		 push	 edx
  000c1	e8 00 00 00 00	 call	 __snprintf

; 1966 :         PushBackDetails(format);

  000c6	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000c9	8b fc		 mov	 edi, esp
  000cb	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  000cf	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH
  000d6	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  000d9	89 64 24 34	 mov	 DWORD PTR $T224793[esp+1100], esp
  000dd	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  000e0	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL276@EndpointDe:
  000e3	8a 08		 mov	 cl, BYTE PTR [eax]
  000e5	40		 inc	 eax
  000e6	3a cb		 cmp	 cl, bl
  000e8	75 f9		 jne	 SHORT $LL276@EndpointDe
  000ea	2b c2		 sub	 eax, edx
  000ec	50		 push	 eax
  000ed	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  000f1	50		 push	 eax
  000f2	8b cf		 mov	 ecx, edi
  000f4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000f9	c7 84 24 48 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 1
  00104	83 cf ff	 or	 edi, -1
  00107	89 bc 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], edi
  0010e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1967 :         memset(format,0x00,sizeof(format));

  00113	68 00 04 00 00	 push	 1024			; 00000400H
  00118	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0011c	53		 push	 ebx
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 _memset
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1968 :     }
; 1969 :     else

  00126	eb 7f		 jmp	 SHORT $LN9@EndpointDe
$LN10@EndpointDe:

; 1970 :     {
; 1971 :         _snprintf(format,sizeof(format)-1,">   bEndpointAddress: 0x%02X OUT",EndpointDesc->bEndpointAddress);

  00128	0f b6 d0	 movzx	 edx, al
  0012b	52		 push	 edx
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PIKLNKCM@?$DO?5?5?5bEndpointAddress?3?50x?$CF02X?5OUT@
  00131	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00135	68 ff 03 00 00	 push	 1023			; 000003ffH
  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 __snprintf

; 1972 :         PushBackDetails(format);

  00140	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00143	8b fc		 mov	 edi, esp
  00145	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00149	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH
  00150	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  00153	89 64 24 34	 mov	 DWORD PTR $T224794[esp+1100], esp
  00157	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  0015a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0015d	8d 49 00	 npad	 3
$LL277@EndpointDe:
  00160	8a 08		 mov	 cl, BYTE PTR [eax]
  00162	40		 inc	 eax
  00163	3a cb		 cmp	 cl, bl
  00165	75 f9		 jne	 SHORT $LL277@EndpointDe
  00167	2b c2		 sub	 eax, edx
  00169	50		 push	 eax
  0016a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0016e	51		 push	 ecx
  0016f	8b cf		 mov	 ecx, edi
  00171	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00176	c7 84 24 48 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 2
  00181	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0018c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1973 :         memset(format,0x00,sizeof(format));

  00191	68 00 04 00 00	 push	 1024			; 00000400H
  00196	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0019a	53		 push	 ebx
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 _memset
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a4	83 cf ff	 or	 edi, -1
$LN9@EndpointDe:

; 1974 :     }
; 1975 : 
; 1976 :     switch (EndpointDesc->bmAttributes & 0x03)

  001a7	0f b6 45 03	 movzx	 eax, BYTE PTR [ebp+3]
  001ab	83 e0 03	 and	 eax, 3
  001ae	83 f8 03	 cmp	 eax, 3
  001b1	0f 87 91 00 00
	00		 ja	 $LN7@EndpointDe
  001b7	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN285@EndpointDe[eax*4]
$LN6@EndpointDe:

; 1977 :     {
; 1978 :         case 0x00:
; 1979 :             PushBackDetails(">   Transfer Type: Control");

  001be	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001c1	8b cc		 mov	 ecx, esp
  001c3	89 64 24 34	 mov	 DWORD PTR $T224795[esp+1100], esp
  001c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@ICIOMPJC@?$DO?5?5?5Transfer?5Type?3?5Control?$AA@
  001cc	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001d1	c7 84 24 48 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 3

; 1980 :             break;

  001dc	eb 5e		 jmp	 SHORT $LN283@EndpointDe
$LN5@EndpointDe:

; 1981 : 
; 1982 :         case 0x01:
; 1983 :             PushBackDetails(">   Transfer Type: Isochronous");

  001de	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001e1	8b cc		 mov	 ecx, esp
  001e3	89 64 24 34	 mov	 DWORD PTR $T224796[esp+1100], esp
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DMDNFJME@?$DO?5?5?5Transfer?5Type?3?5Isochronous?$AA@
  001ec	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001f1	c7 84 24 48 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 4

; 1984 :             break;

  001fc	eb 3e		 jmp	 SHORT $LN283@EndpointDe
$LN4@EndpointDe:

; 1985 : 
; 1986 :         case 0x02:
; 1987 :             PushBackDetails(">   Transfer Type: Bulk");

  001fe	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00201	8b cc		 mov	 ecx, esp
  00203	89 64 24 34	 mov	 DWORD PTR $T224797[esp+1100], esp
  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@ELEHNLID@?$DO?5?5?5Transfer?5Type?3?5Bulk?$AA@
  0020c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00211	c7 84 24 48 04
	00 00 05 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 5

; 1988 :             break;

  0021c	eb 1e		 jmp	 SHORT $LN283@EndpointDe
$LN3@EndpointDe:

; 1989 : 
; 1990 :         case 0x03:
; 1991 :             PushBackDetails(">   Transfer Type: Interrupt");

  0021e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00221	8b cc		 mov	 ecx, esp
  00223	89 64 24 34	 mov	 DWORD PTR $T224798[esp+1100], esp
  00227	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@MOOEBEKA@?$DO?5?5?5Transfer?5Type?3?5Interrupt?$AA@
  0022c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00231	c7 84 24 48 04
	00 00 06 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 6
$LN283@EndpointDe:
  0023c	89 bc 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], edi
  00243	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
$LN7@EndpointDe:

; 1992 :             break;
; 1993 : 
; 1994 :     }
; 1995 : 
; 1996 :     _snprintf(format,sizeof(format)-1,">   wMaxPacketSize: 0x%04X (%d)",EndpointDesc->wMaxPacketSize,EndpointDesc->wMaxPacketSize);

  00248	0f b7 45 04	 movzx	 eax, WORD PTR [ebp+4]
  0024c	50		 push	 eax
  0024d	50		 push	 eax
  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@OFHICAPC@?$DO?5?5?5wMaxPacketSize?3?50x?$CF04X?5?$CI?$CFd?$CJ?$AA@
  00253	8d 44 24 28	 lea	 eax, DWORD PTR _format$[esp+1084]
  00257	68 ff 03 00 00	 push	 1023			; 000003ffH
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 __snprintf

; 1997 :     PushBackDetails(format);

  00262	83 ec 08	 sub	 esp, 8
  00265	8b fc		 mov	 edi, esp
  00267	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  0026b	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH
  00272	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  00275	89 64 24 34	 mov	 DWORD PTR $T224799[esp+1100], esp
  00279	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  0027c	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0027f	90		 npad	 1
$LL278@EndpointDe:
  00280	8a 10		 mov	 dl, BYTE PTR [eax]
  00282	40		 inc	 eax
  00283	3a d3		 cmp	 dl, bl
  00285	75 f9		 jne	 SHORT $LL278@EndpointDe
  00287	2b c1		 sub	 eax, ecx
  00289	50		 push	 eax
  0028a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0028e	51		 push	 ecx
  0028f	8b cf		 mov	 ecx, edi
  00291	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00296	c7 84 24 48 04
	00 00 07 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 7
  002a1	83 cf ff	 or	 edi, -1
  002a4	89 bc 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], edi
  002ab	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1998 :     memset(format,0x00,sizeof(format));

  002b0	68 00 04 00 00	 push	 1024			; 00000400H
  002b5	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  002b9	53		 push	 ebx
  002ba	52		 push	 edx
  002bb	e8 00 00 00 00	 call	 _memset
  002c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1999 : 
; 2000 :     if (EndpointDesc->bLength == sizeof(USB_ENDPOINT_DESCRIPTOR))

  002c3	80 7d 00 07	 cmp	 BYTE PTR [ebp], 7
  002c7	75 74		 jne	 SHORT $LN2@EndpointDe

; 2001 :     {
; 2002 :         _snprintf(format,sizeof(format)-1,">   bInterval: 0x%02X",EndpointDesc->bInterval);

  002c9	0f b6 45 06	 movzx	 eax, BYTE PTR [ebp+6]
  002cd	50		 push	 eax
  002ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LPGMHCMJ@?$DO?5?5?5bInterval?3?50x?$CF02X?$AA@
  002d3	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1080]
  002d7	68 ff 03 00 00	 push	 1023			; 000003ffH
  002dc	51		 push	 ecx
  002dd	e8 00 00 00 00	 call	 __snprintf

; 2003 :         PushBackDetails(format);

  002e2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002e5	8b ec		 mov	 ebp, esp
  002e7	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  002eb	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  002f2	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  002f5	89 64 24 34	 mov	 DWORD PTR $T224800[esp+1100], esp
  002f9	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  002fc	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  002ff	90		 npad	 1
$LL279@EndpointDe:
  00300	8a 08		 mov	 cl, BYTE PTR [eax]
  00302	40		 inc	 eax
  00303	3a cb		 cmp	 cl, bl
  00305	75 f9		 jne	 SHORT $LL279@EndpointDe
  00307	2b c2		 sub	 eax, edx
  00309	50		 push	 eax
  0030a	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  0030e	52		 push	 edx
  0030f	8b cd		 mov	 ecx, ebp
  00311	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00316	c7 84 24 48 04
	00 00 08 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 8
  00321	89 bc 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], edi
  00328	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2004 :         memset(format,0x00,sizeof(format));

  0032d	68 00 04 00 00	 push	 1024			; 00000400H
  00332	53		 push	 ebx
  00333	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00337	50		 push	 eax

; 2005 :     }
; 2006 :     else

  00338	e9 ef 00 00 00	 jmp	 $LN284@EndpointDe
$LN2@EndpointDe:

; 2007 :     {
; 2008 :         PUSB_ENDPOINT_DESCRIPTOR2 endpointDesc2 = (PUSB_ENDPOINT_DESCRIPTOR2)EndpointDesc;
; 2009 : 
; 2010 :         _snprintf(format,sizeof(format)-1,">   wInterval: 0x%04X",endpointDesc2->wInterval);

  0033d	0f b7 4d 06	 movzx	 ecx, WORD PTR [ebp+6]
  00341	51		 push	 ecx
  00342	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HBLIDDIE@?$DO?5?5?5wInterval?3?50x?$CF04X?$AA@
  00347	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  0034b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00350	52		 push	 edx
  00351	e8 00 00 00 00	 call	 __snprintf

; 2011 :         PushBackDetails(format);

  00356	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00359	8b fc		 mov	 edi, esp
  0035b	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  0035f	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH
  00366	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  00369	89 64 24 34	 mov	 DWORD PTR $T224801[esp+1100], esp
  0036d	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  00370	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL280@EndpointDe:
  00373	8a 10		 mov	 dl, BYTE PTR [eax]
  00375	40		 inc	 eax
  00376	3a d3		 cmp	 dl, bl
  00378	75 f9		 jne	 SHORT $LL280@EndpointDe
  0037a	2b c1		 sub	 eax, ecx
  0037c	50		 push	 eax
  0037d	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  00381	50		 push	 eax
  00382	8b cf		 mov	 ecx, edi
  00384	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00389	c7 84 24 48 04
	00 00 09 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 9
  00394	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0039f	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2012 :         memset(format,0x00,sizeof(format));

  003a4	68 00 04 00 00	 push	 1024			; 00000400H
  003a9	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  003ad	53		 push	 ebx
  003ae	51		 push	 ecx
  003af	e8 00 00 00 00	 call	 _memset

; 2013 : 
; 2014 :         _snprintf(format,sizeof(format)-1,">   bSyncAddress: 0x%02X",endpointDesc2->bSyncAddress);

  003b4	0f b6 55 08	 movzx	 edx, BYTE PTR [ebp+8]
  003b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003bb	52		 push	 edx
  003bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CECFOBBD@?$DO?5?5?5bSyncAddress?3?50x?$CF02X?$AA@
  003c1	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  003c5	68 ff 03 00 00	 push	 1023			; 000003ffH
  003ca	50		 push	 eax
  003cb	e8 00 00 00 00	 call	 __snprintf

; 2015 :         PushBackDetails(format);

  003d0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003d3	8b fc		 mov	 edi, esp
  003d5	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  003d9	c7 47 18 0f 00
	00 00		 mov	 DWORD PTR [edi+24], 15	; 0000000fH
  003e0	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  003e3	89 64 24 34	 mov	 DWORD PTR $T224802[esp+1100], esp
  003e7	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  003ea	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]
  003ed	8d 49 00	 npad	 3
$LL281@EndpointDe:
  003f0	8a 08		 mov	 cl, BYTE PTR [eax]
  003f2	40		 inc	 eax
  003f3	3a cb		 cmp	 cl, bl
  003f5	75 f9		 jne	 SHORT $LL281@EndpointDe
  003f7	2b c5		 sub	 eax, ebp
  003f9	50		 push	 eax
  003fa	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  003fe	51		 push	 ecx
  003ff	8b cf		 mov	 ecx, edi
  00401	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00406	c7 84 24 48 04
	00 00 0a 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 10 ; 0000000aH
  00411	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0041c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 2016 :         memset(format,0x00,sizeof(format));

  00421	68 00 04 00 00	 push	 1024			; 00000400H
  00426	53		 push	 ebx
  00427	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  0042b	52		 push	 edx
$LN284@EndpointDe:
  0042c	e8 00 00 00 00	 call	 _memset
  00431	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2017 :     }
; 2018 : 
; 2019 :     Log(LOG_DEBUG,__LINE__,"<< USB.EndpointDesc");

  00434	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KDOIKLAK@?$DM?$DM?5USB?4EndpointDesc?$AA@
  00439	68 e3 07 00 00	 push	 2019			; 000007e3H
  0043e	6a 10		 push	 16			; 00000010H
  00440	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00445	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2020 : }

  00448	8b 8c 24 24 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1072]
  0044f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00456	59		 pop	 ecx
  00457	5f		 pop	 edi
  00458	5e		 pop	 esi
  00459	5d		 pop	 ebp
  0045a	5b		 pop	 ebx
  0045b	8b 8c 24 08 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1052]
  00462	33 cc		 xor	 ecx, esp
  00464	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00469	81 c4 1c 04 00
	00		 add	 esp, 1052		; 0000041cH
  0046f	c2 04 00	 ret	 4
  00472	8b ff		 npad	 2
$LN285@EndpointDe:
  00474	00 00 00 00	 DD	 $LN6@EndpointDe
  00478	00 00 00 00	 DD	 $LN5@EndpointDe
  0047c	00 00 00 00	 DD	 $LN4@EndpointDe
  00480	00 00 00 00	 DD	 $LN3@EndpointDe
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$0:
  00000	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224792[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$1:
  0000b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224793[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$2:
  00016	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224794[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$3:
  00021	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224795[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$4:
  0002c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224796[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$5:
  00037	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224797[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$6:
  00042	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224798[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$7:
  0004d	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224799[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$8:
  00058	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224800[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$9:
  00063	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224801[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z$10:
  0006e	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T224802[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z:
  00079	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0007d	8d 82 e0 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1056]
  00083	8b 8a dc fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1060]
  00089	33 c8		 xor	 ecx, eax
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	83 c0 10	 add	 eax, 16			; 00000010H
  00093	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00096	33 c8		 xor	 ecx, eax
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z
  000a2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z ENDP ; USB::EndpointDescriptor
PUBLIC	_StringDescs$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::InterfaceDescriptor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$8
__ehfuncinfo$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
_TEXT	SEGMENT
$T225862 = -1048					; size = 4
$T225861 = -1048					; size = 4
$T225860 = -1048					; size = 4
$T225859 = -1048					; size = 4
$T225852 = -1048					; size = 4
$T225845 = -1048					; size = 4
$T225844 = -1048					; size = 4
$T225843 = -1048					; size = 4
$T225842 = -1048					; size = 4
_StringDescs$GSCopy$ = -1044				; size = 4
_format$ = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_StringDescs$ = 12					; size = 4
?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z PROC ; USB::InterfaceDescriptor, COMDAT
; _InterfaceDesc$ = edi

; 1891 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 0c 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1052], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c4		 xor	 eax, esp
  0002c	50		 push	 eax
  0002d	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1068]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	8b ac 24 30 04
	00 00		 mov	 ebp, DWORD PTR _this$[esp+1064]
  00041	8b 84 24 34 04
	00 00		 mov	 eax, DWORD PTR _StringDescs$[esp+1064]

; 1892 :     char format[1024] = {0};

  00048	33 db		 xor	 ebx, ebx
  0004a	68 ff 03 00 00	 push	 1023			; 000003ffH
  0004f	8d 4c 24 21	 lea	 ecx, DWORD PTR _format$[esp+1073]
  00053	53		 push	 ebx
  00054	51		 push	 ecx

; 1947 :         PushBackDetails(format);

  00055	89 44 24 24	 mov	 DWORD PTR _StringDescs$GSCopy$[esp+1080], eax
  00059	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1080], bl
  0005d	e8 00 00 00 00	 call	 _memset
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FGFFFEAJ@?$DO?$DO?5USB?4InterfaceDesc?$AA@
  0006a	68 66 07 00 00	 push	 1894			; 00000766H
  0006f	6a 10		 push	 16			; 00000010H
  00071	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00076	83 ec 10	 sub	 esp, 16			; 00000010H
  00079	8b cc		 mov	 ecx, esp
  0007b	89 64 24 30	 mov	 DWORD PTR $T225842[esp+1096], esp
  0007f	6a 17		 push	 23			; 00000017H
  00081	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00088	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FGHPJGGP@?$DO?5Interface?5Descriptor?3?$AA@
  00090	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00093	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00098	89 9c 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebx
  0009f	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  000aa	8b f5		 mov	 esi, ebp
  000ac	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  000b1	0f b6 57 02	 movzx	 edx, BYTE PTR [edi+2]
  000b5	52		 push	 edx
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@ONGOLDBE@?$DO?5?5?5bInterfaceNumber?3?50x?$CF02X?$AA@
  000bb	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1076]
  000bf	68 ff 03 00 00	 push	 1023			; 000003ffH
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 __snprintf
  000ca	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000cd	8b f4		 mov	 esi, esp
  000cf	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  000d3	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  000da	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000dd	89 64 24 30	 mov	 DWORD PTR $T225843[esp+1096], esp
  000e1	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  000e4	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL352@InterfaceD:
  000e7	8a 10		 mov	 dl, BYTE PTR [eax]
  000e9	40		 inc	 eax
  000ea	3a d3		 cmp	 dl, bl
  000ec	75 f9		 jne	 SHORT $LL352@InterfaceD
  000ee	2b c1		 sub	 eax, ecx
  000f0	50		 push	 eax
  000f1	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1100]
  000f5	51		 push	 ecx
  000f6	8b ce		 mov	 ecx, esi
  000f8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000fd	c7 84 24 44 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 1
  00108	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  00113	8b f5		 mov	 esi, ebp
  00115	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  0011a	68 00 04 00 00	 push	 1024			; 00000400H
  0011f	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1072]
  00123	53		 push	 ebx
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 _memset
  0012a	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0012e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00131	50		 push	 eax
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JANOLKEO@?$DO?5?5?5bAlternateSetting?3?50x?$CF02X?$AA@
  00137	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0013b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 __snprintf
  00146	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00149	8b f4		 mov	 esi, esp
  0014b	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  0014f	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00156	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00159	89 64 24 30	 mov	 DWORD PTR $T225844[esp+1096], esp
  0015d	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00160	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL353@InterfaceD:
  00163	8a 10		 mov	 dl, BYTE PTR [eax]
  00165	40		 inc	 eax
  00166	3a d3		 cmp	 dl, bl
  00168	75 f9		 jne	 SHORT $LL353@InterfaceD
  0016a	2b c1		 sub	 eax, ecx
  0016c	50		 push	 eax
  0016d	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1100]
  00171	52		 push	 edx
  00172	8b ce		 mov	 ecx, esi
  00174	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00179	c7 84 24 44 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 2
  00184	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0018f	8b f5		 mov	 esi, ebp
  00191	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  00196	68 00 04 00 00	 push	 1024			; 00000400H
  0019b	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1072]
  0019f	53		 push	 ebx
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 _memset
  001a6	0f b6 4f 04	 movzx	 ecx, BYTE PTR [edi+4]
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ad	51		 push	 ecx
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EHJBAMGD@?$DO?5?5?5bNumEndpoints?3?50x?$CF02X?$AA@
  001b3	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1076]
  001b7	68 ff 03 00 00	 push	 1023			; 000003ffH
  001bc	52		 push	 edx
  001bd	e8 00 00 00 00	 call	 __snprintf
  001c2	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c5	8b f4		 mov	 esi, esp
  001c7	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  001cb	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  001d2	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  001d5	89 64 24 30	 mov	 DWORD PTR $T225845[esp+1096], esp
  001d9	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  001dc	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  001df	90		 npad	 1
$LL354@InterfaceD:
  001e0	8a 10		 mov	 dl, BYTE PTR [eax]
  001e2	40		 inc	 eax
  001e3	3a d3		 cmp	 dl, bl
  001e5	75 f9		 jne	 SHORT $LL354@InterfaceD
  001e7	2b c1		 sub	 eax, ecx
  001e9	50		 push	 eax
  001ea	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1100]
  001ee	50		 push	 eax
  001ef	8b ce		 mov	 ecx, esi
  001f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  001f6	c7 84 24 44 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 3
  00201	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0020c	8b f5		 mov	 esi, ebp
  0020e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  00213	68 00 04 00 00	 push	 1024			; 00000400H
  00218	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1072]
  0021c	53		 push	 ebx
  0021d	51		 push	 ecx
  0021e	e8 00 00 00 00	 call	 _memset
  00223	8a 47 05	 mov	 al, BYTE PTR [edi+5]
  00226	83 c4 0c	 add	 esp, 12			; 0000000cH
  00229	3c 01		 cmp	 al, 1
  0022b	75 07		 jne	 SHORT $LN11@InterfaceD

; 1893 : 
; 1894 :     Log(LOG_DEBUG,__LINE__,">> USB.InterfaceDesc");
; 1895 : 
; 1896 :     PushBackDetails("> Interface Descriptor:");
; 1897 : 
; 1898 :     _snprintf(format,sizeof(format)-1,">   bInterfaceNumber: 0x%02X",InterfaceDesc->bInterfaceNumber);
; 1899 :     PushBackDetails(format);
; 1900 :     memset(format,0x00,sizeof(format));
; 1901 : 
; 1902 :     _snprintf(format,sizeof(format)-1,">   bAlternateSetting: 0x%02X",InterfaceDesc->bAlternateSetting);
; 1903 :     PushBackDetails(format);
; 1904 :     memset(format,0x00,sizeof(format));
; 1905 : 
; 1906 :     _snprintf(format,sizeof(format)-1,">   bNumEndpoints: 0x%02X",InterfaceDesc->bNumEndpoints);
; 1907 :     PushBackDetails(format);
; 1908 :     memset(format,0x00,sizeof(format));
; 1909 : 
; 1910 :     _snprintf(format,sizeof(format)-1,">   bInterfaceClass: 0x%02X (%s)",InterfaceDesc->bInterfaceClass,
; 1911 :                      (InterfaceDesc->bInterfaceClass==USB_DEVICE_CLASS_AUDIO?"Audio":
; 1912 :                       (InterfaceDesc->bInterfaceClass==USB_DEVICE_CLASS_HUMAN_INTERFACE?"HID":
; 1913 :                        (InterfaceDesc->bInterfaceClass==USB_DEVICE_CLASS_HUB?"Hub":"?"))));

  0022d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05KKCMAPLJ@Audio?$AA@
  00232	eb 19		 jmp	 SHORT $LN8@InterfaceD
$LN11@InterfaceD:
  00234	3c 03		 cmp	 al, 3
  00236	75 07		 jne	 SHORT $LN9@InterfaceD
  00238	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03GLEFGMHP@HID?$AA@
  0023d	eb 0e		 jmp	 SHORT $LN8@InterfaceD
$LN9@InterfaceD:
  0023f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03IFOKPDKP@Hub?$AA@
  00244	3c 09		 cmp	 al, 9
  00246	74 05		 je	 SHORT $LN8@InterfaceD
  00248	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
$LN8@InterfaceD:
  0024d	51		 push	 ecx
  0024e	0f b6 d0	 movzx	 edx, al
  00251	52		 push	 edx
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KPEKNPLO@?$DO?5?5?5bInterfaceClass?3?50x?$CF02X?5?$CI?$CFs?$CJ@
  00257	8d 44 24 28	 lea	 eax, DWORD PTR _format$[esp+1080]
  0025b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00260	50		 push	 eax
  00261	e8 00 00 00 00	 call	 __snprintf

; 1914 :     PushBackDetails(format);

  00266	83 ec 08	 sub	 esp, 8
  00269	8b f4		 mov	 esi, esp
  0026b	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  0026f	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00276	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00279	89 64 24 30	 mov	 DWORD PTR $T225852[esp+1096], esp
  0027d	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00280	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL355@InterfaceD:
  00283	8a 10		 mov	 dl, BYTE PTR [eax]
  00285	40		 inc	 eax
  00286	3a d3		 cmp	 dl, bl
  00288	75 f9		 jne	 SHORT $LL355@InterfaceD
  0028a	2b c1		 sub	 eax, ecx
  0028c	50		 push	 eax
  0028d	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1100]
  00291	51		 push	 ecx
  00292	8b ce		 mov	 ecx, esi
  00294	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00299	c7 84 24 44 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 4
  002a4	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  002af	8b f5		 mov	 esi, ebp
  002b1	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1915 :     memset(format,0x00,sizeof(format));

  002b6	68 00 04 00 00	 push	 1024			; 00000400H
  002bb	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1072]
  002bf	53		 push	 ebx
  002c0	52		 push	 edx
  002c1	e8 00 00 00 00	 call	 _memset
  002c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1916 : 
; 1917 :     if(InterfaceDesc->bInterfaceClass==USB_DEVICE_CLASS_AUDIO)

  002c9	80 7f 05 01	 cmp	 BYTE PTR [edi+5], 1
  002cd	75 45		 jne	 SHORT $LN4@InterfaceD

; 1918 :     {
; 1919 :         _snprintf(format,sizeof(format)-1,">   bInterfaceSubClass: 0x%02X (%s)",InterfaceDesc->bInterfaceSubClass,
; 1920 :                          (InterfaceDesc->bInterfaceSubClass==USB_AUDIO_SUBCLASS_AUDIOCONTROL?"Audio Control":
; 1921 :                           (InterfaceDesc->bInterfaceSubClass==USB_AUDIO_SUBCLASS_AUDIOSTREAMING?"Audio Streaming":
; 1922 :                            (InterfaceDesc->bInterfaceSubClass==USB_AUDIO_SUBCLASS_MIDISTREAMING?"MIDI Streaming":"?"))));

  002cf	8a 47 06	 mov	 al, BYTE PTR [edi+6]
  002d2	3c 01		 cmp	 al, 1
  002d4	75 07		 jne	 SHORT $LN17@InterfaceD
  002d6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0O@FIEMGMDK@Audio?5Control?$AA@
  002db	eb 19		 jmp	 SHORT $LN14@InterfaceD
$LN17@InterfaceD:
  002dd	3c 02		 cmp	 al, 2
  002df	75 07		 jne	 SHORT $LN15@InterfaceD
  002e1	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BA@CCICINDB@Audio?5Streaming?$AA@
  002e6	eb 0e		 jmp	 SHORT $LN14@InterfaceD
$LN15@InterfaceD:
  002e8	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0P@ODBCJCKO@MIDI?5Streaming?$AA@
  002ed	3c 03		 cmp	 al, 3
  002ef	74 05		 je	 SHORT $LN14@InterfaceD
  002f1	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
$LN14@InterfaceD:
  002f6	51		 push	 ecx
  002f7	0f b6 c0	 movzx	 eax, al
  002fa	50		 push	 eax
  002fb	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PEKAFJHJ@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?5?$CI@
  00300	8d 4c 24 28	 lea	 ecx, DWORD PTR _format$[esp+1080]
  00304	68 ff 03 00 00	 push	 1023			; 000003ffH
  00309	51		 push	 ecx
  0030a	e8 00 00 00 00	 call	 __snprintf
  0030f	83 c4 14	 add	 esp, 20			; 00000014H

; 1923 :     }
; 1924 :     else

  00312	eb 1c		 jmp	 SHORT $LN3@InterfaceD
$LN4@InterfaceD:

; 1925 :         _snprintf(format,sizeof(format)-1,">   bInterfaceSubClass: 0x%02X",InterfaceDesc->bInterfaceSubClass);

  00314	0f b6 57 06	 movzx	 edx, BYTE PTR [edi+6]
  00318	52		 push	 edx
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@MCCALMMN@?$DO?5?5?5bInterfaceSubClass?3?50x?$CF02X?$AA@
  0031e	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1076]
  00322	68 ff 03 00 00	 push	 1023			; 000003ffH
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 __snprintf
  0032d	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@InterfaceD:

; 1926 :     PushBackDetails(format);

  00330	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00333	8b f4		 mov	 esi, esp
  00335	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00339	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  00340	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00343	89 64 24 30	 mov	 DWORD PTR $T225859[esp+1096], esp
  00347	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  0034a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0034d	8d 49 00	 npad	 3
$LL356@InterfaceD:
  00350	8a 10		 mov	 dl, BYTE PTR [eax]
  00352	40		 inc	 eax
  00353	3a d3		 cmp	 dl, bl
  00355	75 f9		 jne	 SHORT $LL356@InterfaceD
  00357	2b c1		 sub	 eax, ecx
  00359	50		 push	 eax
  0035a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1100]
  0035e	51		 push	 ecx
  0035f	8b ce		 mov	 ecx, esi
  00361	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00366	c7 84 24 44 04
	00 00 05 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 5
  00371	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0037c	8b f5		 mov	 esi, ebp
  0037e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1927 :     memset(format,0x00,sizeof(format));

  00383	68 00 04 00 00	 push	 1024			; 00000400H
  00388	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1072]
  0038c	53		 push	 ebx
  0038d	52		 push	 edx
  0038e	e8 00 00 00 00	 call	 _memset

; 1928 : 
; 1929 :     _snprintf(format,sizeof(format)-1,">   bInterfaceProtocol: 0x%02X",InterfaceDesc->bInterfaceProtocol);

  00393	0f b6 47 07	 movzx	 eax, BYTE PTR [edi+7]
  00397	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039a	50		 push	 eax
  0039b	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HNOOPNHM@?$DO?5?5?5bInterfaceProtocol?3?50x?$CF02X?$AA@
  003a0	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1076]
  003a4	68 ff 03 00 00	 push	 1023			; 000003ffH
  003a9	51		 push	 ecx
  003aa	e8 00 00 00 00	 call	 __snprintf

; 1930 :     PushBackDetails(format);

  003af	83 ec 0c	 sub	 esp, 12			; 0000000cH
  003b2	8b f4		 mov	 esi, esp
  003b4	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  003b8	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  003bf	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  003c2	89 64 24 30	 mov	 DWORD PTR $T225860[esp+1096], esp
  003c6	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  003c9	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  003cc	8d 64 24 00	 npad	 4
$LL357@InterfaceD:
  003d0	8a 10		 mov	 dl, BYTE PTR [eax]
  003d2	40		 inc	 eax
  003d3	3a d3		 cmp	 dl, bl
  003d5	75 f9		 jne	 SHORT $LL357@InterfaceD
  003d7	2b c1		 sub	 eax, ecx
  003d9	50		 push	 eax
  003da	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1100]
  003de	52		 push	 edx
  003df	8b ce		 mov	 ecx, esi
  003e1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  003e6	c7 84 24 44 04
	00 00 06 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 6
  003f1	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  003fc	8b f5		 mov	 esi, ebp
  003fe	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1931 :     memset(format,0x00,sizeof(format));

  00403	68 00 04 00 00	 push	 1024			; 00000400H
  00408	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1072]
  0040c	53		 push	 ebx
  0040d	50		 push	 eax
  0040e	e8 00 00 00 00	 call	 _memset

; 1932 : 
; 1933 :     _snprintf(format,sizeof(format)-1,">   iInterface: 0x%02X",InterfaceDesc->iInterface);

  00413	0f b6 4f 08	 movzx	 ecx, BYTE PTR [edi+8]
  00417	83 c4 0c	 add	 esp, 12			; 0000000cH
  0041a	51		 push	 ecx
  0041b	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@JAJKJCLD@?$DO?5?5?5iInterface?3?50x?$CF02X?$AA@
  00420	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1076]
  00424	68 ff 03 00 00	 push	 1023			; 000003ffH
  00429	52		 push	 edx
  0042a	e8 00 00 00 00	 call	 __snprintf

; 1934 :     PushBackDetails(format);

  0042f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00432	8b f4		 mov	 esi, esp
  00434	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00438	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0043f	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00442	89 64 24 30	 mov	 DWORD PTR $T225861[esp+1096], esp
  00446	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00449	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0044c	8d 64 24 00	 npad	 4
$LL358@InterfaceD:
  00450	8a 10		 mov	 dl, BYTE PTR [eax]
  00452	40		 inc	 eax
  00453	3a d3		 cmp	 dl, bl
  00455	75 f9		 jne	 SHORT $LL358@InterfaceD
  00457	2b c1		 sub	 eax, ecx
  00459	50		 push	 eax
  0045a	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1100]
  0045e	50		 push	 eax
  0045f	8b ce		 mov	 ecx, esi
  00461	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00466	c7 84 24 44 04
	00 00 07 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 7
  00471	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0047c	8b f5		 mov	 esi, ebp
  0047e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1935 :     memset(format,0x00,sizeof(format));

  00483	68 00 04 00 00	 push	 1024			; 00000400H
  00488	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1072]
  0048c	53		 push	 ebx
  0048d	51		 push	 ecx
  0048e	e8 00 00 00 00	 call	 _memset

; 1936 : 
; 1937 :     if (InterfaceDesc->iInterface)

  00493	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  00497	83 c4 0c	 add	 esp, 12			; 0000000cH
  0049a	3a c3		 cmp	 al, bl
  0049c	74 0b		 je	 SHORT $LN2@InterfaceD

; 1938 :     {
; 1939 :         StringDescriptor(InterfaceDesc->iInterface,StringDescs);

  0049e	8b 4c 24 18	 mov	 ecx, DWORD PTR _StringDescs$GSCopy$[esp+1068]
  004a2	50		 push	 eax
  004a3	55		 push	 ebp
  004a4	e8 00 00 00 00	 call	 ?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::StringDescriptor
$LN2@InterfaceD:

; 1940 :     }
; 1941 : 
; 1942 :     if (InterfaceDesc->bLength == sizeof(USB_INTERFACE_DESCRIPTOR2))

  004a9	80 3f 0b	 cmp	 BYTE PTR [edi], 11	; 0000000bH
  004ac	75 7c		 jne	 SHORT $LN1@InterfaceD

; 1943 :     {
; 1944 :         PUSB_INTERFACE_DESCRIPTOR2 interfaceDesc2 = (PUSB_INTERFACE_DESCRIPTOR2)InterfaceDesc;
; 1945 : 
; 1946 :         _snprintf(format,sizeof(format)-1,">   wNumClasses: 0x%04X",interfaceDesc2->wNumClasses);

  004ae	0f b7 57 09	 movzx	 edx, WORD PTR [edi+9]
  004b2	52		 push	 edx
  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MFPCCAIN@?$DO?5?5?5wNumClasses?3?50x?$CF04X?$AA@
  004b8	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1076]
  004bc	68 ff 03 00 00	 push	 1023			; 000003ffH
  004c1	50		 push	 eax
  004c2	e8 00 00 00 00	 call	 __snprintf

; 1947 :         PushBackDetails(format);

  004c7	83 ec 0c	 sub	 esp, 12			; 0000000cH
  004ca	8b f4		 mov	 esi, esp
  004cc	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  004d0	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  004d7	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  004da	89 64 24 30	 mov	 DWORD PTR $T225862[esp+1096], esp
  004de	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  004e1	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL359@InterfaceD:
  004e4	8a 08		 mov	 cl, BYTE PTR [eax]
  004e6	40		 inc	 eax
  004e7	3a cb		 cmp	 cl, bl
  004e9	75 f9		 jne	 SHORT $LL359@InterfaceD
  004eb	2b c2		 sub	 eax, edx
  004ed	50		 push	 eax
  004ee	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1100]
  004f2	51		 push	 ecx
  004f3	8b ce		 mov	 ecx, esi
  004f5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  004fa	c7 84 24 44 04
	00 00 08 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 8
  00505	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  00510	8b f5		 mov	 esi, ebp
  00512	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1948 :         memset(format,0x00,sizeof(format));

  00517	68 00 04 00 00	 push	 1024			; 00000400H
  0051c	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1072]
  00520	53		 push	 ebx
  00521	52		 push	 edx
  00522	e8 00 00 00 00	 call	 _memset
  00527	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@InterfaceD:

; 1949 :     }
; 1950 : 
; 1951 :     Log(LOG_DEBUG,__LINE__,"<< USB.InterfaceDesc");

  0052a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HIFPCDPI@?$DM?$DM?5USB?4InterfaceDesc?$AA@
  0052f	68 9f 07 00 00	 push	 1951			; 0000079fH
  00534	6a 10		 push	 16			; 00000010H
  00536	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0053b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1952 : }

  0053e	8b 8c 24 20 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1068]
  00545	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0054c	59		 pop	 ecx
  0054d	5e		 pop	 esi
  0054e	5d		 pop	 ebp
  0054f	5b		 pop	 ebx
  00550	8b 8c 24 0c 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1052]
  00557	33 cc		 xor	 ecx, esp
  00559	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0055e	81 c4 1c 04 00
	00		 add	 esp, 1052		; 0000041cH
  00564	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$0:
  00000	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225842[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$1:
  0000b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225843[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$2:
  00016	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225844[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$3:
  00021	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225845[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$4:
  0002c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225852[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$5:
  00037	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225859[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$6:
  00042	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225860[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$7:
  0004d	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225861[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$8:
  00058	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T225862[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z:
  00063	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00067	8d 82 e4 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1052]
  0006d	8b 8a e0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1056]
  00073	33 c8		 xor	 ecx, eax
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0007d	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00080	33 c8		 xor	 ecx, eax
  00082	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00087	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
  0008c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ENDP ; USB::InterfaceDescriptor
PUBLIC	_StringDescs$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::ConfigurationDescriptor
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$6
__ehfuncinfo$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
_TEXT	SEGMENT
$T227200 = -1048					; size = 4
$T227199 = -1048					; size = 4
$T227192 = -1048					; size = 4
$T227191 = -1048					; size = 4
$T227190 = -1048					; size = 4
$T227189 = -1048					; size = 4
$T227188 = -1048					; size = 4
_StringDescs$GSCopy$ = -1044				; size = 4
_format$ = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_StringDescs$ = 12					; size = 4
?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z PROC ; USB::ConfigurationDescriptor, COMDAT
; _ConfigDesc$ = ecx

; 1846 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 08 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1048], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c4		 xor	 eax, esp
  0002d	50		 push	 eax
  0002e	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1068]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b ac 24 30 04
	00 00		 mov	 ebp, DWORD PTR _this$[esp+1064]
  00042	8b 84 24 34 04
	00 00		 mov	 eax, DWORD PTR _StringDescs$[esp+1064]

; 1847 :     char format[1024] = {0};

  00049	33 db		 xor	 ebx, ebx
  0004b	68 ff 03 00 00	 push	 1023			; 000003ffH
  00050	8b f9		 mov	 edi, ecx
  00052	8d 4c 24 21	 lea	 ecx, DWORD PTR _format$[esp+1073]
  00056	53		 push	 ebx
  00057	51		 push	 ecx

; 1883 :     PushBackDetails(format);

  00058	89 44 24 24	 mov	 DWORD PTR _StringDescs$GSCopy$[esp+1080], eax
  0005c	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1080], bl
  00060	e8 00 00 00 00	 call	 _memset
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KMFKJDAO@?$DO?$DO?5USB?4CfgDesc?$AA@
  0006d	68 39 07 00 00	 push	 1849			; 00000739H
  00072	6a 10		 push	 16			; 00000010H
  00074	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00079	83 ec 10	 sub	 esp, 16			; 00000010H
  0007c	8b cc		 mov	 ecx, esp
  0007e	89 64 24 30	 mov	 DWORD PTR $T227188[esp+1096], esp
  00082	6a 1b		 push	 27			; 0000001bH
  00084	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0008b	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PCIMCBFD@?$DO?5Configuration?5Descriptor?3?$AA@
  00093	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00096	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0009b	89 9c 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebx
  000a2	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  000ad	8b f5		 mov	 esi, ebp
  000af	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  000b4	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  000b8	52		 push	 edx
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JBGKFDNL@?$DO?5?5?5wTotalLength?3?50x?$CF04X?$AA@
  000be	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1076]
  000c2	68 ff 03 00 00	 push	 1023			; 000003ffH
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 __snprintf
  000cd	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d0	8b f4		 mov	 esi, esp
  000d2	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  000d6	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  000dd	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  000e0	89 64 24 30	 mov	 DWORD PTR $T227189[esp+1096], esp
  000e4	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  000e7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  000ea	8d 9b 00 00 00
	00		 npad	 6
$LL269@Configurat:
  000f0	8a 10		 mov	 dl, BYTE PTR [eax]
  000f2	40		 inc	 eax
  000f3	3a d3		 cmp	 dl, bl
  000f5	75 f9		 jne	 SHORT $LL269@Configurat
  000f7	2b c1		 sub	 eax, ecx
  000f9	50		 push	 eax
  000fa	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1100]
  000fe	51		 push	 ecx
  000ff	8b ce		 mov	 ecx, esi
  00101	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00106	c7 84 24 44 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 1
  00111	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0011c	8b f5		 mov	 esi, ebp
  0011e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  00123	68 00 04 00 00	 push	 1024			; 00000400H
  00128	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1072]
  0012c	53		 push	 ebx
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 _memset
  00133	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00137	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013a	50		 push	 eax
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@JNHEPBEN@?$DO?5?5?5bNumInterfaces?3?50x?$CF02X?$AA@
  00140	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1076]
  00144	68 ff 03 00 00	 push	 1023			; 000003ffH
  00149	51		 push	 ecx
  0014a	e8 00 00 00 00	 call	 __snprintf
  0014f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00152	8b f4		 mov	 esi, esp
  00154	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00158	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0015f	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00162	89 64 24 30	 mov	 DWORD PTR $T227190[esp+1096], esp
  00166	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00169	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0016c	8d 64 24 00	 npad	 4
$LL270@Configurat:
  00170	8a 10		 mov	 dl, BYTE PTR [eax]
  00172	40		 inc	 eax
  00173	3a d3		 cmp	 dl, bl
  00175	75 f9		 jne	 SHORT $LL270@Configurat
  00177	2b c1		 sub	 eax, ecx
  00179	50		 push	 eax
  0017a	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1100]
  0017e	52		 push	 edx
  0017f	8b ce		 mov	 ecx, esi
  00181	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00186	c7 84 24 44 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 2
  00191	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0019c	8b f5		 mov	 esi, ebp
  0019e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  001a3	68 00 04 00 00	 push	 1024			; 00000400H
  001a8	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1072]
  001ac	53		 push	 ebx
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 _memset
  001b3	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ba	51		 push	 ecx
  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KHMLNGHE@?$DO?5?5?5bConfigurationValue?3?50x?$CF02X?$AA@
  001c0	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1076]
  001c4	68 ff 03 00 00	 push	 1023			; 000003ffH
  001c9	52		 push	 edx
  001ca	e8 00 00 00 00	 call	 __snprintf
  001cf	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001d2	8b f4		 mov	 esi, esp
  001d4	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  001d8	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  001df	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  001e2	89 64 24 30	 mov	 DWORD PTR $T227191[esp+1096], esp
  001e6	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  001e9	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  001ec	8d 64 24 00	 npad	 4
$LL271@Configurat:
  001f0	8a 10		 mov	 dl, BYTE PTR [eax]
  001f2	40		 inc	 eax
  001f3	3a d3		 cmp	 dl, bl
  001f5	75 f9		 jne	 SHORT $LL271@Configurat
  001f7	2b c1		 sub	 eax, ecx
  001f9	50		 push	 eax
  001fa	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1100]
  001fe	50		 push	 eax
  001ff	8b ce		 mov	 ecx, esi
  00201	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00206	c7 84 24 44 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 3
  00211	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0021c	8b f5		 mov	 esi, ebp
  0021e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  00223	68 00 04 00 00	 push	 1024			; 00000400H
  00228	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1072]
  0022c	53		 push	 ebx
  0022d	51		 push	 ecx
  0022e	e8 00 00 00 00	 call	 _memset
  00233	0f b6 57 06	 movzx	 edx, BYTE PTR [edi+6]
  00237	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023a	52		 push	 edx
  0023b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MGNBONG@?$DO?5?5?5iConfiguration?3?50x?$CF02X?$AA@
  00240	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1076]
  00244	68 ff 03 00 00	 push	 1023			; 000003ffH
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 __snprintf
  0024f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00252	8b f4		 mov	 esi, esp
  00254	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00258	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0025f	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00262	89 64 24 30	 mov	 DWORD PTR $T227192[esp+1096], esp
  00266	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00269	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0026c	8d 64 24 00	 npad	 4
$LL272@Configurat:
  00270	8a 10		 mov	 dl, BYTE PTR [eax]
  00272	40		 inc	 eax
  00273	3a d3		 cmp	 dl, bl
  00275	75 f9		 jne	 SHORT $LL272@Configurat
  00277	2b c1		 sub	 eax, ecx
  00279	50		 push	 eax
  0027a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1100]
  0027e	51		 push	 ecx
  0027f	8b ce		 mov	 ecx, esi
  00281	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00286	c7 84 24 44 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 4
  00291	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  0029c	8b f5		 mov	 esi, ebp
  0029e	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
  002a3	68 00 04 00 00	 push	 1024			; 00000400H
  002a8	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1072]
  002ac	53		 push	 ebx
  002ad	52		 push	 edx
  002ae	e8 00 00 00 00	 call	 _memset
  002b3	0f b6 47 06	 movzx	 eax, BYTE PTR [edi+6]
  002b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  002ba	3a c3		 cmp	 al, bl
  002bc	74 0b		 je	 SHORT $LN1@Configurat
  002be	8b 4c 24 18	 mov	 ecx, DWORD PTR _StringDescs$GSCopy$[esp+1068]
  002c2	50		 push	 eax
  002c3	55		 push	 ebp
  002c4	e8 00 00 00 00	 call	 ?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::StringDescriptor
$LN1@Configurat:
  002c9	8a 4f 07	 mov	 cl, BYTE PTR [edi+7]
  002cc	84 c9		 test	 cl, cl
  002ce	79 07		 jns	 SHORT $LN8@Configurat

; 1848 : 
; 1849 :     Log(LOG_DEBUG,__LINE__,">> USB.CfgDesc");
; 1850 : 
; 1851 :     PushBackDetails("> Configuration Descriptor:");
; 1852 : 
; 1853 :     _snprintf(format,sizeof(format)-1,">   wTotalLength: 0x%04X",ConfigDesc->wTotalLength);
; 1854 :     PushBackDetails(format);
; 1855 :     memset(format,0x00,sizeof(format));
; 1856 : 
; 1857 :     _snprintf(format,sizeof(format)-1,">   bNumInterfaces: 0x%02X",ConfigDesc->bNumInterfaces);
; 1858 :     PushBackDetails(format);
; 1859 :     memset(format,0x00,sizeof(format));
; 1860 : 
; 1861 :     _snprintf(format,sizeof(format)-1,">   bConfigurationValue: 0x%02X",ConfigDesc->bConfigurationValue);
; 1862 :     PushBackDetails(format);
; 1863 :     memset(format,0x00,sizeof(format));
; 1864 : 
; 1865 :     _snprintf(format,sizeof(format)-1,">   iConfiguration: 0x%02X",ConfigDesc->iConfiguration);
; 1866 :     PushBackDetails(format);
; 1867 :     memset(format,0x00,sizeof(format));
; 1868 : 
; 1869 :     if (ConfigDesc->iConfiguration)
; 1870 :     {
; 1871 :         StringDescriptor(ConfigDesc->iConfiguration,StringDescs);
; 1872 :     }
; 1873 : 
; 1874 :     _snprintf(format,sizeof(format)-1,">   bmAttributes: 0x%02X (%s)",ConfigDesc->bmAttributes,
; 1875 :                      (ConfigDesc->bmAttributes & 0x80?"Bus Powered":
; 1876 :                       (ConfigDesc->bmAttributes & 0x40?"Self Powered":
; 1877 :                        (ConfigDesc->bmAttributes & 0x20?"Remote Wakeup":"?"))));

  002d0	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@KJBOJHIH@Bus?5Powered?$AA@
  002d5	eb 1b		 jmp	 SHORT $LN5@Configurat
$LN8@Configurat:
  002d7	f6 c1 40	 test	 cl, 64			; 00000040H
  002da	74 07		 je	 SHORT $LN6@Configurat
  002dc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@BBGKMOEA@Self?5Powered?$AA@
  002e1	eb 0f		 jmp	 SHORT $LN5@Configurat
$LN6@Configurat:
  002e3	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@CEMJPFOE@Remote?5Wakeup?$AA@
  002e8	f6 c1 20	 test	 cl, 32			; 00000020H
  002eb	75 05		 jne	 SHORT $LN5@Configurat
  002ed	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
$LN5@Configurat:
  002f2	50		 push	 eax
  002f3	0f b6 c1	 movzx	 eax, cl
  002f6	50		 push	 eax
  002f7	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@GBBHCHCO@?$DO?5?5?5bmAttributes?3?50x?$CF02X?5?$CI?$CFs?$CJ?$AA@
  002fc	8d 4c 24 28	 lea	 ecx, DWORD PTR _format$[esp+1080]
  00300	68 ff 03 00 00	 push	 1023			; 000003ffH
  00305	51		 push	 ecx
  00306	e8 00 00 00 00	 call	 __snprintf

; 1878 :     PushBackDetails(format);

  0030b	83 ec 08	 sub	 esp, 8
  0030e	8b f4		 mov	 esi, esp
  00310	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00314	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0031b	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0031e	89 64 24 30	 mov	 DWORD PTR $T227199[esp+1096], esp
  00322	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  00325	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL273@Configurat:
  00328	8a 10		 mov	 dl, BYTE PTR [eax]
  0032a	40		 inc	 eax
  0032b	3a d3		 cmp	 dl, bl
  0032d	75 f9		 jne	 SHORT $LL273@Configurat
  0032f	2b c1		 sub	 eax, ecx
  00331	50		 push	 eax
  00332	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1100]
  00336	52		 push	 edx
  00337	8b ce		 mov	 ecx, esi
  00339	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0033e	c7 84 24 44 04
	00 00 05 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 5
  00349	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  00354	8b f5		 mov	 esi, ebp
  00356	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1879 :     memset(format,0x00,sizeof(format));

  0035b	68 00 04 00 00	 push	 1024			; 00000400H
  00360	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1072]
  00364	53		 push	 ebx
  00365	50		 push	 eax
  00366	e8 00 00 00 00	 call	 _memset

; 1880 : 
; 1881 :     _snprintf(format,sizeof(format)-1,">   MaxPower: 0x%02X (%d mA)",ConfigDesc->MaxPower,
; 1882 :                                                                      ConfigDesc->MaxPower * 2);

  0036b	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  0036f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00372	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00375	51		 push	 ecx
  00376	50		 push	 eax
  00377	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@BADCCJC@?$DO?5?5?5MaxPower?3?50x?$CF02X?5?$CI?$CFd?5mA?$CJ?$AA@
  0037c	8d 54 24 28	 lea	 edx, DWORD PTR _format$[esp+1080]
  00380	68 ff 03 00 00	 push	 1023			; 000003ffH
  00385	52		 push	 edx
  00386	e8 00 00 00 00	 call	 __snprintf

; 1883 :     PushBackDetails(format);

  0038b	83 ec 08	 sub	 esp, 8
  0038e	8b f4		 mov	 esi, esp
  00390	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00394	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
  0039b	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  0039e	89 64 24 30	 mov	 DWORD PTR $T227200[esp+1096], esp
  003a2	88 5e 04	 mov	 BYTE PTR [esi+4], bl
  003a5	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
$LL274@Configurat:
  003a8	8a 08		 mov	 cl, BYTE PTR [eax]
  003aa	40		 inc	 eax
  003ab	3a cb		 cmp	 cl, bl
  003ad	75 f9		 jne	 SHORT $LL274@Configurat
  003af	2b c7		 sub	 eax, edi
  003b1	50		 push	 eax
  003b2	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1100]
  003b6	50		 push	 eax
  003b7	8b ce		 mov	 ecx, esi
  003b9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  003be	c7 84 24 44 04
	00 00 06 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 6
  003c9	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  003d4	8b f5		 mov	 esi, ebp
  003d6	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1884 :     memset(format,0x00,sizeof(format));

  003db	68 00 04 00 00	 push	 1024			; 00000400H
  003e0	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1072]
  003e4	53		 push	 ebx
  003e5	51		 push	 ecx
  003e6	e8 00 00 00 00	 call	 _memset
  003eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1885 : 
; 1886 :     Log(LOG_DEBUG,__LINE__,"<< USB.CfgDesc");

  003ee	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OFLCOGDC@?$DM?$DM?5USB?4CfgDesc?$AA@
  003f3	68 5e 07 00 00	 push	 1886			; 0000075eH
  003f8	6a 10		 push	 16			; 00000010H
  003fa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1887 : }

  00402	8b 8c 24 20 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1068]
  00409	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00410	59		 pop	 ecx
  00411	5f		 pop	 edi
  00412	5e		 pop	 esi
  00413	5d		 pop	 ebp
  00414	5b		 pop	 ebx
  00415	8b 8c 24 08 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1048]
  0041c	33 cc		 xor	 ecx, esp
  0041e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00423	81 c4 18 04 00
	00		 add	 esp, 1048		; 00000418H
  00429	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$0:
  00000	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227188[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$1:
  0000b	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227189[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$2:
  00016	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227190[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$3:
  00021	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227191[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$4:
  0002c	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227192[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$5:
  00037	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227199[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z$6:
  00042	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T227200[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z:
  0004d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00051	8d 82 e4 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1052]
  00057	8b 8a e0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1056]
  0005d	33 c8		 xor	 ecx, eax
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	83 c0 10	 add	 eax, 16			; 00000010H
  00067	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006a	33 c8		 xor	 ecx, eax
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
  00076	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ENDP ; USB::ConfigurationDescriptor
PUBLIC	?ConfigDesc@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::ConfigDesc
; Function compile flags: /Ogtpy
;	COMDAT ?ConfigDesc@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z
_TEXT	SEGMENT
_StringDescs$ = 8					; size = 4
?ConfigDesc@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z PROC ; USB::ConfigDesc, COMDAT
; _this$ = ebx
; _ConfigDesc$ = eax

; 1754 : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _StringDescs$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1755 :     PUCHAR                  descEnd = NULL;
; 1756 :     PUSB_COMMON_DESCRIPTOR  commonDesc = NULL;
; 1757 :     UCHAR                   bInterfaceClass;
; 1758 :     UCHAR                   bInterfaceSubClass;
; 1759 :     BOOL                    displayUnknown;
; 1760 : 
; 1761 :     Log(LOG_DEBUG,__LINE__,">> USB.ConnDesc");

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BANBJKNP@?$DO?$DO?5USB?4ConnDesc?$AA@
  0000d	68 e1 06 00 00	 push	 1761			; 000006e1H
  00012	6a 10		 push	 16			; 00000010H
  00014	8b f8		 mov	 edi, eax
  00016	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1762 : 
; 1763 :     if(!ConfigDesc)

  0001e	85 ff		 test	 edi, edi
  00020	75 1b		 jne	 SHORT $LN16@ConfigDesc

; 1764 :     {
; 1765 :         Log(LOG_DEBUG,__LINE__,"<< USB.ConnDesc, Input null");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HNNAHBOO@?$DM?$DM?5USB?4ConnDesc?0?5Input?5null?$AA@
  00027	68 e5 06 00 00	 push	 1765			; 000006e5H

; 1840 :     }
; 1841 :     Log(LOG_DEBUG,__LINE__,"<< USB.ConnDesc");

  0002c	6a 10		 push	 16			; 00000010H
  0002e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1842 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	59		 pop	 ecx
  0003a	c2 04 00	 ret	 4
$LN16@ConfigDesc:

; 1766 :         return;
; 1767 :     }
; 1768 : 
; 1769 :     bInterfaceClass = 0;
; 1770 : 
; 1771 :     descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

  0003d	0f b7 77 02	 movzx	 esi, WORD PTR [edi+2]
  00041	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00044	03 f7		 add	 esi, edi

; 1772 : 
; 1773 :     commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;
; 1774 : 
; 1775 :     while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
; 1776 :            (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)

  00046	3b c6		 cmp	 eax, esi
  00048	0f 83 7e 00 00
	00		 jae	 $LN20@ConfigDesc
  0004e	8b ff		 npad	 2
$LL15@ConfigDesc:
  00050	8a 07		 mov	 al, BYTE PTR [edi]
  00052	0f b6 c8	 movzx	 ecx, al
  00055	03 cf		 add	 ecx, edi
  00057	3b ce		 cmp	 ecx, esi
  00059	77 71		 ja	 SHORT $LN20@ConfigDesc

; 1777 :     {
; 1778 :         displayUnknown = FALSE;
; 1779 : 
; 1780 :         switch (commonDesc->bDescriptorType)

  0005b	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  0005f	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00062	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  00065	77 4c		 ja	 SHORT $LN3@ConfigDesc
  00067	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN23@ConfigDesc[ecx]
  0006e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN25@ConfigDesc[edx*4]
$LN11@ConfigDesc:

; 1781 :         {
; 1782 :             case USB_CONFIGURATION_DESCRIPTOR_TYPE:
; 1783 :                 if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))

  00075	3c 09		 cmp	 al, 9

; 1784 :                 {
; 1785 :                     displayUnknown = TRUE;
; 1786 :                     break;

  00077	75 3a		 jne	 SHORT $LN3@ConfigDesc

; 1787 :                 }
; 1788 :                 ConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc,StringDescs);

  00079	55		 push	 ebp
  0007a	53		 push	 ebx
  0007b	8b cf		 mov	 ecx, edi
  0007d	e8 00 00 00 00	 call	 ?ConfigurationDescriptor@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::ConfigurationDescriptor

; 1789 :                 break;

  00082	eb 35		 jmp	 SHORT $LN2@ConfigDesc
$LN9@ConfigDesc:

; 1790 : 
; 1791 :             case USB_INTERFACE_DESCRIPTOR_TYPE:
; 1792 :                 if ((commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR)) &&
; 1793 :                     (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR2)))

  00084	3c 09		 cmp	 al, 9
  00086	74 04		 je	 SHORT $LN8@ConfigDesc
  00088	3c 0b		 cmp	 al, 11			; 0000000bH

; 1794 :                 {
; 1795 :                     displayUnknown = TRUE;
; 1796 :                     break;

  0008a	75 27		 jne	 SHORT $LN3@ConfigDesc
$LN8@ConfigDesc:

; 1797 :                 }
; 1798 :                 bInterfaceClass = ((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceClass;
; 1799 :                 bInterfaceSubClass = ((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceSubClass;
; 1800 : 
; 1801 :                 InterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc,StringDescs);

  0008c	55		 push	 ebp
  0008d	53		 push	 ebx
  0008e	e8 00 00 00 00	 call	 ?InterfaceDescriptor@USB@@IAEXPAU_USB_INTERFACE_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::InterfaceDescriptor

; 1802 :                 break;

  00093	eb 24		 jmp	 SHORT $LN2@ConfigDesc
$LN7@ConfigDesc:

; 1803 : 
; 1804 :             case USB_ENDPOINT_DESCRIPTOR_TYPE:
; 1805 :                 if ((commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR)) &&
; 1806 :                     (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR2)))

  00095	3c 07		 cmp	 al, 7
  00097	74 04		 je	 SHORT $LN6@ConfigDesc
  00099	3c 09		 cmp	 al, 9

; 1807 :                 {
; 1808 :                     displayUnknown = TRUE;
; 1809 :                     break;

  0009b	75 16		 jne	 SHORT $LN3@ConfigDesc
$LN6@ConfigDesc:

; 1810 :                 }
; 1811 :                 EndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);

  0009d	57		 push	 edi
  0009e	8b cb		 mov	 ecx, ebx
  000a0	e8 00 00 00 00	 call	 ?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z ; USB::EndpointDescriptor

; 1812 :                 break;

  000a5	eb 12		 jmp	 SHORT $LN2@ConfigDesc
$LN5@ConfigDesc:

; 1813 : 
; 1814 :             case USB_HID_DESCRIPTOR_TYPE:
; 1815 :                 if (commonDesc->bLength < sizeof(USB_HID_DESCRIPTOR))

  000a7	3c 09		 cmp	 al, 9

; 1816 :                 {
; 1817 :                     displayUnknown = TRUE;
; 1818 :                     break;

  000a9	72 08		 jb	 SHORT $LN3@ConfigDesc

; 1819 :                 }
; 1820 :                 HidDescriptor((PUSB_HID_DESCRIPTOR)commonDesc);

  000ab	53		 push	 ebx
  000ac	e8 00 00 00 00	 call	 ?HidDescriptor@USB@@IAEXPAU_USB_HID_DESCRIPTOR@@@Z ; USB::HidDescriptor

; 1821 :                 break;

  000b1	eb 06		 jmp	 SHORT $LN2@ConfigDesc
$LN3@ConfigDesc:

; 1822 : 
; 1823 :             default:
; 1824 :                 //if(bInterfaceClass==USB_DEVICE_CLASS_AUDIO)
; 1825 :                 //    displayUnknown = !AudioDescriptor((PUSB_AUDIO_COMMON_DESCRIPTOR)commonDesc,bInterfaceSubClass);
; 1826 :                 //else
; 1827 :                     displayUnknown = TRUE;
; 1828 :                 break;
; 1829 :         }
; 1830 : 
; 1831 :         if (displayUnknown)
; 1832 :         {
; 1833 :             UnknownDescriptor(commonDesc);

  000b3	53		 push	 ebx
  000b4	e8 00 00 00 00	 call	 ?UnknownDescriptor@USB@@IAEXPAU_USB_COMMON_DESCRIPTOR@@@Z ; USB::UnknownDescriptor
$LN2@ConfigDesc:

; 1834 :         }
; 1835 : 
; 1836 :         if(commonDesc->bLength==0x00)

  000b9	8a 07		 mov	 al, BYTE PTR [edi]
  000bb	84 c0		 test	 al, al
  000bd	74 0d		 je	 SHORT $LN20@ConfigDesc

; 1837 :             break;  //no more data
; 1838 : 
; 1839 :         commonDesc += commonDesc->bLength;

  000bf	0f b6 c0	 movzx	 eax, al
  000c2	8d 3c 47	 lea	 edi, DWORD PTR [edi+eax*2]
  000c5	8d 4f 02	 lea	 ecx, DWORD PTR [edi+2]
  000c8	3b ce		 cmp	 ecx, esi
  000ca	72 84		 jb	 SHORT $LL15@ConfigDesc
$LN20@ConfigDesc:

; 1840 :     }
; 1841 :     Log(LOG_DEBUG,__LINE__,"<< USB.ConnDesc");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DPPHAOCN@?$DM?$DM?5USB?4ConnDesc?$AA@
  000d1	68 31 07 00 00	 push	 1841			; 00000731H
  000d6	6a 10		 push	 16			; 00000010H
  000d8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1842 : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5d		 pop	 ebp
  000e3	59		 pop	 ecx
  000e4	c2 04 00	 ret	 4
  000e7	90		 npad	 1
$LN25@ConfigDesc:
  000e8	00 00 00 00	 DD	 $LN11@ConfigDesc
  000ec	00 00 00 00	 DD	 $LN9@ConfigDesc
  000f0	00 00 00 00	 DD	 $LN7@ConfigDesc
  000f4	00 00 00 00	 DD	 $LN5@ConfigDesc
  000f8	00 00 00 00	 DD	 $LN3@ConfigDesc
$LN23@ConfigDesc:
  000fc	00		 DB	 0
  000fd	04		 DB	 4
  000fe	01		 DB	 1
  000ff	02		 DB	 2
  00100	04		 DB	 4
  00101	04		 DB	 4
  00102	04		 DB	 4
  00103	04		 DB	 4
  00104	04		 DB	 4
  00105	04		 DB	 4
  00106	04		 DB	 4
  00107	04		 DB	 4
  00108	04		 DB	 4
  00109	04		 DB	 4
  0010a	04		 DB	 4
  0010b	04		 DB	 4
  0010c	04		 DB	 4
  0010d	04		 DB	 4
  0010e	04		 DB	 4
  0010f	04		 DB	 4
  00110	04		 DB	 4
  00111	04		 DB	 4
  00112	04		 DB	 4
  00113	04		 DB	 4
  00114	04		 DB	 4
  00115	04		 DB	 4
  00116	04		 DB	 4
  00117	04		 DB	 4
  00118	04		 DB	 4
  00119	04		 DB	 4
  0011a	04		 DB	 4
  0011b	03		 DB	 3
?ConfigDesc@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ENDP ; USB::ConfigDesc
_TEXT	ENDS
PUBLIC	?PipeInfo@USB@@IAEXKPAU_USB_PIPE_INFO@@@Z	; USB::PipeInfo
; Function compile flags: /Ogtpy
;	COMDAT ?PipeInfo@USB@@IAEXKPAU_USB_PIPE_INFO@@@Z
_TEXT	SEGMENT
_PipeInfo$ = 8						; size = 4
?PipeInfo@USB@@IAEXKPAU_USB_PIPE_INFO@@@Z PROC		; USB::PipeInfo, COMDAT
; _this$ = ebx
; _NumPipes$ = eax

; 1739 : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f8		 mov	 edi, eax

; 1740 :     ULONG i;
; 1741 : 
; 1742 :     Log(LOG_DEBUG,__LINE__,">> USB.PipeInfo, %u",NumPipes);

  00004	57		 push	 edi
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MPHLOHIN@?$DO?$DO?5USB?4PipeInfo?0?5?$CFu?$AA@
  0000a	68 ce 06 00 00	 push	 1742			; 000006ceH
  0000f	6a 10		 push	 16			; 00000010H
  00011	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 1743 :     for (i=0; i<NumPipes; i++)

  00019	85 ff		 test	 edi, edi
  0001b	76 14		 jbe	 SHORT $LN1@PipeInfo

; 1740 :     ULONG i;
; 1741 : 
; 1742 :     Log(LOG_DEBUG,__LINE__,">> USB.PipeInfo, %u",NumPipes);

  0001d	8b 74 24 0c	 mov	 esi, DWORD PTR _PipeInfo$[esp+4]
$LL3@PipeInfo:

; 1744 :     {
; 1745 :         EndpointDescriptor(&PipeInfo[i].EndpointDescriptor);

  00021	56		 push	 esi
  00022	8b cb		 mov	 ecx, ebx
  00024	e8 00 00 00 00	 call	 ?EndpointDescriptor@USB@@IAEXPAU_USB_ENDPOINT_DESCRIPTOR@@@Z ; USB::EndpointDescriptor
  00029	83 c6 0b	 add	 esi, 11			; 0000000bH
  0002c	83 ef 01	 sub	 edi, 1
  0002f	75 f0		 jne	 SHORT $LL3@PipeInfo
$LN1@PipeInfo:

; 1746 :     }
; 1747 :     Log(LOG_DEBUG,__LINE__,"<< USB.PipeInfo");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KIDKADGJ@?$DM?$DM?5USB?4PipeInfo?$AA@
  00036	68 d3 06 00 00	 push	 1747			; 000006d3H
  0003b	6a 10		 push	 16			; 00000010H
  0003d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1748 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	c2 04 00	 ret	 4
?PipeInfo@USB@@IAEXKPAU_USB_PIPE_INFO@@@Z ENDP		; USB::PipeInfo
_TEXT	ENDS
PUBLIC	_StringDescs$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::ConnectionInfo
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$21
__ehfuncinfo$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z
_TEXT	SEGMENT
$T228270 = -1052					; size = 4
$T228269 = -1052					; size = 4
$T228268 = -1052					; size = 4
$T228267 = -1052					; size = 4
$T228266 = -1052					; size = 4
$T228265 = -1052					; size = 4
$T228264 = -1052					; size = 4
$T228263 = -1052					; size = 4
$T228262 = -1052					; size = 4
$T228261 = -1052					; size = 4
$T228260 = -1052					; size = 4
$T228259 = -1052					; size = 4
$T228258 = -1052					; size = 4
$T228257 = -1052					; size = 4
$T228256 = -1052					; size = 4
$T228255 = -1052					; size = 4
$T228254 = -1052					; size = 4
$T228253 = -1052					; size = 4
$T228252 = -1052					; size = 4
$T228251 = -1052					; size = 4
$T228250 = -1052					; size = 4
_StringDescs$GSCopy$ = -1048				; size = 4
$T228249 = -1048					; size = 4
_format$ = -1044					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_StringDescs$ = 8					; size = 4
?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z PROC ; USB::ConnectionInfo, COMDAT
; _this$ = ecx
; _ConnectInfo$ = edx

; 1611 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 08 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1052], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c4		 xor	 eax, esp
  0002d	50		 push	 eax
  0002e	8d 84 24 24 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1072]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx
  0003d	8b 84 24 34 04
	00 00		 mov	 eax, DWORD PTR _StringDescs$[esp+1068]

; 1612 :     char format[1024] = {0};

  00044	33 db		 xor	 ebx, ebx
  00046	68 ff 03 00 00	 push	 1023			; 000003ffH
  0004b	8d 4c 24 21	 lea	 ecx, DWORD PTR _format$[esp+1077]
  0004f	53		 push	 ebx
  00050	51		 push	 ecx
  00051	8b fa		 mov	 edi, edx

; 1648 :         PushBackDetails(format);

  00053	89 44 24 24	 mov	 DWORD PTR _StringDescs$GSCopy$[esp+1084], eax
  00057	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1084], bl
  0005b	e8 00 00 00 00	 call	 _memset
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IJBIPHPI@?$DO?$DO?5USB?4ConnInfo?$AA@
  00068	68 4e 06 00 00	 push	 1614			; 0000064eH
  0006d	6a 10		 push	 16			; 00000010H
  0006f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	3b fb		 cmp	 edi, ebx
  00079	75 0f		 jne	 SHORT $LN13@Connection
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GIKFEJKI@?$DM?$DM?5USB?4ConnInfo?0?5Input?5null?$AA@
  00080	68 52 06 00 00	 push	 1618			; 00000652H
  00085	e9 36 09 00 00	 jmp	 $LN705@Connection
$LN13@Connection:

; 1613 : 
; 1614 :     Log(LOG_DEBUG,__LINE__,">> USB.ConnInfo");
; 1615 : 
; 1616 :     if(!ConnectInfo)
; 1617 :     {
; 1618 :         Log(LOG_DEBUG,__LINE__,"<< USB.ConnInfo, Input null");
; 1619 :         return;
; 1620 :     }
; 1621 : 
; 1622 :     if (ConnectInfo->ConnectionStatus == NoDeviceConnected)
; 1623 :     {
; 1624 :         PushBackDetails("> ConnectionStatus: NoDeviceConnected");

  0008a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0008d	39 5f 1f	 cmp	 DWORD PTR [edi+31], ebx
  00090	8b cc		 mov	 ecx, esp
  00092	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00099	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0009c	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  0009f	75 2c		 jne	 SHORT $LN12@Connection
  000a1	89 64 24 34	 mov	 DWORD PTR $T228249[esp+1100], esp
  000a5	6a 25		 push	 37			; 00000025H
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KIPJNEMD@?$DO?5ConnectionStatus?3?5NoDeviceConn@
  000ac	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000b1	89 9c 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], ebx
  000b8	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  000c3	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1625 :     }
; 1626 :     else

  000c8	e9 e9 08 00 00	 jmp	 $LN1@Connection
$LN12@Connection:

; 1627 :     {
; 1628 :         PushBackDetails("> Device Descriptor:");

  000cd	89 64 24 30	 mov	 DWORD PTR $T228250[esp+1100], esp
  000d1	6a 14		 push	 20			; 00000014H
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EPIIACIH@?$DO?5Device?5Descriptor?3?$AA@
  000d8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000dd	c7 84 24 48 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 1
  000e8	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  000f3	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1629 : 
; 1630 :         _snprintf(format,sizeof(format)-1,">   bcdUSB: 0x%04X",ConnectInfo->DeviceDescriptor.bcdUSB);

  000f8	0f b7 57 06	 movzx	 edx, WORD PTR [edi+6]
  000fc	52		 push	 edx
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EOGCPDGC@?$DO?5?5?5bcdUSB?3?50x?$CF04X?$AA@
  00102	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00106	68 ff 03 00 00	 push	 1023			; 000003ffH
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 __snprintf

; 1631 :         PushBackDetails(format);

  00111	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00114	8b ec		 mov	 ebp, esp
  00116	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  0011a	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00121	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00124	89 64 24 30	 mov	 DWORD PTR $T228251[esp+1100], esp
  00128	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  0012b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0012e	8b ff		 npad	 2
$LL686@Connection:
  00130	8a 10		 mov	 dl, BYTE PTR [eax]
  00132	40		 inc	 eax
  00133	3a d3		 cmp	 dl, bl
  00135	75 f9		 jne	 SHORT $LL686@Connection
  00137	2b c1		 sub	 eax, ecx
  00139	50		 push	 eax
  0013a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0013e	51		 push	 ecx
  0013f	8b cd		 mov	 ecx, ebp
  00141	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00146	c7 84 24 48 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 2
  00151	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0015c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1632 :         memset(format,0x00,sizeof(format));

  00161	68 00 04 00 00	 push	 1024			; 00000400H
  00166	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0016a	53		 push	 ebx
  0016b	52		 push	 edx
  0016c	e8 00 00 00 00	 call	 _memset

; 1633 : 
; 1634 :         _snprintf(format,sizeof(format)-1,">   bDeviceClass: 0x%02X",ConnectInfo->DeviceDescriptor.bDeviceClass);

  00171	0f b6 47 08	 movzx	 eax, BYTE PTR [edi+8]
  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
  00178	50		 push	 eax
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BBNICMHO@?$DO?5?5?5bDeviceClass?3?50x?$CF02X?$AA@
  0017e	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1080]
  00182	68 ff 03 00 00	 push	 1023			; 000003ffH
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 __snprintf

; 1635 :         PushBackDetails(format);

  0018d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00190	8b ec		 mov	 ebp, esp
  00192	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00196	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0019d	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  001a0	89 64 24 30	 mov	 DWORD PTR $T228252[esp+1100], esp
  001a4	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  001a7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  001aa	8d 9b 00 00 00
	00		 npad	 6
$LL687@Connection:
  001b0	8a 10		 mov	 dl, BYTE PTR [eax]
  001b2	40		 inc	 eax
  001b3	3a d3		 cmp	 dl, bl
  001b5	75 f9		 jne	 SHORT $LL687@Connection
  001b7	2b c1		 sub	 eax, ecx
  001b9	50		 push	 eax
  001ba	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  001be	52		 push	 edx
  001bf	8b cd		 mov	 ecx, ebp
  001c1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  001c6	c7 84 24 48 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 3
  001d1	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  001dc	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1636 :         memset(format,0x00,sizeof(format));

  001e1	68 00 04 00 00	 push	 1024			; 00000400H
  001e6	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  001ea	53		 push	 ebx
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _memset

; 1637 : 
; 1638 :         _snprintf(format,sizeof(format)-1,">   bDeviceSubClass: 0x%02X",ConnectInfo->DeviceDescriptor.bDeviceSubClass);

  001f1	0f b6 4f 09	 movzx	 ecx, BYTE PTR [edi+9]
  001f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f8	51		 push	 ecx
  001f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IBBMEPAK@?$DO?5?5?5bDeviceSubClass?3?50x?$CF02X?$AA@
  001fe	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  00202	68 ff 03 00 00	 push	 1023			; 000003ffH
  00207	52		 push	 edx
  00208	e8 00 00 00 00	 call	 __snprintf

; 1639 :         PushBackDetails(format);

  0020d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00210	8b ec		 mov	 ebp, esp
  00212	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00216	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0021d	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00220	89 64 24 30	 mov	 DWORD PTR $T228253[esp+1100], esp
  00224	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  00227	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0022a	8d 9b 00 00 00
	00		 npad	 6
$LL688@Connection:
  00230	8a 10		 mov	 dl, BYTE PTR [eax]
  00232	40		 inc	 eax
  00233	3a d3		 cmp	 dl, bl
  00235	75 f9		 jne	 SHORT $LL688@Connection
  00237	2b c1		 sub	 eax, ecx
  00239	50		 push	 eax
  0023a	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  0023e	50		 push	 eax
  0023f	8b cd		 mov	 ecx, ebp
  00241	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00246	c7 84 24 48 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 4
  00251	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0025c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1640 :         memset(format,0x00,sizeof(format));

  00261	68 00 04 00 00	 push	 1024			; 00000400H
  00266	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0026a	53		 push	 ebx
  0026b	51		 push	 ecx
  0026c	e8 00 00 00 00	 call	 _memset

; 1641 : 
; 1642 :         _snprintf(format,sizeof(format)-1,">   bDeviceProtocol: 0x%02X",ConnectInfo->DeviceDescriptor.bDeviceProtocol);

  00271	0f b6 57 0a	 movzx	 edx, BYTE PTR [edi+10]
  00275	83 c4 0c	 add	 esp, 12			; 0000000cH
  00278	52		 push	 edx
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DONCAOLL@?$DO?5?5?5bDeviceProtocol?3?50x?$CF02X?$AA@
  0027e	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00282	68 ff 03 00 00	 push	 1023			; 000003ffH
  00287	50		 push	 eax
  00288	e8 00 00 00 00	 call	 __snprintf

; 1643 :         PushBackDetails(format);

  0028d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00290	8b ec		 mov	 ebp, esp
  00292	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00296	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0029d	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  002a0	89 64 24 30	 mov	 DWORD PTR $T228254[esp+1100], esp
  002a4	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  002a7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  002aa	8d 9b 00 00 00
	00		 npad	 6
$LL689@Connection:
  002b0	8a 10		 mov	 dl, BYTE PTR [eax]
  002b2	40		 inc	 eax
  002b3	3a d3		 cmp	 dl, bl
  002b5	75 f9		 jne	 SHORT $LL689@Connection
  002b7	2b c1		 sub	 eax, ecx
  002b9	50		 push	 eax
  002ba	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  002be	51		 push	 ecx
  002bf	8b cd		 mov	 ecx, ebp
  002c1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  002c6	c7 84 24 48 04
	00 00 05 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 5
  002d1	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  002dc	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1644 :         memset(format,0x00,sizeof(format));

  002e1	68 00 04 00 00	 push	 1024			; 00000400H
  002e6	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  002ea	53		 push	 ebx
  002eb	52		 push	 edx
  002ec	e8 00 00 00 00	 call	 _memset

; 1645 : 
; 1646 :         _snprintf(format,sizeof(format)-1,">   bMaxPacketSize0: 0x%02X (%d)",ConnectInfo->DeviceDescriptor.bMaxPacketSize0,
; 1647 :                                                                              ConnectInfo->DeviceDescriptor.bMaxPacketSize0);

  002f1	0f b6 47 0b	 movzx	 eax, BYTE PTR [edi+11]
  002f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f8	50		 push	 eax
  002f9	50		 push	 eax
  002fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KJHHAJF@?$DO?5?5?5bMaxPacketSize0?3?50x?$CF02X?5?$CI?$CFd?$CJ@
  002ff	8d 44 24 28	 lea	 eax, DWORD PTR _format$[esp+1084]
  00303	68 ff 03 00 00	 push	 1023			; 000003ffH
  00308	50		 push	 eax
  00309	e8 00 00 00 00	 call	 __snprintf

; 1648 :         PushBackDetails(format);

  0030e	83 ec 08	 sub	 esp, 8
  00311	8b ec		 mov	 ebp, esp
  00313	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00317	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0031e	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00321	89 64 24 30	 mov	 DWORD PTR $T228255[esp+1100], esp
  00325	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  00328	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0032b	eb 03 8d 49 00	 npad	 5
$LL690@Connection:
  00330	8a 10		 mov	 dl, BYTE PTR [eax]
  00332	40		 inc	 eax
  00333	3a d3		 cmp	 dl, bl
  00335	75 f9		 jne	 SHORT $LL690@Connection
  00337	2b c1		 sub	 eax, ecx
  00339	50		 push	 eax
  0033a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0033e	51		 push	 ecx
  0033f	8b cd		 mov	 ecx, ebp
  00341	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00346	c7 84 24 48 04
	00 00 06 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 6
  00351	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0035c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1649 :         memset(format,0x00,sizeof(format));

  00361	68 00 04 00 00	 push	 1024			; 00000400H
  00366	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0036a	53		 push	 ebx
  0036b	52		 push	 edx
  0036c	e8 00 00 00 00	 call	 _memset

; 1650 : 
; 1651 :         _snprintf(format,sizeof(format)-1,">   idVendor: 0x%04X (%s)",ConnectInfo->DeviceDescriptor.idVendor,
; 1652 :                                                       GetVendorString(ConnectInfo->DeviceDescriptor.idVendor));

  00371	0f b7 6f 0c	 movzx	 ebp, WORD PTR [edi+12]
  00375	83 c4 0c	 add	 esp, 12			; 0000000cH
  00378	8b d5		 mov	 edx, ebp
  0037a	e8 00 00 00 00	 call	 ?GetVendorString@USB@@SAPADG@Z ; USB::GetVendorString
  0037f	50		 push	 eax
  00380	0f b7 c5	 movzx	 eax, bp
  00383	50		 push	 eax
  00384	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FCNKAGPN@?$DO?5?5?5idVendor?3?50x?$CF04X?5?$CI?$CFs?$CJ?$AA@
  00389	8d 4c 24 28	 lea	 ecx, DWORD PTR _format$[esp+1084]
  0038d	68 ff 03 00 00	 push	 1023			; 000003ffH
  00392	51		 push	 ecx
  00393	e8 00 00 00 00	 call	 __snprintf

; 1653 :         PushBackDetails(format);

  00398	83 ec 08	 sub	 esp, 8
  0039b	8b ec		 mov	 ebp, esp
  0039d	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  003a1	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  003a8	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  003ab	89 64 24 30	 mov	 DWORD PTR $T228256[esp+1100], esp
  003af	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  003b2	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL691@Connection:
  003b5	8a 10		 mov	 dl, BYTE PTR [eax]
  003b7	40		 inc	 eax
  003b8	3a d3		 cmp	 dl, bl
  003ba	75 f9		 jne	 SHORT $LL691@Connection
  003bc	2b c1		 sub	 eax, ecx
  003be	50		 push	 eax
  003bf	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  003c3	52		 push	 edx
  003c4	8b cd		 mov	 ecx, ebp
  003c6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  003cb	c7 84 24 48 04
	00 00 07 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 7
  003d6	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  003e1	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1654 :         memset(format,0x00,sizeof(format));

  003e6	68 00 04 00 00	 push	 1024			; 00000400H
  003eb	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  003ef	53		 push	 ebx
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 _memset

; 1655 : 
; 1656 :         _snprintf(format,sizeof(format)-1,">   idProduct: 0x%04X",ConnectInfo->DeviceDescriptor.idProduct);

  003f6	0f b7 4f 0e	 movzx	 ecx, WORD PTR [edi+14]
  003fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  003fd	51		 push	 ecx
  003fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FEBFICPG@?$DO?5?5?5idProduct?3?50x?$CF04X?$AA@
  00403	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  00407	68 ff 03 00 00	 push	 1023			; 000003ffH
  0040c	52		 push	 edx
  0040d	e8 00 00 00 00	 call	 __snprintf

; 1657 :         PushBackDetails(format);

  00412	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00415	8b ec		 mov	 ebp, esp
  00417	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  0041b	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00422	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00425	89 64 24 30	 mov	 DWORD PTR $T228257[esp+1100], esp
  00429	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  0042c	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0042f	90		 npad	 1
$LL692@Connection:
  00430	8a 10		 mov	 dl, BYTE PTR [eax]
  00432	40		 inc	 eax
  00433	3a d3		 cmp	 dl, bl
  00435	75 f9		 jne	 SHORT $LL692@Connection
  00437	2b c1		 sub	 eax, ecx
  00439	50		 push	 eax
  0043a	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  0043e	50		 push	 eax
  0043f	8b cd		 mov	 ecx, ebp
  00441	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00446	c7 84 24 48 04
	00 00 08 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 8
  00451	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0045c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1658 :         memset(format,0x00,sizeof(format));

  00461	68 00 04 00 00	 push	 1024			; 00000400H
  00466	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0046a	53		 push	 ebx
  0046b	51		 push	 ecx
  0046c	e8 00 00 00 00	 call	 _memset

; 1659 : 
; 1660 :         _snprintf(format,sizeof(format)-1,">   bcdDevice: 0x%04X",ConnectInfo->DeviceDescriptor.bcdDevice);

  00471	0f b7 57 10	 movzx	 edx, WORD PTR [edi+16]
  00475	83 c4 0c	 add	 esp, 12			; 0000000cH
  00478	52		 push	 edx
  00479	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IFDGHCDF@?$DO?5?5?5bcdDevice?3?50x?$CF04X?$AA@
  0047e	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00482	68 ff 03 00 00	 push	 1023			; 000003ffH
  00487	50		 push	 eax
  00488	e8 00 00 00 00	 call	 __snprintf

; 1661 :         PushBackDetails(format);

  0048d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00490	8b ec		 mov	 ebp, esp
  00492	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00496	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0049d	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  004a0	89 64 24 30	 mov	 DWORD PTR $T228258[esp+1100], esp
  004a4	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  004a7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  004aa	8d 9b 00 00 00
	00		 npad	 6
$LL693@Connection:
  004b0	8a 10		 mov	 dl, BYTE PTR [eax]
  004b2	40		 inc	 eax
  004b3	3a d3		 cmp	 dl, bl
  004b5	75 f9		 jne	 SHORT $LL693@Connection
  004b7	2b c1		 sub	 eax, ecx
  004b9	50		 push	 eax
  004ba	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  004be	51		 push	 ecx
  004bf	8b cd		 mov	 ecx, ebp
  004c1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  004c6	c7 84 24 48 04
	00 00 09 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 9
  004d1	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  004dc	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1662 :         memset(format,0x00,sizeof(format));

  004e1	68 00 04 00 00	 push	 1024			; 00000400H
  004e6	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  004ea	53		 push	 ebx
  004eb	52		 push	 edx
  004ec	e8 00 00 00 00	 call	 _memset

; 1663 : 
; 1664 :         _snprintf(format,sizeof(format)-1,">   iManufacturer: 0x%02X",ConnectInfo->DeviceDescriptor.iManufacturer);

  004f1	0f b6 47 12	 movzx	 eax, BYTE PTR [edi+18]
  004f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  004f8	50		 push	 eax
  004f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IFOFIIGL@?$DO?5?5?5iManufacturer?3?50x?$CF02X?$AA@
  004fe	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1080]
  00502	68 ff 03 00 00	 push	 1023			; 000003ffH
  00507	51		 push	 ecx
  00508	e8 00 00 00 00	 call	 __snprintf

; 1665 :         PushBackDetails(format);

  0050d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00510	8b ec		 mov	 ebp, esp
  00512	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00516	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0051d	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00520	89 64 24 30	 mov	 DWORD PTR $T228259[esp+1100], esp
  00524	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  00527	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0052a	8d 9b 00 00 00
	00		 npad	 6
$LL694@Connection:
  00530	8a 10		 mov	 dl, BYTE PTR [eax]
  00532	40		 inc	 eax
  00533	3a d3		 cmp	 dl, bl
  00535	75 f9		 jne	 SHORT $LL694@Connection
  00537	2b c1		 sub	 eax, ecx
  00539	50		 push	 eax
  0053a	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  0053e	52		 push	 edx
  0053f	8b cd		 mov	 ecx, ebp
  00541	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00546	c7 84 24 48 04
	00 00 0a 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 10 ; 0000000aH
  00551	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0055c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1666 :         memset(format,0x00,sizeof(format));

  00561	68 00 04 00 00	 push	 1024			; 00000400H
  00566	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  0056a	53		 push	 ebx
  0056b	50		 push	 eax
  0056c	e8 00 00 00 00	 call	 _memset

; 1667 : 
; 1668 :         if (ConnectInfo->DeviceDescriptor.iManufacturer)

  00571	0f b6 47 12	 movzx	 eax, BYTE PTR [edi+18]
  00575	83 c4 0c	 add	 esp, 12			; 0000000cH
  00578	3a c3		 cmp	 al, bl
  0057a	74 0b		 je	 SHORT $LN10@Connection

; 1669 :         {
; 1670 :             StringDescriptor(ConnectInfo->DeviceDescriptor.iManufacturer,StringDescs);

  0057c	8b 4c 24 18	 mov	 ecx, DWORD PTR _StringDescs$GSCopy$[esp+1072]
  00580	50		 push	 eax
  00581	56		 push	 esi
  00582	e8 00 00 00 00	 call	 ?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::StringDescriptor
$LN10@Connection:

; 1671 :         }
; 1672 : 
; 1673 :         _snprintf(format,sizeof(format)-1,">   iProduct: 0x%02X",ConnectInfo->DeviceDescriptor.iProduct);

  00587	0f b6 4f 13	 movzx	 ecx, BYTE PTR [edi+19]
  0058b	51		 push	 ecx
  0058c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JLHEPLOO@?$DO?5?5?5iProduct?3?50x?$CF02X?$AA@
  00591	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  00595	68 ff 03 00 00	 push	 1023			; 000003ffH
  0059a	52		 push	 edx
  0059b	e8 00 00 00 00	 call	 __snprintf

; 1674 :         PushBackDetails(format);

  005a0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  005a3	8b ec		 mov	 ebp, esp
  005a5	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  005a9	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  005b0	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  005b3	89 64 24 30	 mov	 DWORD PTR $T228260[esp+1100], esp
  005b7	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  005ba	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  005bd	8d 49 00	 npad	 3
$LL695@Connection:
  005c0	8a 10		 mov	 dl, BYTE PTR [eax]
  005c2	40		 inc	 eax
  005c3	3a d3		 cmp	 dl, bl
  005c5	75 f9		 jne	 SHORT $LL695@Connection
  005c7	2b c1		 sub	 eax, ecx
  005c9	50		 push	 eax
  005ca	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  005ce	50		 push	 eax
  005cf	8b cd		 mov	 ecx, ebp
  005d1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  005d6	c7 84 24 48 04
	00 00 0b 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 11 ; 0000000bH
  005e1	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  005ec	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1675 :         memset(format,0x00,sizeof(format));

  005f1	68 00 04 00 00	 push	 1024			; 00000400H
  005f6	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  005fa	53		 push	 ebx
  005fb	51		 push	 ecx
  005fc	e8 00 00 00 00	 call	 _memset

; 1676 : 
; 1677 :         if (ConnectInfo->DeviceDescriptor.iProduct)

  00601	0f b6 47 13	 movzx	 eax, BYTE PTR [edi+19]
  00605	83 c4 0c	 add	 esp, 12			; 0000000cH
  00608	3a c3		 cmp	 al, bl
  0060a	74 0b		 je	 SHORT $LN9@Connection

; 1678 :         {
; 1679 :             StringDescriptor(ConnectInfo->DeviceDescriptor.iProduct,StringDescs);

  0060c	8b 4c 24 18	 mov	 ecx, DWORD PTR _StringDescs$GSCopy$[esp+1072]
  00610	50		 push	 eax
  00611	56		 push	 esi
  00612	e8 00 00 00 00	 call	 ?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::StringDescriptor
$LN9@Connection:

; 1680 :         }
; 1681 : 
; 1682 :         _snprintf(format,sizeof(format)-1,">   iSerialNumber: 0x%02X",ConnectInfo->DeviceDescriptor.iSerialNumber);

  00617	0f b6 57 14	 movzx	 edx, BYTE PTR [edi+20]
  0061b	52		 push	 edx
  0061c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LAPCHIKM@?$DO?5?5?5iSerialNumber?3?50x?$CF02X?$AA@
  00621	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00625	68 ff 03 00 00	 push	 1023			; 000003ffH
  0062a	50		 push	 eax
  0062b	e8 00 00 00 00	 call	 __snprintf

; 1683 :         PushBackDetails(format);

  00630	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00633	8b ec		 mov	 ebp, esp
  00635	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00639	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00640	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00643	89 64 24 30	 mov	 DWORD PTR $T228261[esp+1100], esp
  00647	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  0064a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0064d	8d 49 00	 npad	 3
$LL696@Connection:
  00650	8a 10		 mov	 dl, BYTE PTR [eax]
  00652	40		 inc	 eax
  00653	3a d3		 cmp	 dl, bl
  00655	75 f9		 jne	 SHORT $LL696@Connection
  00657	2b c1		 sub	 eax, ecx
  00659	50		 push	 eax
  0065a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0065e	51		 push	 ecx
  0065f	8b cd		 mov	 ecx, ebp
  00661	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00666	c7 84 24 48 04
	00 00 0c 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 12 ; 0000000cH
  00671	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0067c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1684 :         memset(format,0x00,sizeof(format));

  00681	68 00 04 00 00	 push	 1024			; 00000400H
  00686	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0068a	53		 push	 ebx
  0068b	52		 push	 edx
  0068c	e8 00 00 00 00	 call	 _memset

; 1685 : 
; 1686 :         if (ConnectInfo->DeviceDescriptor.iSerialNumber)

  00691	0f b6 47 14	 movzx	 eax, BYTE PTR [edi+20]
  00695	83 c4 0c	 add	 esp, 12			; 0000000cH
  00698	3a c3		 cmp	 al, bl
  0069a	74 0b		 je	 SHORT $LN8@Connection

; 1687 :         {
; 1688 :             StringDescriptor(ConnectInfo->DeviceDescriptor.iSerialNumber,StringDescs);

  0069c	8b 4c 24 18	 mov	 ecx, DWORD PTR _StringDescs$GSCopy$[esp+1072]
  006a0	50		 push	 eax
  006a1	56		 push	 esi
  006a2	e8 00 00 00 00	 call	 ?StringDescriptor@USB@@IAEXEPAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::StringDescriptor
$LN8@Connection:

; 1689 :         }
; 1690 : 
; 1691 :         _snprintf(format,sizeof(format)-1,">   bNumConfigurations: 0x%02X",ConnectInfo->DeviceDescriptor.bNumConfigurations);

  006a7	0f b6 47 15	 movzx	 eax, BYTE PTR [edi+21]
  006ab	50		 push	 eax
  006ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@EFEAMJPP@?$DO?5?5?5bNumConfigurations?3?50x?$CF02X?$AA@
  006b1	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1080]
  006b5	68 ff 03 00 00	 push	 1023			; 000003ffH
  006ba	51		 push	 ecx
  006bb	e8 00 00 00 00	 call	 __snprintf

; 1692 :         PushBackDetails(format);

  006c0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  006c3	8b ec		 mov	 ebp, esp
  006c5	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  006c9	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  006d0	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  006d3	89 64 24 30	 mov	 DWORD PTR $T228262[esp+1100], esp
  006d7	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  006da	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  006dd	8d 49 00	 npad	 3
$LL697@Connection:
  006e0	8a 10		 mov	 dl, BYTE PTR [eax]
  006e2	40		 inc	 eax
  006e3	3a d3		 cmp	 dl, bl
  006e5	75 f9		 jne	 SHORT $LL697@Connection
  006e7	2b c1		 sub	 eax, ecx
  006e9	50		 push	 eax
  006ea	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  006ee	52		 push	 edx
  006ef	8b cd		 mov	 ecx, ebp
  006f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  006f6	c7 84 24 48 04
	00 00 0d 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 13 ; 0000000dH
  00701	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0070c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1693 :         memset(format,0x00,sizeof(format));

  00711	68 00 04 00 00	 push	 1024			; 00000400H
  00716	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  0071a	53		 push	 ebx
  0071b	50		 push	 eax
  0071c	e8 00 00 00 00	 call	 _memset

; 1694 : 
; 1695 :         _snprintf(format,sizeof(format)-1,">   ConnectionStatus: %s",ConnectionStatuses[ConnectInfo->ConnectionStatus]);

  00721	8b 4f 1f	 mov	 ecx, DWORD PTR [edi+31]
  00724	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ConnectionStatuses@@3PAPADA[ecx*4]
  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0072e	52		 push	 edx
  0072f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@POKCFGAN@?$DO?5?5?5ConnectionStatus?3?5?$CFs?$AA@
  00734	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00738	68 ff 03 00 00	 push	 1023			; 000003ffH
  0073d	50		 push	 eax
  0073e	e8 00 00 00 00	 call	 __snprintf

; 1696 :         PushBackDetails(format);

  00743	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00746	8b ec		 mov	 ebp, esp
  00748	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  0074c	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  00753	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  00756	89 64 24 30	 mov	 DWORD PTR $T228263[esp+1100], esp
  0075a	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  0075d	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
$LL698@Connection:
  00760	8a 10		 mov	 dl, BYTE PTR [eax]
  00762	40		 inc	 eax
  00763	3a d3		 cmp	 dl, bl
  00765	75 f9		 jne	 SHORT $LL698@Connection
  00767	2b c1		 sub	 eax, ecx
  00769	50		 push	 eax
  0076a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0076e	51		 push	 ecx
  0076f	8b cd		 mov	 ecx, ebp
  00771	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00776	c7 84 24 48 04
	00 00 0e 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 14 ; 0000000eH
  00781	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0078c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1697 :         memset(format,0x00,sizeof(format));

  00791	68 00 04 00 00	 push	 1024			; 00000400H
  00796	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0079a	53		 push	 ebx
  0079b	52		 push	 edx
  0079c	e8 00 00 00 00	 call	 _memset

; 1698 : 
; 1699 :         _snprintf(format,sizeof(format)-1,">   Current Config Value: 0x%02X",ConnectInfo->CurrentConfigurationValue);

  007a1	0f b6 47 16	 movzx	 eax, BYTE PTR [edi+22]
  007a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  007a8	50		 push	 eax
  007a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CNIJGGK@?$DO?5?5?5Current?5Config?5Value?3?50x?$CF02X@
  007ae	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1080]
  007b2	68 ff 03 00 00	 push	 1023			; 000003ffH
  007b7	51		 push	 ecx
  007b8	e8 00 00 00 00	 call	 __snprintf

; 1700 :         PushBackDetails(format);

  007bd	83 ec 0c	 sub	 esp, 12			; 0000000cH
  007c0	8b ec		 mov	 ebp, esp
  007c2	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  007c6	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  007cd	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  007d0	89 64 24 30	 mov	 DWORD PTR $T228264[esp+1100], esp
  007d4	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  007d7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  007da	8d 9b 00 00 00
	00		 npad	 6
$LL699@Connection:
  007e0	8a 10		 mov	 dl, BYTE PTR [eax]
  007e2	40		 inc	 eax
  007e3	3a d3		 cmp	 dl, bl
  007e5	75 f9		 jne	 SHORT $LL699@Connection
  007e7	2b c1		 sub	 eax, ecx
  007e9	50		 push	 eax
  007ea	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1104]
  007ee	52		 push	 edx
  007ef	8b cd		 mov	 ecx, ebp
  007f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  007f6	c7 84 24 48 04
	00 00 0f 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 15 ; 0000000fH
  00801	83 cd ff	 or	 ebp, -1
  00804	89 ac 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], ebp
  0080b	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1701 :         memset(format,0x00,sizeof(format));

  00810	68 00 04 00 00	 push	 1024			; 00000400H
  00815	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1076]
  00819	53		 push	 ebx
  0081a	50		 push	 eax
  0081b	e8 00 00 00 00	 call	 _memset

; 1702 : 
; 1703 :         switch	(ConnectInfo->Speed)

  00820	0f b6 47 17	 movzx	 eax, BYTE PTR [edi+23]
  00824	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1714 :             default:
; 1715 :                 PushBackDetails(">   Device Bus Speed: Unknown");

  00827	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0082a	2b c3		 sub	 eax, ebx
  0082c	8b cc		 mov	 ecx, esp
  0082e	89 64 24 30	 mov	 DWORD PTR $T228268[esp+1100], esp
  00832	74 4f		 je	 SHORT $LN5@Connection

; 1702 : 
; 1703 :         switch	(ConnectInfo->Speed)

  00834	83 e8 01	 sub	 eax, 1
  00837	74 33		 je	 SHORT $LN4@Connection
  00839	83 e8 01	 sub	 eax, 1
  0083c	74 17		 je	 SHORT $LN3@Connection

; 1714 :             default:
; 1715 :                 PushBackDetails(">   Device Bus Speed: Unknown");

  0083e	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IIJPBIOD@?$DO?5?5?5Device?5Bus?5Speed?3?5Unknown?$AA@
  00843	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00848	c7 84 24 48 04
	00 00 13 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 19 ; 00000013H
  00853	eb 43		 jmp	 SHORT $LN706@Connection
$LN3@Connection:

; 1711 :             case UsbHighSpeed:
; 1712 :                 PushBackDetails(">   Device Bus Speed: High");

  00855	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@OEKHLNNJ@?$DO?5?5?5Device?5Bus?5Speed?3?5High?$AA@
  0085a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0085f	c7 84 24 48 04
	00 00 12 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 18 ; 00000012H

; 1713 :                 break;

  0086a	eb 2c		 jmp	 SHORT $LN706@Connection
$LN4@Connection:

; 1707 :                 break;
; 1708 :             case UsbFullSpeed:
; 1709 :                 PushBackDetails(">   Device Bus Speed: Full");

  0086c	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CJGBMBHK@?$DO?5?5?5Device?5Bus?5Speed?3?5Full?$AA@
  00871	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00876	c7 84 24 48 04
	00 00 11 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 17 ; 00000011H

; 1710 :                 break;

  00881	eb 15		 jmp	 SHORT $LN706@Connection
$LN5@Connection:

; 1704 :         {
; 1705 :             case UsbLowSpeed:
; 1706 :                 PushBackDetails(">   Device Bus Speed: Low");

  00883	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CLDGMCFC@?$DO?5?5?5Device?5Bus?5Speed?3?5Low?$AA@
  00888	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0088d	c7 84 24 48 04
	00 00 10 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 16 ; 00000010H
$LN706@Connection:
  00898	89 ac 24 48 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1108], ebp
  0089f	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1716 :         }
; 1717 : 
; 1718 :         _snprintf(format,sizeof(format)-1,">   Device Address: 0x%02X",ConnectInfo->DeviceAddress);

  008a4	0f b7 4f 19	 movzx	 ecx, WORD PTR [edi+25]
  008a8	51		 push	 ecx
  008a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DEBOODEI@?$DO?5?5?5Device?5Address?3?50x?$CF02X?$AA@
  008ae	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1080]
  008b2	68 ff 03 00 00	 push	 1023			; 000003ffH
  008b7	52		 push	 edx
  008b8	e8 00 00 00 00	 call	 __snprintf

; 1719 :         PushBackDetails(format);

  008bd	83 ec 0c	 sub	 esp, 12			; 0000000cH
  008c0	8b ec		 mov	 ebp, esp
  008c2	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  008c6	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  008cd	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  008d0	89 64 24 30	 mov	 DWORD PTR $T228269[esp+1100], esp
  008d4	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  008d7	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  008da	8d 9b 00 00 00
	00		 npad	 6
$LL700@Connection:
  008e0	8a 10		 mov	 dl, BYTE PTR [eax]
  008e2	40		 inc	 eax
  008e3	3a d3		 cmp	 dl, bl
  008e5	75 f9		 jne	 SHORT $LL700@Connection
  008e7	2b c1		 sub	 eax, ecx
  008e9	50		 push	 eax
  008ea	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1104]
  008ee	50		 push	 eax
  008ef	8b cd		 mov	 ecx, ebp
  008f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  008f6	c7 84 24 48 04
	00 00 14 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 20 ; 00000014H
  00901	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0090c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1720 :         memset(format,0x00,sizeof(format));

  00911	68 00 04 00 00	 push	 1024			; 00000400H
  00916	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1076]
  0091a	53		 push	 ebx
  0091b	51		 push	 ecx
  0091c	e8 00 00 00 00	 call	 _memset

; 1721 : 
; 1722 :         _snprintf(format,sizeof(format)-1,">   Open Pipes: %02d",ConnectInfo->NumberOfOpenPipes);

  00921	8b 57 1b	 mov	 edx, DWORD PTR [edi+27]
  00924	83 c4 0c	 add	 esp, 12			; 0000000cH
  00927	52		 push	 edx
  00928	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@BAEOANMA@?$DO?5?5?5Open?5Pipes?3?5?$CF02d?$AA@
  0092d	8d 44 24 24	 lea	 eax, DWORD PTR _format$[esp+1080]
  00931	68 ff 03 00 00	 push	 1023			; 000003ffH
  00936	50		 push	 eax
  00937	e8 00 00 00 00	 call	 __snprintf

; 1723 :         PushBackDetails(format);

  0093c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0093f	8b ec		 mov	 ebp, esp
  00941	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1100]
  00945	c7 45 18 0f 00
	00 00		 mov	 DWORD PTR [ebp+24], 15	; 0000000fH
  0094c	89 5d 14	 mov	 DWORD PTR [ebp+20], ebx
  0094f	89 64 24 30	 mov	 DWORD PTR $T228270[esp+1100], esp
  00953	88 5d 04	 mov	 BYTE PTR [ebp+4], bl
  00956	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00959	8d a4 24 00 00
	00 00		 npad	 7
$LL701@Connection:
  00960	8a 10		 mov	 dl, BYTE PTR [eax]
  00962	40		 inc	 eax
  00963	3a d3		 cmp	 dl, bl
  00965	75 f9		 jne	 SHORT $LL701@Connection
  00967	2b c1		 sub	 eax, ecx
  00969	50		 push	 eax
  0096a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _format$[esp+1104]
  0096e	51		 push	 ecx
  0096f	8b cd		 mov	 ecx, ebp
  00971	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00976	c7 84 24 48 04
	00 00 15 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1108], 21 ; 00000015H
  00981	c7 84 24 48 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1108], -1
  0098c	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1724 :         memset(format,0x00,sizeof(format));

  00991	68 00 04 00 00	 push	 1024			; 00000400H
  00996	8d 54 24 20	 lea	 edx, DWORD PTR _format$[esp+1076]
  0099a	53		 push	 ebx
  0099b	52		 push	 edx
  0099c	e8 00 00 00 00	 call	 _memset

; 1725 : 
; 1726 :         if (ConnectInfo->NumberOfOpenPipes)

  009a1	8b 47 1b	 mov	 eax, DWORD PTR [edi+27]
  009a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  009a7	3b c3		 cmp	 eax, ebx
  009a9	74 0b		 je	 SHORT $LN1@Connection

; 1727 :         {
; 1728 :             PipeInfo(ConnectInfo->NumberOfOpenPipes,ConnectInfo->PipeList);

  009ab	83 c7 23	 add	 edi, 35			; 00000023H
  009ae	57		 push	 edi
  009af	8b de		 mov	 ebx, esi
  009b1	e8 00 00 00 00	 call	 ?PipeInfo@USB@@IAEXKPAU_USB_PIPE_INFO@@@Z ; USB::PipeInfo
$LN1@Connection:

; 1729 :         }
; 1730 :     }
; 1731 : 
; 1732 :     Log(LOG_DEBUG,__LINE__,"<< USB.ConnInfo");

  009b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KGDOGDAK@?$DM?$DM?5USB?4ConnInfo?$AA@
  009bb	68 c4 06 00 00	 push	 1732			; 000006c4H
$LN705@Connection:
  009c0	6a 10		 push	 16			; 00000010H
  009c2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  009c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 : }

  009ca	8b 8c 24 24 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1072]
  009d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  009d8	59		 pop	 ecx
  009d9	5f		 pop	 edi
  009da	5e		 pop	 esi
  009db	5d		 pop	 ebp
  009dc	5b		 pop	 ebx
  009dd	8b 8c 24 08 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1052]
  009e4	33 cc		 xor	 ecx, esp
  009e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  009eb	81 c4 1c 04 00
	00		 add	 esp, 1052		; 0000041cH
  009f1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$0:
  00000	8b 8d e8 fb ff
	ff		 mov	 ecx, DWORD PTR $T228249[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$1:
  0000b	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228250[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$2:
  00016	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228251[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$3:
  00021	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228252[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$4:
  0002c	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228253[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$5:
  00037	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228254[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$6:
  00042	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228255[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$7:
  0004d	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228256[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$8:
  00058	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228257[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$9:
  00063	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228258[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$10:
  0006e	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228259[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$11:
  00079	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228260[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$12:
  00084	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228261[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$13:
  0008f	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228262[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$14:
  0009a	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228263[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$15:
  000a5	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228264[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$19:
  000b0	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228268[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$18:
  000bb	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228267[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$17:
  000c6	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228266[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$16:
  000d1	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228265[ebp]
  000d7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$20:
  000dc	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228269[ebp]
  000e2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z$21:
  000e7	8b 8d e4 fb ff
	ff		 mov	 ecx, DWORD PTR $T228270[ebp]
  000ed	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z:
  000f2	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000f6	8d 82 e0 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1056]
  000fc	8b 8a dc fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1060]
  00102	33 c8		 xor	 ecx, eax
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	83 c0 10	 add	 eax, 16			; 00000010H
  0010c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0010f	33 c8		 xor	 ecx, eax
  00111	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00116	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z
  0011b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z ENDP ; USB::ConnectionInfo
PUBLIC	__$ArrayPad$
PUBLIC	?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z	; USB::HubInfo
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$9
__ehfuncinfo$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z
_TEXT	SEGMENT
$T230928 = -1044					; size = 4
$T230927 = -1044					; size = 4
$T230926 = -1044					; size = 4
$T230925 = -1044					; size = 4
$T230924 = -1044					; size = 4
$T230923 = -1044					; size = 4
$T230922 = -1044					; size = 4
$T230921 = -1044					; size = 4
$T230920 = -1044					; size = 4
$T230919 = -1044					; size = 4
_format$ = -1040					; size = 1024
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z PROC	; USB::HubInfo, COMDAT
; _this$ = ecx
; _HubInfo$ = edx

; 1484 : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 0c 04 00
	00		 sub	 esp, 1036		; 0000040cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 08 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1048], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c4		 xor	 eax, esp
  0002d	50		 push	 eax
  0002e	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1068]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	8b f1		 mov	 esi, ecx

; 1485 :     USHORT wHubChar = 0;
; 1486 :     char format[1024] = {0};

  0003d	33 db		 xor	 ebx, ebx
  0003f	68 ff 03 00 00	 push	 1023			; 000003ffH
  00044	8d 44 24 21	 lea	 eax, DWORD PTR _format$[esp+1073]
  00048	53		 push	 ebx
  00049	50		 push	 eax
  0004a	8b fa		 mov	 edi, edx
  0004c	88 5c 24 28	 mov	 BYTE PTR _format$[esp+1080], bl
  00050	e8 00 00 00 00	 call	 _memset
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1487 : 
; 1488 :     Log(LOG_DEBUG,__LINE__,">> USB.HubInfo");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GOACPFJP@?$DO?$DO?5USB?4HubInfo?$AA@
  0005d	68 d0 05 00 00	 push	 1488			; 000005d0H
  00062	6a 10		 push	 16			; 00000010H
  00064	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1489 : 
; 1490 :     _snprintf(format,sizeof(format)-1,"> Hub Power: %s",HubInfo->HubIsBusPowered ? "Bus Power" : "Self Power");

  0006c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09GDHNALJA@Bus?5Power?$AA@
  00071	38 5f 47	 cmp	 BYTE PTR [edi+71], bl
  00074	75 05		 jne	 SHORT $LN18@HubInfo
  00076	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@JDJFLKOD@Self?5Power?$AA@
$LN18@HubInfo:
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KPNNFMHH@?$DO?5Hub?5Power?3?5?$CFs?$AA@
  00081	8d 4c 24 24	 lea	 ecx, DWORD PTR _format$[esp+1076]
  00085	68 ff 03 00 00	 push	 1023			; 000003ffH
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 __snprintf

; 1491 :     PushBackDetails(format);

  00090	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00093	8b cc		 mov	 ecx, esp
  00095	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00099	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  000a0	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  000a3	89 64 24 34	 mov	 DWORD PTR $T230919[esp+1096], esp
  000a7	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  000aa	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]
  000ad	8d 49 00	 npad	 3
$LL209@HubInfo:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	40		 inc	 eax
  000b3	3a d3		 cmp	 dl, bl
  000b5	75 f9		 jne	 SHORT $LL209@HubInfo
  000b7	2b c5		 sub	 eax, ebp
  000b9	50		 push	 eax
  000ba	8d 54 24 3c	 lea	 edx, DWORD PTR _format$[esp+1100]
  000be	52		 push	 edx
  000bf	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000c4	89 9c 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebx
  000cb	c7 84 24 44 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1104], -1
  000d6	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1492 :     memset(format,0x00,sizeof(format));

  000db	68 00 04 00 00	 push	 1024			; 00000400H
  000e0	8d 44 24 20	 lea	 eax, DWORD PTR _format$[esp+1072]
  000e4	53		 push	 ebx
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memset

; 1493 : 
; 1494 :     _snprintf(format,sizeof(format)-1,"> Number of Ports: %d",HubInfo->HubDescriptor.bNumberOfPorts);

  000eb	0f b6 4f 02	 movzx	 ecx, BYTE PTR [edi+2]
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	51		 push	 ecx
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IOHBDCFM@?$DO?5Number?5of?5Ports?3?5?$CFd?$AA@
  000f8	8d 54 24 24	 lea	 edx, DWORD PTR _format$[esp+1076]
  000fc	68 ff 03 00 00	 push	 1023			; 000003ffH
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 __snprintf

; 1495 :     PushBackDetails(format);

  00107	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0010a	8b cc		 mov	 ecx, esp
  0010c	8d 44 24 38	 lea	 eax, DWORD PTR _format$[esp+1096]
  00110	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00117	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0011a	89 64 24 34	 mov	 DWORD PTR $T230920[esp+1096], esp
  0011e	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00121	8d 68 01	 lea	 ebp, DWORD PTR [eax+1]
$LL210@HubInfo:
  00124	8a 10		 mov	 dl, BYTE PTR [eax]
  00126	40		 inc	 eax
  00127	3a d3		 cmp	 dl, bl
  00129	75 f9		 jne	 SHORT $LL210@HubInfo
  0012b	2b c5		 sub	 eax, ebp
  0012d	50		 push	 eax
  0012e	8d 44 24 3c	 lea	 eax, DWORD PTR _format$[esp+1100]
  00132	50		 push	 eax
  00133	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00138	c7 84 24 44 04
	00 00 01 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 1
  00143	83 cd ff	 or	 ebp, -1
  00146	89 ac 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebp
  0014d	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1496 :     memset(format,0x00,sizeof(format));

  00152	68 00 04 00 00	 push	 1024			; 00000400H
  00157	8d 4c 24 20	 lea	 ecx, DWORD PTR _format$[esp+1072]
  0015b	53		 push	 ebx
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 _memset

; 1497 : 
; 1498 :     wHubChar = HubInfo->HubDescriptor.wHubCharacteristics;

  00162	0f b7 47 03	 movzx	 eax, WORD PTR [edi+3]

; 1499 : 
; 1500 :     switch (wHubChar & 0x0003)

  00166	0f b7 f8	 movzx	 edi, ax
  00169	8b c7		 mov	 eax, edi
  0016b	83 e0 03	 and	 eax, 3
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	83 f8 03	 cmp	 eax, 3
  00174	77 71		 ja	 SHORT $LN13@HubInfo
  00176	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN217@HubInfo[eax*4]
$LN12@HubInfo:

; 1501 :     {
; 1502 :         case 0x0000:
; 1503 :             PushBackDetails("> Power switching: Ganged");

  0017d	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00180	8b cc		 mov	 ecx, esp
  00182	89 64 24 34	 mov	 DWORD PTR $T230921[esp+1096], esp
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CEEHKAND@?$DO?5Power?5switching?3?5Ganged?$AA@
  0018b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00190	c7 84 24 44 04
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 2

; 1504 :             break;

  0019b	eb 3e		 jmp	 SHORT $LN214@HubInfo
$LN11@HubInfo:

; 1505 : 
; 1506 :         case 0x0001:
; 1507 :             PushBackDetails("> Power switching: Individual");

  0019d	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001a0	8b cc		 mov	 ecx, esp
  001a2	89 64 24 34	 mov	 DWORD PTR $T230922[esp+1096], esp
  001a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BHNNAPDB@?$DO?5Power?5switching?3?5Individual?$AA@
  001ab	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001b0	c7 84 24 44 04
	00 00 03 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 3

; 1508 :             break;

  001bb	eb 1e		 jmp	 SHORT $LN214@HubInfo
$LN10@HubInfo:

; 1509 : 
; 1510 :         case 0x0002:
; 1511 :         case 0x0003:
; 1512 :             PushBackDetails("> Power switching: None");

  001bd	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001c0	8b cc		 mov	 ecx, esp
  001c2	89 64 24 34	 mov	 DWORD PTR $T230923[esp+1096], esp
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FICFFJGB@?$DO?5Power?5switching?3?5None?$AA@
  001cb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001d0	c7 84 24 44 04
	00 00 04 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 4
$LN214@HubInfo:
  001db	89 ac 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebp
  001e2	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
$LN13@HubInfo:

; 1513 :             break;
; 1514 :     }
; 1515 : 
; 1516 :     switch (wHubChar & 0x0004)

  001e7	8b c7		 mov	 eax, edi
  001e9	83 e0 04	 and	 eax, 4
  001ec	74 34		 je	 SHORT $LN7@HubInfo
  001ee	83 f8 04	 cmp	 eax, 4
  001f1	75 68		 jne	 SHORT $LN8@HubInfo

; 1520 :             break;
; 1521 : 
; 1522 :         case 0x0004:
; 1523 :             PushBackDetails("> Compound device: Yes");

  001f3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001f6	8b cc		 mov	 ecx, esp
  001f8	89 64 24 34	 mov	 DWORD PTR $T230925[esp+1096], esp
  001fc	6a 16		 push	 22			; 00000016H
  001fe	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00205	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFBEDMDO@?$DO?5Compound?5device?3?5Yes?$AA@
  0020d	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00210	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00215	c7 84 24 44 04
	00 00 06 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 6

; 1524 :             break;

  00220	eb 2d		 jmp	 SHORT $LN215@HubInfo
$LN7@HubInfo:

; 1517 :     {
; 1518 :         case 0x0000:
; 1519 :             PushBackDetails("> Compound device: No");

  00222	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00225	8b cc		 mov	 ecx, esp
  00227	89 64 24 34	 mov	 DWORD PTR $T230924[esp+1096], esp
  0022b	6a 15		 push	 21			; 00000015H
  0022d	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00234	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00237	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FBGEODEL@?$DO?5Compound?5device?3?5No?$AA@
  0023c	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  0023f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00244	c7 84 24 44 04
	00 00 05 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 5
$LN215@HubInfo:
  0024f	89 ac 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebp
  00256	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
$LN8@HubInfo:

; 1525 :     }
; 1526 : 
; 1527 :     switch (wHubChar & 0x0018)

  0025b	83 e7 18	 and	 edi, 24			; 00000018H
  0025e	83 ff 18	 cmp	 edi, 24			; 00000018H
  00261	0f 87 87 00 00
	00		 ja	 $LN4@HubInfo
  00267	0f b6 97 00 00
	00 00		 movzx	 edx, BYTE PTR $LN211@HubInfo[edi]
  0026e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN218@HubInfo[edx*4]
$LN3@HubInfo:

; 1528 :     {
; 1529 :         case 0x0000:
; 1530 :             PushBackDetails("> Over-current Protection: Global");

  00275	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00278	8b cc		 mov	 ecx, esp
  0027a	89 64 24 34	 mov	 DWORD PTR $T230926[esp+1096], esp
  0027e	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ELIAJJDL@?$DO?5Over?9current?5Protection?3?5Globa@
  00283	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00288	c7 84 24 44 04
	00 00 07 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 7

; 1531 :             break;

  00293	eb 4d		 jmp	 SHORT $LN216@HubInfo
$LN2@HubInfo:

; 1532 : 
; 1533 :         case 0x0008:
; 1534 :             PushBackDetails("> Over-current Protection: Individual");

  00295	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00298	8b cc		 mov	 ecx, esp
  0029a	89 64 24 34	 mov	 DWORD PTR $T230927[esp+1096], esp
  0029e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@MEGDLCFA@?$DO?5Over?9current?5Protection?3?5Indiv@
  002a3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002a8	c7 84 24 44 04
	00 00 08 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 8

; 1535 :             break;

  002b3	eb 2d		 jmp	 SHORT $LN216@HubInfo
$LN1@HubInfo:

; 1536 : 
; 1537 :         case 0x0010:
; 1538 :         case 0x0018:
; 1539 :             PushBackDetails("> No Over-current Protection (Bus Power Only)");

  002b5	83 ec 1c	 sub	 esp, 28			; 0000001cH
  002b8	8b cc		 mov	 ecx, esp
  002ba	89 64 24 34	 mov	 DWORD PTR $T230928[esp+1096], esp
  002be	6a 2d		 push	 45			; 0000002dH
  002c0	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  002c7	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@FGJIHOLC@?$DO?5No?5Over?9current?5Protection?5?$CIBu@
  002cf	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  002d2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  002d7	c7 84 24 44 04
	00 00 09 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1104], 9
$LN216@HubInfo:
  002e2	89 ac 24 44 04
	00 00		 mov	 DWORD PTR __$EHRec$[esp+1104], ebp
  002e9	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails
$LN4@HubInfo:

; 1540 :             break;
; 1541 :     }
; 1542 :     Log(LOG_DEBUG,__LINE__,"<< USB.HubInfo");

  002ee	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CHOKIAKD@?$DM?$DM?5USB?4HubInfo?$AA@
  002f3	68 06 06 00 00	 push	 1542			; 00000606H
  002f8	6a 10		 push	 16			; 00000010H
  002fa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002ff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1543 : }

  00302	8b 8c 24 20 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1068]
  00309	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00310	59		 pop	 ecx
  00311	5f		 pop	 edi
  00312	5e		 pop	 esi
  00313	5d		 pop	 ebp
  00314	5b		 pop	 ebx
  00315	8b 8c 24 08 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1048]
  0031c	33 cc		 xor	 ecx, esp
  0031e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00323	81 c4 18 04 00
	00		 add	 esp, 1048		; 00000418H
  00329	c3		 ret	 0
  0032a	8b ff		 npad	 2
$LN217@HubInfo:
  0032c	00 00 00 00	 DD	 $LN12@HubInfo
  00330	00 00 00 00	 DD	 $LN11@HubInfo
  00334	00 00 00 00	 DD	 $LN10@HubInfo
  00338	00 00 00 00	 DD	 $LN10@HubInfo
$LN218@HubInfo:
  0033c	00 00 00 00	 DD	 $LN3@HubInfo
  00340	00 00 00 00	 DD	 $LN2@HubInfo
  00344	00 00 00 00	 DD	 $LN1@HubInfo
  00348	00 00 00 00	 DD	 $LN4@HubInfo
$LN211@HubInfo:
  0034c	00		 DB	 0
  0034d	03		 DB	 3
  0034e	03		 DB	 3
  0034f	03		 DB	 3
  00350	03		 DB	 3
  00351	03		 DB	 3
  00352	03		 DB	 3
  00353	03		 DB	 3
  00354	01		 DB	 1
  00355	03		 DB	 3
  00356	03		 DB	 3
  00357	03		 DB	 3
  00358	03		 DB	 3
  00359	03		 DB	 3
  0035a	03		 DB	 3
  0035b	03		 DB	 3
  0035c	02		 DB	 2
  0035d	03		 DB	 3
  0035e	03		 DB	 3
  0035f	03		 DB	 3
  00360	03		 DB	 3
  00361	03		 DB	 3
  00362	03		 DB	 3
  00363	03		 DB	 3
  00364	02		 DB	 2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$0:
  00000	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230919[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$1:
  0000b	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230920[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$2:
  00016	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230921[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$3:
  00021	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230922[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$4:
  0002c	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230923[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$6:
  00037	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230925[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$5:
  00042	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230924[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$7:
  0004d	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230926[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$8:
  00058	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230927[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z$9:
  00063	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T230928[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z:
  0006e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00072	8d 82 e4 fb ff
	ff		 lea	 eax, DWORD PTR [edx-1052]
  00078	8b 8a e0 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1056]
  0007e	33 c8		 xor	 ecx, eax
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	83 c0 10	 add	 eax, 16			; 00000010H
  00088	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0008b	33 c8		 xor	 ecx, eax
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z
  00097	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z ENDP	; USB::HubInfo
PUBLIC	?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z ; USB::EnumerateHub
PUBLIC	_hHubDevice$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?EnumerateHubPorts@USB@@IAEXPAXK@Z		; USB::EnumerateHubPorts
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?EnumerateHubPorts@USB@@IAEXPAXK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumerateHubPorts@USB@@IAEXPAXK@Z$0
__ehfuncinfo$?EnumerateHubPorts@USB@@IAEXPAXK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumerateHubPorts@USB@@IAEXPAXK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\usb.cpp
xdata$x	ENDS
;	COMDAT ?EnumerateHubPorts@USB@@IAEXPAXK@Z
_TEXT	SEGMENT
_stringDescs$ = -1572					; size = 4
_configDesc$ = -1568					; size = 4
_this$GSCopy$ = -1564					; size = 4
_index$ = -1560						; size = 4
_hHubDevice$GSCopy$ = -1556				; size = 4
_nBytes$136427 = -1552					; size = 4
$T231679 = -1548					; size = 4
_deviceDesc$ = -1548					; size = 4
_extHubName$136445 = -1544				; size = 4
_info$ = -1544						; size = 4
_deviceSpeed$ = -1540					; size = 5
_leafName$ = -1532					; size = 512
_deviceInfo$ = -1020					; size = 1000
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_NumPorts$ = 8						; size = 4
?EnumerateHubPorts@USB@@IAEXPAXK@Z PROC			; USB::EnumerateHubPorts, COMDAT
; _this$ = ecx
; _hHubDevice$ = edx

; 683  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?EnumerateHubPorts@USB@@IAEXPAXK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	81 ec 18 06 00
	00		 sub	 esp, 1560		; 00000618H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c4		 xor	 eax, esp
  0001b	89 84 24 10 06
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1572], eax
  00022	53		 push	 ebx
  00023	55		 push	 ebp
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c4		 xor	 eax, esp
  0002d	50		 push	 eax
  0002e	8d 84 24 2c 06
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+1592]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 684  :     ULONG       index = 0;
; 685  :     BOOL        success;
; 686  : 
; 687  :     PUSB_NODE_CONNECTION_INFORMATION_EX connectionInfo = NULL;
; 688  :     PUSB_DESCRIPTOR_REQUEST             configDesc = NULL;
; 689  :     PSTRING_DESCRIPTOR_NODE             stringDescs = NULL;
; 690  : 	PSTRING_DESCRIPTOR_NODE				Next = NULL;
; 691  :     PUSBDEVICEINFO                      info = NULL;
; 692  : 
; 693  :     PCHAR driverKeyName = NULL;
; 694  :     PCHAR deviceDesc = NULL;
; 695  :     CHAR  leafName[512] = {0};

  0003b	68 ff 01 00 00	 push	 511			; 000001ffH
  00040	8d 44 24 41	 lea	 eax, DWORD PTR _leafName$[esp+1597]
  00044	8b d9		 mov	 ebx, ecx
  00046	8b fa		 mov	 edi, edx
  00048	6a 00		 push	 0
  0004a	50		 push	 eax

; 696  :     char deviceSpeed[5] = {0};
; 697  :     char deviceInfo[1000] = {0};
; 698  : 
; 699  :     Log(LOG_DEBUG,__LINE__,">> USB.EnumHubPorts");
; 700  : 
; 701  : 	NestedLevel++;
; 702  :     // Loop over all ports of the hub.
; 703  :     //
; 704  :     // Port indices are 1 based, not 0 based.
; 705  :     //
; 706  :    
; 707  : 	// for (index=1; index <= NumPorts; index++)
; 708  : 	for (index=1; index <= NumPorts; index++)

  0004b	89 5c 24 28	 mov	 DWORD PTR _this$GSCopy$[esp+1604], ebx
  0004f	89 7c 24 30	 mov	 DWORD PTR _hHubDevice$GSCopy$[esp+1604], edi
  00053	c6 44 24 48 00	 mov	 BYTE PTR _leafName$[esp+1604], 0
  00058	e8 00 00 00 00	 call	 _memset
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	68 e7 03 00 00	 push	 999			; 000003e7H
  00065	8d 8c 24 41 02
	00 00		 lea	 ecx, DWORD PTR _deviceInfo$[esp+1597]
  0006c	6a 00		 push	 0
  0006e	51		 push	 ecx
  0006f	c6 44 24 40 00	 mov	 BYTE PTR _deviceSpeed$[esp+1604], 0
  00074	c7 44 24 41 00
	00 00 00	 mov	 DWORD PTR _deviceSpeed$[esp+1605], 0
  0007c	c6 84 24 48 02
	00 00 00	 mov	 BYTE PTR _deviceInfo$[esp+1604], 0
  00084	e8 00 00 00 00	 call	 _memset
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CPBFJJJ@?$DO?$DO?5USB?4EnumHubPorts?$AA@
  00091	68 bb 02 00 00	 push	 699			; 000002bbH
  00096	6a 10		 push	 16			; 00000010H
  00098	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0009d	be 01 00 00 00	 mov	 esi, 1
  000a2	01 73 08	 add	 DWORD PTR [ebx+8], esi
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	89 74 24 20	 mov	 DWORD PTR _index$[esp+1592], esi
  000ac	39 b4 24 3c 06
	00 00		 cmp	 DWORD PTR _NumPorts$[esp+1588], esi
  000b3	0f 82 23 05 00
	00		 jb	 $LN41@EnumerateH
  000b9	eb 09		 jmp	 SHORT $LN43@EnumerateH
  000bb	eb 03 8d 49 00	 npad	 5
$LL118@EnumerateH:
  000c0	8b 7c 24 24	 mov	 edi, DWORD PTR _hHubDevice$GSCopy$[esp+1592]
$LN43@EnumerateH:

; 709  :     {
; 710  :         ULONG nBytes = 0;
; 711  : 
; 712  :         // Allocate space to hold the connection info for this port.
; 713  :         // For now, allocate it big enough to hold info for 30 pipes.
; 714  :         //
; 715  :         // Endpoint numbers are 0-15.  Endpoint number 0 is the standard
; 716  :         // control endpoint which is not explicitly listed in the Configuration
; 717  :         // Descriptor.  There can be an IN endpoint and an OUT endpoint at
; 718  :         // endpoint numbers 1-15 so there can be a maximum of 30 endpoints
; 719  :         // per device configuration.
; 720  :         //
; 721  :         // Should probably size this dynamically at some point.
; 722  :         //
; 723  :         nBytes = sizeof(USB_NODE_CONNECTION_INFORMATION_EX) +
; 724  :                  sizeof(USB_PIPE_INFO) * 30;
; 725  : 
; 726  :         connectionInfo = (PUSB_NODE_CONNECTION_INFORMATION_EX)malloc(nBytes);

  000c4	68 6d 01 00 00	 push	 365			; 0000016dH
  000c9	c7 44 24 2c 6d
	01 00 00	 mov	 DWORD PTR _nBytes$136427[esp+1596], 365 ; 0000016dH
  000d1	e8 00 00 00 00	 call	 _malloc
  000d6	8b e8		 mov	 ebp, eax
  000d8	83 c4 04	 add	 esp, 4

; 727  :         if(connectionInfo)

  000db	85 ed		 test	 ebp, ebp
  000dd	0f 84 c5 04 00
	00		 je	 $LN40@EnumerateH

; 728  :         {
; 729  :             memset(connectionInfo,0x00,nBytes);

  000e3	8b 54 24 28	 mov	 edx, DWORD PTR _nBytes$136427[esp+1592]
  000e7	52		 push	 edx
  000e8	6a 00		 push	 0
  000ea	55		 push	 ebp
  000eb	e8 00 00 00 00	 call	 _memset
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 730  : 
; 731  :             //
; 732  :             // Now query USBHUB for the USB_NODE_CONNECTION_INFORMATION_EX structure
; 733  :             // for this port.  This will tell us if a device is attached to this
; 734  :             // port, among other things.
; 735  :             //
; 736  :             connectionInfo->ConnectionIndex = index;
; 737  : 
; 738  :             success = DeviceIoControl(hHubDevice,
; 739  :                                       IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX,
; 740  :                                       connectionInfo,
; 741  :                                       nBytes,
; 742  :                                       connectionInfo,
; 743  :                                       nBytes,
; 744  :                                       &nBytes,
; 745  :                                       NULL);

  000f3	6a 00		 push	 0
  000f5	8d 44 24 2c	 lea	 eax, DWORD PTR _nBytes$136427[esp+1596]
  000f9	50		 push	 eax
  000fa	89 75 00	 mov	 DWORD PTR [ebp], esi
  000fd	8b 44 24 30	 mov	 eax, DWORD PTR _nBytes$136427[esp+1600]
  00101	50		 push	 eax
  00102	55		 push	 ebp
  00103	50		 push	 eax
  00104	55		 push	 ebp
  00105	68 48 04 22 00	 push	 2229320			; 00220448H
  0010a	57		 push	 edi
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32

; 746  : 
; 747  :             if (!success)

  00111	85 c0		 test	 eax, eax
  00113	75 0e		 jne	 SHORT $LN39@EnumerateH

; 748  :             {
; 749  :                 free(connectionInfo);

  00115	55		 push	 ebp
  00116	e8 00 00 00 00	 call	 _free
  0011b	83 c4 04	 add	 esp, 4

; 750  :                 continue;

  0011e	e9 9f 04 00 00	 jmp	 $LN42@EnumerateH
$LN39@EnumerateH:

; 756  :             continue;
; 757  :         }
; 758  : 
; 759  :         // Update the count of connected devices
; 760  :         //
; 761  :         if (connectionInfo->ConnectionStatus == DeviceConnected)

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	39 45 1f	 cmp	 DWORD PTR [ebp+31], eax
  0012b	75 03		 jne	 SHORT $LN37@EnumerateH

; 762  :         {
; 763  :             ulTotalDevicesConnected++;

  0012d	01 43 04	 add	 DWORD PTR [ebx+4], eax
$LN37@EnumerateH:

; 764  :         }
; 765  : 
; 766  :         // If there is a device connected, get the Device Description
; 767  :         //
; 768  :         deviceDesc = NULL;
; 769  :         if (connectionInfo->ConnectionStatus != NoDeviceConnected)

  00130	83 7d 1f 00	 cmp	 DWORD PTR [ebp+31], 0
  00134	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _deviceDesc$[esp+1592], 0
  0013c	74 22		 je	 SHORT $LN35@EnumerateH

; 770  :         {
; 771  :             driverKeyName = GetDriverKeyName(hHubDevice,
; 772  :                                              index);

  0013e	8b ce		 mov	 ecx, esi
  00140	e8 00 00 00 00	 call	 ?GetDriverKeyName@USB@@IAEPADPAXK@Z ; USB::GetDriverKeyName
  00145	8b f8		 mov	 edi, eax

; 773  : 
; 774  :             if (driverKeyName)

  00147	85 ff		 test	 edi, edi
  00149	74 15		 je	 SHORT $LN35@EnumerateH

; 775  :             {
; 776  :                 deviceDesc = DriverNameToDeviceDesc(driverKeyName);

  0014b	57		 push	 edi
  0014c	8b f3		 mov	 esi, ebx
  0014e	e8 00 00 00 00	 call	 ?DriverNameToDeviceDesc@USB@@IAEPADPAD@Z ; USB::DriverNameToDeviceDesc

; 777  :                 free(driverKeyName);

  00153	57		 push	 edi
  00154	89 44 24 30	 mov	 DWORD PTR _deviceDesc$[esp+1596], eax
  00158	e8 00 00 00 00	 call	 _free
  0015d	83 c4 04	 add	 esp, 4
$LN35@EnumerateH:

; 778  :             }
; 779  :         }
; 780  : 
; 781  :         // If there is a device connected to the port, try to retrieve the
; 782  :         // Configuration Descriptor from the device.
; 783  :         //
; 784  :         if (connectionInfo->ConnectionStatus == DeviceConnected)

  00160	83 7d 1f 01	 cmp	 DWORD PTR [ebp+31], 1

; 785  :         {
; 786  :             configDesc = GetConfigDescriptor(hHubDevice,index,0);

  00164	8b 74 24 20	 mov	 esi, DWORD PTR _index$[esp+1592]
  00168	75 3a		 jne	 SHORT $LN34@EnumerateH
  0016a	8b 5c 24 24	 mov	 ebx, DWORD PTR _hHubDevice$GSCopy$[esp+1592]
  0016e	56		 push	 esi
  0016f	e8 00 00 00 00	 call	 ?GetConfigDescriptor@USB@@IAEPAU_USB_DESCRIPTOR_REQUEST@@PAXKE@Z ; USB::GetConfigDescriptor
  00174	89 44 24 18	 mov	 DWORD PTR _configDesc$[esp+1592], eax

; 791  :         }
; 792  : 
; 793  :         if (configDesc != NULL &&
; 794  :             AreThereStringDescriptors(&connectionInfo->DeviceDescriptor,
; 795  :                                       (PUSB_CONFIGURATION_DESCRIPTOR)(configDesc+1)))

  00178	85 c0		 test	 eax, eax
  0017a	74 30		 je	 SHORT $LN32@EnumerateH
  0017c	8b f8		 mov	 edi, eax
  0017e	8d 5d 04	 lea	 ebx, DWORD PTR [ebp+4]
  00181	83 c7 0c	 add	 edi, 12			; 0000000cH
  00184	8b c3		 mov	 eax, ebx
  00186	e8 00 00 00 00	 call	 ?AreThereStringDescriptors@USB@@IAEHPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z ; USB::AreThereStringDescriptors
  0018b	85 c0		 test	 eax, eax
  0018d	74 1d		 je	 SHORT $LN32@EnumerateH

; 796  :         {
; 797  :             stringDescs = GetAllStringDescriptors(hHubDevice,index,
; 798  :                                   &connectionInfo->DeviceDescriptor,
; 799  :                                   (PUSB_CONFIGURATION_DESCRIPTOR)(configDesc+1));

  0018f	8b 4c 24 24	 mov	 ecx, DWORD PTR _hHubDevice$GSCopy$[esp+1592]
  00193	57		 push	 edi
  00194	53		 push	 ebx
  00195	56		 push	 esi
  00196	51		 push	 ecx
  00197	e8 00 00 00 00	 call	 ?GetAllStringDescriptors@USB@@IAEPAU_STRING_DESCRIPTOR_NODE@@PAXKPAU_USB_DEVICE_DESCRIPTOR@@PAU_USB_CONFIGURATION_DESCRIPTOR@@@Z ; USB::GetAllStringDescriptors
  0019c	8b d8		 mov	 ebx, eax
  0019e	89 44 24 14	 mov	 DWORD PTR _stringDescs$[esp+1592], eax

; 800  :         }
; 801  :         else

  001a2	eb 0e		 jmp	 SHORT $LN31@EnumerateH
$LN34@EnumerateH:

; 787  :         }
; 788  :         else
; 789  :         {
; 790  :             configDesc = NULL;

  001a4	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _configDesc$[esp+1592], 0
$LN32@EnumerateH:

; 802  :         {
; 803  :             stringDescs = NULL;

  001ac	33 db		 xor	 ebx, ebx
  001ae	89 5c 24 14	 mov	 DWORD PTR _stringDescs$[esp+1592], ebx
$LN31@EnumerateH:

; 804  :         }
; 805  : 
; 806  :         // If the device connected to the port is an external hub, get the
; 807  :         // name of the external hub and recursively enumerate it.
; 808  :         //
; 809  :         if (connectionInfo->DeviceIsHub)

  001b2	80 7d 18 00	 cmp	 BYTE PTR [ebp+24], 0
  001b6	0f 84 1b 01 00
	00		 je	 $LN29@EnumerateH

; 810  :         {
; 811  :             PCHAR extHubName = GetExternalHubName(hHubDevice,index);

  001bc	8b 7c 24 24	 mov	 edi, DWORD PTR _hHubDevice$GSCopy$[esp+1592]
  001c0	8b ce		 mov	 ecx, esi
  001c2	e8 00 00 00 00	 call	 ?GetExternalHubName@USB@@IAEPADPAXK@Z ; USB::GetExternalHubName
  001c7	89 44 24 30	 mov	 DWORD PTR _extHubName$136445[esp+1592], eax

; 812  :             if (extHubName != NULL)

  001cb	85 c0		 test	 eax, eax
  001cd	0f 84 04 01 00
	00		 je	 $LN29@EnumerateH

; 813  :             {
; 814  : 		        wsprintf(leafName, "%s[Port%d] ", UsbViewIndent[NestedLevel],index);

  001d3	8b 54 24 1c	 mov	 edx, DWORD PTR _this$GSCopy$[esp+1592]
  001d7	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001da	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?UsbViewIndent@@3PAPADA[eax*4]
  001e1	56		 push	 esi
  001e2	51		 push	 ecx
  001e3	8d 54 24 44	 lea	 edx, DWORD PTR _leafName$[esp+1600]
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PONEPIOA@?$CFs?$FLPort?$CFd?$FN?5?$AA@
  001ec	52		 push	 edx
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 815  : 		        strcat(leafName, ConnectionStatuses[connectionInfo->ConnectionStatus]);

  001f3	8b 45 1f	 mov	 eax, DWORD PTR [ebp+31]
  001f6	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?ConnectionStatuses@@3PAPADA[eax*4]
  001fd	83 c4 10	 add	 esp, 16			; 00000010H
  00200	8b c8		 mov	 ecx, eax
$LL108@EnumerateH:
  00202	8a 10		 mov	 dl, BYTE PTR [eax]
  00204	40		 inc	 eax
  00205	84 d2		 test	 dl, dl
  00207	75 f9		 jne	 SHORT $LL108@EnumerateH
  00209	8d 7c 24 3c	 lea	 edi, DWORD PTR _leafName$[esp+1592]
  0020d	2b c1		 sub	 eax, ecx
  0020f	8b f1		 mov	 esi, ecx
  00211	4f		 dec	 edi
$LL109@EnumerateH:
  00212	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00215	47		 inc	 edi
  00216	84 c9		 test	 cl, cl
  00218	75 f8		 jne	 SHORT $LL109@EnumerateH

; 816  : 				if (deviceDesc)

  0021a	8b 5c 24 2c	 mov	 ebx, DWORD PTR _deviceDesc$[esp+1592]
  0021e	8b c8		 mov	 ecx, eax
  00220	c1 e9 02	 shr	 ecx, 2
  00223	f3 a5		 rep movsd
  00225	8b c8		 mov	 ecx, eax
  00227	83 e1 03	 and	 ecx, 3
  0022a	f3 a4		 rep movsb
  0022c	85 db		 test	 ebx, ebx
  0022e	74 46		 je	 SHORT $LN28@EnumerateH

; 817  : 				{
; 818  : 					strcat(leafName, " : ");

  00230	8d 7c 24 3c	 lea	 edi, DWORD PTR _leafName$[esp+1592]
  00234	4f		 dec	 edi
$LL110@EnumerateH:
  00235	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00238	47		 inc	 edi
  00239	84 c0		 test	 al, al
  0023b	75 f8		 jne	 SHORT $LL110@EnumerateH
  0023d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_03MCPBMLDJ@?5?3?5?$AA@

; 819  : 					strcat(leafName, deviceDesc);

  00243	8b c3		 mov	 eax, ebx
  00245	89 0f		 mov	 DWORD PTR [edi], ecx
  00247	8b c8		 mov	 ecx, eax
  00249	8d a4 24 00 00
	00 00		 npad	 7
$LL111@EnumerateH:
  00250	8a 10		 mov	 dl, BYTE PTR [eax]
  00252	40		 inc	 eax
  00253	84 d2		 test	 dl, dl
  00255	75 f9		 jne	 SHORT $LL111@EnumerateH
  00257	8d 7c 24 3c	 lea	 edi, DWORD PTR _leafName$[esp+1592]
  0025b	2b c1		 sub	 eax, ecx
  0025d	8b f1		 mov	 esi, ecx
  0025f	4f		 dec	 edi
$LL112@EnumerateH:
  00260	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00263	47		 inc	 edi
  00264	84 c9		 test	 cl, cl
  00266	75 f8		 jne	 SHORT $LL112@EnumerateH
  00268	8b c8		 mov	 ecx, eax
  0026a	c1 e9 02	 shr	 ecx, 2
  0026d	f3 a5		 rep movsd
  0026f	8b c8		 mov	 ecx, eax
  00271	83 e1 03	 and	 ecx, 3
  00274	f3 a4		 rep movsb
$LN28@EnumerateH:

; 820  : 				}
; 821  : 				USBTraceInfo(leafName,extHubName);

  00276	8b 7c 24 30	 mov	 edi, DWORD PTR _extHubName$136445[esp+1592]
  0027a	8d 54 24 3c	 lea	 edx, DWORD PTR _leafName$[esp+1592]
  0027e	52		 push	 edx
  0027f	8b c7		 mov	 eax, edi
  00281	e8 00 00 00 00	 call	 ?USBTraceInfo@@YAXPAD0@Z ; USBTraceInfo

; 822  : 
; 823  :                 EnumerateHub(extHubName,
; 824  :                              connectionInfo,
; 825  :                              configDesc,
; 826  :                              stringDescs,
; 827  :                              deviceDesc);

  00286	8b 74 24 1c	 mov	 esi, DWORD PTR _configDesc$[esp+1596]
  0028a	8b 4c 24 20	 mov	 ecx, DWORD PTR _this$GSCopy$[esp+1596]
  0028e	83 c4 04	 add	 esp, 4
  00291	53		 push	 ebx
  00292	8b 5c 24 18	 mov	 ebx, DWORD PTR _stringDescs$[esp+1596]
  00296	53		 push	 ebx
  00297	56		 push	 esi
  00298	55		 push	 ebp
  00299	57		 push	 edi
  0029a	e8 00 00 00 00	 call	 ?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z ; USB::EnumerateHub

; 828  : 
; 829  : 			    if (configDesc != NULL)

  0029f	85 f6		 test	 esi, esi
  002a1	74 09		 je	 SHORT $LN27@EnumerateH

; 830  : 				    free(configDesc);

  002a3	56		 push	 esi
  002a4	e8 00 00 00 00	 call	 _free
  002a9	83 c4 04	 add	 esp, 4
$LN27@EnumerateH:

; 831  : 
; 832  : 			    if (connectionInfo != NULL)
; 833  : 				    free(connectionInfo);

  002ac	55		 push	 ebp
  002ad	e8 00 00 00 00	 call	 _free
  002b2	83 c4 04	 add	 esp, 4

; 834  : 
; 835  : 			    while (stringDescs != NULL)

  002b5	85 db		 test	 ebx, ebx
  002b7	0f 84 05 03 00
	00		 je	 $LN42@EnumerateH
  002bd	8b 44 24 14	 mov	 eax, DWORD PTR _stringDescs$[esp+1592]
$LL25@EnumerateH:

; 836  : 			    {
; 837  : 				    Next = stringDescs->Next;

  002c1	8b 30		 mov	 esi, DWORD PTR [eax]

; 838  : 				    free(stringDescs);

  002c3	50		 push	 eax
  002c4	e8 00 00 00 00	 call	 _free
  002c9	83 c4 04	 add	 esp, 4

; 839  : 				    stringDescs = Next;

  002cc	8b c6		 mov	 eax, esi
  002ce	85 f6		 test	 esi, esi
  002d0	75 ef		 jne	 SHORT $LL25@EnumerateH

; 840  : 			    }
; 841  : 
; 842  :                 // On to the next port
; 843  :                 //
; 844  :                 continue;

  002d2	e9 eb 02 00 00	 jmp	 $LN42@EnumerateH
$LN29@EnumerateH:

; 845  :             }
; 846  :         }
; 847  : 
; 848  :         // Allocate some space for a USBDEVICEINFO structure to hold the
; 849  :         // hub info, hub name, and connection info pointers.  GPTR zero
; 850  :         // initializes the structure for us.
; 851  :         //
; 852  :         info = (PUSBDEVICEINFO) malloc(sizeof(USBDEVICEINFO));

  002d7	6a 14		 push	 20			; 00000014H
  002d9	e8 00 00 00 00	 call	 _malloc
  002de	8b c8		 mov	 ecx, eax
  002e0	83 c4 04	 add	 esp, 4
  002e3	89 4c 24 30	 mov	 DWORD PTR _info$[esp+1592], ecx

; 853  :         if(info)

  002e7	85 c9		 test	 ecx, ecx
  002e9	0f 84 84 02 00
	00		 je	 $LN23@EnumerateH

; 854  :         {
; 855  :             memset(info,0x00,sizeof(USBDEVICEINFO));

  002ef	33 c0		 xor	 eax, eax
  002f1	89 01		 mov	 DWORD PTR [ecx], eax
  002f3	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 856  : 
; 857  :             info->ConnectionInfo = connectionInfo;
; 858  :             info->ConfigDesc = configDesc;

  002f6	8b 44 24 18	 mov	 eax, DWORD PTR _configDesc$[esp+1592]

; 859  :             info->StringDescs = stringDescs;
; 860  : 
; 861  :             wsprintf(leafName, "[Port%d] ", index);

  002fa	56		 push	 esi
  002fb	89 69 08	 mov	 DWORD PTR [ecx+8], ebp
  002fe	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00301	89 59 10	 mov	 DWORD PTR [ecx+16], ebx
  00304	8d 4c 24 40	 lea	 ecx, DWORD PTR _leafName$[esp+1596]
  00308	68 00 00 00 00	 push	 OFFSET ??_C@_09IBNJMOOD@?$FLPort?$CFd?$FN?5?$AA@
  0030d	51		 push	 ecx
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 862  :             strcat(leafName, ConnectionStatuses[connectionInfo->ConnectionStatus]);

  00314	8b 55 1f	 mov	 edx, DWORD PTR [ebp+31]
  00317	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ConnectionStatuses@@3PAPADA[edx*4]
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00321	8b c8		 mov	 ecx, eax
$LL113@EnumerateH:
  00323	8a 10		 mov	 dl, BYTE PTR [eax]
  00325	40		 inc	 eax
  00326	84 d2		 test	 dl, dl
  00328	75 f9		 jne	 SHORT $LL113@EnumerateH
  0032a	8d 7c 24 3c	 lea	 edi, DWORD PTR _leafName$[esp+1592]
  0032e	2b c1		 sub	 eax, ecx
  00330	8b f1		 mov	 esi, ecx
  00332	4f		 dec	 edi
$LL114@EnumerateH:
  00333	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00336	47		 inc	 edi
  00337	84 c9		 test	 cl, cl
  00339	75 f8		 jne	 SHORT $LL114@EnumerateH
  0033b	8b c8		 mov	 ecx, eax
  0033d	c1 e9 02	 shr	 ecx, 2
  00340	f3 a5		 rep movsd
  00342	8b c8		 mov	 ecx, eax
  00344	83 e1 03	 and	 ecx, 3
  00347	f3 a4		 rep movsb

; 863  :             if (deviceDesc)

  00349	8b 74 24 2c	 mov	 esi, DWORD PTR _deviceDesc$[esp+1592]
  0034d	85 f6		 test	 esi, esi
  0034f	74 14		 je	 SHORT $LN22@EnumerateH

; 864  :             {
; 865  :                 strcat(leafName, " : ");

  00351	8d 7c 24 3c	 lea	 edi, DWORD PTR _leafName$[esp+1592]
  00355	4f		 dec	 edi
$LL115@EnumerateH:
  00356	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00359	47		 inc	 edi
  0035a	84 c0		 test	 al, al
  0035c	75 f8		 jne	 SHORT $LL115@EnumerateH
  0035e	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_03MCPBMLDJ@?5?3?5?$AA@
  00363	89 07		 mov	 DWORD PTR [edi], eax
$LN22@EnumerateH:

; 866  :             }
; 867  : 
; 868  :             memset(deviceInfo,0x00,sizeof(deviceInfo));

  00365	68 e8 03 00 00	 push	 1000			; 000003e8H
  0036a	8d 8c 24 40 02
	00 00		 lea	 ecx, DWORD PTR _deviceInfo$[esp+1596]
  00371	6a 00		 push	 0
  00373	51		 push	 ecx
  00374	e8 00 00 00 00	 call	 _memset
  00379	83 c4 0c	 add	 esp, 12			; 0000000cH

; 869  : 		    if (info->ConnectionInfo->ConnectionStatus == DeviceConnected)

  0037c	83 7d 1f 01	 cmp	 DWORD PTR [ebp+31], 1
  00380	0f 85 b4 01 00
	00		 jne	 $LN21@EnumerateH

; 870  : 		    {
; 871  : 			    PSTRING_DESCRIPTOR_NODE pDescNode = NULL;
; 872  : 
; 873  : 			    //get speed of device - Low/Full/High
; 874  : 			    memset(deviceSpeed,0x0,5);

  00386	33 c0		 xor	 eax, eax
  00388	89 44 24 34	 mov	 DWORD PTR _deviceSpeed$[esp+1592], eax
  0038c	88 44 24 38	 mov	 BYTE PTR _deviceSpeed$[esp+1596], al

; 875  : 			    strcpy(deviceSpeed, "???");

  00390	c7 44 24 34 3f
	3f 3f 00	 mov	 DWORD PTR _deviceSpeed$[esp+1592], 4144959 ; 003f3f3fH

; 876  : 
; 877  : 			    if(info->ConnectionInfo->Speed == UsbHighSpeed)

  00398	8a 45 17	 mov	 al, BYTE PTR [ebp+23]
  0039b	3c 02		 cmp	 al, 2
  0039d	75 15		 jne	 SHORT $LN20@EnumerateH

; 878  : 			    {
; 879  : 				    strcpy(deviceSpeed,"HIGH");

  0039f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_04PKDHFCJF@HIGH?$AA@
  003a5	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04PKDHFCJF@HIGH?$AA@+4
  003aa	89 54 24 34	 mov	 DWORD PTR _deviceSpeed$[esp+1592], edx
  003ae	88 44 24 38	 mov	 BYTE PTR _deviceSpeed$[esp+1596], al
  003b2	eb 26		 jmp	 SHORT $LN16@EnumerateH
$LN20@EnumerateH:

; 880  : 			    }
; 881  : 			    else if(info->ConnectionInfo->Speed == UsbLowSpeed)

  003b4	84 c0		 test	 al, al
  003b6	75 0a		 jne	 SHORT $LN18@EnumerateH

; 882  : 			    {
; 883  : 				    strcpy(deviceSpeed, "LOW");

  003b8	c7 44 24 34 4c
	4f 57 00	 mov	 DWORD PTR _deviceSpeed$[esp+1592], 5721932 ; 00574f4cH
  003c0	eb 18		 jmp	 SHORT $LN16@EnumerateH
$LN18@EnumerateH:

; 884  : 			    }
; 885  : 			    else if(info->ConnectionInfo->Speed == UsbFullSpeed)

  003c2	3c 01		 cmp	 al, 1
  003c4	75 14		 jne	 SHORT $LN16@EnumerateH

; 886  : 			    {
; 887  : 				    strcpy(deviceSpeed, "FULL");

  003c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04DHPBCODG@FULL?$AA@
  003cc	8a 15 04 00 00
	00		 mov	 dl, BYTE PTR ??_C@_04DHPBCODG@FULL?$AA@+4
  003d2	89 4c 24 34	 mov	 DWORD PTR _deviceSpeed$[esp+1592], ecx
  003d6	88 54 24 38	 mov	 BYTE PTR _deviceSpeed$[esp+1596], dl
$LN16@EnumerateH:

; 888  : 			    }
; 889  :     			
; 890  : 			    if(info->ConnectionInfo->DeviceDescriptor.iSerialNumber)

  003da	8a 4d 14	 mov	 cl, BYTE PTR [ebp+20]
  003dd	84 c9		 test	 cl, cl
  003df	74 75		 je	 SHORT $LN15@EnumerateH

; 891  : 			    {
; 892  : 				    pDescNode = info->StringDescs;

  003e1	8b 5c 24 14	 mov	 ebx, DWORD PTR _stringDescs$[esp+1592]
  003e5	8b c3		 mov	 eax, ebx

; 893  : 				    while (pDescNode)

  003e7	85 db		 test	 ebx, ebx
  003e9	74 10		 je	 SHORT $LN11@EnumerateH
  003eb	eb 03 8d 49 00	 npad	 5
$LL14@EnumerateH:

; 894  : 				    {
; 895  : 					    if (pDescNode->DescriptorIndex == info->ConnectionInfo->DeviceDescriptor.iSerialNumber)

  003f0	38 48 04	 cmp	 BYTE PTR [eax+4], cl
  003f3	74 34		 je	 SHORT $LN103@EnumerateH

; 896  : 						    break;
; 897  : 					    pDescNode = pDescNode->Next;

  003f5	8b 00		 mov	 eax, DWORD PTR [eax]
  003f7	85 c0		 test	 eax, eax
  003f9	75 f5		 jne	 SHORT $LL14@EnumerateH
$LN11@EnumerateH:

; 906  :                         _snprintf(deviceInfo,sizeof(deviceInfo)-1,"%s [VID:%.4X PID:%.4X SN:%s Spd: %s]",deviceDesc,
; 907  :                                         info->ConnectionInfo->DeviceDescriptor.idVendor,
; 908  :                                         info->ConnectionInfo->DeviceDescriptor.idProduct,
; 909  :                                         "Not Initialized",deviceSpeed);

  003fb	0f b7 45 0e	 movzx	 eax, WORD PTR [ebp+14]
  003ff	0f b7 4d 0c	 movzx	 ecx, WORD PTR [ebp+12]
  00403	8d 54 24 34	 lea	 edx, DWORD PTR _deviceSpeed$[esp+1592]
  00407	52		 push	 edx
  00408	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CGBIAJFO@Not?5Initialized?$AA@
  0040d	50		 push	 eax
  0040e	51		 push	 ecx
  0040f	56		 push	 esi
  00410	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LGIDNAEF@?$CFs?5?$FLVID?3?$CF?44X?5PID?3?$CF?44X?5SN?3?$CFs?5Spd?3@
  00415	8d 94 24 54 02
	00 00		 lea	 edx, DWORD PTR _deviceInfo$[esp+1616]
  0041c	68 e7 03 00 00	 push	 999			; 000003e7H
  00421	52		 push	 edx
  00422	e8 00 00 00 00	 call	 __snprintf

; 910  : 			    }
; 911  : 			    else

  00427	eb 5d		 jmp	 SHORT $LN123@EnumerateH
$LN103@EnumerateH:

; 898  : 				    }
; 899  : 				    // Modified to fix the SCR 3176
; 900  : 				    if (pDescNode)
; 901  :                         _snprintf(deviceInfo,sizeof(deviceInfo)-1,"%s [VID:%.4X PID:%.4X SN:%s Spd: %s]",deviceDesc,
; 902  :                                         info->ConnectionInfo->DeviceDescriptor.idVendor,
; 903  :                                         info->ConnectionInfo->DeviceDescriptor.idProduct,
; 904  :                                         (char const* )pDescNode->StringDescriptor->bString,deviceSpeed);

  00429	0f b7 55 0e	 movzx	 edx, WORD PTR [ebp+14]
  0042d	8d 4c 24 34	 lea	 ecx, DWORD PTR _deviceSpeed$[esp+1592]
  00431	51		 push	 ecx
  00432	83 c0 0a	 add	 eax, 10			; 0000000aH
  00435	50		 push	 eax
  00436	0f b7 45 0c	 movzx	 eax, WORD PTR [ebp+12]
  0043a	52		 push	 edx
  0043b	50		 push	 eax
  0043c	56		 push	 esi
  0043d	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LGIDNAEF@?$CFs?5?$FLVID?3?$CF?44X?5PID?3?$CF?44X?5SN?3?$CFs?5Spd?3@
  00442	8d 8c 24 54 02
	00 00		 lea	 ecx, DWORD PTR _deviceInfo$[esp+1616]
  00449	68 e7 03 00 00	 push	 999			; 000003e7H
  0044e	51		 push	 ecx
  0044f	e8 00 00 00 00	 call	 __snprintf

; 905  : 				    else

  00454	eb 30		 jmp	 SHORT $LN123@EnumerateH
$LN15@EnumerateH:

; 912  : 				    _snprintf(deviceInfo,sizeof(deviceInfo)-1,"%s [VID:%.4X PID:%.4X SN:%s Spd: %s]",deviceDesc,
; 913  : 								    info->ConnectionInfo->DeviceDescriptor.idVendor,
; 914  : 								    info->ConnectionInfo->DeviceDescriptor.idProduct,
; 915  : 								    "Not Found",deviceSpeed);

  00456	0f b7 4d 0e	 movzx	 ecx, WORD PTR [ebp+14]
  0045a	0f b7 55 0c	 movzx	 edx, WORD PTR [ebp+12]
  0045e	8d 44 24 34	 lea	 eax, DWORD PTR _deviceSpeed$[esp+1592]
  00462	50		 push	 eax
  00463	68 00 00 00 00	 push	 OFFSET ??_C@_09CFCBFJND@Not?5Found?$AA@
  00468	51		 push	 ecx
  00469	52		 push	 edx
  0046a	56		 push	 esi
  0046b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LGIDNAEF@?$CFs?5?$FLVID?3?$CF?44X?5PID?3?$CF?44X?5SN?3?$CFs?5Spd?3@
  00470	8d 84 24 54 02
	00 00		 lea	 eax, DWORD PTR _deviceInfo$[esp+1616]
  00477	68 e7 03 00 00	 push	 999			; 000003e7H
  0047c	50		 push	 eax
  0047d	e8 00 00 00 00	 call	 __snprintf
  00482	8b 5c 24 34	 mov	 ebx, DWORD PTR _stringDescs$[esp+1624]
$LN123@EnumerateH:

; 916  :     			
; 917  : 		        Log(LOG_MESSAGE,__LINE__,"%s%s%s",UsbViewIndent[NestedLevel],leafName,deviceInfo);

  00486	8b 74 24 3c	 mov	 esi, DWORD PTR _this$GSCopy$[esp+1624]
  0048a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0048d	83 c4 20	 add	 esp, 32			; 00000020H
  00490	8d 8c 24 3c 02
	00 00		 lea	 ecx, DWORD PTR _deviceInfo$[esp+1592]
  00497	51		 push	 ecx
  00498	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?UsbViewIndent@@3PAPADA[eax*4]
  0049f	8d 54 24 40	 lea	 edx, DWORD PTR _leafName$[esp+1596]
  004a3	52		 push	 edx
  004a4	51		 push	 ecx
  004a5	68 00 00 00 00	 push	 OFFSET ??_C@_06DIJPEION@?$CFs?$CFs?$CFs?$AA@
  004aa	68 95 03 00 00	 push	 917			; 00000395H
  004af	6a 01		 push	 1
  004b1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 918  : 
; 919  :                 PushBackDetails(deviceInfo);

  004b6	51		 push	 ecx
  004b7	8b cc		 mov	 ecx, esp
  004b9	8d 84 24 58 02
	00 00		 lea	 eax, DWORD PTR _deviceInfo$[esp+1620]
  004c0	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  004c7	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  004ce	89 64 24 48	 mov	 DWORD PTR $T231679[esp+1620], esp
  004d2	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  004d6	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  004d9	8d a4 24 00 00
	00 00		 npad	 7
$LL116@EnumerateH:
  004e0	8a 10		 mov	 dl, BYTE PTR [eax]
  004e2	40		 inc	 eax
  004e3	84 d2		 test	 dl, dl
  004e5	75 f9		 jne	 SHORT $LL116@EnumerateH
  004e7	2b c7		 sub	 eax, edi
  004e9	50		 push	 eax
  004ea	8d 94 24 5c 02
	00 00		 lea	 edx, DWORD PTR _deviceInfo$[esp+1624]
  004f1	52		 push	 edx
  004f2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  004f7	c7 84 24 50 06
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1628], 0
  00502	c7 84 24 50 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1628], -1
  0050d	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 920  :                 if(info->ConnectionInfo)
; 921  :                     ConnectionInfo(info->ConnectionInfo,info->StringDescs);

  00512	53		 push	 ebx
  00513	8b d5		 mov	 edx, ebp
  00515	8b ce		 mov	 ecx, esi
  00517	e8 00 00 00 00	 call	 ?ConnectionInfo@USB@@IAEXPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::ConnectionInfo

; 922  :                 if(info->ConfigDesc)

  0051c	83 7c 24 18 00	 cmp	 DWORD PTR _configDesc$[esp+1592], 0
  00521	74 3f		 je	 SHORT $LN6@EnumerateH

; 923  :                     ConfigDesc((PUSB_CONFIGURATION_DESCRIPTOR)(info->ConfigDesc + 1),info->StringDescs);

  00523	8b 44 24 14	 mov	 eax, DWORD PTR _stringDescs$[esp+1592]
  00527	8b 5c 24 1c	 mov	 ebx, DWORD PTR _this$GSCopy$[esp+1592]
  0052b	50		 push	 eax
  0052c	8b 44 24 1c	 mov	 eax, DWORD PTR _configDesc$[esp+1596]
  00530	83 c0 0c	 add	 eax, 12			; 0000000cH
  00533	e8 00 00 00 00	 call	 ?ConfigDesc@USB@@IAEXPAU_USB_CONFIGURATION_DESCRIPTOR@@PAU_STRING_DESCRIPTOR_NODE@@@Z ; USB::ConfigDesc

; 924  : 		    }
; 925  :     		else

  00538	eb 28		 jmp	 SHORT $LN6@EnumerateH
$LN21@EnumerateH:

; 926  : 		    {
; 927  : 			    Log(LOG_MESSAGE,__LINE__,"%s%s",UsbViewIndent[NestedLevel],leafName);

  0053a	8b 54 24 1c	 mov	 edx, DWORD PTR _this$GSCopy$[esp+1592]
  0053e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00541	8d 4c 24 3c	 lea	 ecx, DWORD PTR _leafName$[esp+1592]
  00545	51		 push	 ecx
  00546	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?UsbViewIndent@@3PAPADA[eax*4]
  0054d	51		 push	 ecx
  0054e	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00553	68 9f 03 00 00	 push	 927			; 0000039fH
  00558	6a 01		 push	 1
  0055a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0055f	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@EnumerateH:

; 928  : 		    }
; 929  :             free(info);

  00562	8b 54 24 30	 mov	 edx, DWORD PTR _info$[esp+1592]
  00566	52		 push	 edx
  00567	e8 00 00 00 00	 call	 _free
  0056c	8b 5c 24 18	 mov	 ebx, DWORD PTR _stringDescs$[esp+1596]
  00570	83 c4 04	 add	 esp, 4
$LN23@EnumerateH:

; 930  :             info = NULL;
; 931  :         }   //END: if(info)
; 932  : 
; 933  : 	    if (configDesc != NULL)

  00573	8b 44 24 18	 mov	 eax, DWORD PTR _configDesc$[esp+1592]
  00577	85 c0		 test	 eax, eax
  00579	74 09		 je	 SHORT $LN5@EnumerateH

; 934  : 		    free(configDesc);

  0057b	50		 push	 eax
  0057c	e8 00 00 00 00	 call	 _free
  00581	83 c4 04	 add	 esp, 4
$LN5@EnumerateH:

; 935  : 
; 936  : 	    if (connectionInfo != NULL)
; 937  : 		    free(connectionInfo);

  00584	55		 push	 ebp
  00585	e8 00 00 00 00	 call	 _free
  0058a	83 c4 04	 add	 esp, 4

; 938  : 
; 939  :         while (stringDescs != NULL)

  0058d	85 db		 test	 ebx, ebx
  0058f	74 31		 je	 SHORT $LN42@EnumerateH
  00591	8b 44 24 14	 mov	 eax, DWORD PTR _stringDescs$[esp+1592]
$LL3@EnumerateH:

; 940  : 	    {
; 941  : 		    Next = stringDescs->Next;

  00595	8b 30		 mov	 esi, DWORD PTR [eax]

; 942  : 		    free(stringDescs);

  00597	50		 push	 eax
  00598	e8 00 00 00 00	 call	 _free
  0059d	83 c4 04	 add	 esp, 4

; 943  : 		    stringDescs = Next;

  005a0	8b c6		 mov	 eax, esi
  005a2	85 f6		 test	 esi, esi
  005a4	75 ef		 jne	 SHORT $LL3@EnumerateH

; 944  : 	    }
; 945  :     }

  005a6	eb 1a		 jmp	 SHORT $LN42@EnumerateH
$LN40@EnumerateH:

; 751  :             }
; 752  :         }
; 753  :         else
; 754  :         {
; 755  :             Log(LOG_DEBUG,__LINE__,"-- USB.EnumHubPorts, new Port %d ConnInfo (%u) null",index,nBytes);

  005a8	8b 44 24 28	 mov	 eax, DWORD PTR _nBytes$136427[esp+1592]
  005ac	50		 push	 eax
  005ad	56		 push	 esi
  005ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@EKAJALEI@?9?9?5USB?4EnumHubPorts?0?5new?5Port?5?$CFd@
  005b3	68 f3 02 00 00	 push	 755			; 000002f3H
  005b8	6a 10		 push	 16			; 00000010H
  005ba	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  005bf	83 c4 14	 add	 esp, 20			; 00000014H
$LN42@EnumerateH:
  005c2	8b 74 24 20	 mov	 esi, DWORD PTR _index$[esp+1592]
  005c6	8b 5c 24 1c	 mov	 ebx, DWORD PTR _this$GSCopy$[esp+1592]
  005ca	46		 inc	 esi
  005cb	89 74 24 20	 mov	 DWORD PTR _index$[esp+1592], esi
  005cf	3b b4 24 3c 06
	00 00		 cmp	 esi, DWORD PTR _NumPorts$[esp+1588]
  005d6	0f 86 e4 fa ff
	ff		 jbe	 $LL118@EnumerateH
$LN41@EnumerateH:

; 946  : 
; 947  : 	if(NestedLevel)			// only for prevent bugs

  005dc	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  005df	85 c0		 test	 eax, eax
  005e1	74 04		 je	 SHORT $LN1@EnumerateH

; 948  : 		NestedLevel--;

  005e3	48		 dec	 eax
  005e4	89 43 08	 mov	 DWORD PTR [ebx+8], eax
$LN1@EnumerateH:

; 949  : 
; 950  :     Log(LOG_DEBUG,__LINE__,"<< USB.EnumHubPorts");

  005e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LMILCJOE@?$DM?$DM?5USB?4EnumHubPorts?$AA@
  005ec	68 b6 03 00 00	 push	 950			; 000003b6H
  005f1	6a 10		 push	 16			; 00000010H
  005f3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  005f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 951  : }

  005fb	8b 8c 24 2c 06
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1592]
  00602	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00609	59		 pop	 ecx
  0060a	5f		 pop	 edi
  0060b	5e		 pop	 esi
  0060c	5d		 pop	 ebp
  0060d	5b		 pop	 ebx
  0060e	8b 8c 24 10 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1572]
  00615	33 cc		 xor	 ecx, esp
  00617	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061c	81 c4 24 06 00
	00		 add	 esp, 1572		; 00000624H
  00622	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EnumerateHubPorts@USB@@IAEXPAXK@Z$0:
  00000	8b 8d f4 f9 ff
	ff		 mov	 ecx, DWORD PTR $T231679[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?EnumerateHubPorts@USB@@IAEXPAXK@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 82 d8 f9 ff
	ff		 lea	 eax, DWORD PTR [edx-1576]
  00015	8b 8a d4 f9 ff
	ff		 mov	 ecx, DWORD PTR [edx-1580]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	83 c0 10	 add	 eax, 16			; 00000010H
  00025	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?EnumerateHubPorts@USB@@IAEXPAXK@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?EnumerateHubPorts@USB@@IAEXPAXK@Z ENDP			; USB::EnumerateHubPorts
PUBLIC	_DeviceDesc$GSCopy$
PUBLIC	_ConnectionInfo$GSCopy$
PUBLIC	_HubName$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z$0
__ehfuncinfo$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z
_TEXT	SEGMENT
_hHubDevice$ = -564					; size = 4
tv80 = -560						; size = 4
_HubName$GSCopy$ = -556					; size = 4
_DeviceDesc$GSCopy$ = -552				; size = 4
$T237242 = -552						; size = 4
_nBytes$ = -548						; size = 4
_this$GSCopy$ = -544					; size = 4
_ConnectionInfo$GSCopy$ = -540				; size = 4
_leafName$ = -536					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_HubName$ = 8						; size = 4
_ConnectionInfo$ = 12					; size = 4
_ConfigDesc$ = 16					; size = 4
_StringDescs$ = 20					; size = 4
_DeviceDesc$ = 24					; size = 4
?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z PROC ; USB::EnumerateHub, COMDAT
; _this$ = ecx

; 1052 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 28 02 00
	00		 sub	 esp, 552		; 00000228H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 20 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+564], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 38 02
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+580]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1179 :     }
; 1180 :     Log(LOG_DEBUG,__LINE__,"<< USB.EnumHub");

  00040	8b 45 18	 mov	 eax, DWORD PTR _DeviceDesc$[ebp]
  00043	8b 7d 08	 mov	 edi, DWORD PTR _HubName$[ebp]
  00046	8b 75 0c	 mov	 esi, DWORD PTR _ConnectionInfo$[ebp]
  00049	68 ff 01 00 00	 push	 511			; 000001ffH
  0004e	89 4c 24 28	 mov	 DWORD PTR _this$GSCopy$[esp+584], ecx
  00052	8d 4c 24 31	 lea	 ecx, DWORD PTR _leafName$[esp+585]
  00056	6a 00		 push	 0
  00058	51		 push	 ecx
  00059	89 7c 24 24	 mov	 DWORD PTR _HubName$GSCopy$[esp+592], edi
  0005d	89 74 24 34	 mov	 DWORD PTR _ConnectionInfo$GSCopy$[esp+592], esi
  00061	89 44 24 28	 mov	 DWORD PTR _DeviceDesc$GSCopy$[esp+592], eax
  00065	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _nBytes$[esp+592], 0
  0006d	c6 44 24 38 00	 mov	 BYTE PTR _leafName$[esp+592], 0
  00072	e8 00 00 00 00	 call	 _memset
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JENLAABL@?$DO?$DO?5USB?4EnumHub?$AA@
  0007f	68 24 04 00 00	 push	 1060			; 00000424H
  00084	6a 10		 push	 16			; 00000010H
  00086	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	6a 14		 push	 20			; 00000014H
  00090	e8 00 00 00 00	 call	 _malloc
  00095	8b d8		 mov	 ebx, eax
  00097	83 c4 04	 add	 esp, 4
  0009a	85 db		 test	 ebx, ebx
  0009c	0f 84 7d 02 00
	00		 je	 $LN12@EnumerateH@2
  000a2	8b 55 10	 mov	 edx, DWORD PTR _ConfigDesc$[ebp]
  000a5	8b 45 14	 mov	 eax, DWORD PTR _StringDescs$[ebp]
  000a8	6a 4c		 push	 76			; 0000004cH
  000aa	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  000ad	89 73 08	 mov	 DWORD PTR [ebx+8], esi
  000b0	89 53 0c	 mov	 DWORD PTR [ebx+12], edx
  000b3	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000b6	e8 00 00 00 00	 call	 _malloc
  000bb	83 c4 04	 add	 esp, 4
  000be	89 44 24 14	 mov	 DWORD PTR tv80[esp+580], eax
  000c2	89 03		 mov	 DWORD PTR [ebx], eax
  000c4	6a 4c		 push	 76			; 0000004cH
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 32 02 00
	00		 je	 $LN11@EnumerateH@2
  000ce	6a 00		 push	 0
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 _memset
  000d6	8b c7		 mov	 eax, edi
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  000de	8b ff		 npad	 2
$LL18@EnumerateH@2:
  000e0	8a 08		 mov	 cl, BYTE PTR [eax]
  000e2	40		 inc	 eax
  000e3	84 c9		 test	 cl, cl
  000e5	75 f9		 jne	 SHORT $LL18@EnumerateH@2
  000e7	2b c2		 sub	 eax, edx
  000e9	83 c0 05	 add	 eax, 5
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _malloc
  000f2	8b f0		 mov	 esi, eax
  000f4	83 c4 04	 add	 esp, 4
  000f7	85 f6		 test	 esi, esi
  000f9	0f 84 30 01 00
	00		 je	 $LN10@EnumerateH@2
  000ff	8b c7		 mov	 eax, edi
  00101	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL19@EnumerateH@2:
  00104	8a 08		 mov	 cl, BYTE PTR [eax]
  00106	40		 inc	 eax
  00107	84 c9		 test	 cl, cl
  00109	75 f9		 jne	 SHORT $LL19@EnumerateH@2
  0010b	2b c2		 sub	 eax, edx
  0010d	83 c0 05	 add	 eax, 5
  00110	50		 push	 eax
  00111	6a 00		 push	 0
  00113	56		 push	 esi
  00114	e8 00 00 00 00	 call	 _memset
  00119	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04GBDIODIA@?2?2?4?2?$AA@
  0011f	89 0e		 mov	 DWORD PTR [esi], ecx
  00121	8a 15 04 00 00
	00		 mov	 dl, BYTE PTR ??_C@_04GBDIODIA@?2?2?4?2?$AA@+4
  00127	8b ce		 mov	 ecx, esi
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012c	2b cf		 sub	 ecx, edi
  0012e	88 56 04	 mov	 BYTE PTR [esi+4], dl
  00131	8b c7		 mov	 eax, edi
  00133	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
$LL15@EnumerateH@2:
  00136	8a 08		 mov	 cl, BYTE PTR [eax]
  00138	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0013b	40		 inc	 eax
  0013c	84 c9		 test	 cl, cl
  0013e	75 f6		 jne	 SHORT $LL15@EnumerateH@2
  00140	6a 00		 push	 0
  00142	6a 00		 push	 0
  00144	6a 03		 push	 3
  00146	6a 00		 push	 0
  00148	6a 02		 push	 2
  0014a	68 00 00 00 40	 push	 1073741824		; 40000000H
  0014f	56		 push	 esi
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00156	56		 push	 esi
  00157	89 44 24 14	 mov	 DWORD PTR _hHubDevice$[esp+584], eax
  0015b	e8 00 00 00 00	 call	 _free
  00160	8b 74 24 14	 mov	 esi, DWORD PTR _hHubDevice$[esp+584]
  00164	83 c4 04	 add	 esp, 4
  00167	83 fe ff	 cmp	 esi, -1
  0016a	0f 84 6f 01 00
	00		 je	 $LN8@EnumerateH@2
  00170	8b 44 24 14	 mov	 eax, DWORD PTR tv80[esp+580]
  00174	6a 00		 push	 0
  00176	8d 54 24 24	 lea	 edx, DWORD PTR _nBytes$[esp+584]
  0017a	52		 push	 edx
  0017b	6a 4c		 push	 76			; 0000004cH
  0017d	50		 push	 eax
  0017e	6a 4c		 push	 76			; 0000004cH
  00180	50		 push	 eax
  00181	68 08 04 22 00	 push	 2229256			; 00220408H
  00186	56		 push	 esi
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0018d	85 c0		 test	 eax, eax
  0018f	0f 84 43 01 00
	00		 je	 $LN7@EnumerateH@2
  00195	8b 74 24 28	 mov	 esi, DWORD PTR _ConnectionInfo$GSCopy$[esp+580]
  00199	c6 44 24 2c 00	 mov	 BYTE PTR _leafName$[esp+580], 0
  0019e	85 f6		 test	 esi, esi
  001a0	74 6b		 je	 SHORT $LN6@EnumerateH@2
  001a2	8b 06		 mov	 eax, DWORD PTR [esi]
  001a4	50		 push	 eax
  001a5	8d 4c 24 30	 lea	 ecx, DWORD PTR _leafName$[esp+584]
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_09IBNJMOOD@?$FLPort?$CFd?$FN?5?$AA@
  001ae	51		 push	 ecx
  001af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001b5	8b 56 1f	 mov	 edx, DWORD PTR [esi+31]
  001b8	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ConnectionStatuses@@3PAPADA[edx*4]
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c2	8b d0		 mov	 edx, eax
$LL20@EnumerateH@2:
  001c4	8a 08		 mov	 cl, BYTE PTR [eax]
  001c6	40		 inc	 eax
  001c7	84 c9		 test	 cl, cl
  001c9	75 f9		 jne	 SHORT $LL20@EnumerateH@2
  001cb	8d 7c 24 2c	 lea	 edi, DWORD PTR _leafName$[esp+580]
  001cf	2b c2		 sub	 eax, edx
  001d1	4f		 dec	 edi
$LL21@EnumerateH@2:
  001d2	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  001d5	47		 inc	 edi
  001d6	84 c9		 test	 cl, cl
  001d8	75 f8		 jne	 SHORT $LL21@EnumerateH@2
  001da	8b c8		 mov	 ecx, eax
  001dc	c1 e9 02	 shr	 ecx, 2
  001df	8b f2		 mov	 esi, edx
  001e1	f3 a5		 rep movsd
  001e3	8b c8		 mov	 ecx, eax
  001e5	83 e1 03	 and	 ecx, 3
  001e8	8d 44 24 2c	 lea	 eax, DWORD PTR _leafName$[esp+580]
  001ec	f3 a4		 rep movsb
  001ee	48		 dec	 eax
  001ef	90		 npad	 1
$LL22@EnumerateH@2:
  001f0	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  001f3	40		 inc	 eax
  001f4	84 c9		 test	 cl, cl
  001f6	75 f8		 jne	 SHORT $LL22@EnumerateH@2
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ??_C@_04MKEDFNGB@?5?3?5?5?$AA@
  001fe	8a 15 04 00 00
	00		 mov	 dl, BYTE PTR ??_C@_04MKEDFNGB@?5?3?5?5?$AA@+4
  00204	8b 7c 24 18	 mov	 edi, DWORD PTR _HubName$GSCopy$[esp+580]
  00208	89 08		 mov	 DWORD PTR [eax], ecx
  0020a	88 50 04	 mov	 BYTE PTR [eax+4], dl
$LN6@EnumerateH@2:
  0020d	8b 44 24 1c	 mov	 eax, DWORD PTR _DeviceDesc$GSCopy$[esp+580]
  00211	85 c0		 test	 eax, eax
  00213	74 34		 je	 SHORT $LN5@EnumerateH@2

; 1119 :             {
; 1120 : 	            //
; 1121 : 		        // Now query USBHUB for the USB_NODE_INFORMATION structure for this hub.
; 1122 : 	            // This will tell us the number of downstream ports to enumerate, among
; 1123 : 		        // other things.
; 1124 : 	            //
; 1125 : 		        success = DeviceIoControl(hHubDevice,
; 1126 : 			                              IOCTL_USB_GET_NODE_INFORMATION,
; 1127 : 				                          info->HubInfo,
; 1128 : 					                      sizeof(USB_NODE_INFORMATION),
; 1129 : 						                  info->HubInfo,
; 1130 : 							              sizeof(USB_NODE_INFORMATION),
; 1131 : 								          &nBytes,
; 1132 : 	                                      NULL);
; 1133 : 
; 1134 : 		        if (success)
; 1135 : 		        {
; 1136 : 	            // Build the leaf name from the port number and the device description
; 1137 : 		        //
; 1138 : 		            leafName[0] = 0;
; 1139 : 			        if (ConnectionInfo)
; 1140 : 			        {
; 1141 : 				        wsprintf(leafName, "[Port%d] ", ConnectionInfo->ConnectionIndex);
; 1142 : 		                strcat(leafName, ConnectionStatuses[ConnectionInfo->ConnectionStatus]);
; 1143 : 			            strcat(leafName, " :  ");
; 1144 : 			        }
; 1145 : 
; 1146 : 		            if (DeviceDesc != NULL)
; 1147 : 				        strcat(leafName, DeviceDesc);

  00215	8b d0		 mov	 edx, eax
$LL23@EnumerateH@2:
  00217	8a 08		 mov	 cl, BYTE PTR [eax]
  00219	40		 inc	 eax
  0021a	84 c9		 test	 cl, cl
  0021c	75 f9		 jne	 SHORT $LL23@EnumerateH@2
  0021e	8d 7c 24 2c	 lea	 edi, DWORD PTR _leafName$[esp+580]
  00222	2b c2		 sub	 eax, edx
  00224	4f		 dec	 edi
$LL24@EnumerateH@2:
  00225	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00228	47		 inc	 edi
  00229	84 c9		 test	 cl, cl
  0022b	75 f8		 jne	 SHORT $LL24@EnumerateH@2

; 1148 : 			        else

  0022d	eb 39		 jmp	 SHORT $LN29@EnumerateH@2
$LN10@EnumerateH@2:

; 1053 :     HANDLE          hHubDevice = NULL;
; 1054 :     PCHAR           deviceName = NULL;
; 1055 :     BOOL            success;
; 1056 :     ULONG           nBytes = 0;
; 1057 :     PUSBDEVICEINFO  info = NULL;
; 1058 :     CHAR            leafName[512] = {0};
; 1059 : 
; 1060 :     Log(LOG_DEBUG,__LINE__,">> USB.EnumHub");
; 1061 : 
; 1062 :     // Allocate some space for a USBDEVICEINFO structure to hold the
; 1063 :     // hub info, hub name, and connection info pointers.  GPTR zero
; 1064 :     // initializes the structure for us.
; 1065 :     //
; 1066 :     info = (PUSBDEVICEINFO) malloc(sizeof(USBDEVICEINFO));
; 1067 :     if(info)
; 1068 :     {
; 1069 :         memset(info,0x00,sizeof(USBDEVICEINFO));
; 1070 : 
; 1071 :         // Keep copies of the Hub Name, Connection Info, and Configuration
; 1072 :         // Descriptor pointers
; 1073 :         //
; 1074 :         info->HubName = HubName;
; 1075 :         info->ConnectionInfo = ConnectionInfo;
; 1076 :         info->ConfigDesc = ConfigDesc;
; 1077 :         info->StringDescs = StringDescs;
; 1078 : 
; 1079 :         // Allocate some space for a USB_NODE_INFORMATION structure for this Hub,
; 1080 :         //
; 1081 :         info->HubInfo = (PUSB_NODE_INFORMATION)malloc(sizeof(USB_NODE_INFORMATION));
; 1082 :         if(info->HubInfo)
; 1083 :         {
; 1084 :             memset(info->HubInfo,0x00,sizeof(USB_NODE_INFORMATION));
; 1085 : 
; 1086 :             // Allocate a temp buffer for the full hub device name.
; 1087 :             //
; 1088 :             deviceName = (PCHAR)malloc(strlen(HubName) + sizeof("\\\\.\\"));
; 1089 :             if(deviceName)
; 1090 :             {
; 1091 :                 memset(deviceName,0x00,strlen(HubName) + sizeof("\\\\.\\"));
; 1092 : 
; 1093 :                 // Create the full hub device name
; 1094 :                 //
; 1095 :                 strcpy(deviceName, "\\\\.\\");
; 1096 :                 strcpy(deviceName + sizeof("\\\\.\\") - 1, HubName);
; 1097 : 
; 1098 :                 // Try to hub the open device
; 1099 :                 //
; 1100 :                 hHubDevice = CreateFile(deviceName,
; 1101 :                                         GENERIC_WRITE,
; 1102 :                                         FILE_SHARE_WRITE,
; 1103 :                                         NULL,
; 1104 :                                         OPEN_EXISTING,
; 1105 :                                         0,
; 1106 :                                         NULL);
; 1107 : 
; 1108 :                 // Done with temp buffer for full hub device name
; 1109 :                 //
; 1110 :                 free(deviceName);
; 1111 :             }
; 1112 :             else
; 1113 :             {
; 1114 :                 Log(LOG_DEBUG,__LINE__,"-- USB.EnumHub, new Pntr for DevName \\\\.\\%s null",HubName);

  0022f	57		 push	 edi
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MFBNHHNK@?9?9?5USB?4EnumHub?0?5new?5Pntr?5for?5Dev@
  00235	68 5a 04 00 00	 push	 1114			; 0000045aH
  0023a	6a 10		 push	 16			; 00000010H
  0023c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00241	83 c4 10	 add	 esp, 16			; 00000010H

; 1115 :                 hHubDevice = INVALID_HANDLE_VALUE;
; 1116 :             }
; 1117 : 
; 1118 :             if (hHubDevice != INVALID_HANDLE_VALUE)

  00244	e9 96 00 00 00	 jmp	 $LN8@EnumerateH@2
$LN5@EnumerateH@2:

; 1149 : 				        strcat(leafName, info->HubName);

  00249	8b c7		 mov	 eax, edi
  0024b	8b d7		 mov	 edx, edi
  0024d	8d 49 00	 npad	 3
$LL25@EnumerateH@2:
  00250	8a 08		 mov	 cl, BYTE PTR [eax]
  00252	40		 inc	 eax
  00253	84 c9		 test	 cl, cl
  00255	75 f9		 jne	 SHORT $LL25@EnumerateH@2
  00257	8d 7c 24 2c	 lea	 edi, DWORD PTR _leafName$[esp+580]
  0025b	2b c2		 sub	 eax, edx
  0025d	4f		 dec	 edi
  0025e	8b ff		 npad	 2
$LL26@EnumerateH@2:
  00260	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00263	47		 inc	 edi
  00264	84 c9		 test	 cl, cl
  00266	75 f8		 jne	 SHORT $LL26@EnumerateH@2
$LN29@EnumerateH@2:
  00268	8b c8		 mov	 ecx, eax
  0026a	c1 e9 02	 shr	 ecx, 2
  0026d	8b f2		 mov	 esi, edx
  0026f	f3 a5		 rep movsd
  00271	8b c8		 mov	 ecx, eax

; 1150 : 
; 1151 : 		            // Now recursively enumerate the ports of this hub.
; 1152 : 			        //
; 1153 :                     PushBackDetails(info->HubName);

  00273	8b 44 24 18	 mov	 eax, DWORD PTR _HubName$GSCopy$[esp+580]
  00277	83 e1 03	 and	 ecx, 3
  0027a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0027d	f3 a4		 rep movsb
  0027f	8b cc		 mov	 ecx, esp
  00281	89 64 24 38	 mov	 DWORD PTR $T237242[esp+608], esp
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0028b	c7 84 24 5c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+616], 0
  00296	c7 84 24 5c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+616], -1
  002a1	8b 74 24 40	 mov	 esi, DWORD PTR _this$GSCopy$[esp+608]
  002a5	e8 00 00 00 00	 call	 ?PushBackDetails@USB@@IAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; USB::PushBackDetails

; 1154 :                     HubInfo(&info->HubInfo->u.HubInformation);

  002aa	8b 7c 24 14	 mov	 edi, DWORD PTR tv80[esp+580]
  002ae	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  002b1	8b ce		 mov	 ecx, esi
  002b3	e8 00 00 00 00	 call	 ?HubInfo@USB@@IAEXPAU_USB_HUB_INFORMATION@@@Z ; USB::HubInfo

; 1155 : 		            EnumerateHubPorts (hHubDevice,
; 1156 : 						           info->HubInfo->u.HubInformation.HubDescriptor.bNumberOfPorts);

  002b8	0f b6 4f 06	 movzx	 ecx, BYTE PTR [edi+6]
  002bc	8b 54 24 10	 mov	 edx, DWORD PTR _hHubDevice$[esp+580]
  002c0	51		 push	 ecx
  002c1	8b ce		 mov	 ecx, esi
  002c3	e8 00 00 00 00	 call	 ?EnumerateHubPorts@USB@@IAEXPAXK@Z ; USB::EnumerateHubPorts

; 1157 : 
; 1158 : 			        wPortsNumber += info->HubInfo->u.HubInformation.HubDescriptor.bNumberOfPorts;

  002c8	66 0f b6 57 06	 movzx	 dx, BYTE PTR [edi+6]
  002cd	66 01 16	 add	 WORD PTR [esi], dx
  002d0	8b 7c 24 18	 mov	 edi, DWORD PTR _HubName$GSCopy$[esp+580]
  002d4	8b 74 24 10	 mov	 esi, DWORD PTR _hHubDevice$[esp+580]
$LN7@EnumerateH@2:

; 1159 : 		        }
; 1160 : 		        CloseHandle(hHubDevice);

  002d8	56		 push	 esi
  002d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN8@EnumerateH@2:

; 1161 : 	        }
; 1162 :             //
; 1163 :             // Clean up any stuff that got allocated
; 1164 :             //
; 1165 : 	        free(HubName);

  002df	57		 push	 edi
  002e0	e8 00 00 00 00	 call	 _free

; 1166 : 
; 1167 : 	        if (info->HubInfo != NULL)
; 1168 : 		        free(info->HubInfo);

  002e5	8b 44 24 18	 mov	 eax, DWORD PTR tv80[esp+584]
  002e9	83 c4 04	 add	 esp, 4
  002ec	50		 push	 eax
  002ed	e8 00 00 00 00	 call	 _free
  002f2	83 c4 04	 add	 esp, 4

; 1173 :         }
; 1174 : 	    free(info);

  002f5	53		 push	 ebx
  002f6	e8 00 00 00 00	 call	 _free
  002fb	83 c4 04	 add	 esp, 4

; 1175 :     }
; 1176 :     else

  002fe	eb 35		 jmp	 SHORT $LN1@EnumerateH@2
$LN11@EnumerateH@2:

; 1169 :         }
; 1170 :         else
; 1171 :         {
; 1172 :             Log(LOG_DEBUG,__LINE__,"-- USB.EnumHub, new HubInfo (%u) null",sizeof(USB_NODE_INFORMATION));

  00300	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@FMONKKAG@?9?9?5USB?4EnumHub?0?5new?5HubInfo?5?$CI?$CFu?$CJ@
  00305	68 94 04 00 00	 push	 1172			; 00000494H
  0030a	6a 10		 push	 16			; 00000010H
  0030c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00311	83 c4 10	 add	 esp, 16			; 00000010H

; 1173 :         }
; 1174 : 	    free(info);

  00314	53		 push	 ebx
  00315	e8 00 00 00 00	 call	 _free
  0031a	83 c4 04	 add	 esp, 4

; 1175 :     }
; 1176 :     else

  0031d	eb 16		 jmp	 SHORT $LN1@EnumerateH@2
$LN12@EnumerateH@2:

; 1177 :     {
; 1178 :         Log(LOG_DEBUG,__LINE__,"-- USB.EnumHub, new Info (%u) null",sizeof(USBDEVICEINFO));

  0031f	6a 14		 push	 20			; 00000014H
  00321	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@EDMNKMD@?9?9?5USB?4EnumHub?0?5new?5Info?5?$CI?$CFu?$CJ?5nu@
  00326	68 9a 04 00 00	 push	 1178			; 0000049aH
  0032b	6a 10		 push	 16			; 00000010H
  0032d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00332	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@EnumerateH@2:

; 1179 :     }
; 1180 :     Log(LOG_DEBUG,__LINE__,"<< USB.EnumHub");

  00335	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NNDDHFCH@?$DM?$DM?5USB?4EnumHub?$AA@
  0033a	68 9c 04 00 00	 push	 1180			; 0000049cH
  0033f	6a 10		 push	 16			; 00000010H
  00341	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00346	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1181 :     return;
; 1182 : }

  00349	8b 8c 24 38 02
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+580]
  00350	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00357	59		 pop	 ecx
  00358	5f		 pop	 edi
  00359	5e		 pop	 esi
  0035a	5b		 pop	 ebx
  0035b	8b 8c 24 20 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+564]
  00362	33 cc		 xor	 ecx, esp
  00364	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00369	8b e5		 mov	 esp, ebp
  0036b	5d		 pop	 ebp
  0036c	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z$0:
  00000	8b 8d d8 fd ff
	ff		 mov	 ecx, DWORD PTR $T237242[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 82 cc fd ff
	ff		 lea	 eax, DWORD PTR [edx-564]
  00015	8b 8a c8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-568]
  0001b	33 c8		 xor	 ecx, eax
  0001d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00022	83 c0 0c	 add	 eax, 12			; 0000000cH
  00025	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z ENDP ; USB::EnumerateHub
PUBLIC	__$ArrayPad$
PUBLIC	?EnumerateUSB@USB@@QAEXXZ			; USB::EnumerateUSB
; Function compile flags: /Ogtpy
;	COMDAT ?EnumerateUSB@USB@@QAEXXZ
_TEXT	SEGMENT
_HCNum$ = -1072						; size = 4
_leafName$ = -1068					; size = 4
$T237427 = -1064					; size = 8
$T237424 = -1064					; size = 8
_hPnpDll$ = -1064					; size = 4
_tickStart$ = -1056					; size = 8
_HCName$ = -1048					; size = 16
_szLastError$136173 = -1032				; size = 1024
_szLastError$136167 = -1032				; size = 1024
_szLastError$136161 = -1032				; size = 1024
_szLastError$136155 = -1032				; size = 1024
_szLastError$136149 = -1032				; size = 1024
_szLastError$136143 = -1032				; size = 1024
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
?EnumerateUSB@USB@@QAEXXZ PROC				; USB::EnumerateUSB, COMDAT

; 34   : {

  00000	81 ec 30 04 00
	00		 sub	 esp, 1072		; 00000430H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	89 84 24 2c 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1072], eax
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	8b ac 24 3c 04
	00 00		 mov	 ebp, DWORD PTR _this$[esp+1076]
  0001d	56		 push	 esi
  0001e	57		 push	 edi

; 35   :     char        HCName[16];
; 36   :     int         HCNum = 0;
; 37   :     HANDLE      hHCDev = 0;
; 38   :     PCHAR       rootHubName = NULL;
; 39   :     PCHAR       leafName = NULL;
; 40   : 
; 41   :     unsigned __int64 tickStart = SysTick;

  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 42   : 
; 43   : 	Log(LOG_DEBUG,__LINE__,">> USB.EnumUSB");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JPOMJBKJ@?$DO?$DO?5USB?4EnumUSB?$AA@
  0002a	6a 2b		 push	 43			; 0000002bH
  0002c	6a 10		 push	 16			; 00000010H
  0002e	89 44 24 2c	 mov	 DWORD PTR _tickStart$[esp+1100], eax
  00032	33 f6		 xor	 esi, esi
  00034	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 
; 45   :     ulTotalDevicesConnected = 0;
; 46   : 	wPortsNumber = 0;
; 47   :     NestedLevel = 0;
; 48   :     memset(buf,0x00,sizeof(buf));

  0003c	68 00 02 00 00	 push	 512			; 00000200H
  00041	8d 4d 0c	 lea	 ecx, DWORD PTR [ebp+12]
  00044	33 c0		 xor	 eax, eax
  00046	56		 push	 esi
  00047	51		 push	 ecx
  00048	89 75 04	 mov	 DWORD PTR [ebp+4], esi
  0004b	66 89 45 00	 mov	 WORD PTR [ebp], ax
  0004f	89 75 08	 mov	 DWORD PTR [ebp+8], esi
  00052	e8 00 00 00 00	 call	 _memset

; 49   : 
; 50   :     usbDevDetails.clear();

  00057	8b bd 1c 02 00
	00		 mov	 edi, DWORD PTR [ebp+540]
  0005d	8d b5 0c 02 00
	00		 lea	 esi, DWORD PTR [ebp+524]
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00069	76 05		 jbe	 SHORT $LN24@EnumerateU
  0006b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@EnumerateU:
  00070	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00073	8b 16		 mov	 edx, DWORD PTR [esi]
  00075	89 54 24 18	 mov	 DWORD PTR $T237424[esp+1088], edx
  00079	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  0007c	76 05		 jbe	 SHORT $LN43@EnumerateU
  0007e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN43@EnumerateU:
  00083	8b 4c 24 18	 mov	 ecx, DWORD PTR $T237424[esp+1088]
  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	57		 push	 edi
  0008a	51		 push	 ecx
  0008b	53		 push	 ebx
  0008c	50		 push	 eax
  0008d	8d 5c 24 28	 lea	 ebx, DWORD PTR $T237427[esp+1104]
  00091	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 51   : 
; 52   :     lpfnCM_Get_Parent = NULL;

  00096	33 f6		 xor	 esi, esi

; 53   :     lpfnCM_Get_Sibling = NULL;
; 54   :     lpfnCM_Get_Child = NULL;
; 55   :     lpfnCM_Get_DevNode_Registry_PropertyA = NULL;
; 56   :     lpfnCM_Locate_DevNodeA = NULL;
; 57   : 
; 58   : 	HMODULE hPnpDll = LoadLibrary ("cfgmgr32.dll");

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JNFFEOEJ@cfgmgr32?4dll?$AA@
  0009d	89 b5 24 02 00
	00		 mov	 DWORD PTR [ebp+548], esi
  000a3	89 b5 28 02 00
	00		 mov	 DWORD PTR [ebp+552], esi
  000a9	89 b5 2c 02 00
	00		 mov	 DWORD PTR [ebp+556], esi
  000af	89 b5 30 02 00
	00		 mov	 DWORD PTR [ebp+560], esi
  000b5	89 b5 34 02 00
	00		 mov	 DWORD PTR [ebp+564], esi
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000c1	8b f8		 mov	 edi, eax
  000c3	89 7c 24 18	 mov	 DWORD PTR _hPnpDll$[esp+1088], edi

; 59   : 	if (hPnpDll == NULL)

  000c7	3b fe		 cmp	 edi, esi
  000c9	75 41		 jne	 SHORT $LN13@EnumerateU

; 60   : 	{
; 61   :         char szLastError[1024] = {0};

  000cb	68 ff 03 00 00	 push	 1023			; 000003ffH
  000d0	8d 54 24 3d	 lea	 edx, DWORD PTR _szLastError$136143[esp+1093]
  000d4	56		 push	 esi
  000d5	52		 push	 edx
  000d6	c6 44 24 44 00	 mov	 BYTE PTR _szLastError$136143[esp+1100], 0
  000db	e8 00 00 00 00	 call	 _memset
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   :         DWORD dwLastError = GetLastError();

  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000e9	8b d8		 mov	 ebx, eax

; 63   :         GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  000eb	68 00 04 00 00	 push	 1024			; 00000400H
  000f0	8d 74 24 3c	 lea	 esi, DWORD PTR _szLastError$136143[esp+1092]
  000f4	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage
  000f9	83 c4 04	 add	 esp, 4

; 64   :         Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB, LoadLib cfgmgr32.dll failed: %u, %s",dwLastError,szLastError);

  000fc	8b c6		 mov	 eax, esi
  000fe	50		 push	 eax
  000ff	53		 push	 ebx
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@MNEBEEPL@?$DM?$DM?5USB?4EnumUSB?0?5LoadLib?5cfgmgr32@
  00105	6a 40		 push	 64			; 00000040H

; 65   : 		return;

  00107	e9 d3 02 00 00	 jmp	 $LN59@EnumerateU
$LN13@EnumerateU:

; 66   : 	}
; 67   : 
; 68   : 	if ((lpfnCM_Get_Parent = (CMGETPARENT) GetProcAddress (hPnpDll, "CM_Get_Parent")) == NULL)

  0010c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetProcAddress@8
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CIKLALFP@CM_Get_Parent?$AA@
  00117	57		 push	 edi
  00118	ff d3		 call	 ebx
  0011a	89 85 24 02 00
	00		 mov	 DWORD PTR [ebp+548], eax
  00120	3b c6		 cmp	 eax, esi
  00122	75 48		 jne	 SHORT $LN12@EnumerateU

; 69   : 	{
; 70   :         char szLastError[1024] = {0};

  00124	68 ff 03 00 00	 push	 1023			; 000003ffH
  00129	8d 4c 24 3d	 lea	 ecx, DWORD PTR _szLastError$136149[esp+1093]
  0012d	56		 push	 esi
  0012e	51		 push	 ecx
  0012f	c6 44 24 44 00	 mov	 BYTE PTR _szLastError$136149[esp+1100], 0
  00134	e8 00 00 00 00	 call	 _memset
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH

; 71   :         DWORD dwLastError = GetLastError();

  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00142	8b d8		 mov	 ebx, eax

; 72   :         GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  00144	68 00 04 00 00	 push	 1024			; 00000400H
  00149	8d 74 24 3c	 lea	 esi, DWORD PTR _szLastError$136149[esp+1092]
  0014d	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage
  00152	83 c4 04	 add	 esp, 4

; 73   : 		FreeLibrary (hPnpDll);

  00155	57		 push	 edi
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 74   :         Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB, GetProcAdr CM_Get_Parent failed: %u, %s",dwLastError,szLastError);

  0015c	8b d6		 mov	 edx, esi
  0015e	52		 push	 edx
  0015f	53		 push	 ebx
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@OFIMABNG@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
  00165	6a 4a		 push	 74			; 0000004aH

; 75   : 		return;

  00167	e9 73 02 00 00	 jmp	 $LN59@EnumerateU
$LN12@EnumerateU:

; 76   : 	}
; 77   : 
; 78   : 	if ((lpfnCM_Get_Sibling = (CMGETSIBLING) GetProcAddress (hPnpDll, "CM_Get_Sibling")) == NULL)

  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OOIACNHP@CM_Get_Sibling?$AA@
  00171	57		 push	 edi
  00172	ff d3		 call	 ebx
  00174	89 85 28 02 00
	00		 mov	 DWORD PTR [ebp+552], eax
  0017a	3b c6		 cmp	 eax, esi
  0017c	75 48		 jne	 SHORT $LN11@EnumerateU

; 79   : 	{
; 80   :         char szLastError[1024] = {0};

  0017e	68 ff 03 00 00	 push	 1023			; 000003ffH
  00183	8d 44 24 3d	 lea	 eax, DWORD PTR _szLastError$136155[esp+1093]
  00187	56		 push	 esi
  00188	50		 push	 eax
  00189	c6 44 24 44 00	 mov	 BYTE PTR _szLastError$136155[esp+1100], 0
  0018e	e8 00 00 00 00	 call	 _memset
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   :         DWORD dwLastError = GetLastError();

  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0019c	8b d8		 mov	 ebx, eax

; 82   :         GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  0019e	68 00 04 00 00	 push	 1024			; 00000400H
  001a3	8d 74 24 3c	 lea	 esi, DWORD PTR _szLastError$136155[esp+1092]
  001a7	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage
  001ac	83 c4 04	 add	 esp, 4

; 83   : 		FreeLibrary (hPnpDll);

  001af	57		 push	 edi
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 84   : 		Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB, GetProcAdr CM_Get_Sibling failed: %u, %s",dwLastError,szLastError);

  001b6	8b ce		 mov	 ecx, esi
  001b8	51		 push	 ecx
  001b9	53		 push	 ebx
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@MMFCGNCK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
  001bf	6a 54		 push	 84			; 00000054H

; 85   : 		return;

  001c1	e9 19 02 00 00	 jmp	 $LN59@EnumerateU
$LN11@EnumerateU:

; 86   : 	}
; 87   : 
; 88   : 	if ((lpfnCM_Get_Child = (CMGETCHILD) GetProcAddress (hPnpDll, "CM_Get_Child")) == NULL)

  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EKPGFMC@CM_Get_Child?$AA@
  001cb	57		 push	 edi
  001cc	ff d3		 call	 ebx
  001ce	89 85 2c 02 00
	00		 mov	 DWORD PTR [ebp+556], eax
  001d4	3b c6		 cmp	 eax, esi
  001d6	75 48		 jne	 SHORT $LN10@EnumerateU

; 89   : 	{
; 90   :         char szLastError[1024] = {0};

  001d8	68 ff 03 00 00	 push	 1023			; 000003ffH
  001dd	8d 54 24 3d	 lea	 edx, DWORD PTR _szLastError$136161[esp+1093]
  001e1	56		 push	 esi
  001e2	52		 push	 edx
  001e3	c6 44 24 44 00	 mov	 BYTE PTR _szLastError$136161[esp+1100], 0
  001e8	e8 00 00 00 00	 call	 _memset
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   :         DWORD dwLastError = GetLastError();

  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001f6	8b d8		 mov	 ebx, eax

; 92   :         GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  001f8	68 00 04 00 00	 push	 1024			; 00000400H
  001fd	8d 74 24 3c	 lea	 esi, DWORD PTR _szLastError$136161[esp+1092]
  00201	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage
  00206	83 c4 04	 add	 esp, 4

; 93   : 		FreeLibrary (hPnpDll);

  00209	57		 push	 edi
  0020a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 94   : 		Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB, GetProcAdr CM_Get_Child failed: %u, %s",dwLastError,szLastError);

  00210	8b c6		 mov	 eax, esi
  00212	50		 push	 eax
  00213	53		 push	 ebx
  00214	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@HAEGCLCE@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
  00219	6a 5e		 push	 94			; 0000005eH

; 95   : 		return;

  0021b	e9 bf 01 00 00	 jmp	 $LN59@EnumerateU
$LN10@EnumerateU:

; 96   : 	}
; 97   : 
; 98   : 	if ((lpfnCM_Get_DevNode_Registry_PropertyA = (CMGETDEVNODEREGISTRYPROPERTYA) GetProcAddress (hPnpDll, "CM_Get_DevNode_Registry_PropertyA"))  == NULL)

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NHFCMMFN@CM_Get_DevNode_Registry_Property@
  00225	57		 push	 edi
  00226	ff d3		 call	 ebx
  00228	89 85 30 02 00
	00		 mov	 DWORD PTR [ebp+560], eax
  0022e	3b c6		 cmp	 eax, esi
  00230	75 48		 jne	 SHORT $LN9@EnumerateU

; 99   : 	{
; 100  :         char szLastError[1024] = {0};

  00232	68 ff 03 00 00	 push	 1023			; 000003ffH
  00237	8d 4c 24 3d	 lea	 ecx, DWORD PTR _szLastError$136167[esp+1093]
  0023b	56		 push	 esi
  0023c	51		 push	 ecx
  0023d	c6 44 24 44 00	 mov	 BYTE PTR _szLastError$136167[esp+1100], 0
  00242	e8 00 00 00 00	 call	 _memset
  00247	83 c4 0c	 add	 esp, 12			; 0000000cH

; 101  :         DWORD dwLastError = GetLastError();

  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00250	8b d8		 mov	 ebx, eax

; 102  :         GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  00252	68 00 04 00 00	 push	 1024			; 00000400H
  00257	8d 74 24 3c	 lea	 esi, DWORD PTR _szLastError$136167[esp+1092]
  0025b	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage
  00260	83 c4 04	 add	 esp, 4

; 103  : 		FreeLibrary (hPnpDll);

  00263	57		 push	 edi
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 104  : 		Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB, GetProcAdr CM_Get_DevNode_Registry_Property failed: %u, %s",dwLastError,szLastError);

  0026a	8b d6		 mov	 edx, esi
  0026c	52		 push	 edx
  0026d	53		 push	 ebx
  0026e	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@DLHLJOM@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Ge@
  00273	6a 68		 push	 104			; 00000068H

; 105  : 		return;

  00275	e9 65 01 00 00	 jmp	 $LN59@EnumerateU
$LN9@EnumerateU:

; 106  : 	}
; 107  : 
; 108  : 	if ((lpfnCM_Locate_DevNodeA = (CMLOCATEDEVNODEA) GetProcAddress (hPnpDll, "CM_Locate_DevNodeA")) == NULL)

  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FFDOPOAJ@CM_Locate_DevNodeA?$AA@
  0027f	57		 push	 edi
  00280	ff d3		 call	 ebx
  00282	89 85 34 02 00
	00		 mov	 DWORD PTR [ebp+564], eax
  00288	3b c6		 cmp	 eax, esi
  0028a	75 48		 jne	 SHORT $LN8@EnumerateU

; 109  : 	{
; 110  :         char szLastError[1024] = {0};

  0028c	68 ff 03 00 00	 push	 1023			; 000003ffH
  00291	8d 44 24 3d	 lea	 eax, DWORD PTR _szLastError$136173[esp+1093]
  00295	56		 push	 esi
  00296	50		 push	 eax
  00297	c6 44 24 44 00	 mov	 BYTE PTR _szLastError$136173[esp+1100], 0
  0029c	e8 00 00 00 00	 call	 _memset
  002a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 111  :         DWORD dwLastError = GetLastError();

  002a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002aa	8b d8		 mov	 ebx, eax

; 112  :         GetLastErrorMessage(dwLastError,szLastError,sizeof(szLastError));

  002ac	68 00 04 00 00	 push	 1024			; 00000400H
  002b1	8d 74 24 3c	 lea	 esi, DWORD PTR _szLastError$136173[esp+1092]
  002b5	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YAPADKPADK@Z ; GetLastErrorMessage
  002ba	83 c4 04	 add	 esp, 4

; 113  : 		FreeLibrary (hPnpDll);

  002bd	57		 push	 edi
  002be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 114  : 		Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB, GetProcAdr CM_Locate_DevNode failed: %u, %s",dwLastError,szLastError);

  002c4	8b ce		 mov	 ecx, esi
  002c6	51		 push	 ecx
  002c7	53		 push	 ebx
  002c8	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DIBECLHK@?$DM?$DM?5USB?4EnumUSB?0?5GetProcAdr?5CM_Lo@
  002cd	6a 72		 push	 114			; 00000072H

; 115  :         return;

  002cf	e9 0b 01 00 00	 jmp	 $LN59@EnumerateU
$LN8@EnumerateU:

; 116  : 	}
; 117  : 
; 118  :     Log(LOG_HEADER,__LINE__,"Enumerate USB");

  002d4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BMIBGHPI@Enumerate?5USB?$AA@
  002d9	6a 76		 push	 118			; 00000076H
  002db	6a 02		 push	 2
  002dd	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 119  : 
; 120  :     // Iterate over some Host Controller names and try to open them.
; 121  :     //
; 122  :     for (HCNum = 0; HCNum < NUM_HCS_TO_CHECK; HCNum++)

  002e5	89 74 24 10	 mov	 DWORD PTR _HCNum$[esp+1088], esi
$LN7@EnumerateU:

; 123  :     {
; 124  :         sprintf(HCName, "\\\\.\\HCD%d", HCNum);

  002e9	8b 54 24 10	 mov	 edx, DWORD PTR _HCNum$[esp+1088]
  002ed	52		 push	 edx
  002ee	8d 44 24 2c	 lea	 eax, DWORD PTR _HCName$[esp+1092]
  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_09PEILPPNA@?2?2?4?2HCD?$CFd?$AA@
  002f7	50		 push	 eax
  002f8	e8 00 00 00 00	 call	 _sprintf
  002fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 125  : 
; 126  :         hHCDev = CreateFile(HCName,
; 127  :                             GENERIC_WRITE,
; 128  :                             FILE_SHARE_WRITE,
; 129  :                             NULL,
; 130  :                             OPEN_EXISTING,
; 131  :                             0,
; 132  :                             NULL);

  00300	56		 push	 esi
  00301	56		 push	 esi
  00302	6a 03		 push	 3
  00304	56		 push	 esi
  00305	6a 02		 push	 2
  00307	68 00 00 00 40	 push	 1073741824		; 40000000H
  0030c	8d 4c 24 40	 lea	 ecx, DWORD PTR _HCName$[esp+1112]
  00310	51		 push	 ecx
  00311	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00317	8b d8		 mov	 ebx, eax

; 133  : 
; 134  :         // If the handle is valid, then we've successfully opened a Host
; 135  :         // Controller.  Display some info about the Host Controller itself,
; 136  :         // then enumerate the Root Hub attached to the Host Controller.
; 137  :         //
; 138  :         if (hHCDev != INVALID_HANDLE_VALUE)

  00319	83 fb ff	 cmp	 ebx, -1
  0031c	74 72		 je	 SHORT $LN6@EnumerateU

; 139  :         {
; 140  :             PCHAR driverKeyName = NULL, deviceDesc = NULL;
; 141  : 
; 142  :             driverKeyName = GetHCDDriverKeyName(hHCDev);

  0031e	8b fb		 mov	 edi, ebx
  00320	e8 00 00 00 00	 call	 ?GetHCDDriverKeyName@USB@@IAEPADPAX@Z ; USB::GetHCDDriverKeyName
  00325	8b f8		 mov	 edi, eax

; 143  : 
; 144  :             leafName = HCName + sizeof("\\\\.\\") - sizeof("");

  00327	8d 54 24 2c	 lea	 edx, DWORD PTR _HCName$[esp+1092]
  0032b	89 54 24 14	 mov	 DWORD PTR _leafName$[esp+1088], edx

; 145  : 
; 146  :             if (driverKeyName)

  0032f	3b fe		 cmp	 edi, esi
  00331	74 19		 je	 SHORT $LN3@EnumerateU

; 147  :             {
; 148  :                 deviceDesc = DriverNameToDeviceDesc(driverKeyName);

  00333	57		 push	 edi
  00334	8b f5		 mov	 esi, ebp
  00336	e8 00 00 00 00	 call	 ?DriverNameToDeviceDesc@USB@@IAEPADPAD@Z ; USB::DriverNameToDeviceDesc

; 149  : 
; 150  :                 if (deviceDesc)

  0033b	85 c0		 test	 eax, eax
  0033d	74 04		 je	 SHORT $LN2@EnumerateU

; 151  :                 {
; 152  :                     leafName = deviceDesc;

  0033f	89 44 24 14	 mov	 DWORD PTR _leafName$[esp+1088], eax
$LN2@EnumerateU:

; 153  :                }
; 154  : 
; 155  :                 free(driverKeyName);

  00343	57		 push	 edi
  00344	e8 00 00 00 00	 call	 _free
  00349	83 c4 04	 add	 esp, 4
$LN3@EnumerateU:

; 156  :             }
; 157  : 
; 158  : 			Log(LOG_MESSAGE,__LINE__,"RootHub : %s",leafName);

  0034c	8b 44 24 14	 mov	 eax, DWORD PTR _leafName$[esp+1088]
  00350	50		 push	 eax
  00351	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BEFNEIBE@RootHub?5?3?5?$CFs?$AA@
  00356	68 9e 00 00 00	 push	 158			; 0000009eH
  0035b	6a 01		 push	 1
  0035d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00362	83 c4 10	 add	 esp, 16			; 00000010H

; 159  : 
; 160  :             rootHubName = GetRootHubName(hHCDev);

  00365	8b f3		 mov	 esi, ebx
  00367	e8 00 00 00 00	 call	 ?GetRootHubName@USB@@IAEPADPAX@Z ; USB::GetRootHubName

; 161  : 
; 162  :             if (rootHubName != NULL)

  0036c	85 c0		 test	 eax, eax
  0036e	74 13		 je	 SHORT $LN1@EnumerateU

; 163  :             {
; 164  :                 EnumerateHub(rootHubName,
; 165  :                              NULL,      // ConnectionInfo
; 166  :                              NULL,      // ConfigDesc
; 167  :                              NULL,      // StringDescs
; 168  :                              "RootHub"  // DeviceDesc
; 169  :                             );

  00370	68 00 00 00 00	 push	 OFFSET ??_C@_07FOIBMAON@RootHub?$AA@
  00375	6a 00		 push	 0
  00377	6a 00		 push	 0
  00379	6a 00		 push	 0
  0037b	50		 push	 eax
  0037c	8b cd		 mov	 ecx, ebp
  0037e	e8 00 00 00 00	 call	 ?EnumerateHub@USB@@IAEXPADPAU_USB_NODE_CONNECTION_INFORMATION_EX@@PAU_USB_DESCRIPTOR_REQUEST@@PAU_STRING_DESCRIPTOR_NODE@@0@Z ; USB::EnumerateHub
$LN1@EnumerateU:

; 170  :             }
; 171  : 
; 172  :             CloseHandle(hHCDev);

  00383	53		 push	 ebx
  00384	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0038a	8b 7c 24 18	 mov	 edi, DWORD PTR _hPnpDll$[esp+1088]
  0038e	33 f6		 xor	 esi, esi
$LN6@EnumerateU:
  00390	8b 44 24 10	 mov	 eax, DWORD PTR _HCNum$[esp+1088]
  00394	40		 inc	 eax
  00395	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00398	89 44 24 10	 mov	 DWORD PTR _HCNum$[esp+1088], eax
  0039c	0f 8c 47 ff ff
	ff		 jl	 $LN7@EnumerateU

; 173  : 			hHCDev = 0;
; 174  :         }
; 175  :     }
; 176  : 
; 177  :     Log(LOG_MESSAGE,__LINE__,"Total Devices Connected %u",ulTotalDevicesConnected);

  003a2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  003a5	51		 push	 ecx
  003a6	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FOIGIFIJ@Total?5Devices?5Connected?5?$CFu?$AA@
  003ab	68 b1 00 00 00	 push	 177			; 000000b1H
  003b0	6a 01		 push	 1
  003b2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003b7	83 c4 10	 add	 esp, 16			; 00000010H

; 178  : 	FreeLibrary (hPnpDll);

  003ba	57		 push	 edi
  003bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 179  :     LogElapsedTime(__LINE__,tickStart);

  003c1	8b 54 24 20	 mov	 edx, DWORD PTR _tickStart$[esp+1088]
  003c5	33 c0		 xor	 eax, eax
  003c7	50		 push	 eax
  003c8	52		 push	 edx
  003c9	33 db		 xor	 ebx, ebx
  003cb	bf b3 00 00 00	 mov	 edi, 179		; 000000b3H
  003d0	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPAD@Z ; LogElapsedTime

; 180  : 	Log(LOG_DEBUG,__LINE__,"<< USB.EnumUSB");

  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NGAEOEJF@?$DM?$DM?5USB?4EnumUSB?$AA@
  003da	68 b4 00 00 00	 push	 180			; 000000b4H
$LN59@EnumerateU:
  003df	6a 10		 push	 16			; 00000010H
  003e1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 181  : }

  003e6	8b 8c 24 50 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1108]
  003ed	83 c4 14	 add	 esp, 20			; 00000014H
  003f0	5f		 pop	 edi
  003f1	5e		 pop	 esi
  003f2	5d		 pop	 ebp
  003f3	5b		 pop	 ebx
  003f4	33 cc		 xor	 ecx, esp
  003f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fb	81 c4 30 04 00
	00		 add	 esp, 1072		; 00000430H
  00401	c2 04 00	 ret	 4
?EnumerateUSB@USB@@QAEXXZ ENDP				; USB::EnumerateUSB
END
