; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	e:\Tools\SysStatus\WMI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?_Same_container@_Iterator_base_secure@std@@QBE_NABV12@@Z ; std::_Iterator_base_secure::_Same_container
PUBLIC	?_Has_container@_Iterator_base_secure@std@@QBE_NXZ ; std::_Iterator_base_secure::_Has_container
PUBLIC	??G?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV01@@Z ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator-
PUBLIC	?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KAIV?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Pdif
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	??0_Iterator_base_secure@std@@QAE@XZ		; std::_Iterator_base_secure::_Iterator_base_secure
PUBLIC	??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ ; std::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>
PUBLIC	??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	??0Data_t@_bstr_t@@QAE@PBD@Z			; _bstr_t::Data_t::Data_t
PUBLIC	??0_bstr_t@@QAE@PBD@Z				; _bstr_t::_bstr_t
PUBLIC	??0Data_t@_bstr_t@@QAE@PB_W@Z			; _bstr_t::Data_t::Data_t
PUBLIC	??2Data_t@_bstr_t@@SAPAXI@Z			; _bstr_t::Data_t::operator new
PUBLIC	??0_bstr_t@@QAE@PB_W@Z				; _bstr_t::_bstr_t
PUBLIC	?_Free@Data_t@_bstr_t@@AAEXXZ			; _bstr_t::Data_t::_Free
PUBLIC	??1Data_t@_bstr_t@@AAE@XZ			; _bstr_t::Data_t::~Data_t
PUBLIC	??_GData_t@_bstr_t@@AAEPAXI@Z			; _bstr_t::Data_t::`scalar deleting destructor'
PUBLIC	?Release@Data_t@_bstr_t@@QAEKXZ			; _bstr_t::Data_t::Release
PUBLIC	?_Free@_bstr_t@@AAEXXZ				; _bstr_t::_Free
PUBLIC	??1_bstr_t@@QAE@XZ				; _bstr_t::~_bstr_t
PUBLIC	?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ		; _bstr_t::Data_t::GetWString
PUBLIC	??B_bstr_t@@QBEPA_WXZ				; _bstr_t::operator wchar_t *
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >
PUBLIC	??0?$allocator@E@std@@QAE@ABV01@@Z		; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
PUBLIC	??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@EHPBEABE@std@@QAE@XZ		; std::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>
PUBLIC	??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==
PUBLIC	??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=
PUBLIC	??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z	; stdext::unchecked_copy<unsigned char *,unsigned char *>
PUBLIC	?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
PUBLIC	?deallocate@?$allocator@E@std@@QAEXPAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	??$_Allocate@E@std@@YAPAEIPAE@Z			; std::_Allocate<unsigned char>
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?max_size@?$allocator@E@std@@QBEIXZ		; std::allocator<unsigned char>::max_size
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ; std::_Iter_cat<unsigned char *>
PUBLIC	??$_Fill_n@PAEIE@std@@YAXPAEIABEU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned char *,unsigned int,unsigned char>
PUBLIC	??$_Fill_n@PAEIE@std@@YAXPAEIABEUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned char *,unsigned int,unsigned char>
PUBLIC	??$unchecked_fill_n@PAEIE@stdext@@YAXPAEIABE@Z	; stdext::unchecked_fill_n<unsigned char *,unsigned int,unsigned char>
PUBLIC	??$_Uninit_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAEIEV?$allocator@E@std@@@stdext@@YAXPAEIABEAAV?$allocator@E@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
PUBLIC	?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
PUBLIC	??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Uninit_move@PAEPAEV?$allocator@E@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned char *,unsigned char *,std::allocator<unsigned char>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>
PUBLIC	??$_Fill@PAEE@std@@YAXPAE0ABE@Z			; std::_Fill<unsigned char *,unsigned char>
PUBLIC	??$fill@PAEE@std@@YAXPAE0ABE@Z			; std::fill<unsigned char *,unsigned char>
PUBLIC	??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned char *>
PUBLIC	??$_Checked_base@PAE@std@@YAPAEAAPAE@Z		; std::_Checked_base<unsigned char *>
PUBLIC	??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ; std::_Iter_random<unsigned char *,unsigned char *>
PUBLIC	??$_Move_cat@PAE@std@@YA?AU_Undefined_move_tag@0@ABQAE@Z ; std::_Move_cat<unsigned char *>
PUBLIC	??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ; std::_Ptr_cat<unsigned char *,unsigned char *>
PUBLIC	??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAEPAE@stdext@@YAPAEPAE00@Z ; stdext::_Unchecked_move_backward<unsigned char *,unsigned char *>
PUBLIC	?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator+=
PUBLIC	??Y?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::operator+=
PUBLIC	??H?$_Vector_iterator@EV?$allocator@E@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::operator+
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned char,17>::CComSafeArray<unsigned char,17>
PUBLIC	??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>
PUBLIC	?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned char,17>::GetType
PUBLIC	?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned char,17>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned char,17>::Destroy
PUBLIC	?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned char,17>::Lock
PUBLIC	?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned char,17>::Attach
PUBLIC	?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned char,17>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned char,17>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned char,17>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z	; ATL::CComSafeArray<unsigned char,17>::GetAt
PUBLIC	??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ; FromVariant<unsigned char>
PUBLIC	??0?$allocator@G@std@@QAE@XZ			; std::allocator<unsigned short>::allocator<unsigned short>
PUBLIC	??$?0G@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned short>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::_Container_base_aux_alloc_real<std::allocator<unsigned short> >
PUBLIC	??0?$allocator@G@std@@QAE@ABV01@@Z		; std::allocator<unsigned short>::allocator<unsigned short>
PUBLIC	??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::_Vector_val<unsigned short,std::allocator<unsigned short> >
PUBLIC	?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy
PUBLIC	??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >
PUBLIC	??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::~_Vector_val<unsigned short,std::allocator<unsigned short> >
PUBLIC	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
PUBLIC	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
PUBLIC	?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::clear
PUBLIC	?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
PUBLIC	?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@GHPBGABG@std@@QAE@XZ		; std::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>
PUBLIC	??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >
PUBLIC	??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
PUBLIC	?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==
PUBLIC	??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=
PUBLIC	??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z	; stdext::unchecked_copy<unsigned short *,unsigned short *>
PUBLIC	?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
PUBLIC	?deallocate@?$allocator@G@std@@QAEXPAGI@Z	; std::allocator<unsigned short>::deallocate
PUBLIC	??$_Allocate@G@std@@YAPAGIPAG@Z			; std::_Allocate<unsigned short>
PUBLIC	?allocate@?$allocator@G@std@@QAEPAGI@Z		; std::allocator<unsigned short>::allocate
PUBLIC	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
PUBLIC	?max_size@?$allocator@G@std@@QBEIXZ		; std::allocator<unsigned short>::max_size
PUBLIC	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
PUBLIC	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
PUBLIC	??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z ; std::_Iter_cat<unsigned short *>
PUBLIC	??$_Fill_n@PAGIG@std@@YAXPAGIABGU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned short *,unsigned int,unsigned short>
PUBLIC	??$_Fill_n@PAGIG@std@@YAXPAGIABGUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned short *,unsigned int,unsigned short>
PUBLIC	??$unchecked_fill_n@PAGIG@stdext@@YAXPAGIABG@Z	; stdext::unchecked_fill_n<unsigned short *,unsigned int,unsigned short>
PUBLIC	??$_Uninit_fill_n@PAGIGV?$allocator@G@std@@@std@@YAXPAGIABGAAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned short *,unsigned int,unsigned short,std::allocator<unsigned short> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAGIGV?$allocator@G@std@@@stdext@@YAXPAGIABGAAV?$allocator@G@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned short *,unsigned int,unsigned short,std::allocator<unsigned short> >
PUBLIC	?_Ufill@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAGIABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ufill
PUBLIC	?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
PUBLIC	??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
PUBLIC	??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
PUBLIC	??$_Uninit_move@PAGPAGV?$allocator@G@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned short *,unsigned short *,std::allocator<unsigned short>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
PUBLIC	??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
PUBLIC	??$_Fill@PAGG@std@@YAXPAG0ABG@Z			; std::_Fill<unsigned short *,unsigned short>
PUBLIC	??$fill@PAGG@std@@YAXPAG0ABG@Z			; std::fill<unsigned short *,unsigned short>
PUBLIC	??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned short *>
PUBLIC	??$_Checked_base@PAG@std@@YAPAGAAPAG@Z		; std::_Checked_base<unsigned short *>
PUBLIC	??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z ; std::_Iter_random<unsigned short *,unsigned short *>
PUBLIC	??$_Move_cat@PAG@std@@YA?AU_Undefined_move_tag@0@ABQAG@Z ; std::_Move_cat<unsigned short *>
PUBLIC	??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ; std::_Ptr_cat<unsigned short *,unsigned short *>
PUBLIC	??$_Copy_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAGPAG@stdext@@YAPAGPAG00@Z ; stdext::_Unchecked_move_backward<unsigned short *,unsigned short *>
PUBLIC	?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator+=
PUBLIC	??Y?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::operator+=
PUBLIC	??H?$_Vector_iterator@GV?$allocator@G@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::operator+
PUBLIC	?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXIG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
PUBLIC	?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
PUBLIC	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
PUBLIC	??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
PUBLIC	??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned short,18>::CComSafeArray<unsigned short,18>
PUBLIC	??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>
PUBLIC	?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned short,18>::GetType
PUBLIC	?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned short,18>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned short,18>::Destroy
PUBLIC	?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned short,18>::Lock
PUBLIC	?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned short,18>::Attach
PUBLIC	?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned short,18>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned short,18>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned short,18>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z	; ATL::CComSafeArray<unsigned short,18>::GetAt
PUBLIC	??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z ; FromVariant<unsigned short>
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
PUBLIC	??$?0K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@K@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned long>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::_Container_base_aux_alloc_real<std::allocator<unsigned long> >
PUBLIC	??0?$allocator@K@std@@QAE@ABV01@@Z		; std::allocator<unsigned long>::allocator<unsigned long>
PUBLIC	??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >
PUBLIC	??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::~_Vector_val<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear
PUBLIC	?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
PUBLIC	?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@KHPBKABKV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned long,int,unsigned long const *,unsigned long const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned long,int,unsigned long const *,unsigned long const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@KHPBKABK@std@@QAE@XZ		; std::_Ranit<unsigned long,int,unsigned long const *,unsigned long const &>::_Ranit<unsigned long,int,unsigned long const *,unsigned long const &>
PUBLIC	??0?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >
PUBLIC	??0?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::_Vector_iterator<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Make_iter@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator==
PUBLIC	??9?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator!=
PUBLIC	??$_Copy_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAKPAK@stdext@@YAPAKPAK00@Z	; stdext::unchecked_copy<unsigned long *,unsigned long *>
PUBLIC	?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::erase
PUBLIC	?deallocate@?$allocator@K@std@@QAEXPAKI@Z	; std::allocator<unsigned long>::deallocate
PUBLIC	??$_Allocate@K@std@@YAPAKIPAK@Z			; std::_Allocate<unsigned long>
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
PUBLIC	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
PUBLIC	?max_size@?$allocator@K@std@@QBEIXZ		; std::allocator<unsigned long>::max_size
PUBLIC	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
PUBLIC	??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
PUBLIC	??$_Iter_cat@PAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK@Z ; std::_Iter_cat<unsigned long *>
PUBLIC	??$_Fill_n@PAKIK@std@@YAXPAKIABKU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned long *,unsigned int,unsigned long>
PUBLIC	??$_Fill_n@PAKIK@std@@YAXPAKIABKUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned long *,unsigned int,unsigned long>
PUBLIC	??$unchecked_fill_n@PAKIK@stdext@@YAXPAKIABK@Z	; stdext::unchecked_fill_n<unsigned long *,unsigned int,unsigned long>
PUBLIC	??$_Uninit_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAKIKV?$allocator@K@std@@@stdext@@YAXPAKIABKAAV?$allocator@K@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill
PUBLIC	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
PUBLIC	??$_Uninit_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$unchecked_uninitialized_copy@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$_Uninit_move@PAKPAKV?$allocator@K@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned long *,unsigned long *,std::allocator<unsigned long>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
PUBLIC	??$_Fill@PAKK@std@@YAXPAK0ABK@Z			; std::_Fill<unsigned long *,unsigned long>
PUBLIC	??$fill@PAKK@std@@YAXPAK0ABK@Z			; std::fill<unsigned long *,unsigned long>
PUBLIC	??$_Checked_base@PAK@std@@YAPAKAAPAKU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned long *>
PUBLIC	??$_Checked_base@PAK@std@@YAPAKAAPAK@Z		; std::_Checked_base<unsigned long *>
PUBLIC	??$_Iter_random@PAKPAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK0@Z ; std::_Iter_random<unsigned long *,unsigned long *>
PUBLIC	??$_Move_cat@PAK@std@@YA?AU_Undefined_move_tag@0@ABQAK@Z ; std::_Move_cat<unsigned long *>
PUBLIC	??$_Ptr_cat@PAKPAK@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAK0@Z ; std::_Ptr_cat<unsigned long *,unsigned long *>
PUBLIC	??$_Copy_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAKPAK@stdext@@YAPAKPAK00@Z ; stdext::_Unchecked_move_backward<unsigned long *,unsigned long *>
PUBLIC	?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator+=
PUBLIC	??Y?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::operator+=
PUBLIC	??H?$_Vector_iterator@KV?$allocator@K@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::operator+
PUBLIC	?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXIK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
PUBLIC	?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
PUBLIC	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
PUBLIC	??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
PUBLIC	??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned long,19>::CComSafeArray<unsigned long,19>
PUBLIC	??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>
PUBLIC	?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned long,19>::GetType
PUBLIC	?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned long,19>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned long,19>::Destroy
PUBLIC	?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned long,19>::Lock
PUBLIC	?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned long,19>::Attach
PUBLIC	?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned long,19>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned long,19>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned long,19>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z	; ATL::CComSafeArray<unsigned long,19>::GetAt
PUBLIC	??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z ; FromVariant<unsigned long>
PUBLIC	??0?$allocator@_K@std@@QAE@XZ			; std::allocator<unsigned __int64>::allocator<unsigned __int64>
PUBLIC	??$?0_K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_K@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned __int64>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
PUBLIC	??0?$allocator@_K@std@@QAE@ABV01@@Z		; std::allocator<unsigned __int64>::allocator<unsigned __int64>
PUBLIC	??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z ; std::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?_Buy@?$vector@_KV?$allocator@_K@std@@@std@@IAE_NI@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Buy
PUBLIC	??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
PUBLIC	??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >::~_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy
PUBLIC	??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::clear
PUBLIC	?begin@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::begin
PUBLIC	?end@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_KHPB_KAB_KV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@_KHPB_KAB_K@std@@QAE@XZ		; std::_Ranit<unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &>::_Ranit<unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &>
PUBLIC	??0?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	??0?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?_Make_iter@?$vector@_KV?$allocator@_K@std@@@std@@QBE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator==
PUBLIC	??9?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator!=
PUBLIC	??$_Copy_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PA_KPA_K@stdext@@YAPA_KPA_K00@Z ; stdext::unchecked_copy<unsigned __int64 *,unsigned __int64 *>
PUBLIC	?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::erase
PUBLIC	?deallocate@?$allocator@_K@std@@QAEXPA_KI@Z	; std::allocator<unsigned __int64>::deallocate
PUBLIC	??$_Allocate@_K@std@@YAPA_KIPA_K@Z		; std::_Allocate<unsigned __int64>
PUBLIC	?allocate@?$allocator@_K@std@@QAEPA_KI@Z	; std::allocator<unsigned __int64>::allocate
PUBLIC	?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::capacity
PUBLIC	?max_size@?$allocator@_K@std@@QBEIXZ		; std::allocator<unsigned __int64>::max_size
PUBLIC	?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned __int64> >
PUBLIC	??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z ; std::_Destroy_range<std::allocator<unsigned __int64> >
PUBLIC	?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXPA_K0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Destroy
PUBLIC	??$_Iter_cat@PA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K@Z ; std::_Iter_cat<unsigned __int64 *>
PUBLIC	??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned __int64 *,unsigned int,unsigned __int64>
PUBLIC	??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned __int64 *,unsigned int,unsigned __int64>
PUBLIC	??$unchecked_fill_n@PA_KI_K@stdext@@YAXPA_KIAB_K@Z ; stdext::unchecked_fill_n<unsigned __int64 *,unsigned int,unsigned __int64>
PUBLIC	??$_Uninit_fill_n@PA_KI_KV?$allocator@_K@std@@@std@@YAXPA_KIAB_KAAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned __int64 *,unsigned int,unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	??$unchecked_uninitialized_fill_n@PA_KI_KV?$allocator@_K@std@@@stdext@@YAXPA_KIAB_KAAV?$allocator@_K@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned __int64 *,unsigned int,unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?_Ufill@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_KIAB_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Ufill
PUBLIC	?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlen
PUBLIC	??$_Uninit_copy@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
PUBLIC	??$unchecked_uninitialized_copy@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
PUBLIC	??$_Uninit_move@PA_KPA_KV?$allocator@_K@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
PUBLIC	??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>
PUBLIC	??$_Fill@PA_K_K@std@@YAXPA_K0AB_K@Z		; std::_Fill<unsigned __int64 *,unsigned __int64>
PUBLIC	??$fill@PA_K_K@std@@YAXPA_K0AB_K@Z		; std::fill<unsigned __int64 *,unsigned __int64>
PUBLIC	??$_Checked_base@PA_K@std@@YAPA_KAAPA_KU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned __int64 *>
PUBLIC	??$_Checked_base@PA_K@std@@YAPA_KAAPA_K@Z	; std::_Checked_base<unsigned __int64 *>
PUBLIC	??$_Iter_random@PA_KPA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K0@Z ; std::_Iter_random<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Move_cat@PA_K@std@@YA?AU_Undefined_move_tag@0@ABQA_K@Z ; std::_Move_cat<unsigned __int64 *>
PUBLIC	??$_Ptr_cat@PA_KPA_K@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_K0@Z ; std::_Ptr_cat<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Copy_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PA_KPA_K@stdext@@YAPA_KPA_K00@Z ; stdext::_Unchecked_move_backward<unsigned __int64 *,unsigned __int64 *>
PUBLIC	?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+=
PUBLIC	??Y?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+=
PUBLIC	??H?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+
PUBLIC	?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
PUBLIC	?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
PUBLIC	?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::size
PUBLIC	??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator[]
PUBLIC	??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned __int64,21>::CComSafeArray<unsigned __int64,21>
PUBLIC	??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>
PUBLIC	?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned __int64,21>::GetType
PUBLIC	?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned __int64,21>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned __int64,21>::Destroy
PUBLIC	?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned __int64,21>::Lock
PUBLIC	?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned __int64,21>::Attach
PUBLIC	?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned __int64,21>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned __int64,21>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned __int64,21>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z	; ATL::CComSafeArray<unsigned __int64,21>::GetAt
PUBLIC	??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ; FromVariant<unsigned __int64>
PUBLIC	??0?$allocator@M@std@@QAE@XZ			; std::allocator<float>::allocator<float>
PUBLIC	??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
PUBLIC	??0?$allocator@M@std@@QAE@ABV01@@Z		; std::allocator<float>::allocator<float>
PUBLIC	??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
PUBLIC	?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ; std::vector<float,std::allocator<float> >::_Buy
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
PUBLIC	??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ; std::vector<float,std::allocator<float> >::clear
PUBLIC	?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::begin
PUBLIC	?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ; std::vector<float,std::allocator<float> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@MHPBMABM@std@@QAE@XZ		; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>
PUBLIC	??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >
PUBLIC	??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >
PUBLIC	?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z ; std::vector<float,std::allocator<float> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==
PUBLIC	??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=
PUBLIC	??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z	; stdext::unchecked_copy<float *,float *>
PUBLIC	?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase
PUBLIC	?deallocate@?$allocator@M@std@@QAEXPAMI@Z	; std::allocator<float>::deallocate
PUBLIC	??$_Allocate@M@std@@YAPAMIPAM@Z			; std::_Allocate<float>
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::capacity
PUBLIC	?max_size@?$allocator@M@std@@QBEIXZ		; std::allocator<float>::max_size
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z ; std::_Iter_cat<float *>
PUBLIC	??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<float *,unsigned int,float>
PUBLIC	??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<float *,unsigned int,float>
PUBLIC	??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z	; stdext::unchecked_fill_n<float *,unsigned int,float>
PUBLIC	??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >
PUBLIC	?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z ; std::vector<float,std::allocator<float> >::_Ufill
PUBLIC	?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
PUBLIC	??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<float *,float *,std::allocator<float> >
PUBLIC	??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >
PUBLIC	??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<float *,float *,std::allocator<float>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ; stdext::_Unchecked_uninitialized_move<float *,float *,std::allocator<float> >
PUBLIC	??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>
PUBLIC	??$_Fill@PAMM@std@@YAXPAM0ABM@Z			; std::_Fill<float *,float>
PUBLIC	??$fill@PAMM@std@@YAXPAM0ABM@Z			; std::fill<float *,float>
PUBLIC	??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<float *>
PUBLIC	??$_Checked_base@PAM@std@@YAPAMAAPAM@Z		; std::_Checked_base<float *>
PUBLIC	??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z ; std::_Iter_random<float *,float *>
PUBLIC	??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z ; std::_Move_cat<float *>
PUBLIC	??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ; std::_Ptr_cat<float *,float *>
PUBLIC	??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<float *,float *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<float *,float *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z ; stdext::_Unchecked_move_backward<float *,float *>
PUBLIC	?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z ; std::vector<float,std::allocator<float> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<float,std::allocator<float> >::operator+=
PUBLIC	??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<float,std::allocator<float> >::operator+=
PUBLIC	??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<float,std::allocator<float> >::operator+
PUBLIC	?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXIM@Z ; std::vector<float,std::allocator<float> >::resize
PUBLIC	?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z ; std::vector<float,std::allocator<float> >::resize
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ; std::vector<float,std::allocator<float> >::operator[]
PUBLIC	??0?$CComSafeArray@M$03@ATL@@QAE@XZ		; ATL::CComSafeArray<float,4>::CComSafeArray<float,4>
PUBLIC	??1?$CComSafeArray@M$03@ATL@@QAE@XZ		; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>
PUBLIC	?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ	; ATL::CComSafeArray<float,4>::GetType
PUBLIC	?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ	; ATL::CComSafeArray<float,4>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ	; ATL::CComSafeArray<float,4>::Destroy
PUBLIC	?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ		; ATL::CComSafeArray<float,4>::Lock
PUBLIC	?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<float,4>::Attach
PUBLIC	?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z	; ATL::CComSafeArray<float,4>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ; ATL::CComSafeArray<float,4>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ; ATL::CComSafeArray<float,4>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z	; ATL::CComSafeArray<float,4>::GetAt
PUBLIC	??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z ; FromVariant<float>
PUBLIC	??0?$allocator@N@std@@QAE@XZ			; std::allocator<double>::allocator<double>
PUBLIC	??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
PUBLIC	??0?$allocator@N@std@@QAE@ABV01@@Z		; std::allocator<double>::allocator<double>
PUBLIC	??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >
PUBLIC	?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z ; std::vector<double,std::allocator<double> >::_Buy
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
PUBLIC	??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ ; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >
PUBLIC	?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ ; std::vector<double,std::allocator<double> >::_Tidy
PUBLIC	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
PUBLIC	?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ ; std::vector<double,std::allocator<double> >::clear
PUBLIC	?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::begin
PUBLIC	?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@NHPBNABN@std@@QAE@XZ		; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>
PUBLIC	??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >
PUBLIC	??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >
PUBLIC	?_Make_iter@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@@Z ; std::vector<double,std::allocator<double> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator==
PUBLIC	??9?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator!=
PUBLIC	??$_Copy_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<double *,double *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PANPAN@stdext@@YAPANPAN00@Z	; stdext::unchecked_copy<double *,double *>
PUBLIC	?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z ; std::vector<double,std::allocator<double> >::erase
PUBLIC	?deallocate@?$allocator@N@std@@QAEXPANI@Z	; std::allocator<double>::deallocate
PUBLIC	??$_Allocate@N@std@@YAPANIPAN@Z			; std::_Allocate<double>
PUBLIC	?allocate@?$allocator@N@std@@QAEPANI@Z		; std::allocator<double>::allocate
PUBLIC	?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::capacity
PUBLIC	?max_size@?$allocator@N@std@@QBEIXZ		; std::allocator<double>::max_size
PUBLIC	?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z ; std::vector<double,std::allocator<double> >::_Destroy
PUBLIC	??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z ; std::_Iter_cat<double *>
PUBLIC	??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<double *,unsigned int,double>
PUBLIC	??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<double *,unsigned int,double>
PUBLIC	??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z	; stdext::unchecked_fill_n<double *,unsigned int,double>
PUBLIC	??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >
PUBLIC	?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z ; std::vector<double,std::allocator<double> >::_Ufill
PUBLIC	?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
PUBLIC	??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<double *,double *,std::allocator<double> >
PUBLIC	??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >
PUBLIC	??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >
PUBLIC	??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>
PUBLIC	??$_Fill@PANN@std@@YAXPAN0ABN@Z			; std::_Fill<double *,double>
PUBLIC	??$fill@PANN@std@@YAXPAN0ABN@Z			; std::fill<double *,double>
PUBLIC	??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<double *>
PUBLIC	??$_Checked_base@PAN@std@@YAPANAAPAN@Z		; std::_Checked_base<double *>
PUBLIC	??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z ; std::_Iter_random<double *,double *>
PUBLIC	??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z ; std::_Move_cat<double *>
PUBLIC	??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z ; std::_Ptr_cat<double *,double *>
PUBLIC	??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ; stdext::_Unchecked_move_backward<double *,double *>
PUBLIC	?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ; std::vector<double,std::allocator<double> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=
PUBLIC	??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<double,std::allocator<double> >::operator+=
PUBLIC	??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<double,std::allocator<double> >::operator+
PUBLIC	?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXIN@Z ; std::vector<double,std::allocator<double> >::resize
PUBLIC	?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z ; std::vector<double,std::allocator<double> >::resize
PUBLIC	?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::size
PUBLIC	??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ; std::vector<double,std::allocator<double> >::operator[]
PUBLIC	??0?$CComSafeArray@N$04@ATL@@QAE@XZ		; ATL::CComSafeArray<double,5>::CComSafeArray<double,5>
PUBLIC	??1?$CComSafeArray@N$04@ATL@@QAE@XZ		; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>
PUBLIC	?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ	; ATL::CComSafeArray<double,5>::GetType
PUBLIC	?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ	; ATL::CComSafeArray<double,5>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ	; ATL::CComSafeArray<double,5>::Destroy
PUBLIC	?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ		; ATL::CComSafeArray<double,5>::Lock
PUBLIC	?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<double,5>::Attach
PUBLIC	?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z	; ATL::CComSafeArray<double,5>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ; ATL::CComSafeArray<double,5>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ; ATL::CComSafeArray<double,5>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z	; ATL::CComSafeArray<double,5>::GetAt
PUBLIC	??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z ; FromVariant<double>
PUBLIC	??0?$allocator@PA_W@std@@QAE@XZ			; std::allocator<wchar_t *>::allocator<wchar_t *>
PUBLIC	??$?0PA_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PA_W@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><wchar_t *>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
PUBLIC	??0?$allocator@PA_W@std@@QAE@ABV01@@Z		; std::allocator<wchar_t *>::allocator<wchar_t *>
PUBLIC	??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z ; std::_Vector_val<wchar_t *,std::allocator<wchar_t *> >::_Vector_val<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	?_Buy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAE_NI@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Buy
PUBLIC	??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
PUBLIC	??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::_Vector_val<wchar_t *,std::allocator<wchar_t *> >::~_Vector_val<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Tidy
PUBLIC	??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::clear
PUBLIC	??BCComBSTR@ATL@@QBEPA_WXZ			; ATL::CComBSTR::operator wchar_t *
PUBLIC	??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ		; ATL::CComSafeArray<wchar_t *,8>::CComSafeArray<wchar_t *,8>
PUBLIC	??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ		; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>
PUBLIC	?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z ; ATL::AtlSafeArrayGetActualVartype
PUBLIC	?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ	; ATL::CComSafeArray<wchar_t *,8>::GetType
PUBLIC	?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ	; ATL::CComSafeArray<wchar_t *,8>::Unlock
PUBLIC	?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ	; ATL::CComSafeArray<wchar_t *,8>::Destroy
PUBLIC	?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ	; ATL::CComSafeArray<wchar_t *,8>::Lock
PUBLIC	?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<wchar_t *,8>::Attach
PUBLIC	?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z	; ATL::CComSafeArray<wchar_t *,8>::GetCount
PUBLIC	?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ; ATL::CComSafeArray<wchar_t *,8>::GetLowerBound
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ; ATL::CComSafeArray<wchar_t *,8>::GetUpperBound
PUBLIC	?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z ; ATL::CComSafeArray<wchar_t *,8>::GetAt
PUBLIC	?begin@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::begin
PUBLIC	?end@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PA_WHPBQA_WABQA_WV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,wchar_t *,int,wchar_t * const *,wchar_t * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,wchar_t *,int,wchar_t * const *,wchar_t * const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@PA_WHPBQA_WABQA_W@std@@QAE@XZ	; std::_Ranit<wchar_t *,int,wchar_t * const *,wchar_t * const &>::_Ranit<wchar_t *,int,wchar_t * const *,wchar_t * const &>
PUBLIC	??0?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??0?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	?_Make_iter@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator==
PUBLIC	??9?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator!=
PUBLIC	??$_Copy_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z ; stdext::unchecked_copy<wchar_t * *,wchar_t * *>
PUBLIC	?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::erase
PUBLIC	?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z	; std::allocator<wchar_t *>::deallocate
PUBLIC	??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z	; std::_Allocate<wchar_t *>
PUBLIC	?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z	; std::allocator<wchar_t *>::allocate
PUBLIC	?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::capacity
PUBLIC	?max_size@?$allocator@PA_W@std@@QBEIXZ		; std::allocator<wchar_t *>::max_size
PUBLIC	?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::max_size
PUBLIC	??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<wchar_t *> >
PUBLIC	??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t *> >
PUBLIC	?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXPAPA_W0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Destroy
PUBLIC	??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z ; std::_Iter_cat<wchar_t * *>
PUBLIC	??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
PUBLIC	??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
PUBLIC	??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z ; stdext::unchecked_fill_n<wchar_t * *,unsigned int,wchar_t *>
PUBLIC	??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z ; stdext::unchecked_uninitialized_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
PUBLIC	?_Ufill@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_WIABQA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Ufill
PUBLIC	?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z ; stdext::unchecked_uninitialized_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
PUBLIC	??$_Uninit_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z ; stdext::_Unchecked_uninitialized_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
PUBLIC	??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>
PUBLIC	??$_Fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z	; std::_Fill<wchar_t * *,wchar_t *>
PUBLIC	??$fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z	; std::fill<wchar_t * *,wchar_t *>
PUBLIC	??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<wchar_t * *>
PUBLIC	??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z	; std::_Checked_base<wchar_t * *>
PUBLIC	??$_Iter_random@PAPA_WPAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W0@Z ; std::_Iter_random<wchar_t * *,wchar_t * *>
PUBLIC	??$_Move_cat@PAPA_W@std@@YA?AU_Undefined_move_tag@0@ABQAPA_W@Z ; std::_Move_cat<wchar_t * *>
PUBLIC	??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z ; std::_Ptr_cat<wchar_t * *,wchar_t * *>
PUBLIC	??$_Copy_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag>
PUBLIC	??$_Move_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z ; stdext::_Unchecked_move_backward<wchar_t * *,wchar_t * *>
PUBLIC	?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+=
PUBLIC	??Y?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+=
PUBLIC	??H?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+
PUBLIC	?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXIPA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
PUBLIC	?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
PUBLIC	?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::size
PUBLIC	??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::operator[]
PUBLIC	??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ; FromVariant<wchar_t *>
PUBLIC	??_Gxmlwriter@@QAEPAXI@Z			; xmlwriter::`scalar deleting destructor'
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Construct_n
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BH@MIMIOLHO@?$DM?$DM?5WMI?0?5Inv?5class?5name?$AA@ ; `string'
PUBLIC	??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex?$AA@	; `string'
PUBLIC	??_C@_0BJ@CAANICIM@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?5timeout?$AA@ ; `string'
PUBLIC	??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5COM@ ; `string'
PUBLIC	??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5sec@ ; `string'
PUBLIC	??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemLo@ ; `string'
PUBLIC	??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?48@ ; `string'
PUBLIC	??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2?5@ ; `string'
PUBLIC	??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5blan@ ; `string'
PUBLIC	??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for?5@ ; `string'
PUBLIC	??_C@_03LJNDFDHG@WQL?$AA@			; `string'
PUBLIC	??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x?$CF@ ; `string'
PUBLIC	??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ?5@ ; `string'
PUBLIC	??_C@_06DBMAJEKE@0x?$CF?42X?$AA@		; `string'
PUBLIC	??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X?$AA@	; `string'
PUBLIC	??_C@_06DFENOIBG@0x?$CF?44X?$AA@		; `string'
PUBLIC	??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X?$AA@	; `string'
PUBLIC	??_C@_06DMFHBBHC@0x?$CF?48X?$AA@		; `string'
PUBLIC	??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X?$AA@	; `string'
PUBLIC	??_C@_07PDBEDJPN@0x?$CF?416X?$AA@		; `string'
PUBLIC	??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X?$AA@	; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf?$AA@		; `string'
PUBLIC	??_C@_02CGLCDNAE@?$CFe?$AA@			; `string'
PUBLIC	??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe?$AA@	; `string'
PUBLIC	??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_C@_07GECKFJJF@?$CFs?5?$DN?5?$CFu?$AA@	; `string'
PUBLIC	??_C@_04EHEKGOB@?$CF?43u?$AA@			; `string'
PUBLIC	??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X?$AA@		; `string'
PUBLIC	??_C@_09MHANBIPO@?$CFs?40x?$CF?44X?$AA@		; `string'
PUBLIC	??_C@_09MOBHOBJK@?$CFs?40x?$CF?48X?$AA@		; `string'
PUBLIC	??_C@_0L@FNDHBDEH@?$CFs?40x?$CF?416X?$AA@	; `string'
PUBLIC	??_C@_05OKOCMAOB@?$CFs?4?$CFf?$AA@		; `string'
PUBLIC	??_C@_05MBMPJDCC@?$CFs?4?$CFe?$AA@		; `string'
PUBLIC	??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3?$AA@		; `string'
PUBLIC	??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion?5@ ; `string'
PUBLIC	??_C@_0BI@NBKPEDCE@No?5properties?5processed?$AA@ ; `string'
PUBLIC	??_C@_0BI@GPOLMEPO@?$CFu?5properties?5processed?$AA@ ; `string'
PUBLIC	??_C@_0CD@BNKPFHB@Elapsed?5Time?3?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@ ; `string'
PUBLIC	??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True?$AA@ ; `string'
PUBLIC	??_C@_0BC@BBPNDDPO@?$DO?$DO?5ThrdWMICls?0?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null?$AA@ ; `string'
PUBLIC	??_C@_0BG@PNOFHJNO@SysStatus_?$CFs_?$CF?41d?4xml?$AA@ ; `string'
PUBLIC	??_C@_0BL@NMIGBPMF@ThrdWMICls?0?5Trying?5opng?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5old@ ; `string'
PUBLIC	??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CFs@ ; `string'
PUBLIC	??_C@_0BD@CJNFHACM@SysStatus_?$CFs_0?4xml?$AA@	; `string'
PUBLIC	??_C@_0BB@PKMMABCD@SysStatus_?$CFs?4xml?$AA@	; `string'
PUBLIC	??_C@_0CB@FDOJEIA@?9?9?5ThrdWMICls?0?5Remaning?5?$CFs?5?9?$DO?5?$CFs@ ; `string'
PUBLIC	??_C@_0CM@DGGGCCBN@?$DM?$DM?5ThrdWMICls?0?5New?5XmlWriter?$CI?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0CI@IKNGLCAL@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02d?3?$CF02d?3?$CF02@ ; `string'
PUBLIC	??_C@_0P@IOMMKEOB@?$DO?$DO?5ThrdWMI?0?5In?$AA@	; `string'
PUBLIC	??_C@_0N@FBNILPME@HardwareInfo?$AA@		; `string'
PUBLIC	??_C@_0BF@MGDJDLAD@Hardware?5Information?$AA@	; `string'
PUBLIC	??_C@_0M@PNBJJAPO@DataStorage?$AA@		; `string'
PUBLIC	??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information?$AA@ ; `string'
PUBLIC	??_C@_06LEBJIAPJ@Memory?$AA@			; `string'
PUBLIC	??_C@_0BD@BGPGMIME@Memory?5Information?$AA@	; `string'
PUBLIC	??_C@_0L@NDINDOCK@SystemInfo?$AA@		; `string'
PUBLIC	??_C@_0BD@OJGHJHKA@System?5Information?$AA@	; `string'
PUBLIC	??_C@_07BGDMAJAE@Network?$AA@			; `string'
PUBLIC	??_C@_0BE@KDFOEONK@Network?5Information?$AA@	; `string'
PUBLIC	??_C@_0BH@IAHFOAM@UserAccountAndSecurity?$AA@	; `string'
PUBLIC	??_C@_0CG@BJFGJGFN@User?5Account?5and?5Security?5Inform@ ; `string'
PUBLIC	??_C@_09HCBPJCHD@Developer?$AA@			; `string'
PUBLIC	??_C@_0BG@KMFPDIMK@Developer?5Information?$AA@	; `string'
PUBLIC	??_C@_07HCOFHGI@Utility?$AA@			; `string'
PUBLIC	??_C@_0BE@DMCOJOJG@Utility?5Information?$AA@	; `string'
PUBLIC	??_C@_0BH@PEBHJHOI@ThrdWMI?0?5Waitg?5?$CFu?5thrs?$AA@ ; `string'
PUBLIC	??_C@_0CD@KILGIJLE@ThrdWMI?0?5Out?0?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@ ; `string'
PUBLIC	??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols?$AA@	; `string'
PUBLIC	??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols?$AA@	; `string'
PUBLIC	??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf?$AA@	; `string'
PUBLIC	??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf?$AA@	; `string'
PUBLIC	??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr?$AA@	; `string'
PUBLIC	??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr?$AA@	; `string'
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__CoInitializeSecurity@36:PROC
EXTRN	__imp__CoSetProxyBlanket@32:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__VariantClear@4:PROC
EXTRN	?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z:PROC ; _com_util::ConvertStringToBSTR
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	?_com_issue_error@@YGXJ@Z:PROC			; _com_issue_error
EXTRN	__imp__InterlockedDecrement@4:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	_IID_IWbemLocator:BYTE
EXTRN	_CLSID_WbemLocator:BYTE
EXTRN	__imp__SafeArrayGetVartype@8:PROC
EXTRN	__imp__SafeArrayDestroy@4:PROC
EXTRN	__imp__SafeArrayUnlock@4:PROC
EXTRN	__imp__SafeArrayLock@4:PROC
EXTRN	__imp__SafeArrayGetLBound@12:PROC
EXTRN	__imp__SafeArrayGetUBound@12:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
;	COMDAT ??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr?$AA@
CONST	SEGMENT
??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr?$AA@ DB '<< WMIHwSnsr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr?$AA@
CONST	SEGMENT
??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr?$AA@ DB '>> WMIHwSnsr', 00H ; `string'
CONST	ENDS
;	COMDAT ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::VoltageProbe
_DATA	ENDS
;	COMDAT ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::TemperatureProbe
_DATA	ENDS
;	COMDAT ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::PortableBattery
_DATA	ENDS
;	COMDAT ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::CurrentProbe
_DATA	ENDS
;	COMDAT ??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf?$AA@
CONST	SEGMENT
??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf?$AA@ DB '<< WMISysPerf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf?$AA@
CONST	SEGMENT
??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf?$AA@ DB '>> WMISysPerf', 00H ; `string'
CONST	ENDS
;	COMDAT ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_System
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Processor
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_PagingFile
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Objects
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Memory
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Cache
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfNet_Redirector
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfDisk_PhysicalDisk
_DATA	ENDS
;	COMDAT ??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols?$AA@
CONST	SEGMENT
??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols?$AA@ DB '<< WMISysVols', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols?$AA@
CONST	SEGMENT
??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols?$AA@ DB '>> WMISysVols', 00H ; `string'
CONST	ENDS
;	COMDAT ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA
_DATA	SEGMENT
?Volume@?1??WMISystemVolumes@@YAXXZ@4KA DD 0ffffffffH	; `WMISystemVolumes'::`2'::Volume
_DATA	ENDS
;	COMDAT ??_C@_0CD@KILGIJLE@ThrdWMI?0?5Out?0?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@
CONST	SEGMENT
??_C@_0CD@KILGIJLE@ThrdWMI?0?5Out?0?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@ DB 'T'
	DB	'hrdWMI, Out, %02d:%02d:%02d, %f s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PEBHJHOI@ThrdWMI?0?5Waitg?5?$CFu?5thrs?$AA@
CONST	SEGMENT
??_C@_0BH@PEBHJHOI@ThrdWMI?0?5Waitg?5?$CFu?5thrs?$AA@ DB 'ThrdWMI, Waitg '
	DB	'%u thrs', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DMCOJOJG@Utility?5Information?$AA@
CONST	SEGMENT
??_C@_0BE@DMCOJOJG@Utility?5Information?$AA@ DB 'Utility Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCOFHGI@Utility?$AA@
CONST	SEGMENT
??_C@_07HCOFHGI@Utility?$AA@ DB 'Utility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KMFPDIMK@Developer?5Information?$AA@
CONST	SEGMENT
??_C@_0BG@KMFPDIMK@Developer?5Information?$AA@ DB 'Developer Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCBPJCHD@Developer?$AA@
CONST	SEGMENT
??_C@_09HCBPJCHD@Developer?$AA@ DB 'Developer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BJFGJGFN@User?5Account?5and?5Security?5Inform@
CONST	SEGMENT
??_C@_0CG@BJFGJGFN@User?5Account?5and?5Security?5Inform@ DB 'User Account'
	DB	' and Security Information', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IAHFOAM@UserAccountAndSecurity?$AA@
CONST	SEGMENT
??_C@_0BH@IAHFOAM@UserAccountAndSecurity?$AA@ DB 'UserAccountAndSecurity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDFOEONK@Network?5Information?$AA@
CONST	SEGMENT
??_C@_0BE@KDFOEONK@Network?5Information?$AA@ DB 'Network Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGDMAJAE@Network?$AA@
CONST	SEGMENT
??_C@_07BGDMAJAE@Network?$AA@ DB 'Network', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJGHJHKA@System?5Information?$AA@
CONST	SEGMENT
??_C@_0BD@OJGHJHKA@System?5Information?$AA@ DB 'System Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDINDOCK@SystemInfo?$AA@
CONST	SEGMENT
??_C@_0L@NDINDOCK@SystemInfo?$AA@ DB 'SystemInfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGPGMIME@Memory?5Information?$AA@
CONST	SEGMENT
??_C@_0BD@BGPGMIME@Memory?5Information?$AA@ DB 'Memory Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEBJIAPJ@Memory?$AA@
CONST	SEGMENT
??_C@_06LEBJIAPJ@Memory?$AA@ DB 'Memory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information?$AA@
CONST	SEGMENT
??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information?$AA@ DB 'Disk and P'
	DB	'artitions Information', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PNBJJAPO@DataStorage?$AA@
CONST	SEGMENT
??_C@_0M@PNBJJAPO@DataStorage?$AA@ DB 'DataStorage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGDJDLAD@Hardware?5Information?$AA@
CONST	SEGMENT
??_C@_0BF@MGDJDLAD@Hardware?5Information?$AA@ DB 'Hardware Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBNILPME@HardwareInfo?$AA@
CONST	SEGMENT
??_C@_0N@FBNILPME@HardwareInfo?$AA@ DB 'HardwareInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IOMMKEOB@?$DO?$DO?5ThrdWMI?0?5In?$AA@
CONST	SEGMENT
??_C@_0P@IOMMKEOB@?$DO?$DO?5ThrdWMI?0?5In?$AA@ DB '>> ThrdWMI, In', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IKNGLCAL@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02d?3?$CF02d?3?$CF02@
CONST	SEGMENT
??_C@_0CI@IKNGLCAL@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02d?3?$CF02d?3?$CF02@ DB '<'
	DB	'< ThrdWMICls, %s, %02d:%02d:%02d, %f s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DGGGCCBN@?$DM?$DM?5ThrdWMICls?0?5New?5XmlWriter?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0CM@DGGGCCBN@?$DM?$DM?5ThrdWMICls?0?5New?5XmlWriter?$CI?$CFs?$CJ@ DB '<'
	DB	'< ThrdWMICls, New XmlWriter(%s) class null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FDOJEIA@?9?9?5ThrdWMICls?0?5Remaning?5?$CFs?5?9?$DO?5?$CFs@
CONST	SEGMENT
??_C@_0CB@FDOJEIA@?9?9?5ThrdWMICls?0?5Remaning?5?$CFs?5?9?$DO?5?$CFs@ DB '-'
	DB	'- ThrdWMICls, Remaning %s -> %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PKMMABCD@SysStatus_?$CFs?4xml?$AA@
CONST	SEGMENT
??_C@_0BB@PKMMABCD@SysStatus_?$CFs?4xml?$AA@ DB 'SysStatus_%s.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJNFHACM@SysStatus_?$CFs_0?4xml?$AA@
CONST	SEGMENT
??_C@_0BD@CJNFHACM@SysStatus_?$CFs_0?4xml?$AA@ DB 'SysStatus_%s_0.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CFs@
CONST	SEGMENT
??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CFs@ DB '-'
	DB	'- ThrdWMICls, Renaming %s -> %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5old@
CONST	SEGMENT
??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5old@ DB '-- Th'
	DB	'rdWMICls, Removing %s - oldest file', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CFs@
CONST	SEGMENT
??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CFs@ DB '-- T'
	DB	'hrdWMICls, Last file fnd: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NMIGBPMF@ThrdWMICls?0?5Trying?5opng?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BL@NMIGBPMF@ThrdWMICls?0?5Trying?5opng?5?$CFs?$AA@ DB 'ThrdWMICls,'
	DB	' Trying opng %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PNOFHJNO@SysStatus_?$CFs_?$CF?41d?4xml?$AA@
CONST	SEGMENT
??_C@_0BG@PNOFHJNO@SysStatus_?$CFs_?$CF?41d?4xml?$AA@ DB 'SysStatus_%s_%.'
	DB	'1d.xml', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null?$AA@
CONST	SEGMENT
??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null?$AA@ DB '<< ThrdWM'
	DB	'ICls, Input null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BBPNDDPO@?$DO?$DO?5ThrdWMICls?0?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0BC@BBPNDDPO@?$DO?$DO?5ThrdWMICls?0?5?$CFX?$AA@ DB '>> ThrdWMICls, '
	DB	'%X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True?$AA@
CONST	SEGMENT
??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True?$AA@ DB '<< WMI, ret True', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BNKPFHB@Elapsed?5Time?3?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@
CONST	SEGMENT
??_C@_0CD@BNKPFHB@Elapsed?5Time?3?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@ DB 'E'
	DB	'lapsed Time: %02d:%02d:%02d, %f s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPOLMEPO@?$CFu?5properties?5processed?$AA@
CONST	SEGMENT
??_C@_0BI@GPOLMEPO@?$CFu?5properties?5processed?$AA@ DB '%u properties pr'
	DB	'ocessed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NBKPEDCE@No?5properties?5processed?$AA@
CONST	SEGMENT
??_C@_0BI@NBKPEDCE@No?5properties?5processed?$AA@ DB 'No properties proce'
	DB	'ssed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion?5@
CONST	SEGMENT
??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion?5@ DB '-- WMI, '
	DB	'Catch unhndld excpetion on %.5u %s (%i) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd?$AA@ DB '%s = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs?$AA@ DB 09H, '> %.3d %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3?$AA@
CONST	SEGMENT
??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3?$AA@ DB '%s, %d:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBMPJDCC@?$CFs?4?$CFe?$AA@
CONST	SEGMENT
??_C@_05MBMPJDCC@?$CFs?4?$CFe?$AA@ DB '%s.%e', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKOCMAOB@?$CFs?4?$CFf?$AA@
CONST	SEGMENT
??_C@_05OKOCMAOB@?$CFs?4?$CFf?$AA@ DB '%s.%f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNDHBDEH@?$CFs?40x?$CF?416X?$AA@
CONST	SEGMENT
??_C@_0L@FNDHBDEH@?$CFs?40x?$CF?416X?$AA@ DB '%s.0x%.16X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOBHOBJK@?$CFs?40x?$CF?48X?$AA@
CONST	SEGMENT
??_C@_09MOBHOBJK@?$CFs?40x?$CF?48X?$AA@ DB '%s.0x%.8X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHANBIPO@?$CFs?40x?$CF?44X?$AA@
CONST	SEGMENT
??_C@_09MHANBIPO@?$CFs?40x?$CF?44X?$AA@ DB '%s.0x%.4X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X?$AA@
CONST	SEGMENT
??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X?$AA@ DB '%s.0x%.2X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHEKGOB@?$CF?43u?$AA@
CONST	SEGMENT
??_C@_04EHEKGOB@?$CF?43u?$AA@ DB '%.3u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GECKFJJF@?$CFs?5?$DN?5?$CFu?$AA@
CONST	SEGMENT
??_C@_07GECKFJJF@?$CFs?5?$DN?5?$CFu?$AA@ DB '%s = %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs?$AA@ DB '%s = %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe?$AA@
CONST	SEGMENT
??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe?$AA@ DB '%s = %e', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02CGLCDNAE@?$CFe?$AA@
CONST	SEGMENT
??_C@_02CGLCDNAE@?$CFe?$AA@ DB '%e', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf?$AA@
CONST	SEGMENT
??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf?$AA@ DB '%s = %f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X?$AA@
CONST	SEGMENT
??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X?$AA@ DB '%s = 0x%.16X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PDBEDJPN@0x?$CF?416X?$AA@
CONST	SEGMENT
??_C@_07PDBEDJPN@0x?$CF?416X?$AA@ DB '0x%.16X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X?$AA@
CONST	SEGMENT
??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X?$AA@ DB '%s = 0x%.8X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMFHBBHC@0x?$CF?48X?$AA@
CONST	SEGMENT
??_C@_06DMFHBBHC@0x?$CF?48X?$AA@ DB '0x%.8X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X?$AA@
CONST	SEGMENT
??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X?$AA@ DB '%s = 0x%.4X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DFENOIBG@0x?$CF?44X?$AA@
CONST	SEGMENT
??_C@_06DFENOIBG@0x?$CF?44X?$AA@ DB '0x%.4X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X?$AA@
CONST	SEGMENT
??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X?$AA@ DB '%s = 0x%.2X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBMAJEKE@0x?$CF?42X?$AA@
CONST	SEGMENT
??_C@_06DBMAJEKE@0x?$CF?42X?$AA@ DB '0x%.2X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ?5@
CONST	SEGMENT
??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ?5@ DB '-'
	DB	'- WMI, Processing %.5u %s (%i) %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x?$CF@
CONST	SEGMENT
??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x?$CF@ DB '-'
	DB	'- WMI, Query for %s failed, 0x%.8x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJNDFDHG@WQL?$AA@
CONST	SEGMENT
??_C@_03LJNDFDHG@WQL?$AA@ DB 'WQL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for?5@
CONST	SEGMENT
??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for?5@ DB '-- WMI, '
	DB	'Querying properties for %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs?$AA@ DB 'SELECT * FROM %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5blan@
CONST	SEGMENT
??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5blan@ DB '<< '
	DB	'WMI, Could not set proxy blanket, 0x%.8x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2?5@
CONST	SEGMENT
??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2?5@ DB '-- WMI,'
	DB	' Connected to ROOT\CIMV2 WMI namespace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?48@
CONST	SEGMENT
??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?48@ DB '<'
	DB	'< WMI, Could not connect, 0x%.8x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2?$AA?$AA@ DB 'R'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '\', 00H, 'C', 00H, 'I', 00H
	DB	'M', 00H, 'V', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemLo@
CONST	SEGMENT
??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemLo@ DB '<< W'
	DB	'MI, Failed to create IWbemLocator object,0x%.8x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5sec@
CONST	SEGMENT
??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5sec@ DB '<< W'
	DB	'MI, Failed to initialize security, 0x%.8x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5COM@
CONST	SEGMENT
??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5COM@ DB '<< WM'
	DB	'I, Failed to initialize COM library, 0x%.8X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CAANICIM@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?5timeout?$AA@
CONST	SEGMENT
??_C@_0BJ@CAANICIM@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?5timeout?$AA@ DB '<< WMI'
	DB	', %s Mutex timeout', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex?$AA@
CONST	SEGMENT
??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex?$AA@ DB 'SysStatus_WMI_Mutex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MIMIOLHO@?$DM?$DM?5WMI?0?5Inv?5class?5name?$AA@
CONST	SEGMENT
??_C@_0BH@MIMIOLHO@?$DM?$DM?5WMI?0?5Inv?5class?5name?$AA@ DB '<< WMI, Inv'
	DB	' class name', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs?$AA@ DB '>> WMI, %s', 00H ; `string'
CONST	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_wmiClasses DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_07HMDPOHHF@Product?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0O@GLLHAKAI@ConfigOptions?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_05BOMFGPKE@Depth?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_06HCAKHJJK@Height?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_06ODJMJFLN@Weight?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_05IBAMDCFI@Width?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0N@CCJNCHMP@HostingBoard?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_09DADBKOHO@Removable?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0BI@NLNEBFOD@RequirementsDescription?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0BG@KNNEFNEE@RequiresDaughterBoard?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0L@NLNCHAIH@SlotLayout?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_0BE@DAJBDDHL@SpecialRequirements?$AA@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0O@PKGMNGNM@BatteryStatus?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0O@IKADLBCG@TimeOnBattery?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BB@HMDCOCCC@TimeToFullCharge?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BE@HNKJKBND@BatteryRechargeTime?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_09CAHFAGKL@Chemistry?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0P@IFPGNGPN@DesignCapacity?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0O@PBABLEFL@DesignVoltage?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BB@NPKJIND@EstimatedRunTime?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BE@NEEKJBPN@ExpectedBatteryLife?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0N@DDGBNILM@ExpectedLife?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BD@HADPLBCE@FullChargeCapacity?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BA@KENPOHHF@MaxRechargeTime?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0BE@IIEJDIAD@SmartBatteryVersion?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BE@DHLHFABD@BiosCharacteristics?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0M@JNJNMLGA@BIOSVersion?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0M@PIEABBJI@BuildNumber?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_07FOHBHJJA@CodeSet?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BA@LAFEEKJE@CurrentLanguage?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BD@IAKLNJOL@IdentificationCode?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BF@JGHHIKJK@InstallableLanguages?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BA@OPCNKLIC@ListOfLanguages?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0O@LMGDODCH@OtherTargetOS?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0M@PLCFCEDN@PrimaryBIOS?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0M@FEKFCCJH@ReleaseDate?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BC@GDJFCIN@SMBIOSBIOSVersion?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BD@GHLLPFOK@SMBIOSMajorVersion?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BD@NBGOPAJG@SMBIOSMinorVersion?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0O@BHMENNOL@SMBIOSPresent?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BC@MBHIKAHO@SoftwareElementID?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_0BF@GFDCFGAP@SoftwareElementState?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_06KNDINCOD@BusNum?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_07FFFMBEEK@BusType?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_05FHDOJGAA@Drive?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0L@PEPMOJNO@VolumeName?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BD@KNELKJMD@VolumeSerialNumber?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0P@HKGKOHLF@DriveIntegrity?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BA@KMBBNBII@FileSystemFlags?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BC@JDDJOAMF@FileSystemFlagsEx?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BH@GKGMNPDK@MaximumComponentLength?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0M@BKHKLNGH@MediaLoaded?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BJ@FCFAAAMD@MfrAssignedRevisionLevel?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0O@MEKHAACN@RevisionLevel?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_07IMFLOLAO@SCSIBus?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0BA@FGFDLPLK@SCSILogicalUnit?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_08IICBNDDA@SCSIPort?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@BGGJIJCI@SCSITargetId?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_04EBKMHHBE@Size?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
	DD	FLAT:??_C@_0N@GFEIEMMN@TransferRate?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_04HOKNCALA@Port?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0L@PGAIMACF@DMAChannel?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0M@HJPEAMBM@AddressSize?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_09LDKFCLB@BurstMode?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_08IOOBKHAJ@ByteMode?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0O@BPLPAGKN@ChannelTiming?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0BA@HBAKOKJE@MaxTransferSize?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0P@HFMGHLOP@TransferWidths?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_0M@MOIPDDOB@TypeCTiming?$AA@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
	DD	FLAT:??_C@_08HKOOHOAE@WordMode?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0M@PIEABBJI@BuildNumber?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_07FOHBHJJA@CodeSet?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_07DFGIDBBA@Control?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BG@IOIHNNJK@DeviceDescriptorBlock?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BD@IAKLNJOL@IdentificationCode?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BA@JOJBKDJN@LanguageEdition?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0O@LMGDODCH@OtherTargetOS?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_06CGGMGNDK@PM_API?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BB@CCKMONLJ@ServiceTableSize?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BC@MBHIKAHO@SoftwareElementID?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BF@GFDCFGAP@SoftwareElementState?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_0BG@LEBBIDOP@TargetOperatingSystem?$AA@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
	DD	FLAT:??_C@_07JENHGIOM@V86_API?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0O@PBOKHICP@ActiveCooling?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_08PPIOJEA@Hardware?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_09PKFILKGD@Shareable?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_0N@NCNNCPPP@TriggerLevel?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_0M@NKHMGHID@TriggerType?$AA@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
	DD	FLAT:??_C@_06BOOCMPNK@Vector?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_06KMHOJANB@Layout?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0BF@DODFNOHG@NumberOfFunctionKeys?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_08EOCJLAAL@IsLocked?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_08FJIAHGMM@Password?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0P@GCEIIPJN@PrimaryBusType?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0P@EJGNFGBG@RevisionNumber?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0BB@MKKJDBAN@SecondaryBusType?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0L@PMICFDLL@DeviceType?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_07DOAOMMKG@Enabled?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_09DADBKOHO@Removable?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_07LMLHFMEG@Service?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_09GPHNMGJN@ClassGuid?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0N@EEHHOFBP@CompatibleID?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0L@MCPBCGGP@HardwareID?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0N@HMDMLBLH@PointingType?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BA@EHILAMBM@NumberOfButtons?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BA@PLLFIHNG@DeviceInterface?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0N@OGCCLEJJ@HardwareType?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0L@DEGCDBKP@Handedness?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BF@FLDPHBAC@DoubleSpeedThreshold?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0M@LNGELFEC@InfFileName?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0L@KHOEHLLF@InfSection?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_08EOCJLAAL@IsLocked?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0BD@MJAHKLJJ@QuadSpeedThreshold?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0L@NEGJIGMA@SampleRate?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
	DD	FLAT:??_C@_05MKJLCFN@Synch?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0BM@OAEDMMAI@ExternalReferenceDesignator?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0BM@JBGCGAG@InternalReferenceDesignator?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_08BOPEOHEK@PortType?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0O@CPCPFFAH@ConnectorType?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0BA@KNNOFNF@ConnectorPinout?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource?$AA@
	DD	FLAT:??_C@_05NNNCCOHC@Alias?$AA@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0BA@PFCCEOEE@DefaultDataType?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0L@EAJLGPDF@DriverPath?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_08CKKAOMLK@FilePath?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0L@LKBOBDBI@ConfigFile?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_08JFJMIJHO@DataFile?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0M@PJPGFADP@MonitorName?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0BC@MLDLGMGB@SupportedPlatform?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_07JFPHJDHA@InfName?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_08GLFJHHAH@HelpFile?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0P@NBBGILI@DependentFiles?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_06ENMIEFDD@OEMUrl?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_07LCDJNPHI@Started?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_09IAGOJBFI@StartMode?$AA@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@MDJPNJNL@Architecture?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0O@FFCOPHIP@NumberOfCores?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0O@MJOHKFKO@MaxClockSpeed?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_06BOFMEHLD@Family?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@DJKFFMLN@L2CacheSize?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@NBPCHGPE@L2CacheSpeed?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@PICLIDHN@L3CacheSize?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@EKFHDKJL@L3CacheSpeed?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@IPOPOCBB@AddressWidth?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_09OJECCCEO@CpuStatus?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BC@JFANJPME@CurrentClockSpeed?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0P@IHAGOHLC@CurrentVoltage?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_09KNGBBIL@DataWidth?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_08JALCBBMK@ExtClock?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_05KOHFLOFG@Level?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0P@HLLBIGKP@LoadPercentage?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BH@LLAHKBOJ@OtherFamilyDescription?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@DHKOOBFD@ProcessorId?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0O@DAODMABE@ProcessorType?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_08DNLDHPFP@Revision?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_04EBAMNOLK@Role?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0BC@GCIFEBIL@SocketDesignation?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_08HPJGCEAH@Stepping?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_08HJBCPKNB@UniqueId?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0O@KHACBBMN@UpgradeMethod?$AA@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
	DD	FLAT:??_C@_0M@DEJHGOJI@VoltageCaps?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0L@DJBCKAGE@DriverName?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BA@BJODOJJC@HardwareVersion?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BD@LPBNFPJD@ControllerTimeouts?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_09DJCHLIFB@DeviceMap?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_05FNNGFGLF@Index?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0N@OLJPFNHL@MaxDataWidth?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BA@IDEAMGMB@MaxTransferRate?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BF@OGNJDJGP@ProtectionManagement?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0M@BFAJGJNN@MaxBaudRate?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0N@KFNBCBNP@ProviderType?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_06JCOMDNII@Binary?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BH@PKAPBGLB@MaximumInputBufferSize?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BI@EAKFLPF@MaximumOutputBufferSize?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BB@NCMHEECO@OSAutoDiscovered?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BB@CCEBCKAP@SettableBaudRate?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BB@BOCNMDDI@SettableDataBits?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BE@FMKJPGFK@SettableFlowControl?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0P@MOHECAJ@SettableParity?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BE@NMPLPPIE@SettableParityCheck?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0N@OBGEBGNG@SettableRLSD?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BB@EPIEMKMF@SettableStopBits?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BC@EEEMKCBH@Supports16BitMode?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0P@GODDIGIP@SupportsDTRDSR?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BI@LJLLOLPH@SupportsElapsedTimeouts?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BE@JOEIKOLI@SupportsIntTimeouts?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BE@JCPAAGPO@SupportsParityCheck?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0N@GBIJPBEE@SupportsRLSD?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0P@NGNOBJLG@SupportsRTSCTS?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BK@GGENNCGN@SupportsSpecialCharacters?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BA@OPAGJFHI@SupportsXOnXOff?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BD@GDEAPHBI@SupportsXOnXOffSet?$AA@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_08FCNNIBJG@BaudRate?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0M@PAFDOFKP@BitsPerByte?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_06OKNHBMNM@Parity?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_08DPBIGBFM@StopBits?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_06OICOCAHF@IsBusy?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BG@DFLLPBBO@AbortReadWriteOnError?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BC@OGEDEEBA@BinaryModeEnabled?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BD@MCBMPIAJ@ContinueXMitOnXOff?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BC@BMKJGEMK@CTSOutflowControl?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BB@LNMOOKGE@DiscardNULLBytes?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BC@HDHNIDHE@DSROutflowControl?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0P@FDLAEJMA@DSRSensitivity?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BD@HKACMHPL@DTRFlowControlType?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0N@HDNBGKMG@EOFCharacter?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BG@HECEEKCN@ErrorReplaceCharacter?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BI@MDNCEDD@ErrorReplacementEnabled?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0P@ELDMBJ@EventCharacter?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BD@KACACAPH@ParityCheckEnabled?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BD@HDDKDMKB@RTSFlowControlType?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0O@IABHIILA@XOffCharacter?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BC@PIOKAKHD@XOffXMitThreshold?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0N@LMKFMCPA@XOnCharacter?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BB@OHGPOKOF@XOnXMitThreshold?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BF@FMELJHC@XOnXOffInFlowControl?$AA@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
	DD	FLAT:??_C@_0BG@LCMFOHKE@XOnXOffOutFlowControl?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0M@MNPNDAHP@ProductName?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0O@GILLNKKD@MPU401Address?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0O@GHJKPLAG@DMABufferSize?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BE@FEOPMOOE@CurrentBitsPerPixel?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BM@OFHJCNEB@CurrentHorizontalResolution?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BK@LFIAOAGD@CurrentVerticalResolution?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BG@NCBMILGB@CurrentNumberOfColors?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BD@JKLPINND@CurrentRefreshRate?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BA@CDIHNLEF@CurrentScanMode?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BH@IKBJPLJ@CurrentNumberOfColumns?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BE@BKBIMFEG@CurrentNumberOfRows?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BC@GFHBBCIN@VideoArchitecture?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BA@COFLHODM@VideoMemoryType?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_09LIEAKBEG@VideoMode?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BF@MAGAOPPB@VideoModeDescription?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0P@OMEGAAG@VideoProcessor?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BC@PEHKLIOA@ColorTableEntries?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BF@JCFFEIIM@NumberOfColorPlanes?$DL?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BD@DECAKEGH@NumberOfVideoPages?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BF@FKKNOPFN@SystemPaletteEntries?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BI@DFJMJFBI@AcceleratorCapabilities?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BF@LPCADEJI@AdapterCompatibility?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0P@MPKKGADB@AdapterDACType?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0L@CKHNOAKJ@AdapterRAM?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0M@HMKFJKEG@InfFilename?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0L@KHOEHLLF@InfSection?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0O@KKIKAADI@DriverVersion?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BD@HBMCPLLH@DeviceSpecificPens?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0L@HJOBJMDE@DitherType?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0L@GAFFCADK@DriverDate?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_09MBIABGHL@ICMIntent?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_09OGGCGCBA@ICMMethod?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BI@NCJGCGIA@InstalledDisplayDrivers?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BD@KFJBBNPN@MaxMemorySupported?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0P@DHIEOPKP@MaxRefreshRate?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0P@BADPIIJO@MinRefreshRate?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0L@NCAJOFAD@Monochrome?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BN@FJFLBOEO@ReservedSystemPaletteEntries?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BF@HGGDLIIF@SpecificationVersion?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0L@BLANPANH@Partitions?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_04EBKMHHBE@Size?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_09GDNFOKKF@Signature?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0P@MMMIFHLL@BytesPerSector?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BB@HMBACBBL@FirmwareRevision?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_05FNNGFGLF@Index?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0O@IHENGMAG@InterfaceType?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0M@BKHKLNGH@MediaLoaded?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_07IMFLOLAO@SCSIBus?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BA@FGFDLPLK@SCSILogicalUnit?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_08IICBNDDA@SCSIPort?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@BGGJIJCI@SCSITargetId?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BA@CCMKCJPC@SectorsPerTrack?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0P@NEMACPGO@TotalCylinders?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0L@PLGEACLG@TotalHeads?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0N@BJMAPGKO@TotalSectors?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0M@BHKEFGGG@TotalTracks?$AA@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
	DD	FLAT:??_C@_0BC@KOKBEBBE@TracksPerCylinder?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_04EBKMHHBE@Size?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_04KOACHJEN@Type?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_08GBCOMNMP@Bootable?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0O@GKABHDFN@BootPartition?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BB@GMPNKCND@PrimaryPartition?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_06IOEANFCI@Access?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0O@NMDEFEE@HiddenSectors?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0BB@CLPKNLNO@RewritePartition?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0P@HEMAHOJD@StartingOffset?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0BB@GANKFIKA@MediaDescription?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0BC@FNAKMFAB@CreationClassName?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_09DADBKOHO@Removable?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_08PINBMPEF@Capacity?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0P@CNPPDDMA@WriteProtectOn?$AA@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
	DD	FLAT:??_C@_0N@NINPCONM@CleanerMedia?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_02HOGEDOAB@Id?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0M@COKFBABJ@Compression?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_03NLPJKHLD@ECC?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BD@IDPNAMKG@EOTWarningZoneSize?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@PNICBLFI@FeaturesHigh?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0M@GCKGDCME@FeaturesLow?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BC@NKLHGLCM@MaxPartitionCount?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_07DDDGKLAD@Padding?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0P@OCFCAPCK@ReportSetMarks?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_06IOEANFCI@Access?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0O@BJAAJMNJ@Associativity?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0L@GKCEABFB@CacheSpeed?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_09LDLPEFB@CacheType?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0N@FNMLGPI@MaxCacheSize?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0M@JJECGOOK@CurrentSRAM?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BB@OEAEPHLK@ErrorCorrectType?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0L@NIIIAJJG@FlushTimer?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0O@BJDNNDOA@InstalledSize?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_05KOHFLOFG@Level?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_08BFDFHGHF@LineSize?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_08KDOEBHGA@Location?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0L@OICKBPFP@ReadPolicy?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BC@CACAEAGO@ReplacementPolicy?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0O@LOONNFKJ@SupportedSRAM?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress?$AA@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
	DD	FLAT:??_C@_0M@GMGLDKG@WritePolicy?$AA@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress?$AA@
	DD	FLAT:??_C@_0L@NKIIONIP@MemoryType?$AA@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_06IOEANFCI@Access?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BB@CCADGENH@ErrorGranularity?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_06IOEANFCI@Access?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BB@CCADGENH@ErrorGranularity?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_09ELEBPJGH@BankLabel?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_08PINBMPEF@Capacity?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_09KNGBBIL@DataWidth?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0O@DKGGAIKL@DeviceLocator?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0L@JPOMKNPI@FormFactor?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0BE@GAJMAAIE@InterleaveDataDepth?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0BD@OOBFBMPB@InterleavePosition?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0L@NKIIONIP@MemoryType?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0O@MJAFBIEI@PositionInRow?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_09DADBKOHO@Removable?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_05HOIAGEJD@Speed?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0L@EONKMHCB@TotalWidth?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_0L@NHBAOOAD@TypeDetail?$AA@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0O@EOCLGIEK@MemoryDevices?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_05BOMFGPKE@Depth?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_06HCAKHJJK@Height?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_05IBAMDCFI@Width?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_06ODJMJFLN@Weight?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_08KDOEBHGA@Location?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0M@LPAFCHAO@MaxCapacity?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0BG@BDKPEMKD@MemoryErrorCorrection?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_09DADBKOHO@Removable?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
	DD	FLAT:??_C@_03GMFFJGJI@Use?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_06IOEANFCI@Access?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress?$AA@
	DD	FLAT:??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@GEHHDFHH@SystemType?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BD@KEFEPCEP@NumberOfProcessors?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_08KAFEAHEM@UserName?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BE@BPKIAGEB@AdminPasswordStatus?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BJ@GMKDMOMC@AutomaticManagedPagefile?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BJ@CCCKPNOE@AutomaticResetBootOption?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BJ@HFJMLPDD@AutomaticResetCapability?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BC@LOIFGJNH@BootOptionOnLimit?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BF@NHNHHNLM@BootOptionOnWatchDog?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BB@KCAGDBFG@BootROMSupported?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0M@FAIFADKE@BootupState?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BD@NPOFELCJ@ChassisBootupState?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BA@KEBGPOLH@CurrentTimeZone?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BB@PNOOHJBN@DaylightInEffect?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0M@HMDMJNAL@DNSHostName?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_06HFDFFJHI@Domain?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@DHGJAMBB@DomainRole?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BK@DMLHGPE@EnableDaylightSavingsTime?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BG@OFHEPCGG@FrontPanelResetStatus?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BC@MOGIEFCC@InfraredSupported?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BA@FHFMLOBH@InitialLoadInfo?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BH@NPMFKEOG@KeyboardPasswordStatus?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0N@FDMFJCLB@LastLoadInfo?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@INCFKHMA@NameFormat?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BJ@OJMPPEPI@NetworkServerModeEnabled?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0O@KFCLFAME@OEMLogoBitmap?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0P@DEDOEGFN@OEMStringArray?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0N@BDBDHMKI@PartOfDomain?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BA@BAAGJACJ@PauseAfterReset?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0N@EOPDJAGI@PCSystemType?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BG@MGBDJIM@PowerOnPasswordStatus?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@PFLEPOFF@PowerState?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BB@PGEJAGBJ@PowerSupplyState?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BE@GNDJOKHP@PrimaryOwnerContact?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BB@CIHLIHGG@PrimaryOwnerName?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BA@JGMMLHGF@ResetCapability?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@NDDNCBN@ResetCount?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@ODMHPMJN@ResetLimit?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_05CPOHHMHJ@Roles?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BK@GHHBNFKI@SupportContactDescription?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BD@MJBJDOPG@SystemStartupDelay?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BF@HNHDCNN@SystemStartupOptions?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BF@IKJAHOGK@SystemStartupSetting?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0N@HHACICKK@ThermalState?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0BE@LPDNMOEG@TotalPhysicalMemory?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_0L@FAPFOCCC@WakeUpType?$AA@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
	DD	FLAT:??_C@_09CLAAHCGK@Workgroup?$AA@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
	DD	FLAT:??_C@_06LGGLFMPE@Vendor?$AA@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
	DD	FLAT:??_C@_04NOKDILIH@UUID?$AA@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
	DD	FLAT:??_C@_0BC@IBEJLMDM@IdentifyingNumber?$AA@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
	DD	FLAT:??_C@_09ODBEMGCH@SKUNumber?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_09IHHILKBJ@ProductID?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_06LGGLFMPE@Vendor?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0P@CAOEPKFE@AssignmentType?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0BC@IBEJLMDM@IdentifyingNumber?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0BA@DLLPKNMD@InstallLocation?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0N@FNHIHJOE@InstallState?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_08LMOOJGEG@HelpLink?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0O@PPCFOOHH@HelpTelephone?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0O@GCCHCBIO@InstallSource?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_08BENDAOKD@Language?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0N@ONDNCIN@LocalPackage?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0N@LIDMIFHK@PackageCache?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0M@OMMGPPBL@PackageCode?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0M@PLFIHHBG@PackageName?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_08KOFIEIPM@RegOwner?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0L@BDBMLIBF@RegCompany?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_09ODBEMGCH@SKUNumber?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0L@LNLOEOEC@Transforms?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0N@CIJCJNDA@URLInfoAbout?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_0O@FDAGMPND@URLUpdateInfo?$AA@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product?$AA@
	DD	FLAT:??_C@_09JCLOCIPO@WordCount?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_08GFKGEEBB@HotFixID?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_0M@NMGHOPGA@InstalledBy?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_0M@NBDMPIKF@InstalledOn?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_0M@PIGNGIJB@FixComments?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_0BE@FBEKBLIJ@ServicePackInEffect?$AA@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0O@PBOKHICP@ActiveCooling?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry?$AA@
	DD	FLAT:??_C@_0M@MLALLFJB@CurrentSize?$AA@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry?$AA@
	DD	FLAT:??_C@_0M@JHEHBNHB@MaximumSize?$AA@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry?$AA@
	DD	FLAT:??_C@_0N@JHIKPPPP@ProposedSize?$AA@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_03OMFNLMOB@SID?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_06HFDFFJHI@Domain?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_0N@FPKOIMIG@LocalAccount?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_07JDPBNNMM@SIDType?$AA@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0M@MLHPPPJP@DisplayName?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_08LHLJMCNC@PathName?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0M@MEIJGDEJ@AcceptPause?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0L@MPAKMMDG@AcceptStop?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0BA@DKLNMHH@DesktopInteract?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0N@GPBKMKLE@ErrorControl?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_08FHJJFIAP@ExitCode?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_0M@CFFFGGEC@ServiceType?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_07LCDJNPHI@Started?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_09IAGOJBFI@StartMode?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_09CIMAKHDE@StartName?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_05JNKNAC@State?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
	DD	FLAT:??_C@_05KFFLJNBG@TagId?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0N@MLFAOMIG@ChassisTypes?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_05BOMFGPKE@Depth?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_06HCAKHJJK@Height?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_05IBAMDCFI@Width?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_06ODJMJFLN@Weight?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0N@FBKDMIBE@AudibleAlarm?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BC@OICCILBJ@BreachDescription?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BI@OIOFCGCN@CableManagementStrategy?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BK@DMAHAAAM@CurrentRequiredOrProduced?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0P@FPMIANAI@HeatGeneration?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0M@FLPBGKMO@LockPresent?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BD@BOLIJOBH@NumberOfPowerCords?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_09DADBKOHO@Removable?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0P@IFAJDLJO@SecurityBreach?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0P@LBCDFKMM@SecurityStatus?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BE@CDEDGENH@ServiceDescriptions?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BC@MJACHPAA@ServicePhilosophy?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0P@GDBINLPP@SMBIOSAssetTag?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0BB@EPPDMJMG@TypeDescriptions?$AA@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
	DD	FLAT:??_C@_0N@BGAIBJKD@VisibleAlarm?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_03PJHNOEGB@Tag?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BA@JKMEMADA@SlotDesignation?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0O@CPCPFFAH@ConnectorType?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_05NFIJOKEG@Model?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BA@KNNOFNF@ConnectorPinout?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0N@OHNMFPEL@CurrentUsage?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0O@JIADPBNP@HeightAllowed?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0O@ICFBEHEI@LengthAllowed?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0N@OLJPFNHL@MaxDataWidth?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_09KGLBDKHB@PMESignal?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BD@MJCDBDLK@PurposeDescription?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_06LOOAMPBO@Shared?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_03LMAAELJP@SKU?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0P@MHGKENBB@SpecialPurpose?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BA@HLMBNLEL@SupportsHotPlug?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0O@OPICFFNJ@ThermalRating?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BH@BMAHGALK@VccMixedVoltageSupport?$AA@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
	DD	FLAT:??_C@_0BH@LMHCBHLE@VppMixedVoltageSupport?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0M@MNPNDAHP@ProductName?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0L@MLCHOGMM@MACAddress?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BA@PKOOKBHK@PhysicalAdapter?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0M@IOFGKGDC@ServiceName?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BA@FMEGGBNH@NetConnectionID?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BE@OHJLPIPO@NetConnectionStatus?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_05HOIAGEJD@Speed?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_08MFFAALKH@MaxSpeed?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_04MEIDEPGF@GUID?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BB@HCIBJPII@NetworkAddresses?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BB@CPOCLJND@PermanentAddress?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0M@CBMGKKGD@AdapterType?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0O@JDINGPBK@AdapterTypeID?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_09MMNBJFFE@AutoSense?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_09HBJECKPO@Installed?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0P@LMPBIBLI@InterfaceIndex?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0L@COBEMNCH@NetEnabled?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0L@MLCHOGMM@MACAddress?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_09NIGMFFPO@IPAddress?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0L@BJOKJMLN@DHCPServer?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BB@HACNIBBH@DefaultIPGateway?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_09FBHLGFBK@DNSDomain?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0M@HMDMJNAL@DNSHostName?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_08EKHHNDLH@IPSubnet?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0M@IOFGKGDC@ServiceName?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BF@NNMMFFI@ArpAlwaysSourceRoute?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BA@DHDIOMKI@ArpUseEtherSNAP?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0N@OAKOAPMO@DatabasePath?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@GOBIIDKA@DeadGWDetectEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0L@JFBEJJHM@DefaultTOS?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0L@EIDNNLHD@DefaultTTL?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0M@HIMIFMFA@DHCPEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BB@BOGKHOEE@DHCPLeaseExpires?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BC@MIONLOAH@DHCPLeaseObtained?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BL@NEHFNDKH@DNSDomainSuffixSearchOrder?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BM@LEBEBEIJ@DNSEnabledForWINSResolution?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BF@CIMMNJEP@DNSServerSearchOrder?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BN@OACMHJBD@DomainDNSRegistrationEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@GGFBGHJP@ForwardBufferMemory?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BL@EIIPDLGE@FullDNSRegistrationEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BC@JPOLFPNM@GatewayCostMetric?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_09LFCMALKM@IGMPLevel?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0P@LMPBIBLI@InterfaceIndex?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BD@KDBLHBOO@IPConnectionMetric?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_09KIFLBGKF@IPEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BI@LBDHONDJ@IPFilterSecurityEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BG@IJANIIKC@IPPortSecurityEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BH@HHIPIHMF@IPSecPermitIPProtocols?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@JOIOPHFJ@IPSecPermitTCPPorts?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@IDDAOKAD@IPSecPermitUDPPorts?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BD@EFBIPBIB@IPUseZeroBroadcast?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0L@JNAHKDDE@IPXAddress?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0L@ONDAOAGP@IPXEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0N@EAKCLKKB@IPXFrameType?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0N@FHNNAGIP@IPXMediaType?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BB@HFHJDNKD@IPXNetworkNumber?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@KIGHGIHN@IPXVirtualNetNumber?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BC@HLLJNCGL@KeepAliveInterval?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0O@HNPIKCNH@KeepAliveTime?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_03BLLMIPHO@MTU?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BC@CHJCENM@NumForwardPackets?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BF@DPKIODPI@PMTUBHDetectEnabled?$DL?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BF@KBFAFCNG@PMTUDiscoveryEnabled?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@MJKNHDFN@TcpipNetbiosOptions?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BN@NBAJINBE@TcpMaxConnectRetransmissions?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BK@ICGANMDC@TcpMaxDataRetransmissions?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BC@CEGEJAFC@TcpNumConnections?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BL@JOFENPLC@TcpUseRFC1122UrgentPointer?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0O@CIEPJIDD@TcpWindowSize?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BI@MIGGLKDO@WINSEnableLMHostsLookup?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BD@POPKKJKC@WINSHostLookupFile?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BC@BECMMLFM@WINSPrimaryServer?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0M@CMEBCDLL@WINSScopeID?$AA@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
	DD	FLAT:??_C@_0BE@CHHDIDN@WINSSecondaryServer?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_08FPDCFGEH@FullName?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0O@PKMMPAKN@HomeDirectory?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0BD@GBDEODMP@HomeDirectoryDrive?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0M@NDLIHBHJ@LogonServer?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_06HAPGBBDI@UserId?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_08LFHMHDM@UserType?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0M@KEGPAPIK@UserComment?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0P@FLJOKOM@AccountExpires?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0BD@JGGENGAP@AuthorizationFlags?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0BB@OBONNEPA@BadPasswordCount?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_08BHOPBADB@Caption?$DL?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_08DOHJINHB@CodePage?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_07JABLCLAF@Comment?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0M@NALIBBDH@CountryCode?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_05BOOEKJH@Flags?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0L@NKJIFPDG@LastLogoff?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_09JEOPKIAO@LastLogon?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0L@HFGJFNDM@LogonHours?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0P@BDLNENEK@MaximumStorage?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0P@FMELCCCP@NumberOfLogons?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0L@PBGCNDPG@Parameters?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0M@HKNCEPDC@PasswordAge?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0BA@HLOHOKEI@PasswordExpires?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0P@CIBDNLPH@PrimaryGroupId?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0L@FILALLBE@Privileges?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_07EELFDIBP@Profile?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0L@GHILPLPE@ScriptPath?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0N@LMMEGDEF@UnitsPerWeek?$AA@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
	DD	FLAT:??_C@_0N@LMIHDJBC@Workstations?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BG@IODJFDPJ@ConnectionlessService?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BD@ECGOALCK@GuaranteesDelivery?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BF@FAHCIDLD@GuaranteesSequencing?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BD@FFCOFDOJ@MaximumAddressSize?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BD@IBPHBINL@MaximumMessageSize?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BA@NLEIFDG@MessageOriented?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BD@PCBKNDJA@MinimumAddressSize?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BF@DJOBDJFP@PseudoStreamOriented?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BF@ONDNBOBK@SupportsBroadcasting?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BE@OAOGNDFG@SupportsConnectData?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BH@KMFDMCNH@SupportsDisconnectData?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BD@BJHEFNDH@SupportsEncryption?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BG@MJFBKLBP@SupportsExpeditedData?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BH@PFGLDBHN@SupportsFragmentation?$DL?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BI@FGBPBAKA@SupportsGracefulClosing?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BM@MDHHIPIM@SupportsGuaranteedBandwidth?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BF@BHPPOJFK@SupportsMulticasting?$AA@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
	DD	FLAT:??_C@_0BJ@MNHPDIFA@SupportsQualityofService?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_08BHIEONMC@FileSize?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_08PICKODJL@FileType?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0L@OHPKPJND@AccessMask?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_07CNOHFBBG@Archive?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0L@FBPJPEIN@Compressed?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0N@GPGLEEKJ@CreationDate?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_09KLPLELGE@Encrypted?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0BB@CPNPJAMG@EncryptionMethod?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_06PDIOKLEE@FSName?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_05MBDCODDP@Group?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_06FHBILLDG@Hidden?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0L@PCJCDOJK@InUseCount?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0N@BLGOKNC@LastAccessed?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0N@JFOMFNHF@LastModified?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_08PMHOKLA@Readable?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_06JIODDOFH@System?$AA@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
	DD	FLAT:??_C@_09HKGIPMHJ@Writeable?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_0M@MNPNDAHP@ProductName?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_06LGGLFMPE@Vendor?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_0BC@IBEJLMDM@IdentifyingNumber?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_08OBOKCFEP@Accesses?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_0L@PLFFHFAH@Attributes?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_0N@FNHIHJOE@InstallState?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_07PKCEDPHO@LastUse?$AA@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0M@MLHPPPJP@DisplayName?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_08LHLJMCNC@PathName?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0M@CFFFGGEC@ServiceType?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_09IAGOJBFI@StartMode?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_05JNKNAC@State?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0N@GPBKMKLE@ErrorControl?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_07LCDJNPHI@Started?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0M@MEIJGDEJ@AcceptPause?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0L@MPAKMMDG@AcceptStop?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0BA@DKLNMHH@DesktopInteract?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_08FHJJFIAP@ExitCode?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_09CIMAKHDE@StartName?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
	DD	FLAT:??_C@_05KFFLJNBG@TagId?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_0O@KLLIKPKC@BootDirectory?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_0BC@BJLIMIEA@ConfigurationPath?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_09PABAEPFH@LastDrive?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_0BB@FHBPINGK@ScratchDirectory?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
	DD	FLAT:??_C@_0O@FDHFFDED@TempDirectory?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0M@EEKAPENF@BorderWidth?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0L@GMHAONPD@CoolSwitch?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BA@NKDGIFD@CursorBlinkRate?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BA@CNEMFCKH@DragFullWindows?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BA@MJNOPNAD@GridGranularity?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0M@FALLBHKM@IconSpacing?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BC@HAAMKFAI@IconTitleFaceName?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0O@COINDPHH@IconTitleSize?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0O@HLNDODKM@IconTitleWrap?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_07NOCIGAPP@Pattern?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BC@KENIIHPI@ScreenSaverActive?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BG@OPEGFPLM@ScreenSaverExecutable?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BC@ENMGOCGL@ScreenSaverSecure?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BD@LIKEHLGN@ScreenSaverTimeout?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_09FAKNONCF@Wallpaper?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0BD@MNOICNPG@WallpaperStretched?$AA@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
	DD	FLAT:??_C@_0P@HLGPBKPI@WallpaperTiled?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0N@EJILFHEF@ScreenHeight?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0M@GOACCFHI@ScreenWidth?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BG@JHIHGKIO@PixelsPerXLogicalInch?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BG@EKBBLDAL@PixelsPerYLogicalInch?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BE@EAJFLPNK@MonitorManufacturer?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0M@FCPFJAEP@MonitorType?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_09LPCHGGLO@Bandwidth?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0M@GAHMDPOP@DisplayType?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_08EOCJLAAL@IsLocked?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0O@PBOKHICP@ActiveCooling?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0N@HOGGFFKF@DesiredSpeed?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan?$AA@
	DD	FLAT:??_C@_0O@ODMHJIAL@VariableSpeed?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0P@NOCBMKBI@OSArchitecture?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0M@PIEABBJI@BuildNumber?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_09LLAGGHGM@BuildType?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0L@EGALIDNG@CSDVersion?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BI@MCMKKPJH@ServicePackMajorVersion?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BI@HEBPKKOL@ServicePackMinorVersion?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0P@HNONGDKL@OSProductSuite?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_06MNBFCOOH@OSType?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0N@MHPBIIPD@Organization?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0P@DAFCPCAO@RegisteredUser?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0M@GGPOPAAP@ProductType?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0L@BLKKOICB@BootDevice?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0N@LCIKLBMI@SystemDevice?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0M@JBPIDKPO@SystemDrive?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BA@FNJMICPB@SystemDirectory?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BB@IEJHMEDK@WindowsDirectory?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_07FOHBHJJA@CodeSet?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0M@NALIBBDH@CountryCode?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0L@IOMOHLID@OSLanguage?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BA@KEBGPOLH@CurrentTimeZone?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0CC@LDMHMPMB@DataExecutionPrevention_Availabl@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0CK@PHHDEHCB@DataExecutionPrevention_32BitApp@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0CA@KCIFHCEN@DataExecutionPrevention_Drivers?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0CG@FOLHLACL@DataExecutionPrevention_SupportP@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_05GCIPIGEI@Debug?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0M@DGCHPHG@Distributed?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BA@LIJDDPMD@EncryptionLevel?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BL@LKLGBOHP@ForegroundApplicationBoost?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BD@KJPLACJD@FreePhysicalMemory?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BH@GDCHGEBO@FreeSpaceInPagingFiles?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BC@HEKPKJCK@FreeVirtualMemory?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BB@GLODIIPC@LargeSystemCache?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0P@DKHNBJBB@LastBootUpTime?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0O@GFNPHCJN@LocalDateTime?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_06BMNFLCFO@Locale?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BF@BJJFAIPL@MaxNumberOfProcesses?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BF@OEEDDGBK@MaxProcessMemorySize?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0N@FEFLNODO@MUILanguages?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BG@MGHJNMGE@NumberOfLicensedUsers?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BC@FILGLGHH@NumberOfProcesses?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0O@PBBGLGFJ@NumberOfUsers?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BD@GLJCNHGP@OperatingSystemSKU?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BF@KAMHDIPP@OtherTypeDescription?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0L@KNGIFFNB@PAEEnabled?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0O@NNCCMBIG@PlusProductID?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BC@LMIHOAGL@PlusVersionNumber?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_07NAEHBBNL@Primary?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BI@BKJHEEOL@SizeStoredInPagingFiles?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_09IIJPJFOC@SuiteMask?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BD@PBNAJGBH@TotalSwapSpaceSize?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BH@IBKKELEK@TotalVirtualMemorySize?$AA@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
	DD	FLAT:??_C@_0BH@EOFEPLNL@TotalVisibleMemorySize?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_08BHIEONMC@FileSize?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_09LCEICGML@FreeSpace?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_08PICKODJL@FileType?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_06PDIOKLEE@FSName?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0L@OHPKPJND@AccessMask?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_07CNOHFBBG@Archive?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0L@FBPJPEIN@Compressed?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0N@GPGLEEKJ@CreationDate?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_09KLPLELGE@Encrypted?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0BB@CPNPJAMG@EncryptionMethod?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_06FHBILLDG@Hidden?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0M@EONNPILK@InitialSize?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0L@PCJCDOJK@InUseCount?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0N@BLGOKNC@LastAccessed?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0N@JFOMFNHF@LastModified?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_0M@JHEHBNHB@MaximumSize?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_08PMHOKLA@Readable?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_06JIODDOFH@System?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_07NGFJPNPN@Version?$AA@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile?$AA@
	DD	FLAT:??_C@_09HKGIPMHJ@Writeable?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0L@LICOLOBE@DMASupport?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BB@NCMHEECO@OSAutoDiscovered?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset?$AA@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
	DD	FLAT:??_C@_0BA@LEMEMCNN@ProxyPortNumber?$AA@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
	DD	FLAT:??_C@_0M@BCMAAPLG@ProxyServer?$AA@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
	DD	FLAT:??_C@_0L@FFDIDHBB@ServerName?$AA@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_04HMIIHGGM@Path?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_0P@IBLGFEE@MaximumAllowed?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_0N@PEAHLPLG@AllowMaximum?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share?$AA@
	DD	FLAT:??_C@_04KOACHJEN@Type?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_09IHHILKBJ@ProductID?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_0BD@HINAAJAB@ActivationRequired?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_0BB@FFPKNIIL@IsNotificationOn?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_0BK@MHMKFBPN@RemainingEvaluationPeriod?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_0BF@GDCPFLAD@RemainingGracePeriod?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_0L@FFDIDHBB@ServerName?$AA@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BK@HACJICBD@ASPScriptDefaultNamespace?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BB@HHJGCMCA@ASPScriptEnabled?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BA@FCAEOBFB@AutorecoverMofs?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0P@LBFHKJDL@AutoStartWin9X?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0P@HCBDPJED@BackupInterval?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0P@HCKKJOFA@BackupLastTime?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0N@DMPKCKPJ@BuildVersion?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BC@PJAEIMII@DatabaseDirectory?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BA@GMIIIOHB@DatabaseMaxSize?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BL@FLALGEND@EnableAnonWin9xConnections?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0N@OBNHEDLP@EnableEvents?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BP@DHLDKHJI@EnableStartupHeapPreallocation?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BN@FBHHPGGC@HighThresholdOnClientObjects?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BG@LKICGCBK@HighThresholdOnEvents?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BG@MDEOBFAH@InstallationDirectory?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BN@GKEEMEKI@LastStartupHeapPreallocation?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BB@FALFKNPE@LoggingDirectory?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0N@FMFGOJPB@LoggingLevel?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BM@NGNJMOHJ@LowThresholdOnClientObjects?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BF@PHEPMKDN@LowThresholdOnEvents?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0P@CEPALFMK@MaxLogFileSize?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BH@PBKELOKA@MaxWaitOnClientObjects?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BA@NHHFPHIJ@MaxWaitOnEvents?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_0BI@NOBDNJPM@MofSelfInstallDirectory?$AA@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0BA@FLFAPDFG@ConnectionState?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0P@LNPCDAPC@ConnectionType?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0M@GAHMDPOP@DisplayType?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0L@CCMICFHJ@RemotePath?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_08KAFEAHEM@UserName?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0L@OHPKPJND@AccessMask?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_07JABLCLAF@Comment?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_09CLGGKACF@LocalName?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0L@FLEBOKCI@RemoteName?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0L@LNKKEMJM@Persistent?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0N@ONCOBKP@ProviderName?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_05IEIONIFO@Label?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0M@EHMJIHII@DriveLetter?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_08PINBMPEF@Capacity?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_09LCEICGML@FreeSpace?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_09NKILGKMH@DriveType?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0L@FPFLHALM@FileSystem?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_06IOEANFCI@Access?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_09HICOCIIF@Automount?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0L@FBPJPEIN@Compressed?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0M@FMPADJNN@DirtyBitSet?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BA@JDIBBDEO@IndexingEnabled?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BG@ELFKDNP@MaximumFileNameLength?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0O@HEHOMNCC@QuotasEnabled?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BB@MPFPEDFA@QuotasIncomplete?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BB@JJBCJECG@QuotasRebuilding?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BD@BJDMHPHA@SupportsDiskQuotas?$AA@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
	DD	FLAT:??_C@_0BN@DMMADKEM@SupportsFileBasedCompression?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@CKOOLAI@AvgDiskQueueLength?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@LLDDCMMH@AvgDiskSecPerRead?$DL?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BH@CFGDHLM@CurrentDiskQueueLength?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BA@BBEHMIEJ@DiskBytesPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BE@IJJNINGL@DiskReadBytesPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BA@GPEPCNFG@DiskReadsPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BE@INHPJNPE@DiskTransfersPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BB@FFLCGPKG@DiskWritesPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BE@KMHMAHCP@PercentDiskReadTime?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BA@HPDMAPLN@PercentDiskTime?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BF@CHKOMNLI@PercentDiskTime_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BF@DOKCNDOL@PercentDiskWriteTime?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BA@LOOKHAGM@PercentIdleTime?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BF@PLICIEBG@PercentIdleTime_Base?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0O@JFLPIICD@SplitIOPerSec?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0O@EJBHEMAA@FreeMegabytes?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BD@CKOOLAI@AvgDiskQueueLength?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BC@IJGACNJB@AvgDiskSecPerRead?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BH@CFGDHLM@CurrentDiskQueueLength?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BA@BBEHMIEJ@DiskBytesPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BE@IJJNINGL@DiskReadBytesPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BA@GPEPCNFG@DiskReadsPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BE@INHPJNPE@DiskTransfersPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BB@FFLCGPKG@DiskWritesPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BE@KMHMAHCP@PercentDiskReadTime?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BA@HPDMAPLN@PercentDiskTime?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BF@CHKOMNLI@PercentDiskTime_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BF@DOKCNDOL@PercentDiskWriteTime?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BB@FDAACFPN@PercentFreeSpace?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BG@KEJCKNPB@PercentFreeSpace_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BA@LOOKHAGM@PercentIdleTime?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BF@PLICIEBG@PercentIdleTime_Base?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0O@JFLPIICD@SplitIOPerSec?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logic@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BE@IEAMAKJB@BytesReceivedPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BH@GKKKHEEC@BytesTransmittedPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BB@NADCFLBJ@BytesTotalPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0O@GPMHHPHG@PacketsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BG@PFNBEMLM@PacketsReceivedPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BJ@EHOOHGK@PacketsTransmittedPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0N@IJGODAGI@ConnectsCore?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BF@MNEGHJGM@ConnectsLanManager20?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BF@NEFNEICN@ConnectsLanManager21?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BC@EOFEMAHF@ConnectsWindowsNT?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BA@DJMJIEBG@CurrentCommands?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BE@OGCPPNJJ@NetworkErrorsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BF@LPDAMOL@ReadBytesCachePerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BH@IAHICFAL@ReadBytesNetworkPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BJ@ILOCGCLG@ReadBytesNonPagingPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BG@OLGMIDCE@ReadBytesPagingPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BL@CFIGOGID@ReadOperationsRandomPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BC@JALNAJBD@ReadPacketsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BH@JCFIFLJN@ReadPacketsSmallPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BC@MGHKCLNK@ReadsDeniedPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BB@FFKFENGC@ReadsLargePerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BC@GAMKMMKB@ServerDisconnects?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BB@LGLKKLGK@ServerReconnects?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0P@EPIIEJNA@ServerSessions?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BD@BALBBJPI@ServerSessionsHung?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BG@GCNKDHCE@WriteBytesCachePerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BI@HNBBGOIH@WriteBytesNetworkPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BK@PNNKNAIA@WriteBytesNonPagingPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BH@OANOHFDO@WriteBytesPagingPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BM@IJPFNDGO@WriteOperationsRandomPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BD@NEABLLFJ@WritePacketsPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BI@GPDBBABB@WritePacketsSmallPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BC@LMECNINB@WriteDeniedPerSec?$AA@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
	DD	FLAT:??_C@_0BB@HAMOOOJ@WriteLargePerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BF@MGINILGA@AsyncCopyReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BE@CAOOLPND@AsyncDataMapsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BF@GKOKALKG@AsyncFastReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BE@OMOFBJFA@AsyncMDLReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BE@PNDFACCO@AsyncPinReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BE@FFJCEMDJ@CopyReadHitsPercent?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BJ@FGOEJAHL@CopyReadHitsPercent_Base?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BA@BIHGDHJL@CopyReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BC@MJKDEPG@DataFlushesPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BF@JDDABGEO@DataFlushPagesPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@KOAAJIJA@DataMapHitsPercent?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BI@ILDKBHLK@DataMapHitsPercent_Base?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BC@OOMEAEEA@DataMapPinsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BH@JDIGEHGG@DataMapPinsPerSec_Base?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0P@GAMMIBDO@DataMapsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BL@HBAEFMGM@FastReadNotPossiblesPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BN@JGPDPBED@FastReadResourceMissesPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BA@LEBBLHFN@FastReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BH@JCPDBLIF@LazyWriteFlushesPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BF@GOGJJNKE@LazyWritePagesPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@PNDPPHMH@MDLReadHitsPercent?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BI@NMONEPAO@MDLReadHitsPercent_Base?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0P@KMMHCHLN@MDLReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@INCEIJBE@PinReadHitsPercent?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BI@KGBEKIEP@PinReadHitsPercent_Base?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0P@LNBHDMMD@PinReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BB@NGKOLIIB@ReadAheadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BE@PJJLELAC@SyncCopyReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@IDCIAAHF@SyncDataMapsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BE@FFPMMLME@SyncFastReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@EPCDKGPG@SyncMDLReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@FOPDLNII@SyncPinReadsPerSec?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0P@HPKKNIPF@AvailableBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BA@DKABBPEK@AvailableKBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BA@FJNBCKHA@AvailableMBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0L@ECJIAGHC@CacheBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0P@BPAGOPIK@CacheBytesPeak?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BC@ONMHHFEO@CacheFaultsPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0M@HHOMCEFN@CommitLimit?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0P@FAEGOFEG@CommittedBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BH@BIADJNEE@DemandZeroFaultsPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BL@MIKHIOLC@FreeSystemPageTableEntries?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BB@HOEEGAIG@PageFaultsPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BA@BHCICMAP@PageReadsPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BB@NHNEKMAP@PagesInputPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BC@PGIEMCPC@PagesOutputPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0M@PJBDCOH@PagesPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BB@EHHNOBPH@PageWritesPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BL@EHMKCOHH@PercentCommittedBytesInUse?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0CA@DKFDEGAA@PercentCommittedBytesInUse_Base?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BD@GAOJBHDB@PoolNonpagedAllocs?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BC@GMPJEGLC@PoolNonpagedBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BA@LDKKFHCE@PoolPagedAllocs?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0P@PJENKINF@PoolPagedBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BH@OMBHLDMN@PoolPagedResidentBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BJ@NPNGHFJN@SystemCacheResidentBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BI@KPKNFENK@SystemCodeResidentBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BF@JBGABIBK@SystemCodeTotalBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BK@MNCINJBF@SystemDriverResidentBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BH@KPIDEMMH@SystemDriverTotalBytes?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BH@KEMPGDKK@TransitionFaultsPerSec?$AA@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
	DD	FLAT:??_C@_0BC@KBPIOBBH@WriteCopiesPerSec?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_09BNGODGIH@Processes?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_07CMIGFCHA@Threads?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_07LDPBBEEB@Mutexes?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_06HEBKAGDH@Events?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0L@GLBCAKLN@Semaphores?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_08FBPDBPOE@Sections?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0N@CKGFJCHF@PercentUsage?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BB@JKLALBIF@PercentUsagePeak?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BF@EMKPKJGP@PercentProcessorTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BA@JCLIOML@PercentUserTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BA@LOOKHAGM@PercentIdleTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BE@DLJADCBG@C1TransitionsPerSec?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BE@JIMGLELP@C2TransitionsPerSec?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BE@EPCEDEOH@C3TransitionsPerSec?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_07BHCICOFH@DPCRate?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BB@KHEGFAIJ@DPCsQueuedPerSec?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BB@FCICDGPJ@InterruptsPerSec?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0O@PJFMGMCN@PercentC1Time?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0O@HPMIBOID@PercentC2Time?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0O@LEJEMNCG@PercentC3Time?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0P@LMLLFJEI@PercentDPCTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BF@GMGAHOLM@PercentInterruptTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BG@FPNGHOGK@PercentPrivilegedTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_09BNGODGIH@Processes?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_07CMIGFCHA@Threads?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BG@KHFHJKMP@AlignmentFixupsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BG@GIPKJDB@ContextSwitchesPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BK@DHKAACDP@ExceptionDispatchesPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BH@EMNLAEFK@FileControlBytesPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BM@PIKKJCOI@FileControlOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BE@NKKLPLAB@FileReadBytesPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BF@LGMPDKBA@FileWriteBytesPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BJ@PHDBHNCO@FloatingEmulationsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BK@NGGOKLMO@PercentRegistryQuotaInUse?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BF@NPGOAGED@ProcessorQueueLength?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BC@HMBPBBJB@SystemCallsPerSec?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0N@JBKHOEPE@SystemUpTime?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime?$AA@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0P@IDBBEDLI@CurrentReading?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_08NLCOAFEI@Accuracy?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_09BKMALBOE@Tolerance?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0P@OAFFNBPO@NominalReading?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_09EDCPMBJN@NormalMax?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_09FBKECFPC@NormalMin?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BH@NMAIJHFM@LowerThresholdCritical?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BE@NPMAGCMK@LowerThresholdFatal?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BH@FKDKGMLL@UpperThresholdCritical?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BE@HGEJIDLL@UpperThresholdFatal?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0M@EIBDACPL@MaxReadable?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0M@NIGABCBB@MinReadable?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_08JLKOPNJP@IsLinear?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0O@PKGMNGNM@BatteryStatus?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BB@NPKJIND@EstimatedRunTime?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0O@IKADLBCG@TimeOnBattery?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BB@HMDCOCCC@TimeToFullCharge?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BA@EMGHNHBI@ManufactureDate?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_09CAHFAGKL@Chemistry?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0P@IFPGNGPN@DesignCapacity?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BD@HADPLBCE@FullChargeCapacity?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BE@HNKJKBND@BatteryRechargeTime?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BD@EBMPMBCC@CapacityMultiplier?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0O@PBABLEFL@DesignVoltage?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BE@NEEKJBPN@ExpectedBatteryLife?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0N@DDGBNILM@ExpectedLife?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_08KDOEBHGA@Location?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BA@LLOCDJF@MaxBatteryError?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BA@KENPOHHF@MaxRechargeTime?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BE@IIEJDIAD@SmartBatteryVersion?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0BI@LFKNNEKA@SystemCreationClassName?$AA@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
	DD	FLAT:??_C@_0L@MPHEPFAH@SystemName?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0P@IDBBEDLI@CurrentReading?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_08NLCOAFEI@Accuracy?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_09BKMALBOE@Tolerance?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0P@OAFFNBPO@NominalReading?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_09EDCPMBJN@NormalMax?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_09FBKECFPC@NormalMin?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BH@NMAIJHFM@LowerThresholdCritical?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BE@NPMAGCMK@LowerThresholdFatal?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BH@FKDKGMLL@UpperThresholdCritical?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BE@HGEJIDLL@UpperThresholdFatal?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0M@NIGABCBB@MinReadable?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0M@EIBDACPL@MaxReadable?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_08JLKOPNJP@IsLinear?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_04FABLJDN@Name?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0P@IDBBEDLI@CurrentReading?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_08NLCOAFEI@Accuracy?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_09BKMALBOE@Tolerance?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0P@OAFFNBPO@NominalReading?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_09EDCPMBJN@NormalMax?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_09FBKECFPC@NormalMin?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BH@NMAIJHFM@LowerThresholdCritical?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BE@NPMAGCMK@LowerThresholdFatal?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BH@FKDKGMLL@UpperThresholdCritical?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BE@HGEJIDLL@UpperThresholdFatal?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0M@NIGABCBB@MinReadable?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0M@EIBDACPL@MaxReadable?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_07OJKFJLLK@Caption?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_08JLKOPNJP@IsLinear?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_06PGDKHFME@Status?$AA@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo?$AA@
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN1@Fill_n@2
  00004	56		 push	 esi
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL3@Fill_n@2
  00011	5e		 pop	 esi
$LN1@Fill_n@2:

; 3199 : 	}

  00012	c3		 ret	 0
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<double *,unsigned int,double>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN1@Fill_n@3
$LL3@Fill_n@3:

; 3198 : 		*_First = _Val;

  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	48		 dec	 eax
  00007	dd 19		 fstp	 QWORD PTR [ecx]
  00009	83 c1 08	 add	 ecx, 8
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL3@Fill_n@3
$LN1@Fill_n@3:

; 3199 : 	}

  00010	c3		 ret	 0
??$_Fill_n@PANIN@std@@YAXPANIABNU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<float *,unsigned int,float>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN1@Fill_n@4
$LL3@Fill_n@4:

; 3198 : 		*_First = _Val;

  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	48		 dec	 eax
  00007	d9 19		 fstp	 DWORD PTR [ecx]
  00009	83 c1 04	 add	 ecx, 4
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL3@Fill_n@4
$LN1@Fill_n@4:

; 3199 : 	}

  00010	c3		 ret	 0
??$_Fill_n@PAMIM@std@@YAXPAMIABMU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned __int64 *,unsigned int,unsigned __int64>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c9		 test	 ecx, ecx
  00002	76 14		 jbe	 SHORT $LN1@Fill_n@5
  00004	56		 push	 esi
$LL3@Fill_n@5:

; 3198 : 		*_First = _Val;

  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	49		 dec	 ecx
  00010	83 c0 08	 add	 eax, 8
  00013	85 c9		 test	 ecx, ecx
  00015	77 ee		 ja	 SHORT $LL3@Fill_n@5
  00017	5e		 pop	 esi
$LN1@Fill_n@5:

; 3199 : 	}

  00018	c3		 ret	 0
??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned __int64 *,unsigned int,unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAKIK@std@@YAXPAKIABKU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PAKIK@std@@YAXPAKIABKU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned long *,unsigned int,unsigned long>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN1@Fill_n@6
  00004	56		 push	 esi
$LL3@Fill_n@6:

; 3198 : 		*_First = _Val;

  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL3@Fill_n@6
  00011	5e		 pop	 esi
$LN1@Fill_n@6:

; 3199 : 	}

  00012	c3		 ret	 0
??$_Fill_n@PAKIK@std@@YAXPAKIABKU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned long *,unsigned int,unsigned long>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAGIG@std@@YAXPAGIABGU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PAGIG@std@@YAXPAGIABGU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned short *,unsigned int,unsigned short>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c0		 test	 eax, eax
  00002	76 10		 jbe	 SHORT $LN1@Fill_n@7
  00004	56		 push	 esi
$LL3@Fill_n@7:

; 3198 : 		*_First = _Val;

  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 31	 mov	 WORD PTR [ecx], si
  0000b	48		 dec	 eax
  0000c	83 c1 02	 add	 ecx, 2
  0000f	85 c0		 test	 eax, eax
  00011	77 f2		 ja	 SHORT $LL3@Fill_n@7
  00013	5e		 pop	 esi
$LN1@Fill_n@7:

; 3199 : 	}

  00014	c3		 ret	 0
??$_Fill_n@PAGIG@std@@YAXPAGIABGU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned short *,unsigned int,unsigned short>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAEIE@std@@YAXPAEIABEU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Fill_n@PAEIE@std@@YAXPAEIABEU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned char *,unsigned int,unsigned char>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = esi

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

  00000	85 c0		 test	 eax, eax
  00002	76 0a		 jbe	 SHORT $LN1@Fill_n@8
$LL3@Fill_n@8:

; 3198 : 		*_First = _Val;

  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 11		 mov	 BYTE PTR [ecx], dl
  00008	48		 dec	 eax
  00009	41		 inc	 ecx
  0000a	85 c0		 test	 eax, eax
  0000c	77 f6		 ja	 SHORT $LL3@Fill_n@8
$LN1@Fill_n@8:

; 3199 : 	}

  0000e	c3		 ret	 0
??$_Fill_n@PAEIE@std@@YAXPAEIABEU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned char *,unsigned int,unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	52		 push	 edx
  00008	e8 00 00 00 00	 call	 _memmove_s

; 152  : 	return (_Result);

  0000d	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	}

  00014	c3		 ret	 0
??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<double *,double *,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	03 c0		 add	 eax, eax
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	e8 00 00 00 00	 call	 _memmove_s

; 152  : 	return (_Result);

  0000f	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	}

  00016	c3		 ret	 0
??$_Uninit_copy@PANPANV?$allocator@N@std@@@std@@YAPANPAN00AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<float *,float *,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	52		 push	 edx
  00008	e8 00 00 00 00	 call	 _memmove_s

; 152  : 	return (_Result);

  0000d	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	}

  00014	c3		 ret	 0
??$_Uninit_copy@PAMPAMV?$allocator@M@std@@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Uninit_copy@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	03 c0		 add	 eax, eax
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	e8 00 00 00 00	 call	 _memmove_s

; 152  : 	return (_Result);

  0000f	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	}

  00016	c3		 ret	 0
??$_Uninit_copy@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Uninit_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	52		 push	 edx
  00008	e8 00 00 00 00	 call	 _memmove_s

; 152  : 	return (_Result);

  0000d	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	}

  00014	c3		 ret	 0
??$_Uninit_copy@PAKPAKV?$allocator@K@std@@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00000	03 c0		 add	 eax, eax
  00002	50		 push	 eax
  00003	51		 push	 ecx
  00004	50		 push	 eax
  00005	52		 push	 edx
  00006	e8 00 00 00 00	 call	 _memmove_s

; 152  : 	return (_Result);

  0000b	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  0000f	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	}

  00012	c3		 ret	 0
??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi

; 149  : 	_FwdIt _Result = _Dest + _Count;

  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 150  : 	if (_Count > 0)

  00006	74 0c		 je	 SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _memmove_s
  00011	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@Uninit_cop:

; 152  : 	return (_Result);

  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 153  : 	}

  00017	c3		 ret	 0
??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z PROC ; std::_Iter_cat<wchar_t * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z ENDP ; std::_Iter_cat<wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z
_TEXT	SEGMENT
??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z PROC ; std::_Iter_cat<double *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN@Z ENDP ; std::_Iter_cat<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z
_TEXT	SEGMENT
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z PROC ; std::_Iter_cat<float *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM@Z ENDP ; std::_Iter_cat<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K@Z
_TEXT	SEGMENT
??$_Iter_cat@PA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K@Z PROC ; std::_Iter_cat<unsigned __int64 *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K@Z ENDP ; std::_Iter_cat<unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK@Z
_TEXT	SEGMENT
??$_Iter_cat@PAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK@Z PROC ; std::_Iter_cat<unsigned long *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK@Z ENDP ; std::_Iter_cat<unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z
_TEXT	SEGMENT
??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z PROC ; std::_Iter_cat<unsigned short *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG@Z ENDP ; std::_Iter_cat<unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z
_TEXT	SEGMENT
??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z PROC ; std::_Iter_cat<unsigned char *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

  00000	c3		 ret	 0
??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ENDP ; std::_Iter_cat<unsigned char *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _memmove_s
  0000d	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 	return _Result;

  00010	8b c6		 mov	 eax, esi

; 2714 : 	}

  00012	c3		 ret	 0
??$_Copy_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	03 c0		 add	 eax, eax
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _memmove_s
  0000f	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 	return _Result;

  00012	8b c6		 mov	 eax, esi

; 2714 : 	}

  00014	c3		 ret	 0
??$_Copy_backward_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<double *,double *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<float *,float *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _memmove_s
  0000d	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 	return _Result;

  00010	8b c6		 mov	 eax, esi

; 2714 : 	}

  00012	c3		 ret	 0
??$_Copy_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<float *,float *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	03 c0		 add	 eax, eax
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _memmove_s
  0000f	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 	return _Result;

  00012	8b c6		 mov	 eax, esi

; 2714 : 	}

  00014	c3		 ret	 0
??$_Copy_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 _memmove_s
  0000d	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 	return _Result;

  00010	8b c6		 mov	 eax, esi

; 2714 : 	}

  00012	c3		 ret	 0
??$_Copy_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;
; 2711 : 	if (_Off > 0)
; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	50		 push	 eax
  00003	51		 push	 ecx
  00004	50		 push	 eax
  00005	56		 push	 esi
  00006	e8 00 00 00 00	 call	 _memmove_s
  0000b	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 	return _Result;

  0000e	8b c6		 mov	 eax, esi

; 2714 : 	}

  00010	c3		 ret	 0
??$_Copy_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	2b c2		 sub	 eax, edx

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

  00002	2b c8		 sub	 ecx, eax
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 2711 : 	if (_Off > 0)

  00007	85 c0		 test	 eax, eax
  00009	7e 0c		 jle	 SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  0000b	50		 push	 eax
  0000c	52		 push	 edx
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove_s
  00014	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 2714 : 	}

  0001a	c3		 ret	 0
??$_Copy_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPA_W@std@@YA?AU_Undefined_move_tag@0@ABQAPA_W@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAPA_W@std@@YA?AU_Undefined_move_tag@0@ABQAPA_W@Z PROC ; std::_Move_cat<wchar_t * *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PAPA_W@std@@YA?AU_Undefined_move_tag@0@ABQAPA_W@Z ENDP ; std::_Move_cat<wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z
_TEXT	SEGMENT
??$_Fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z PROC	; std::_Fill<wchar_t * *,wchar_t *>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0d		 je	 SHORT $LN1@Fill
  00004	56		 push	 esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	83 c0 04	 add	 eax, 4
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f5		 jne	 SHORT $LL3@Fill
  00010	5e		 pop	 esi
$LN1@Fill:

; 3160 : 	}

  00011	c3		 ret	 0
??$_Fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z ENDP	; std::_Fill<wchar_t * *,wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z PROC ; std::_Move_cat<double *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PAN@std@@YA?AU_Undefined_move_tag@0@ABQAN@Z ENDP ; std::_Move_cat<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PANN@std@@YAXPAN0ABN@Z
_TEXT	SEGMENT
??$_Fill@PANN@std@@YAXPAN0ABN@Z PROC			; std::_Fill<double *,double>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0c		 je	 SHORT $LN1@Fill@2
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	83 c0 08	 add	 eax, 8
  00009	dd 58 f8	 fstp	 QWORD PTR [eax-8]
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f4		 jne	 SHORT $LL3@Fill@2
$LN1@Fill@2:

; 3160 : 	}

  00010	c3		 ret	 0
??$_Fill@PANN@std@@YAXPAN0ABN@Z ENDP			; std::_Fill<double *,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z PROC ; std::_Move_cat<float *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PAM@std@@YA?AU_Undefined_move_tag@0@ABQAM@Z ENDP ; std::_Move_cat<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAMM@std@@YAXPAM0ABM@Z
_TEXT	SEGMENT
??$_Fill@PAMM@std@@YAXPAM0ABM@Z PROC			; std::_Fill<float *,float>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0c		 je	 SHORT $LN1@Fill@3
$LL3@Fill@3:

; 3159 : 		*_First = _Val;

  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	83 c0 04	 add	 eax, 4
  00009	d9 58 fc	 fstp	 DWORD PTR [eax-4]
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f4		 jne	 SHORT $LL3@Fill@3
$LN1@Fill@3:

; 3160 : 	}

  00010	c3		 ret	 0
??$_Fill@PAMM@std@@YAXPAM0ABM@Z ENDP			; std::_Fill<float *,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PA_K@std@@YA?AU_Undefined_move_tag@0@ABQA_K@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PA_K@std@@YA?AU_Undefined_move_tag@0@ABQA_K@Z PROC ; std::_Move_cat<unsigned __int64 *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PA_K@std@@YA?AU_Undefined_move_tag@0@ABQA_K@Z ENDP ; std::_Move_cat<unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PA_K_K@std@@YAXPA_K0AB_K@Z
_TEXT	SEGMENT
??$_Fill@PA_K_K@std@@YAXPA_K0AB_K@Z PROC		; std::_Fill<unsigned __int64 *,unsigned __int64>, COMDAT
; __First$ = eax
; __Last$ = edx
; __Val$ = ecx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c2		 cmp	 eax, edx
  00002	74 13		 je	 SHORT $LN1@Fill@4
  00004	56		 push	 esi
$LL3@Fill@4:

; 3159 : 		*_First = _Val;

  00005	8b 31		 mov	 esi, DWORD PTR [ecx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	83 c0 08	 add	 eax, 8
  00012	3b c2		 cmp	 eax, edx
  00014	75 ef		 jne	 SHORT $LL3@Fill@4
  00016	5e		 pop	 esi
$LN1@Fill@4:

; 3160 : 	}

  00017	c3		 ret	 0
??$_Fill@PA_K_K@std@@YAXPA_K0AB_K@Z ENDP		; std::_Fill<unsigned __int64 *,unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAK@std@@YA?AU_Undefined_move_tag@0@ABQAK@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAK@std@@YA?AU_Undefined_move_tag@0@ABQAK@Z PROC ; std::_Move_cat<unsigned long *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PAK@std@@YA?AU_Undefined_move_tag@0@ABQAK@Z ENDP ; std::_Move_cat<unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAKK@std@@YAXPAK0ABK@Z
_TEXT	SEGMENT
??$_Fill@PAKK@std@@YAXPAK0ABK@Z PROC			; std::_Fill<unsigned long *,unsigned long>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0d		 je	 SHORT $LN1@Fill@5
  00004	56		 push	 esi
$LL3@Fill@5:

; 3159 : 		*_First = _Val;

  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	83 c0 04	 add	 eax, 4
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f5		 jne	 SHORT $LL3@Fill@5
  00010	5e		 pop	 esi
$LN1@Fill@5:

; 3160 : 	}

  00011	c3		 ret	 0
??$_Fill@PAKK@std@@YAXPAK0ABK@Z ENDP			; std::_Fill<unsigned long *,unsigned long>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAG@std@@YA?AU_Undefined_move_tag@0@ABQAG@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAG@std@@YA?AU_Undefined_move_tag@0@ABQAG@Z PROC ; std::_Move_cat<unsigned short *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PAG@std@@YA?AU_Undefined_move_tag@0@ABQAG@Z ENDP ; std::_Move_cat<unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAGG@std@@YAXPAG0ABG@Z
_TEXT	SEGMENT
??$_Fill@PAGG@std@@YAXPAG0ABG@Z PROC			; std::_Fill<unsigned short *,unsigned short>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0f		 je	 SHORT $LN1@Fill@6
  00004	56		 push	 esi
$LL3@Fill@6:

; 3159 : 		*_First = _Val;

  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 30	 mov	 WORD PTR [eax], si
  0000b	83 c0 02	 add	 eax, 2
  0000e	3b c1		 cmp	 eax, ecx
  00010	75 f3		 jne	 SHORT $LL3@Fill@6
  00012	5e		 pop	 esi
$LN1@Fill@6:

; 3160 : 	}

  00013	c3		 ret	 0
??$_Fill@PAGG@std@@YAXPAG0ABG@Z ENDP			; std::_Fill<unsigned short *,unsigned short>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAE@std@@YA?AU_Undefined_move_tag@0@ABQAE@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAE@std@@YA?AU_Undefined_move_tag@0@ABQAE@Z PROC ; std::_Move_cat<unsigned char *>, COMDAT

; 1200 : 	{

  00000	51		 push	 ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Move_cat@PAE@std@@YA?AU_Undefined_move_tag@0@ABQAE@Z ENDP ; std::_Move_cat<unsigned char *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAEE@std@@YAXPAE0ABE@Z
_TEXT	SEGMENT
??$_Fill@PAEE@std@@YAXPAE0ABE@Z PROC			; std::_Fill<unsigned char *,unsigned char>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

  00000	3b c1		 cmp	 eax, ecx
  00002	74 09		 je	 SHORT $LN1@Fill@7
$LL3@Fill@7:

; 3159 : 		*_First = _Val;

  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 10		 mov	 BYTE PTR [eax], dl
  00008	40		 inc	 eax
  00009	3b c1		 cmp	 eax, ecx
  0000b	75 f7		 jne	 SHORT $LL3@Fill@7
$LN1@Fill@7:

; 3160 : 	}

  0000d	c3		 ret	 0
??$_Fill@PAEE@std@@YAXPAE0ABE@Z ENDP			; std::_Fill<unsigned char *,unsigned char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<wchar_t * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<double *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAN@std@@YAPANAAPANU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<float *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAM@std@@YAPAMAAPAMU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PA_K@std@@YAPA_KAAPA_KU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PA_K@std@@YAPA_KAAPA_KU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned __int64 *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PA_K@std@@YAPA_KAAPA_KU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAK@std@@YAPAKAAPAKU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAK@std@@YAPAKAAPAKU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned long *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAK@std@@YAPAKAAPAKU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned short *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned char *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1148 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t *> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned __int64> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 242  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Copy_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	52		 push	 edx
  00008	e8 00 00 00 00	 call	 _memmove_s

; 2507 : 	return _Result;

  0000d	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 2508 : 	}

  00014	c3		 ret	 0
??$_Copy_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z PROC ; std::_Ptr_cat<wchar_t * *,wchar_t * *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z ENDP ; std::_Ptr_cat<wchar_t * *,wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPA_WPAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W0@Z
_TEXT	SEGMENT
??$_Iter_random@PAPA_WPAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W0@Z PROC ; std::_Iter_random<wchar_t * *,wchar_t * *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PAPA_WPAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W0@Z ENDP ; std::_Iter_random<wchar_t * *,wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z
_TEXT	SEGMENT
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z PROC	; std::_Checked_base<wchar_t * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z ENDP	; std::_Checked_base<wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Copy_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<double *,double *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	03 c0		 add	 eax, eax
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	e8 00 00 00 00	 call	 _memmove_s

; 2507 : 	return _Result;

  0000f	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 2508 : 	}

  00016	c3		 ret	 0
??$_Copy_opt@PANPANUrandom_access_iterator_tag@std@@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<double *,double *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z PROC ; std::_Ptr_cat<double *,double *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PANPAN@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAN0@Z ENDP ; std::_Ptr_cat<double *,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z
_TEXT	SEGMENT
??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z PROC ; std::_Iter_random<double *,double *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PANPAN@std@@YA?AUrandom_access_iterator_tag@0@ABQAN0@Z ENDP ; std::_Iter_random<double *,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAN@std@@YAPANAAPAN@Z
_TEXT	SEGMENT
??$_Checked_base@PAN@std@@YAPANAAPAN@Z PROC		; std::_Checked_base<double *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAN@std@@YAPANAAPAN@Z ENDP		; std::_Checked_base<double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	52		 push	 edx
  00008	e8 00 00 00 00	 call	 _memmove_s

; 2507 : 	return _Result;

  0000d	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 2508 : 	}

  00014	c3		 ret	 0
??$_Copy_opt@PAMPAMUrandom_access_iterator_tag@std@@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<float *,float *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z PROC ; std::_Ptr_cat<float *,float *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAMPAM@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAM0@Z ENDP ; std::_Ptr_cat<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z
_TEXT	SEGMENT
??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z PROC ; std::_Iter_random<float *,float *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PAMPAM@std@@YA?AUrandom_access_iterator_tag@0@ABQAM0@Z ENDP ; std::_Iter_random<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAM@std@@YAPAMAAPAM@Z
_TEXT	SEGMENT
??$_Checked_base@PAM@std@@YAPAMAAPAM@Z PROC		; std::_Checked_base<float *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAM@std@@YAPAMAAPAM@Z ENDP		; std::_Checked_base<float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Copy_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	03 c0		 add	 eax, eax
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	e8 00 00 00 00	 call	 _memmove_s

; 2507 : 	return _Result;

  0000f	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 2508 : 	}

  00016	c3		 ret	 0
??$_Copy_opt@PA_KPA_KUrandom_access_iterator_tag@std@@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PA_KPA_K@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_K0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PA_KPA_K@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_K0@Z PROC ; std::_Ptr_cat<unsigned __int64 *,unsigned __int64 *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PA_KPA_K@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPA_K0@Z ENDP ; std::_Ptr_cat<unsigned __int64 *,unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PA_KPA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K0@Z
_TEXT	SEGMENT
??$_Iter_random@PA_KPA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K0@Z PROC ; std::_Iter_random<unsigned __int64 *,unsigned __int64 *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PA_KPA_K@std@@YA?AUrandom_access_iterator_tag@0@ABQA_K0@Z ENDP ; std::_Iter_random<unsigned __int64 *,unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PA_K@std@@YAPA_KAAPA_K@Z
_TEXT	SEGMENT
??$_Checked_base@PA_K@std@@YAPA_KAAPA_K@Z PROC		; std::_Checked_base<unsigned __int64 *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PA_K@std@@YAPA_KAAPA_K@Z ENDP		; std::_Checked_base<unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Copy_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	03 c0		 add	 eax, eax
  00004	50		 push	 eax
  00005	51		 push	 ecx
  00006	50		 push	 eax
  00007	52		 push	 edx
  00008	e8 00 00 00 00	 call	 _memmove_s

; 2507 : 	return _Result;

  0000d	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  00011	83 c4 10	 add	 esp, 16			; 00000010H

; 2508 : 	}

  00014	c3		 ret	 0
??$_Copy_opt@PAKPAKUrandom_access_iterator_tag@std@@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAKPAK@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAK0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAKPAK@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAK0@Z PROC ; std::_Ptr_cat<unsigned long *,unsigned long *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAKPAK@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAK0@Z ENDP ; std::_Ptr_cat<unsigned long *,unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAKPAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK0@Z
_TEXT	SEGMENT
??$_Iter_random@PAKPAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK0@Z PROC ; std::_Iter_random<unsigned long *,unsigned long *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PAKPAK@std@@YA?AUrandom_access_iterator_tag@0@ABQAK0@Z ENDP ; std::_Iter_random<unsigned long *,unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAK@std@@YAPAKAAPAK@Z
_TEXT	SEGMENT
??$_Checked_base@PAK@std@@YAPAKAAPAK@Z PROC		; std::_Checked_base<unsigned long *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAK@std@@YAPAKAAPAK@Z ENDP		; std::_Checked_base<unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 4
??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Dest$ = edx
; __Off$ = eax

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;
; 2505 : 	if (_Off > 0)
; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  00000	03 c0		 add	 eax, eax
  00002	50		 push	 eax
  00003	51		 push	 ecx
  00004	50		 push	 eax
  00005	52		 push	 edx
  00006	e8 00 00 00 00	 call	 _memmove_s

; 2507 : 	return _Result;

  0000b	8b 44 24 14	 mov	 eax, DWORD PTR __Result$[esp+12]
  0000f	83 c4 10	 add	 esp, 16			; 00000010H

; 2508 : 	}

  00012	c3		 ret	 0
??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z PROC ; std::_Ptr_cat<unsigned short *,unsigned short *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ENDP ; std::_Ptr_cat<unsigned short *,unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z
_TEXT	SEGMENT
??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z PROC ; std::_Iter_random<unsigned short *,unsigned short *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z ENDP ; std::_Iter_random<unsigned short *,unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAG@std@@YAPAGAAPAG@Z
_TEXT	SEGMENT
??$_Checked_base@PAG@std@@YAPAGAAPAG@Z PROC		; std::_Checked_base<unsigned short *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAG@std@@YAPAGAAPAG@Z ENDP		; std::_Checked_base<unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 2505 : 	if (_Off > 0)

  00006	85 c0		 test	 eax, eax
  00008	7e 0c		 jle	 SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

  0000a	50		 push	 eax
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _memmove_s
  00013	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@Copy_opt:

; 2507 : 	return _Result;

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi

; 2508 : 	}

  00019	c3		 ret	 0
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z PROC ; std::_Ptr_cat<unsigned char *,unsigned char *>, COMDAT

; 1509 : 	{

  00000	51		 push	 ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

  00001	8a 44 24 03	 mov	 al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

  00005	59		 pop	 ecx
  00006	c3		 ret	 0
??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ENDP ; std::_Ptr_cat<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z
_TEXT	SEGMENT
??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z PROC ; std::_Iter_random<unsigned char *,unsigned char *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

  00000	c3		 ret	 0
??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ENDP ; std::_Iter_random<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAE@std@@YAPAEAAPAE@Z
_TEXT	SEGMENT
??$_Checked_base@PAE@std@@YAPAEAAPAE@Z PROC		; std::_Checked_base<unsigned char *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1166 : 	}

  00002	c3		 ret	 0
??$_Checked_base@PAE@std@@YAPAEAAPAE@Z ENDP		; std::_Checked_base<unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 636  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity@2
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 03	 sar	 eax, 3

; 636  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity@3
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity@3:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 636  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity@4
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity@4:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 03	 sar	 eax, 3

; 636  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity@5
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity@5:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2

; 636  : 		}

  00012	c3		 ret	 0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity@6
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity@6:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx
  0000f	d1 f8		 sar	 eax, 1

; 636  : 		}

  00011	c3		 ret	 0
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  00000	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN3@capacity@7
  00007	33 c0		 xor	 eax, eax

; 636  : 		}

  00009	c3		 ret	 0
$LN3@capacity@7:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000d	2b c1		 sub	 eax, ecx

; 636  : 		}

  0000f	c3		 ret	 0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<double,5>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<double,5>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<float,4>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<float,4>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ PROC	; ATL::CComSafeArray<unsigned __int64,21>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ ENDP	; ATL::CComSafeArray<unsigned __int64,21>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned long,19>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned long,19>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned short,18>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned short,18>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned char,17>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned char,17>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ PROC	; ATL::CComSafeArray<wchar_t *,8>::Unlock, COMDAT
; _this$ = eax

; 579  : 		ATLASSUME(m_psa != NULL);
; 580  : 		return SafeArrayUnlock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 581  : 	}

  00009	c3		 ret	 0
?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ ENDP	; ATL::CComSafeArray<wchar_t *,8>::Unlock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<double,5>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<double,5>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ PROC		; ATL::CComSafeArray<double,5>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ ENDP		; ATL::CComSafeArray<double,5>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ PROC		; ATL::CComSafeArray<double,5>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 05 00 00 00	 mov	 eax, 5

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ ENDP		; ATL::CComSafeArray<double,5>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<float,4>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<float,4>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ PROC		; ATL::CComSafeArray<float,4>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy@2

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy@2

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy@2

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy@2:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ ENDP		; ATL::CComSafeArray<float,4>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ PROC		; ATL::CComSafeArray<float,4>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 04 00 00 00	 mov	 eax, 4

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ ENDP		; ATL::CComSafeArray<float,4>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned __int64,21>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned __int64,21>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned __int64,21>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy@3

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy@3

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy@3

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy@3:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned __int64,21>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned __int64,21>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 15 00 00 00	 mov	 eax, 21			; 00000015H

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned __int64,21>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned long,19>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned long,19>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned long,19>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy@4

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy@4

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy@4

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy@4:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned long,19>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned long,19>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 13 00 00 00	 mov	 eax, 19			; 00000013H

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned long,19>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned short,18>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned short,18>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned short,18>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy@5

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy@5

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy@5

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy@5:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned short,18>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned short,18>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned short,18>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned char,17>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned char,17>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned char,17>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy@6

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy@6

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy@6

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy@6:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned char,17>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned char,17>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned char,17>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<wchar_t *,8>::Lock, COMDAT
; _this$ = eax

; 574  : 		ATLASSUME(m_psa != NULL);
; 575  : 		return SafeArrayLock(m_psa);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 576  : 	}

  00009	c3		 ret	 0
?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<wchar_t *,8>::Lock
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<wchar_t *,8>::Destroy, COMDAT
; _this$ = esi

; 558  : 		HRESULT hRes = S_OK;
; 559  : 		if (m_psa != NULL)

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	33 c0		 xor	 eax, eax
  00004	85 c9		 test	 ecx, ecx
  00006	74 1e		 je	 SHORT $LN1@Destroy@7

; 560  : 		{
; 561  : 			hRes = Unlock();

  00008	51		 push	 ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 562  : 			if (SUCCEEDED(hRes))

  0000f	85 c0		 test	 eax, eax
  00011	7c 13		 jl	 SHORT $LN1@Destroy@7

; 563  : 			{
; 564  : 				hRes = SafeArrayDestroy(m_psa);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	50		 push	 eax
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 565  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	7c 06		 jl	 SHORT $LN1@Destroy@7

; 566  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN1@Destroy@7:

; 567  : 			}
; 568  : 		}
; 569  : 		return hRes;
; 570  : 	}

  00026	c3		 ret	 0
?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<wchar_t *,8>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<wchar_t *,8>::GetType, COMDAT

; 305  : 		return _vartype;

  00000	b8 08 00 00 00	 mov	 eax, 8

; 306  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<wchar_t *,8>::GetType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@N$04@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@N$04@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@N$04@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@N$04@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@N$04@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<double,5>::CComSafeArray<double,5>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@N$04@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<double,5>::CComSafeArray<double,5>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@M$03@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@M$03@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr@2
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr@2
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr@2
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr@2:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@M$03@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@M$03@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@M$03@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<float,4>::CComSafeArray<float,4>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@M$03@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<float,4>::CComSafeArray<float,4>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr@3
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr@3
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr@3
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr@3:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned __int64,21>::CComSafeArray<unsigned __int64,21>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned __int64,21>::CComSafeArray<unsigned __int64,21>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr@4
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr@4
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr@4
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr@4:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned long,19>::CComSafeArray<unsigned long,19>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned long,19>::CComSafeArray<unsigned long,19>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr@5
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr@5
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr@5
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr@5:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned short,18>::CComSafeArray<unsigned short,18>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned short,18>::CComSafeArray<unsigned short,18>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr@6
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr@6
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr@6
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr@6:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned char,17>::CComSafeArray<unsigned char,17>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned char,17>::CComSafeArray<unsigned char,17>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>, COMDAT
; _this$ = esi

; 191  : 		HRESULT hRes = Destroy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 1e		 je	 SHORT $LN3@CComSafeAr@7
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0000d	85 c0		 test	 eax, eax
  0000f	7c 13		 jl	 SHORT $LN3@CComSafeAr@7
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  0001a	85 c0		 test	 eax, eax
  0001c	7c 06		 jl	 SHORT $LN3@CComSafeAr@7
  0001e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN3@CComSafeAr@7:

; 192  : 		hRes;
; 193  : 		ATLASSERT(SUCCEEDED(hRes));
; 194  : 	} 

  00024	c3		 ret	 0
??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<wchar_t *,8>::CComSafeArray<wchar_t *,8>, COMDAT
; _this$ = eax

; 143  : 	{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 144  : 	}

  00006	c3		 ret	 0
??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<wchar_t *,8>::CComSafeArray<wchar_t *,8>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PA_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PA_W@1@@Z
_TEXT	SEGMENT
??$?0PA_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PA_W@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><wchar_t *>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0PA_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PA_W@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z
_TEXT	SEGMENT
??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0N@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@N@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z
_TEXT	SEGMENT
??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0M@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@M@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0_K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_K@1@@Z
_TEXT	SEGMENT
??$?0_K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_K@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned __int64>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0_K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_K@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned __int64> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@K@1@@Z
_TEXT	SEGMENT
??$?0K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@K@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned long>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0K@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@K@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned long>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0G@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
??$?0G@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned short>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0G@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned short>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

  00000	c3		 ret	 0
??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z PROC ; stdext::unchecked_copy<wchar_t * *,wchar_t * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 0c		 jle	 SHORT $LN18@unchecked_@2
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@2:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 3607 : 	}

  00023	c3		 ret	 0
??$unchecked_copy@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z ENDP ; stdext::unchecked_copy<wchar_t * *,wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PANPAN@stdext@@YAPANPAN00@Z
_TEXT	SEGMENT
??$unchecked_copy@PANPAN@stdext@@YAPANPAN00@Z PROC	; stdext::unchecked_copy<double *,double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 0c		 jle	 SHORT $LN18@unchecked_@3
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@3:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 3607 : 	}

  00023	c3		 ret	 0
??$unchecked_copy@PANPAN@stdext@@YAPANPAN00@Z ENDP	; stdext::unchecked_copy<double *,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z PROC	; stdext::unchecked_copy<float *,float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 0c		 jle	 SHORT $LN18@unchecked_@4
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@4:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 3607 : 	}

  00023	c3		 ret	 0
??$unchecked_copy@PAMPAM@stdext@@YAPAMPAM00@Z ENDP	; stdext::unchecked_copy<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PA_KPA_K@stdext@@YAPA_KPA_K00@Z
_TEXT	SEGMENT
??$unchecked_copy@PA_KPA_K@stdext@@YAPA_KPA_K00@Z PROC	; stdext::unchecked_copy<unsigned __int64 *,unsigned __int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 0c		 jle	 SHORT $LN18@unchecked_@5
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@5:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 3607 : 	}

  00023	c3		 ret	 0
??$unchecked_copy@PA_KPA_K@stdext@@YAPA_KPA_K00@Z ENDP	; stdext::unchecked_copy<unsigned __int64 *,unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAKPAK@stdext@@YAPAKPAK00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAKPAK@stdext@@YAPAKPAK00@Z PROC	; stdext::unchecked_copy<unsigned long *,unsigned long *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	7e 0c		 jle	 SHORT $LN18@unchecked_@6
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@6:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 3607 : 	}

  00023	c3		 ret	 0
??$unchecked_copy@PAKPAK@stdext@@YAPAKPAK00@Z ENDP	; stdext::unchecked_copy<unsigned long *,unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z PROC	; stdext::unchecked_copy<unsigned short *,unsigned short *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	d1 f8		 sar	 eax, 1
  00004	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00007	56		 push	 esi
  00008	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  0000b	85 c0		 test	 eax, eax
  0000d	7e 0c		 jle	 SHORT $LN18@unchecked_@7
  0000f	51		 push	 ecx
  00010	57		 push	 edi
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 _memmove_s
  00018	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@7:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi

; 3607 : 	}

  0001e	c3		 ret	 0
??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z ENDP	; stdext::unchecked_copy<unsigned short *,unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z PROC	; stdext::unchecked_copy<unsigned char *,unsigned char *>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi
  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00006	85 c0		 test	 eax, eax
  00008	7e 0c		 jle	 SHORT $LN18@unchecked_@8
  0000a	50		 push	 eax
  0000b	52		 push	 edx
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _memmove_s
  00013	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@unchecked_@8:
  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi

; 3607 : 	}

  00019	c3		 ret	 0
??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z ENDP	; stdext::unchecked_copy<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PA_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PA_W@std@@QBEIXZ PROC		; std::allocator<wchar_t *>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@PA_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t *>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@N@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@N@std@@QBEIXZ PROC		; std::allocator<double>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@N@std@@QBEIXZ ENDP		; std::allocator<double>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@M@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@M@std@@QBEIXZ PROC		; std::allocator<float>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@M@std@@QBEIXZ ENDP		; std::allocator<float>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_K@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_K@std@@QBEIXZ PROC		; std::allocator<unsigned __int64>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@_K@std@@QBEIXZ ENDP		; std::allocator<unsigned __int64>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@K@std@@QBEIXZ PROC		; std::allocator<unsigned long>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@K@std@@QBEIXZ ENDP		; std::allocator<unsigned long>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@G@std@@QBEIXZ PROC		; std::allocator<unsigned short>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 167  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@G@std@@QBEIXZ ENDP		; std::allocator<unsigned short>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@E@std@@QBEIXZ PROC		; std::allocator<unsigned char>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

  00000	83 c8 ff	 or	 eax, -1

; 167  : 		}

  00003	c3		 ret	 0
?max_size@?$allocator@E@std@@QBEIXZ ENDP		; std::allocator<unsigned char>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z PROC	; std::allocator<wchar_t *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z ENDP	; std::allocator<wchar_t *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PA_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PA_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t *>::allocator<wchar_t *>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@PA_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t *>::allocator<wchar_t *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXPAPA_W0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXPAPA_W0@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXPAPA_W0@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 732  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@N@std@@QAEXPANI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@N@std@@QAEXPANI@Z PROC		; std::allocator<double>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@N@std@@QAEXPANI@Z ENDP		; std::allocator<double>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@N@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@ABV01@@Z PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@N@std@@QAE@ABV01@@Z ENDP			; std::allocator<double>::allocator<double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z PROC ; std::vector<double,std::allocator<double> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@IAEXPAN0@Z ENDP ; std::vector<double,std::allocator<double> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 732  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXPAMI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@M@std@@QAEXPAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@M@std@@QAEXPAMI@Z ENDP		; std::allocator<float>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@ABV01@@Z PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@M@std@@QAE@ABV01@@Z ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@IAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 732  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_K@std@@QAEXPA_KI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@_K@std@@QAEXPA_KI@Z PROC	; std::allocator<unsigned __int64>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@_K@std@@QAEXPA_KI@Z ENDP	; std::allocator<unsigned __int64>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@_K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@_K@std@@QAE@ABV01@@Z PROC		; std::allocator<unsigned __int64>::allocator<unsigned __int64>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@_K@std@@QAE@ABV01@@Z ENDP		; std::allocator<unsigned __int64>::allocator<unsigned __int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXPA_K0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXPA_K0@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXPA_K0@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 732  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@K@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 732  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@G@std@@QAEXPAGI@Z PROC		; std::allocator<unsigned short>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@G@std@@QAEXPAGI@Z ENDP		; std::allocator<unsigned short>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@G@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@G@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@G@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 732  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 141  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@E@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

  00000	c3		 ret	 0
??0?$allocator@E@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

  00000	83 c8 ff	 or	 eax, -1

; 732  : 		}

  00003	c3		 ret	 0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PA_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PA_W@std@@QAE@XZ PROC			; std::allocator<wchar_t *>::allocator<wchar_t *>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@PA_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t *>::allocator<wchar_t *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@XZ PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@N@std@@QAE@XZ ENDP			; std::allocator<double>::allocator<double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ PROC	; std::vector<double,std::allocator<double> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@IAEXXZ ENDP	; std::vector<double,std::allocator<double> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@M@std@@QAE@XZ ENDP			; std::allocator<float>::allocator<float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@IAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@_K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_K@std@@QAE@XZ PROC			; std::allocator<unsigned __int64>::allocator<unsigned __int64>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@_K@std@@QAE@XZ ENDP			; std::allocator<unsigned __int64>::allocator<unsigned __int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@IAEXXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@G@std@@QAE@XZ PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@G@std@@QAE@XZ ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

  00000	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = esi

; 1124 : 		if (_Myfirst != 0)

  00000	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN4@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
$LN4@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  00010	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0001e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1135 : 		}

  00025	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00006	c1 f8 02	 sar	 eax, 2

; 727  : 		}

  00009	c3		 ret	 0
?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC	; std::vector<double,std::allocator<double> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00006	c1 f8 03	 sar	 eax, 3

; 727  : 		}

  00009	c3		 ret	 0
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP	; std::vector<double,std::allocator<double> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00006	c1 f8 02	 sar	 eax, 2

; 727  : 		}

  00009	c3		 ret	 0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00006	c1 f8 03	 sar	 eax, 3

; 727  : 		}

  00009	c3		 ret	 0
?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00006	c1 f8 02	 sar	 eax, 2

; 727  : 		}

  00009	c3		 ret	 0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]
  00006	d1 f8		 sar	 eax, 1

; 727  : 		}

  00008	c3		 ret	 0
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	2b 41 0c	 sub	 eax, DWORD PTR [ecx+12]

; 727  : 		}

  00006	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlcomcli.h
_TEXT	ENDS
;	COMDAT ??BCComBSTR@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
??BCComBSTR@ATL@@QBEPA_WXZ PROC				; ATL::CComBSTR::operator wchar_t *, COMDAT
; _this$ = eax

; 693  : 		return m_str;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 694  : 	}

  00002	c3		 ret	 0
??BCComBSTR@ATL@@QBEPA_WXZ ENDP				; ATL::CComBSTR::operator wchar_t *
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z
_TEXT	SEGMENT
?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z PROC ; ATL::AtlSafeArrayGetActualVartype, COMDAT
; _psaArray$ = esi
; _pvtType$ = edi

; 429  :     HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00000	57		 push	 edi
  00001	56		 push	 esi
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 430  : 
; 431  :     if(FAILED(hrSystem))

  00008	85 c0		 test	 eax, eax

; 432  :     {
; 433  :         return hrSystem;

  0000a	7c 27		 jl	 SHORT $LN5@AtlSafeArr

; 434  :     }
; 435  : 
; 436  :     /* 
; 437  :     When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 438  :     it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 439  :     */
; 440  :     if(pvtType && *pvtType==VT_UNKNOWN)

  0000c	85 ff		 test	 edi, edi
  0000e	74 23		 je	 SHORT $LN5@AtlSafeArr
  00010	66 83 3f 0d	 cmp	 WORD PTR [edi], 13	; 0000000dH
  00014	75 1d		 jne	 SHORT $LN5@AtlSafeArr

; 441  :     {
; 442  :         if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00016	85 f6		 test	 esi, esi
  00018	74 19		 je	 SHORT $LN5@AtlSafeArr
  0001a	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  0001e	f6 c1 40	 test	 cl, 64			; 00000040H
  00021	74 10		 je	 SHORT $LN5@AtlSafeArr

; 443  :         {
; 444  :             if(psaArray->fFeatures & FADF_DISPATCH)

  00023	f7 c1 00 04 00
	00		 test	 ecx, 1024		; 00000400H
  00029	74 08		 je	 SHORT $LN5@AtlSafeArr

; 445  :             {
; 446  :                 *pvtType=VT_DISPATCH;

  0002b	b9 09 00 00 00	 mov	 ecx, 9
  00030	66 89 0f	 mov	 WORD PTR [edi], cx
$LN5@AtlSafeArr:

; 447  :             }
; 448  :         }
; 449  :     }
; 450  : 
; 451  :     return hrSystem;
; 452  : }

  00033	c3		 ret	 0
?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z ENDP ; ATL::AtlSafeArrayGetActualVartype
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = eax
; _hr$ = ecx

; 42   : 	{

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 43   : 	}

  00002	c3		 ret	 0
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\comutil.h
_TEXT	ENDS
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
?_Free@Data_t@_bstr_t@@AAEXXZ PROC			; _bstr_t::Data_t::_Free, COMDAT
; _this$ = esi

; 930  :     if (m_wstr != NULL) {

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 07		 je	 SHORT $LN2@Free

; 931  :         ::SysFreeString(m_wstr);

  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN2@Free:

; 932  :     }
; 933  : 
; 934  :     if (m_str != NULL) {

  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN1@Free

; 935  :         delete [] m_str;

  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001a	59		 pop	 ecx
$LN1@Free:

; 936  :     }
; 937  : }

  0001b	c3		 ret	 0
?_Free@Data_t@_bstr_t@@AAEXXZ ENDP			; _bstr_t::Data_t::_Free
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT
??1Data_t@_bstr_t@@AAE@XZ PROC				; _bstr_t::Data_t::~Data_t, COMDAT
; _this$ = esi

; 923  :     _Free();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 07		 je	 SHORT $LN4@Data_t
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN4@Data_t:
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN3@Data_t
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001a	59		 pop	 ecx
$LN3@Data_t:

; 924  : }

  0001b	c3		 ret	 0
??1Data_t@_bstr_t@@AAE@XZ ENDP				; _bstr_t::Data_t::~Data_t
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT
??2Data_t@_bstr_t@@SAPAXI@Z PROC			; _bstr_t::Data_t::operator new, COMDAT

; 915  :     return ::operator new(sz);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 916  : }

  0000a	c3		 ret	 0
??2Data_t@_bstr_t@@SAPAXI@Z ENDP			; _bstr_t::Data_t::operator new
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ
_TEXT	SEGMENT
?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ PROC		; _bstr_t::Data_t::GetWString, COMDAT
; _this$ = eax

; 819  :     return m_wstr;
; 820  : }

  00000	c3		 ret	 0
?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ ENDP		; _bstr_t::Data_t::GetWString
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT
??_GData_t@_bstr_t@@AAEPAXI@Z PROC			; _bstr_t::Data_t::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 07		 je	 SHORT $LN7@scalar
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN7@scalar:
  0000d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00010	85 c0		 test	 eax, eax
  00012	74 09		 je	 SHORT $LN6@scalar
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001a	83 c4 04	 add	 esp, 4
$LN6@scalar:
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 04	 add	 esp, 4
  00026	8b c6		 mov	 eax, esi
  00028	c3		 ret	 0
??_GData_t@_bstr_t@@AAEPAXI@Z ENDP			; _bstr_t::Data_t::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT
?Release@Data_t@_bstr_t@@QAEKXZ PROC			; _bstr_t::Data_t::Release, COMDAT
; _this$ = esi

; 772  : {

  00000	57		 push	 edi

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  00001	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00004	50		 push	 eax
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
  0000b	8b f8		 mov	 edi, eax

; 774  :     if (cRef == 0) {

  0000d	85 ff		 test	 edi, edi
  0000f	75 2c		 jne	 SHORT $LN4@Release

; 775  :         delete this;

  00011	85 f6		 test	 esi, esi
  00013	74 28		 je	 SHORT $LN4@Release
  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	85 c0		 test	 eax, eax
  00019	74 07		 je	 SHORT $LN12@Release
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN12@Release:
  00022	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00025	85 c0		 test	 eax, eax
  00027	74 09		 je	 SHORT $LN11@Release
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	83 c4 04	 add	 esp, 4
$LN11@Release:
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00038	83 c4 04	 add	 esp, 4

; 776  :     }
; 777  : 
; 778  :     return cRef;

  0003b	8b c7		 mov	 eax, edi
$LN4@Release:
  0003d	5f		 pop	 edi

; 779  : }

  0003e	c3		 ret	 0
?Release@Data_t@_bstr_t@@QAEKXZ ENDP			; _bstr_t::Data_t::Release
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PB_W@Z
_TEXT	SEGMENT
??0Data_t@_bstr_t@@QAE@PB_W@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = esi

; 691  :     m_wstr = ::SysAllocString(s);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2?$AA?$AA@
  00005	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000c	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  00019	89 06		 mov	 DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

  0001b	85 c0		 test	 eax, eax
  0001d	75 0a		 jne	 SHORT $LN1@Data_t@2

; 694  :         _com_issue_error(E_OUTOFMEMORY);

  0001f	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00024	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN6@Data_t@2:
$LN1@Data_t@2:

; 695  :     }
; 696  : }

  00029	8b c6		 mov	 eax, esi
  0002b	c3		 ret	 0
$LN5@Data_t@2:
??0Data_t@_bstr_t@@QAE@PB_W@Z ENDP			; _bstr_t::Data_t::Data_t
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
??0Data_t@_bstr_t@@QAE@PBD@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = esi
; _s$ = eax

; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);

  00000	50		 push	 eax
  00001	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00008	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  0000f	e8 00 00 00 00	 call	 ?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
  00014	89 06		 mov	 DWORD PTR [esi], eax

; 684  : }

  00016	8b c6		 mov	 eax, esi
  00018	c3		 ret	 0
??0Data_t@_bstr_t@@QAE@PBD@Z ENDP			; _bstr_t::Data_t::Data_t
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
?_Free@_bstr_t@@AAEXXZ PROC				; _bstr_t::_Free, COMDAT
; _this$ = edi

; 636  : {

  00000	56		 push	 esi

; 637  :     if (m_Data != NULL) {

  00001	8b 37		 mov	 esi, DWORD PTR [edi]
  00003	85 f6		 test	 esi, esi
  00005	74 3e		 je	 SHORT $LN1@Free@2

; 638  :         m_Data->Release();

  00007	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
  00011	85 c0		 test	 eax, eax
  00013	75 2a		 jne	 SHORT $LN7@Free@2
  00015	85 f6		 test	 esi, esi
  00017	74 26		 je	 SHORT $LN7@Free@2
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	85 c0		 test	 eax, eax
  0001d	74 07		 je	 SHORT $LN15@Free@2
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN15@Free@2:
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $LN14@Free@2
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00033	83 c4 04	 add	 esp, 4
$LN14@Free@2:
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN7@Free@2:

; 639  :         m_Data = NULL;

  0003f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN1@Free@2:
  00045	5e		 pop	 esi

; 640  :     }
; 641  : }

  00046	c3		 ret	 0
?_Free@_bstr_t@@AAEXXZ ENDP				; _bstr_t::_Free
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPA_WXZ
_TEXT	SEGMENT
??B_bstr_t@@QBEPA_WXZ PROC				; _bstr_t::operator wchar_t *, COMDAT
; _this$ = eax

; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	85 c0		 test	 eax, eax
  00004	74 03		 je	 SHORT $LN3@operator
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 480  : }

  00008	c3		 ret	 0
$LN3@operator:

; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

  00009	33 c0		 xor	 eax, eax

; 480  : }

  0000b	c3		 ret	 0
??B_bstr_t@@QBEPA_WXZ ENDP				; _bstr_t::operator wchar_t *
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT
??1_bstr_t@@QAE@XZ PROC					; _bstr_t::~_bstr_t, COMDAT
; _this$ = edi

; 342  : {

  00000	56		 push	 esi

; 343  :     _Free();

  00001	8b 37		 mov	 esi, DWORD PTR [edi]
  00003	85 f6		 test	 esi, esi
  00005	74 3e		 je	 SHORT $LN3@bstr_t
  00007	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4
  00011	85 c0		 test	 eax, eax
  00013	75 2a		 jne	 SHORT $LN9@bstr_t
  00015	85 f6		 test	 esi, esi
  00017	74 26		 je	 SHORT $LN9@bstr_t
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	85 c0		 test	 eax, eax
  0001d	74 07		 je	 SHORT $LN17@bstr_t
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN17@bstr_t:
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	85 c0		 test	 eax, eax
  0002b	74 09		 je	 SHORT $LN16@bstr_t
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00033	83 c4 04	 add	 esp, 4
$LN16@bstr_t:
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003c	83 c4 04	 add	 esp, 4
$LN9@bstr_t:
  0003f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@bstr_t:
  00045	5e		 pop	 esi

; 344  : }

  00046	c3		 ret	 0
??1_bstr_t@@QAE@XZ ENDP					; _bstr_t::~_bstr_t
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_bstr_t@@QAE@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_bstr_t@@QAE@PB_W@Z$0
__ehfuncinfo$??0_bstr_t@@QAE@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_bstr_t@@QAE@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0_bstr_t@@QAE@PB_W@Z
_TEXT	SEGMENT
$T165815 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0_bstr_t@@QAE@PB_W@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ebx

; 322  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0_bstr_t@@QAE@PB_W@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	6a 0c		 push	 12			; 0000000cH
  00024	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00029	8b f0		 mov	 esi, eax
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 74 24 08	 mov	 DWORD PTR $T165815[esp+24], esi
  00032	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0003a	85 f6		 test	 esi, esi
  0003c	74 29		 je	 SHORT $LN4@bstr_t@2
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2?$AA?$AA@
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004a	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  00057	89 06		 mov	 DWORD PTR [esi], eax
  00059	85 c0		 test	 eax, eax
  0005b	75 0c		 jne	 SHORT $LN5@bstr_t@2
  0005d	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00062	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN16@bstr_t@2:
$LN4@bstr_t@2:
  00067	33 f6		 xor	 esi, esi
$LN5@bstr_t@2:
  00069	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  00071	89 33		 mov	 DWORD PTR [ebx], esi

; 323  :     if (m_Data == NULL) {

  00073	85 f6		 test	 esi, esi
  00075	75 0a		 jne	 SHORT $LN1@bstr_t@2

; 324  :         _com_issue_error(E_OUTOFMEMORY);

  00077	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0007c	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN17@bstr_t@2:
$LN1@bstr_t@2:

; 325  :     }
; 326  : }

  00081	8b c3		 mov	 eax, ebx
  00083	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5e		 pop	 esi
  00090	83 c4 10	 add	 esp, 16			; 00000010H
  00093	c3		 ret	 0
$LN15@bstr_t@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_bstr_t@@QAE@PB_W@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T165815[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$??0_bstr_t@@QAE@PB_W@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_bstr_t@@QAE@PB_W@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_bstr_t@@QAE@PB_W@Z ENDP				; _bstr_t::_bstr_t
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_bstr_t@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_bstr_t@@QAE@PBD@Z$0
__ehfuncinfo$??0_bstr_t@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_bstr_t@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
$T165842 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??0_bstr_t@@QAE@PBD@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ebx

; 312  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0_bstr_t@@QAE@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	6a 0c		 push	 12			; 0000000cH
  00024	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00029	8b f0		 mov	 esi, eax
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 74 24 08	 mov	 DWORD PTR $T165842[esp+24], esi
  00032	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0003a	85 f6		 test	 esi, esi
  0003c	74 1c		 je	 SHORT $LN4@bstr_t@3
  0003e	8b 44 24 1c	 mov	 eax, DWORD PTR _s$[esp+20]
  00042	50		 push	 eax
  00043	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004a	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00051	e8 00 00 00 00	 call	 ?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
  00056	89 06		 mov	 DWORD PTR [esi], eax
  00058	eb 02		 jmp	 SHORT $LN5@bstr_t@3
$LN4@bstr_t@3:
  0005a	33 f6		 xor	 esi, esi
$LN5@bstr_t@3:
  0005c	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  00064	89 33		 mov	 DWORD PTR [ebx], esi

; 313  :     if (m_Data == NULL) {

  00066	85 f6		 test	 esi, esi
  00068	75 0a		 jne	 SHORT $LN1@bstr_t@3

; 314  :         _com_issue_error(E_OUTOFMEMORY);

  0006a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0006f	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN13@bstr_t@3:
$LN1@bstr_t@3:

; 315  :     }
; 316  : }

  00074	8b c3		 mov	 eax, ebx
  00076	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5e		 pop	 esi
  00083	83 c4 10	 add	 esp, 16			; 00000010H
  00086	c2 04 00	 ret	 4
$LN12@bstr_t@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_bstr_t@@QAE@PBD@Z$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T165842[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$??0_bstr_t@@QAE@PBD@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_bstr_t@@QAE@PBD@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_bstr_t@@QAE@PBD@Z ENDP				; _bstr_t::_bstr_t
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Has_container@_Iterator_base_secure@std@@QBE_NXZ
_TEXT	SEGMENT
?_Has_container@_Iterator_base_secure@std@@QBE_NXZ PROC	; std::_Iterator_base_secure::_Has_container, COMDAT
; _this$ = ecx

; 582  : 		return _Mycont != 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 95 c0	 setne	 al

; 583  : 		}

  00007	c3		 ret	 0
?_Has_container@_Iterator_base_secure@std@@QBE_NXZ ENDP	; std::_Iterator_base_secure::_Has_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_secure@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
?_Same_container@_Iterator_base_secure@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_secure::_Same_container, COMDAT
; _this$ = eax
; __Other$ = edx

; 577  : 		return _Mycont == _Other._Mycont;

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 578  : 		}

  00009	c3		 ret	 0
?_Same_container@_Iterator_base_secure@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_secure::_Same_container
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_secure@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base_secure@std@@QAE@XZ PROC		; std::_Iterator_base_secure::_Iterator_base_secure, COMDAT
; _this$ = eax

; 567  : 		{

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 568  : 		}

  00006	c3		 ret	 0
??0_Iterator_base_secure@std@@QAE@XZ ENDP		; std::_Iterator_base_secure::_Iterator_base_secure
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN7@Fill_n@11
  00004	56		 push	 esi
$LL9@Fill_n@11:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL9@Fill_n@11
  00011	5e		 pop	 esi
$LN7@Fill_n@11:

; 3255 : 	}

  00012	c3		 ret	 0
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<double *,unsigned int,double>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN7@Fill_n@12
$LL9@Fill_n@12:
  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	48		 dec	 eax
  00007	dd 19		 fstp	 QWORD PTR [ecx]
  00009	83 c1 08	 add	 ecx, 8
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL9@Fill_n@12
$LN7@Fill_n@12:

; 3255 : 	}

  00010	c3		 ret	 0
??$_Fill_n@PANIN@std@@YAXPANIABNUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<float *,unsigned int,float>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN7@Fill_n@13
$LL9@Fill_n@13:
  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	48		 dec	 eax
  00007	d9 19		 fstp	 DWORD PTR [ecx]
  00009	83 c1 04	 add	 ecx, 4
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL9@Fill_n@13
$LN7@Fill_n@13:

; 3255 : 	}

  00010	c3		 ret	 0
??$_Fill_n@PAMIM@std@@YAXPAMIABMUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned __int64 *,unsigned int,unsigned __int64>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c9		 test	 ecx, ecx
  00002	76 14		 jbe	 SHORT $LN7@Fill_n@14
  00004	56		 push	 esi
$LL9@Fill_n@14:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	49		 dec	 ecx
  00010	83 c0 08	 add	 eax, 8
  00013	85 c9		 test	 ecx, ecx
  00015	77 ee		 ja	 SHORT $LL9@Fill_n@14
  00017	5e		 pop	 esi
$LN7@Fill_n@14:

; 3255 : 	}

  00018	c3		 ret	 0
??$_Fill_n@PA_KI_K@std@@YAXPA_KIAB_KUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned __int64 *,unsigned int,unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAKIK@std@@YAXPAKIABKUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PAKIK@std@@YAXPAKIABKUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned long *,unsigned int,unsigned long>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN7@Fill_n@15
  00004	56		 push	 esi
$LL9@Fill_n@15:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL9@Fill_n@15
  00011	5e		 pop	 esi
$LN7@Fill_n@15:

; 3255 : 	}

  00012	c3		 ret	 0
??$_Fill_n@PAKIK@std@@YAXPAKIABKUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned long *,unsigned int,unsigned long>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAGIG@std@@YAXPAGIABGUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PAGIG@std@@YAXPAGIABGUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned short *,unsigned int,unsigned short>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 10		 jbe	 SHORT $LN7@Fill_n@16
  00004	56		 push	 esi
$LL9@Fill_n@16:
  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 31	 mov	 WORD PTR [ecx], si
  0000b	48		 dec	 eax
  0000c	83 c1 02	 add	 ecx, 2
  0000f	85 c0		 test	 eax, eax
  00011	77 f2		 ja	 SHORT $LL9@Fill_n@16
  00013	5e		 pop	 esi
$LN7@Fill_n@16:

; 3255 : 	}

  00014	c3		 ret	 0
??$_Fill_n@PAGIG@std@@YAXPAGIABGUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned short *,unsigned int,unsigned short>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAEIE@std@@YAXPAEIABEUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Fill_n@PAEIE@std@@YAXPAEIABEUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned char *,unsigned int,unsigned char>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = esi

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0a		 jbe	 SHORT $LN7@Fill_n@17
$LL9@Fill_n@17:
  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 11		 mov	 BYTE PTR [ecx], dl
  00008	48		 dec	 eax
  00009	41		 inc	 ecx
  0000a	85 c0		 test	 eax, eax
  0000c	77 f6		 ja	 SHORT $LL9@Fill_n@17
$LN7@Fill_n@17:

; 3255 : 	}

  0000e	c3		 ret	 0
??$_Fill_n@PAEIE@std@@YAXPAEIABEUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned char *,unsigned int,unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN16@unchecked_@12
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@12:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 823  : 	}

  00023	c3		 ret	 0
??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN16@unchecked_@13
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@13:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 823  : 	}

  00023	c3		 ret	 0
??$unchecked_uninitialized_copy@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN16@unchecked_@14
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@14:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 823  : 	}

  00023	c3		 ret	 0
??$unchecked_uninitialized_copy@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN16@unchecked_@15
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@15:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 823  : 	}

  00023	c3		 ret	 0
??$unchecked_uninitialized_copy@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN16@unchecked_@16
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@16:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 823  : 	}

  00023	c3		 ret	 0
??$unchecked_uninitialized_copy@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned long *,unsigned long *,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c2		 sub	 eax, edx
  00002	d1 f8		 sar	 eax, 1
  00004	8d 04 00	 lea	 eax, DWORD PTR [eax+eax]
  00007	56		 push	 esi
  00008	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0000b	74 0c		 je	 SHORT $LN16@unchecked_@17
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _memmove_s
  00016	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@17:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi

; 823  : 	}

  0001c	c3		 ret	 0
??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi
  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00006	74 0c		 je	 SHORT $LN16@unchecked_@18
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _memmove_s
  00011	83 c4 10	 add	 esp, 16			; 00000010H
$LN16@unchecked_@18:
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 823  : 	}

  00017	c3		 ret	 0
??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z PROC ; stdext::unchecked_fill_n<wchar_t * *,unsigned int,wchar_t *>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN11@unchecked_@19
  00004	56		 push	 esi
$LL13@unchecked_@19:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL13@unchecked_@19
  00011	5e		 pop	 esi
$LN11@unchecked_@19:

; 3722 : 	}

  00012	c3		 ret	 0
??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z ENDP ; stdext::unchecked_fill_n<wchar_t * *,unsigned int,wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z PROC	; stdext::unchecked_fill_n<double *,unsigned int,double>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN11@unchecked_@20
$LL13@unchecked_@20:
  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	48		 dec	 eax
  00007	dd 19		 fstp	 QWORD PTR [ecx]
  00009	83 c1 08	 add	 ecx, 8
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL13@unchecked_@20
$LN11@unchecked_@20:

; 3722 : 	}

  00010	c3		 ret	 0
??$unchecked_fill_n@PANIN@stdext@@YAXPANIABN@Z ENDP	; stdext::unchecked_fill_n<double *,unsigned int,double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z PROC	; stdext::unchecked_fill_n<float *,unsigned int,float>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN11@unchecked_@21
$LL13@unchecked_@21:
  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	48		 dec	 eax
  00007	d9 19		 fstp	 DWORD PTR [ecx]
  00009	83 c1 04	 add	 ecx, 4
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL13@unchecked_@21
$LN11@unchecked_@21:

; 3722 : 	}

  00010	c3		 ret	 0
??$unchecked_fill_n@PAMIM@stdext@@YAXPAMIABM@Z ENDP	; stdext::unchecked_fill_n<float *,unsigned int,float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PA_KI_K@stdext@@YAXPA_KIAB_K@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PA_KI_K@stdext@@YAXPA_KIAB_K@Z PROC	; stdext::unchecked_fill_n<unsigned __int64 *,unsigned int,unsigned __int64>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c9		 test	 ecx, ecx
  00002	76 14		 jbe	 SHORT $LN11@unchecked_@22
  00004	56		 push	 esi
$LL13@unchecked_@22:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	49		 dec	 ecx
  00010	83 c0 08	 add	 eax, 8
  00013	85 c9		 test	 ecx, ecx
  00015	77 ee		 ja	 SHORT $LL13@unchecked_@22
  00017	5e		 pop	 esi
$LN11@unchecked_@22:

; 3722 : 	}

  00018	c3		 ret	 0
??$unchecked_fill_n@PA_KI_K@stdext@@YAXPA_KIAB_K@Z ENDP	; stdext::unchecked_fill_n<unsigned __int64 *,unsigned int,unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAKIK@stdext@@YAXPAKIABK@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PAKIK@stdext@@YAXPAKIABK@Z PROC	; stdext::unchecked_fill_n<unsigned long *,unsigned int,unsigned long>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN11@unchecked_@23
  00004	56		 push	 esi
$LL13@unchecked_@23:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL13@unchecked_@23
  00011	5e		 pop	 esi
$LN11@unchecked_@23:

; 3722 : 	}

  00012	c3		 ret	 0
??$unchecked_fill_n@PAKIK@stdext@@YAXPAKIABK@Z ENDP	; stdext::unchecked_fill_n<unsigned long *,unsigned int,unsigned long>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAGIG@stdext@@YAXPAGIABG@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PAGIG@stdext@@YAXPAGIABG@Z PROC	; stdext::unchecked_fill_n<unsigned short *,unsigned int,unsigned short>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 10		 jbe	 SHORT $LN11@unchecked_@24
  00004	56		 push	 esi
$LL13@unchecked_@24:
  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 31	 mov	 WORD PTR [ecx], si
  0000b	48		 dec	 eax
  0000c	83 c1 02	 add	 ecx, 2
  0000f	85 c0		 test	 eax, eax
  00011	77 f2		 ja	 SHORT $LL13@unchecked_@24
  00013	5e		 pop	 esi
$LN11@unchecked_@24:

; 3722 : 	}

  00014	c3		 ret	 0
??$unchecked_fill_n@PAGIG@stdext@@YAXPAGIABG@Z ENDP	; stdext::unchecked_fill_n<unsigned short *,unsigned int,unsigned short>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAEIE@stdext@@YAXPAEIABE@Z
_TEXT	SEGMENT
??$unchecked_fill_n@PAEIE@stdext@@YAXPAEIABE@Z PROC	; stdext::unchecked_fill_n<unsigned char *,unsigned int,unsigned char>, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = esi

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0a		 jbe	 SHORT $LN11@unchecked_@25
$LL13@unchecked_@25:
  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 11		 mov	 BYTE PTR [ecx], dl
  00008	48		 dec	 eax
  00009	41		 inc	 ecx
  0000a	85 c0		 test	 eax, eax
  0000c	77 f6		 ja	 SHORT $LL13@unchecked_@25
$LN11@unchecked_@25:

; 3722 : 	}

  0000e	c3		 ret	 0
??$unchecked_fill_n@PAEIE@stdext@@YAXPAEIABE@Z ENDP	; stdext::unchecked_fill_n<unsigned char *,unsigned int,unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN18@Uninit_mov
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 208  : 	}

  00023	c3		 ret	 0
??$_Uninit_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN18@Uninit_mov@2
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov@2:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 208  : 	}

  00023	c3		 ret	 0
??$_Uninit_move@PANPANV?$allocator@N@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00AAV?$allocator@N@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<double *,double *,std::allocator<double>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<float *,float *,std::allocator<float>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN18@Uninit_mov@3
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov@3:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 208  : 	}

  00023	c3		 ret	 0
??$_Uninit_move@PAMPAMV?$allocator@M@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00AAV?$allocator@M@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<float *,float *,std::allocator<float>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PA_KPA_KV?$allocator@_K@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PA_KPA_KV?$allocator@_K@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN18@Uninit_mov@4
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov@4:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 208  : 	}

  00023	c3		 ret	 0
??$_Uninit_move@PA_KPA_KV?$allocator@_K@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00AAV?$allocator@_K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAKPAKV?$allocator@K@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAKPAKV?$allocator@K@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned long *,unsigned long *,std::allocator<unsigned long>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN18@Uninit_mov@5
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov@5:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 208  : 	}

  00023	c3		 ret	 0
??$_Uninit_move@PAKPAKV?$allocator@K@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00AAV?$allocator@K@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned long *,unsigned long *,std::allocator<unsigned long>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAGPAGV?$allocator@G@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAGPAGV?$allocator@G@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned short *,unsigned short *,std::allocator<unsigned short>,std::_Undefined_move_tag>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c2		 sub	 eax, edx
  00002	d1 f8		 sar	 eax, 1
  00004	8d 04 00	 lea	 eax, DWORD PTR [eax+eax]
  00007	56		 push	 esi
  00008	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0000b	74 0c		 je	 SHORT $LN18@Uninit_mov@6
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _memmove_s
  00016	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov@6:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi

; 208  : 	}

  0001c	c3		 ret	 0
??$_Uninit_move@PAGPAGV?$allocator@G@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned short *,unsigned short *,std::allocator<unsigned short>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAEPAEV?$allocator@E@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAEPAEV?$allocator@E@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned char *,unsigned char *,std::allocator<unsigned char>,std::_Undefined_move_tag>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi
  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00006	74 0c		 je	 SHORT $LN18@Uninit_mov@7
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _memmove_s
  00011	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@Uninit_mov@7:
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 208  : 	}

  00017	c3		 ret	 0
??$_Uninit_move@PAEPAEV?$allocator@E@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned char *,unsigned char *,std::allocator<unsigned char>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN13@Uninit_fil@2
  00004	56		 push	 esi
$LL15@Uninit_fil@2:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL15@Uninit_fil@2
  00011	5e		 pop	 esi
$LN13@Uninit_fil@2:

; 420  : 	}

  00012	c3		 ret	 0
??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN13@Uninit_fil@3
$LL15@Uninit_fil@3:
  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	48		 dec	 eax
  00007	dd 19		 fstp	 QWORD PTR [ecx]
  00009	83 c1 08	 add	 ecx, 8
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL15@Uninit_fil@3
$LN13@Uninit_fil@3:

; 420  : 	}

  00010	c3		 ret	 0
??$_Uninit_fill_n@PANINV?$allocator@N@std@@@std@@YAXPANIABNAAV?$allocator@N@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<double *,unsigned int,double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN13@Uninit_fil@4
$LL15@Uninit_fil@4:
  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	48		 dec	 eax
  00007	d9 19		 fstp	 DWORD PTR [ecx]
  00009	83 c1 04	 add	 ecx, 4
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL15@Uninit_fil@4
$LN13@Uninit_fil@4:

; 420  : 	}

  00010	c3		 ret	 0
??$_Uninit_fill_n@PAMIMV?$allocator@M@std@@@std@@YAXPAMIABMAAV?$allocator@M@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<float *,unsigned int,float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PA_KI_KV?$allocator@_K@std@@@std@@YAXPA_KIAB_KAAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PA_KI_KV?$allocator@_K@std@@@std@@YAXPA_KIAB_KAAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned __int64 *,unsigned int,unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c9		 test	 ecx, ecx
  00002	76 14		 jbe	 SHORT $LN13@Uninit_fil@5
  00004	56		 push	 esi
$LL15@Uninit_fil@5:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	49		 dec	 ecx
  00010	83 c0 08	 add	 eax, 8
  00013	85 c9		 test	 ecx, ecx
  00015	77 ee		 ja	 SHORT $LL15@Uninit_fil@5
  00017	5e		 pop	 esi
$LN13@Uninit_fil@5:

; 420  : 	}

  00018	c3		 ret	 0
??$_Uninit_fill_n@PA_KI_KV?$allocator@_K@std@@@std@@YAXPA_KIAB_KAAV?$allocator@_K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned __int64 *,unsigned int,unsigned __int64,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN13@Uninit_fil@6
  00004	56		 push	 esi
$LL15@Uninit_fil@6:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL15@Uninit_fil@6
  00011	5e		 pop	 esi
$LN13@Uninit_fil@6:

; 420  : 	}

  00012	c3		 ret	 0
??$_Uninit_fill_n@PAKIKV?$allocator@K@std@@@std@@YAXPAKIABKAAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAGIGV?$allocator@G@std@@@std@@YAXPAGIABGAAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAGIGV?$allocator@G@std@@@std@@YAXPAGIABGAAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned short *,unsigned int,unsigned short,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c0		 test	 eax, eax
  00002	76 10		 jbe	 SHORT $LN13@Uninit_fil@7
  00004	56		 push	 esi
$LL15@Uninit_fil@7:
  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 31	 mov	 WORD PTR [ecx], si
  0000b	48		 dec	 eax
  0000c	83 c1 02	 add	 ecx, 2
  0000f	85 c0		 test	 eax, eax
  00011	77 f2		 ja	 SHORT $LL15@Uninit_fil@7
  00013	5e		 pop	 esi
$LN13@Uninit_fil@7:

; 420  : 	}

  00014	c3		 ret	 0
??$_Uninit_fill_n@PAGIGV?$allocator@G@std@@@std@@YAXPAGIABGAAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned short *,unsigned int,unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = esi

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

  00000	85 c0		 test	 eax, eax
  00002	76 0a		 jbe	 SHORT $LN13@Uninit_fil@8
$LL15@Uninit_fil@8:
  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 11		 mov	 BYTE PTR [ecx], dl
  00008	48		 dec	 eax
  00009	41		 inc	 ecx
  0000a	85 c0		 test	 eax, eax
  0000c	77 f6		 ja	 SHORT $LL15@Uninit_fil@8
$LN13@Uninit_fil@8:

; 420  : 	}

  0000e	c3		 ret	 0
??$_Uninit_fill_n@PAEIEV?$allocator@E@std@@@std@@YAXPAEIABEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN8@Move_backw
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 2755 : 	}

  00024	c3		 ret	 0
??$_Move_backward_opt@PAPA_WPAPA_WUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAPA_WPAPA_W00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<wchar_t * *,wchar_t * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN30@Unchecked_
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 865  : 	}

  00023	c3		 ret	 0
??$_Unchecked_uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN8@Move_backw@2
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw@2:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 2755 : 	}

  00024	c3		 ret	 0
??$_Move_backward_opt@PANPANUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPANPAN00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<double *,double *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN30@Unchecked_@2
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_@2:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 865  : 	}

  00023	c3		 ret	 0
??$_Unchecked_uninitialized_move@PANPANV?$allocator@N@std@@@stdext@@YAPANPAN00AAV?$allocator@N@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<double *,double *,std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<float *,float *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN8@Move_backw@3
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw@3:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 2755 : 	}

  00024	c3		 ret	 0
??$_Move_backward_opt@PAMPAMUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAMPAM00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<float *,float *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<float *,float *,std::allocator<float> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN30@Unchecked_@3
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_@3:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 865  : 	}

  00023	c3		 ret	 0
??$_Unchecked_uninitialized_move@PAMPAMV?$allocator@M@std@@@stdext@@YAPAMPAM00AAV?$allocator@M@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<float *,float *,std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN8@Move_backw@4
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw@4:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 2755 : 	}

  00024	c3		 ret	 0
??$_Move_backward_opt@PA_KPA_KUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPA_KPA_K00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned __int64 *,unsigned __int64 *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN30@Unchecked_@4
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_@4:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 865  : 	}

  00023	c3		 ret	 0
??$_Unchecked_uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@stdext@@YAPA_KPA_K00AAV?$allocator@_K@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN8@Move_backw@5
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw@5:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 2755 : 	}

  00024	c3		 ret	 0
??$_Move_backward_opt@PAKPAKUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAKPAK00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned long *,unsigned long *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN30@Unchecked_@5
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_@5:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 865  : 	}

  00023	c3		 ret	 0
??$_Unchecked_uninitialized_move@PAKPAKV?$allocator@K@std@@@stdext@@YAPAKPAK00AAV?$allocator@K@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c7		 sub	 eax, edi
  00002	d1 f8		 sar	 eax, 1
  00004	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  00007	2b ca		 sub	 ecx, edx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	7e 0c		 jle	 SHORT $LN8@Move_backw@6
  00010	52		 push	 edx
  00011	57		 push	 edi
  00012	52		 push	 edx
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _memmove_s
  00019	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw@6:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi

; 2755 : 	}

  0001f	c3		 ret	 0
??$_Move_backward_opt@PAGPAGUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c2		 sub	 eax, edx
  00002	d1 f8		 sar	 eax, 1
  00004	8d 04 00	 lea	 eax, DWORD PTR [eax+eax]
  00007	56		 push	 esi
  00008	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0000b	74 0c		 je	 SHORT $LN30@Unchecked_@6
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _memmove_s
  00016	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_@6:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi

; 865  : 	}

  0001c	c3		 ret	 0
??$_Unchecked_uninitialized_move@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

  00000	2b c2		 sub	 eax, edx
  00002	2b c8		 sub	 ecx, eax
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	85 c0		 test	 eax, eax
  00009	7e 0c		 jle	 SHORT $LN8@Move_backw@7
  0000b	50		 push	 eax
  0000c	52		 push	 edx
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove_s
  00014	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@Move_backw@7:
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 2755 : 	}

  0001a	c3		 ret	 0
??$_Move_backward_opt@PAEPAEUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi
  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00006	74 0c		 je	 SHORT $LN30@Unchecked_@7
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _memmove_s
  00011	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@Unchecked_@7:
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 865  : 	}

  00017	c3		 ret	 0
??$_Unchecked_uninitialized_move@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN17@unchecked_@26
  00004	56		 push	 esi
$LL19@unchecked_@26:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL19@unchecked_@26
  00011	5e		 pop	 esi
$LN17@unchecked_@26:

; 943  : 	}

  00012	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN17@unchecked_@27
$LL19@unchecked_@27:
  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	48		 dec	 eax
  00007	dd 19		 fstp	 QWORD PTR [ecx]
  00009	83 c1 08	 add	 ecx, 8
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL19@unchecked_@27
$LN17@unchecked_@27:

; 943  : 	}

  00010	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PANINV?$allocator@N@std@@@stdext@@YAXPANIABNAAV?$allocator@N@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<double *,unsigned int,double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0c		 jbe	 SHORT $LN17@unchecked_@28
$LL19@unchecked_@28:
  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	48		 dec	 eax
  00007	d9 19		 fstp	 DWORD PTR [ecx]
  00009	83 c1 04	 add	 ecx, 4
  0000c	85 c0		 test	 eax, eax
  0000e	77 f4		 ja	 SHORT $LL19@unchecked_@28
$LN17@unchecked_@28:

; 943  : 	}

  00010	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PAMIMV?$allocator@M@std@@@stdext@@YAXPAMIABMAAV?$allocator@M@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<float *,unsigned int,float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PA_KI_KV?$allocator@_K@std@@@stdext@@YAXPA_KIAB_KAAV?$allocator@_K@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PA_KI_KV?$allocator@_K@std@@@stdext@@YAXPA_KIAB_KAAV?$allocator@_K@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned __int64 *,unsigned int,unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c9		 test	 ecx, ecx
  00002	76 14		 jbe	 SHORT $LN17@unchecked_@29
  00004	56		 push	 esi
$LL19@unchecked_@29:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	49		 dec	 ecx
  00010	83 c0 08	 add	 eax, 8
  00013	85 c9		 test	 ecx, ecx
  00015	77 ee		 ja	 SHORT $LL19@unchecked_@29
  00017	5e		 pop	 esi
$LN17@unchecked_@29:

; 943  : 	}

  00018	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PA_KI_KV?$allocator@_K@std@@@stdext@@YAXPA_KIAB_KAAV?$allocator@_K@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned __int64 *,unsigned int,unsigned __int64,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAKIKV?$allocator@K@std@@@stdext@@YAXPAKIABKAAV?$allocator@K@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PAKIKV?$allocator@K@std@@@stdext@@YAXPAKIABKAAV?$allocator@K@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0e		 jbe	 SHORT $LN17@unchecked_@30
  00004	56		 push	 esi
$LL19@unchecked_@30:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 31		 mov	 DWORD PTR [ecx], esi
  00009	48		 dec	 eax
  0000a	83 c1 04	 add	 ecx, 4
  0000d	85 c0		 test	 eax, eax
  0000f	77 f4		 ja	 SHORT $LL19@unchecked_@30
  00011	5e		 pop	 esi
$LN17@unchecked_@30:

; 943  : 	}

  00012	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PAKIKV?$allocator@K@std@@@stdext@@YAXPAKIABKAAV?$allocator@K@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned long *,unsigned int,unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAGIGV?$allocator@G@std@@@stdext@@YAXPAGIABGAAV?$allocator@G@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PAGIGV?$allocator@G@std@@@stdext@@YAXPAGIABGAAV?$allocator@G@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned short *,unsigned int,unsigned short,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 10		 jbe	 SHORT $LN17@unchecked_@31
  00004	56		 push	 esi
$LL19@unchecked_@31:
  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 31	 mov	 WORD PTR [ecx], si
  0000b	48		 dec	 eax
  0000c	83 c1 02	 add	 ecx, 2
  0000f	85 c0		 test	 eax, eax
  00011	77 f2		 ja	 SHORT $LL19@unchecked_@31
  00013	5e		 pop	 esi
$LN17@unchecked_@31:

; 943  : 	}

  00014	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PAGIGV?$allocator@G@std@@@stdext@@YAXPAGIABGAAV?$allocator@G@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned short *,unsigned int,unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAEIEV?$allocator@E@std@@@stdext@@YAXPAEIABEAAV?$allocator@E@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_fill_n@PAEIEV?$allocator@E@std@@@stdext@@YAXPAEIABEAAV?$allocator@E@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Count$ = eax
; __Val$ = esi

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

  00000	85 c0		 test	 eax, eax
  00002	76 0a		 jbe	 SHORT $LN17@unchecked_@32
$LL19@unchecked_@32:
  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 11		 mov	 BYTE PTR [ecx], dl
  00008	48		 dec	 eax
  00009	41		 inc	 ecx
  0000a	85 c0		 test	 eax, eax
  0000c	77 f6		 ja	 SHORT $LL19@unchecked_@32
$LN17@unchecked_@32:

; 943  : 	}

  0000e	c3		 ret	 0
??$unchecked_uninitialized_fill_n@PAEIEV?$allocator@E@std@@@stdext@@YAXPAEIABEAAV?$allocator@E@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned char *,unsigned int,unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z PROC ; stdext::_Unchecked_move_backward<wchar_t * *,wchar_t * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN22@Unchecked_@8
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@8:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 3697 : 	}

  00024	c3		 ret	 0
??$_Unchecked_move_backward@PAPA_WPAPA_W@stdext@@YAPAPA_WPAPA_W00@Z ENDP ; stdext::_Unchecked_move_backward<wchar_t * *,wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z
_TEXT	SEGMENT
??$fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z PROC		; std::fill<wchar_t * *,wchar_t *>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0d		 je	 SHORT $LN11@fill@2
  00004	56		 push	 esi
$LL13@fill@2:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	83 c0 04	 add	 eax, 4
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f5		 jne	 SHORT $LL13@fill@2
  00010	5e		 pop	 esi
$LN11@fill@2:

; 3188 : 	}

  00011	c3		 ret	 0
??$fill@PAPA_WPA_W@std@@YAXPAPA_W0ABQA_W@Z ENDP		; std::fill<wchar_t * *,wchar_t *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z
_TEXT	SEGMENT
??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN32@Umove
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 1149 : 		}

  00023	c3		 ret	 0
??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z PROC ; stdext::_Unchecked_move_backward<double *,double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN22@Unchecked_@9
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@9:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 3697 : 	}

  00024	c3		 ret	 0
??$_Unchecked_move_backward@PANPAN@stdext@@YAPANPAN00@Z ENDP ; stdext::_Unchecked_move_backward<double *,double *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PANN@std@@YAXPAN0ABN@Z
_TEXT	SEGMENT
??$fill@PANN@std@@YAXPAN0ABN@Z PROC			; std::fill<double *,double>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0c		 je	 SHORT $LN11@fill@3
$LL13@fill@3:
  00004	dd 02		 fld	 QWORD PTR [edx]
  00006	83 c0 08	 add	 eax, 8
  00009	dd 58 f8	 fstp	 QWORD PTR [eax-8]
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f4		 jne	 SHORT $LL13@fill@3
$LN11@fill@3:

; 3188 : 	}

  00010	c3		 ret	 0
??$fill@PANN@std@@YAXPAN0ABN@Z ENDP			; std::fill<double *,double>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z
_TEXT	SEGMENT
??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z PROC ; std::vector<double,std::allocator<double> >::_Umove<double *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN32@Umove@2
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove@2:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 1149 : 		}

  00023	c3		 ret	 0
??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove<double *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z PROC ; stdext::_Unchecked_move_backward<float *,float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN22@Unchecked_@10
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@10:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 3697 : 	}

  00024	c3		 ret	 0
??$_Unchecked_move_backward@PAMPAM@stdext@@YAPAMPAM00@Z ENDP ; stdext::_Unchecked_move_backward<float *,float *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAMM@std@@YAXPAM0ABM@Z
_TEXT	SEGMENT
??$fill@PAMM@std@@YAXPAM0ABM@Z PROC			; std::fill<float *,float>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0c		 je	 SHORT $LN11@fill@4
$LL13@fill@4:
  00004	d9 02		 fld	 DWORD PTR [edx]
  00006	83 c0 04	 add	 eax, 4
  00009	d9 58 fc	 fstp	 DWORD PTR [eax-4]
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f4		 jne	 SHORT $LL13@fill@4
$LN11@fill@4:

; 3188 : 	}

  00010	c3		 ret	 0
??$fill@PAMM@std@@YAXPAM0ABM@Z ENDP			; std::fill<float *,float>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z
_TEXT	SEGMENT
??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Umove<float *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN32@Umove@3
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove@3:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 1149 : 		}

  00023	c3		 ret	 0
??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove<float *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PA_KPA_K@stdext@@YAPA_KPA_K00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PA_KPA_K@stdext@@YAPA_KPA_K00@Z PROC ; stdext::_Unchecked_move_backward<unsigned __int64 *,unsigned __int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN22@Unchecked_@11
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@11:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 3697 : 	}

  00024	c3		 ret	 0
??$_Unchecked_move_backward@PA_KPA_K@stdext@@YAPA_KPA_K00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned __int64 *,unsigned __int64 *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PA_K_K@std@@YAXPA_K0AB_K@Z
_TEXT	SEGMENT
??$fill@PA_K_K@std@@YAXPA_K0AB_K@Z PROC			; std::fill<unsigned __int64 *,unsigned __int64>, COMDAT
; __First$ = eax
; __Last$ = edx
; __Val$ = ecx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c2		 cmp	 eax, edx
  00002	74 13		 je	 SHORT $LN11@fill@5
  00004	56		 push	 esi
$LL13@fill@5:
  00005	8b 31		 mov	 esi, DWORD PTR [ecx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0000c	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0000f	83 c0 08	 add	 eax, 8
  00012	3b c2		 cmp	 eax, edx
  00014	75 ef		 jne	 SHORT $LL13@fill@5
  00016	5e		 pop	 esi
$LN11@fill@5:

; 3188 : 	}

  00017	c3		 ret	 0
??$fill@PA_K_K@std@@YAXPA_K0AB_K@Z ENDP			; std::fill<unsigned __int64 *,unsigned __int64>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z
_TEXT	SEGMENT
??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 03	 sar	 eax, 3
  00005	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN32@Umove@4
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove@4:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 1149 : 		}

  00023	c3		 ret	 0
??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAKPAK@stdext@@YAPAKPAK00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAKPAK@stdext@@YAPAKPAK00@Z PROC ; stdext::_Unchecked_move_backward<unsigned long *,unsigned long *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0000c	2b ca		 sub	 ecx, edx
  0000e	56		 push	 esi
  0000f	8b f1		 mov	 esi, ecx
  00011	85 c0		 test	 eax, eax
  00013	7e 0c		 jle	 SHORT $LN22@Unchecked_@12
  00015	52		 push	 edx
  00016	57		 push	 edi
  00017	52		 push	 edx
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@12:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi

; 3697 : 	}

  00024	c3		 ret	 0
??$_Unchecked_move_backward@PAKPAK@stdext@@YAPAKPAK00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned long *,unsigned long *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAKK@std@@YAXPAK0ABK@Z
_TEXT	SEGMENT
??$fill@PAKK@std@@YAXPAK0ABK@Z PROC			; std::fill<unsigned long *,unsigned long>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0d		 je	 SHORT $LN11@fill@6
  00004	56		 push	 esi
$LL13@fill@6:
  00005	8b 32		 mov	 esi, DWORD PTR [edx]
  00007	89 30		 mov	 DWORD PTR [eax], esi
  00009	83 c0 04	 add	 eax, 4
  0000c	3b c1		 cmp	 eax, ecx
  0000e	75 f5		 jne	 SHORT $LL13@fill@6
  00010	5e		 pop	 esi
$LN11@fill@6:

; 3188 : 	}

  00011	c3		 ret	 0
??$fill@PAKK@std@@YAXPAK0ABK@Z ENDP			; std::fill<unsigned long *,unsigned long>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT
??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c7		 sub	 eax, edi
  00002	c1 f8 02	 sar	 eax, 2
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000c	56		 push	 esi
  0000d	8d 34 11	 lea	 esi, DWORD PTR [ecx+edx]
  00010	85 c0		 test	 eax, eax
  00012	76 0c		 jbe	 SHORT $LN32@Umove@5
  00014	51		 push	 ecx
  00015	57		 push	 edi
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _memmove_s
  0001d	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove@5:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 1149 : 		}

  00023	c3		 ret	 0
??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAGPAG@stdext@@YAPAGPAG00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAGPAG@stdext@@YAPAGPAG00@Z PROC ; stdext::_Unchecked_move_backward<unsigned short *,unsigned short *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c7		 sub	 eax, edi
  00002	d1 f8		 sar	 eax, 1
  00004	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  00007	2b ca		 sub	 ecx, edx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	85 c0		 test	 eax, eax
  0000e	7e 0c		 jle	 SHORT $LN22@Unchecked_@13
  00010	52		 push	 edx
  00011	57		 push	 edi
  00012	52		 push	 edx
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _memmove_s
  00019	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@13:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi

; 3697 : 	}

  0001f	c3		 ret	 0
??$_Unchecked_move_backward@PAGPAG@stdext@@YAPAGPAG00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned short *,unsigned short *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAGG@std@@YAXPAG0ABG@Z
_TEXT	SEGMENT
??$fill@PAGG@std@@YAXPAG0ABG@Z PROC			; std::fill<unsigned short *,unsigned short>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c1		 cmp	 eax, ecx
  00002	74 0f		 je	 SHORT $LN11@fill@7
  00004	56		 push	 esi
$LL13@fill@7:
  00005	66 8b 32	 mov	 si, WORD PTR [edx]
  00008	66 89 30	 mov	 WORD PTR [eax], si
  0000b	83 c0 02	 add	 eax, 2
  0000e	3b c1		 cmp	 eax, ecx
  00010	75 f3		 jne	 SHORT $LL13@fill@7
  00012	5e		 pop	 esi
$LN11@fill@7:

; 3188 : 	}

  00013	c3		 ret	 0
??$fill@PAGG@std@@YAXPAG0ABG@Z ENDP			; std::fill<unsigned short *,unsigned short>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z
_TEXT	SEGMENT
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Ptr$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c2		 sub	 eax, edx
  00002	d1 f8		 sar	 eax, 1
  00004	8d 04 00	 lea	 eax, DWORD PTR [eax+eax]
  00007	56		 push	 esi
  00008	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  0000b	74 0c		 je	 SHORT $LN32@Umove@6
  0000d	50		 push	 eax
  0000e	52		 push	 edx
  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 _memmove_s
  00016	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove@6:
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi

; 1149 : 		}

  0001c	c3		 ret	 0
??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAEPAE@stdext@@YAPAEPAE00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAEPAE@stdext@@YAPAEPAE00@Z PROC ; stdext::_Unchecked_move_backward<unsigned char *,unsigned char *>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

  00000	2b c2		 sub	 eax, edx
  00002	2b c8		 sub	 ecx, eax
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	85 c0		 test	 eax, eax
  00009	7e 0c		 jle	 SHORT $LN22@Unchecked_@14
  0000b	50		 push	 eax
  0000c	52		 push	 edx
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove_s
  00014	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@Unchecked_@14:
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 3697 : 	}

  0001a	c3		 ret	 0
??$_Unchecked_move_backward@PAEPAE@stdext@@YAPAEPAE00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned char *,unsigned char *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAEE@std@@YAXPAE0ABE@Z
_TEXT	SEGMENT
??$fill@PAEE@std@@YAXPAE0ABE@Z PROC			; std::fill<unsigned char *,unsigned char>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

  00000	3b c1		 cmp	 eax, ecx
  00002	74 09		 je	 SHORT $LN11@fill@8
$LL13@fill@8:
  00004	8a 16		 mov	 dl, BYTE PTR [esi]
  00006	88 10		 mov	 BYTE PTR [eax], dl
  00008	40		 inc	 eax
  00009	3b c1		 cmp	 eax, ecx
  0000b	75 f7		 jne	 SHORT $LL13@fill@8
$LN11@fill@8:

; 3188 : 	}

  0000d	c3		 ret	 0
??$fill@PAEE@std@@YAXPAE0ABE@Z ENDP			; std::fill<unsigned char *,unsigned char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT
??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Ptr$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

  00000	2b c2		 sub	 eax, edx
  00002	56		 push	 esi
  00003	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  00006	74 0c		 je	 SHORT $LN32@Umove@7
  00008	50		 push	 eax
  00009	52		 push	 edx
  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _memmove_s
  00011	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@Umove@7:
  00014	8b c6		 mov	 eax, esi
  00016	5e		 pop	 esi

; 1149 : 		}

  00017	c3		 ret	 0
??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_WIABQA_W@Z
_TEXT	SEGMENT
?_Ufill@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_WIABQA_W@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b c6		 mov	 eax, esi
  00002	8b cf		 mov	 ecx, edi
  00004	85 f6		 test	 esi, esi
  00006	76 15		 jbe	 SHORT $LN26@Ufill
  00008	53		 push	 ebx
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL21@Ufill:
  00010	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00012	89 19		 mov	 DWORD PTR [ecx], ebx
  00014	48		 dec	 eax
  00015	83 c1 04	 add	 ecx, 4
  00018	85 c0		 test	 eax, eax
  0001a	77 f4		 ja	 SHORT $LL21@Ufill
  0001c	5b		 pop	 ebx
$LN26@Ufill:

; 1255 : 		return (_Ptr + _Count);

  0001d	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

  00020	c3		 ret	 0
?_Ufill@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_WIABQA_W@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z
_TEXT	SEGMENT
?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z PROC ; std::vector<double,std::allocator<double> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b c6		 mov	 eax, esi
  00002	8b cf		 mov	 ecx, edi
  00004	85 f6		 test	 esi, esi
  00006	76 0c		 jbe	 SHORT $LN26@Ufill@2
$LL21@Ufill@2:
  00008	dd 02		 fld	 QWORD PTR [edx]
  0000a	48		 dec	 eax
  0000b	dd 19		 fstp	 QWORD PTR [ecx]
  0000d	83 c1 08	 add	 ecx, 8
  00010	85 c0		 test	 eax, eax
  00012	77 f4		 ja	 SHORT $LL21@Ufill@2
$LN26@Ufill@2:

; 1255 : 		return (_Ptr + _Count);

  00014	8d 04 f7	 lea	 eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

  00017	c3		 ret	 0
?_Ufill@?$vector@NV?$allocator@N@std@@@std@@IAEPANPANIABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z
_TEXT	SEGMENT
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z PROC ; std::vector<float,std::allocator<float> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b c6		 mov	 eax, esi
  00002	8b cf		 mov	 ecx, edi
  00004	85 f6		 test	 esi, esi
  00006	76 0c		 jbe	 SHORT $LN26@Ufill@3
$LL21@Ufill@3:
  00008	d9 02		 fld	 DWORD PTR [edx]
  0000a	48		 dec	 eax
  0000b	d9 19		 fstp	 DWORD PTR [ecx]
  0000d	83 c1 04	 add	 ecx, 4
  00010	85 c0		 test	 eax, eax
  00012	77 f4		 ja	 SHORT $LL21@Ufill@3
$LN26@Ufill@3:

; 1255 : 		return (_Ptr + _Count);

  00014	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

  00017	c3		 ret	 0
?_Ufill@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAMIABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_KIAB_K@Z
_TEXT	SEGMENT
?_Ufill@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_KIAB_K@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b ce		 mov	 ecx, esi
  00002	8b c7		 mov	 eax, edi
  00004	85 f6		 test	 esi, esi
  00006	76 1b		 jbe	 SHORT $LN26@Ufill@4
  00008	53		 push	 ebx
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL21@Ufill@4:
  00010	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00012	89 18		 mov	 DWORD PTR [eax], ebx
  00014	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00017	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0001a	49		 dec	 ecx
  0001b	83 c0 08	 add	 eax, 8
  0001e	85 c9		 test	 ecx, ecx
  00020	77 ee		 ja	 SHORT $LL21@Ufill@4
  00022	5b		 pop	 ebx
$LN26@Ufill@4:

; 1255 : 		return (_Ptr + _Count);

  00023	8d 04 f7	 lea	 eax, DWORD PTR [edi+esi*8]

; 1256 : 		}

  00026	c3		 ret	 0
?_Ufill@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_KIAB_K@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z
_TEXT	SEGMENT
?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b c6		 mov	 eax, esi
  00002	8b cf		 mov	 ecx, edi
  00004	85 f6		 test	 esi, esi
  00006	76 15		 jbe	 SHORT $LN26@Ufill@5
  00008	53		 push	 ebx
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL21@Ufill@5:
  00010	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00012	89 19		 mov	 DWORD PTR [ecx], ebx
  00014	48		 dec	 eax
  00015	83 c1 04	 add	 ecx, 4
  00018	85 c0		 test	 eax, eax
  0001a	77 f4		 ja	 SHORT $LL21@Ufill@5
  0001c	5b		 pop	 ebx
$LN26@Ufill@5:

; 1255 : 		return (_Ptr + _Count);

  0001d	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]

; 1256 : 		}

  00020	c3		 ret	 0
?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAGIABG@Z
_TEXT	SEGMENT
?_Ufill@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAGIABG@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00000	8b c6		 mov	 eax, esi
  00002	8b cf		 mov	 ecx, edi
  00004	85 f6		 test	 esi, esi
  00006	76 17		 jbe	 SHORT $LN26@Ufill@6
  00008	53		 push	 ebx
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL21@Ufill@6:
  00010	66 8b 1a	 mov	 bx, WORD PTR [edx]
  00013	66 89 19	 mov	 WORD PTR [ecx], bx
  00016	48		 dec	 eax
  00017	83 c1 02	 add	 ecx, 2
  0001a	85 c0		 test	 eax, eax
  0001c	77 f2		 ja	 SHORT $LL21@Ufill@6
  0001e	5b		 pop	 ebx
$LN26@Ufill@6:

; 1255 : 		return (_Ptr + _Count);

  0001f	8d 04 77	 lea	 eax, DWORD PTR [edi+esi*2]

; 1256 : 		}

  00022	c3		 ret	 0
?_Ufill@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAGIABG@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill, COMDAT
; __Count$ = esi
; __Val$ = edi

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR __Ptr$[esp]

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  00005	8b c6		 mov	 eax, esi
  00007	8b cd		 mov	 ecx, ebp
  00009	85 f6		 test	 esi, esi
  0000b	76 0d		 jbe	 SHORT $LN26@Ufill@7
  0000d	8d 49 00	 npad	 3
$LL21@Ufill@7:
  00010	8a 17		 mov	 dl, BYTE PTR [edi]
  00012	88 11		 mov	 BYTE PTR [ecx], dl
  00014	48		 dec	 eax
  00015	41		 inc	 ecx
  00016	85 c0		 test	 eax, eax
  00018	77 f6		 ja	 SHORT $LL21@Ufill@7
$LN26@Ufill@7:

; 1255 : 		return (_Ptr + _Count);

  0001a	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  0001d	5d		 pop	 ebp

; 1256 : 		}

  0001e	c2 04 00	 ret	 4
?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z
_TEXT	SEGMENT
$T172853 = -12						; size = 12
??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z PROC		; std::_Allocate<wchar_t *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 04	 cmp	 eax, 4
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172853[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172853[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@2:
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	03 c9		 add	 ecx, ecx
  0002b	03 c9		 add	 ecx, ecx
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4

; 44   : 	}

  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	c3		 ret	 0
$LN10@Allocate@2:
??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z ENDP		; std::_Allocate<wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@N@std@@YAPANIPAN@Z
_TEXT	SEGMENT
$T172863 = -12						; size = 12
??$_Allocate@N@std@@YAPANIPAN@Z PROC			; std::_Allocate<double>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172863[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172863[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@3:
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	03 c9		 add	 ecx, ecx
  0002b	03 c9		 add	 ecx, ecx
  0002d	03 c9		 add	 ecx, ecx
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4

; 44   : 	}

  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
$LN10@Allocate@3:
??$_Allocate@N@std@@YAPANIPAN@Z ENDP			; std::_Allocate<double>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@M@std@@YAPAMIPAM@Z
_TEXT	SEGMENT
$T172873 = -12						; size = 12
??$_Allocate@M@std@@YAPAMIPAM@Z PROC			; std::_Allocate<float>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 04	 cmp	 eax, 4
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172873[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172873[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@4:
$LN1@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	03 c9		 add	 ecx, ecx
  0002b	03 c9		 add	 ecx, ecx
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4

; 44   : 	}

  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	c3		 ret	 0
$LN10@Allocate@4:
??$_Allocate@M@std@@YAPAMIPAM@Z ENDP			; std::_Allocate<float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@_K@std@@YAPA_KIPA_K@Z
_TEXT	SEGMENT
$T172883 = -12						; size = 12
??$_Allocate@_K@std@@YAPA_KIPA_K@Z PROC			; std::_Allocate<unsigned __int64>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 08	 cmp	 eax, 8
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172883[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172883[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@5:
$LN1@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	03 c9		 add	 ecx, ecx
  0002b	03 c9		 add	 ecx, ecx
  0002d	03 c9		 add	 ecx, ecx
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4

; 44   : 	}

  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
$LN10@Allocate@5:
??$_Allocate@_K@std@@YAPA_KIPA_K@Z ENDP			; std::_Allocate<unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT
$T172893 = -12						; size = 12
??$_Allocate@K@std@@YAPAKIPAK@Z PROC			; std::_Allocate<unsigned long>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 04	 cmp	 eax, 4
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172893[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172893[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@6:
$LN1@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	03 c9		 add	 ecx, ecx
  0002b	03 c9		 add	 ecx, ecx
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4

; 44   : 	}

  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	c3		 ret	 0
$LN10@Allocate@6:
??$_Allocate@K@std@@YAPAKIPAK@Z ENDP			; std::_Allocate<unsigned long>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@G@std@@YAPAGIPAG@Z
_TEXT	SEGMENT
$T172903 = -12						; size = 12
??$_Allocate@G@std@@YAPAGIPAG@Z PROC			; std::_Allocate<unsigned short>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 02	 cmp	 eax, 2
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172903[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172903[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@7:
$LN1@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	03 c9		 add	 ecx, ecx
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00031	83 c4 04	 add	 esp, 4

; 44   : 	}

  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	c3		 ret	 0
$LN10@Allocate@7:
??$_Allocate@G@std@@YAPAGIPAG@Z ENDP			; std::_Allocate<unsigned short>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT
$T172913 = -12						; size = 12
??$_Allocate@E@std@@YAPAEIPAE@Z PROC			; std::_Allocate<unsigned char>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

  00000	83 c8 ff	 or	 eax, -1
  00003	33 d2		 xor	 edx, edx
  00005	f7 f1		 div	 ecx
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	73 1a		 jae	 SHORT $LN1@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

  0000f	6a 00		 push	 0
  00011	8d 4c 24 04	 lea	 ecx, DWORD PTR $T172913[esp+16]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0001a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0001f	8d 44 24 04	 lea	 eax, DWORD PTR $T172913[esp+16]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN11@Allocate@8:
$LN1@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4

; 44   : 	}

  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	c3		 ret	 0
$LN10@Allocate@8:
??$_Allocate@E@std@@YAPAEIPAE@Z ENDP			; std::_Allocate<unsigned char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PA_WHPBQA_WABQA_WV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PA_WHPBQA_WABQA_WV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,wchar_t *,int,wchar_t * const *,wchar_t * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,wchar_t *,int,wchar_t * const *,wchar_t * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PA_WHPBQA_WABQA_WV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,wchar_t *,int,wchar_t * const *,wchar_t * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,wchar_t *,int,wchar_t * const *,wchar_t * const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@NHPBNABNV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,double,int,double const *,double const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@MHPBMABMV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,float,int,float const *,float const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_KHPB_KAB_KV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_KHPB_KAB_KV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_KHPB_KAB_KV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@KHPBKABKV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@KHPBKABKV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned long,int,unsigned long const *,unsigned long const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned long,int,unsigned long const *,unsigned long const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@KHPBKABKV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned long,int,unsigned long const *,unsigned long const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned long,int,unsigned long const *,unsigned long const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PA_WHPBQA_WABQA_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@PA_WHPBQA_WABQA_W@std@@QAE@XZ PROC		; std::_Ranit<wchar_t *,int,wchar_t * const *,wchar_t * const &>::_Ranit<wchar_t *,int,wchar_t * const *,wchar_t * const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@PA_WHPBQA_WABQA_W@std@@QAE@XZ ENDP		; std::_Ranit<wchar_t *,int,wchar_t * const *,wchar_t * const &>::_Ranit<wchar_t *,int,wchar_t * const *,wchar_t * const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@NHPBNABN@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@NHPBNABN@std@@QAE@XZ PROC			; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@NHPBNABN@std@@QAE@XZ ENDP			; std::_Ranit<double,int,double const *,double const &>::_Ranit<double,int,double const *,double const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@MHPBMABM@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@MHPBMABM@std@@QAE@XZ PROC			; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@MHPBMABM@std@@QAE@XZ ENDP			; std::_Ranit<float,int,float const *,float const &>::_Ranit<float,int,float const *,float const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@_KHPB_KAB_K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@_KHPB_KAB_K@std@@QAE@XZ PROC		; std::_Ranit<unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &>::_Ranit<unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@_KHPB_KAB_K@std@@QAE@XZ ENDP		; std::_Ranit<unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &>::_Ranit<unsigned __int64,int,unsigned __int64 const *,unsigned __int64 const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@KHPBKABK@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@KHPBKABK@std@@QAE@XZ PROC			; std::_Ranit<unsigned long,int,unsigned long const *,unsigned long const &>::_Ranit<unsigned long,int,unsigned long const *,unsigned long const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@KHPBKABK@std@@QAE@XZ ENDP			; std::_Ranit<unsigned long,int,unsigned long const *,unsigned long const &>::_Ranit<unsigned long,int,unsigned long const *,unsigned long const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@GHPBGABG@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@GHPBGABG@std@@QAE@XZ PROC			; std::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@GHPBGABG@std@@QAE@XZ ENDP			; std::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@EHPBEABE@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@EHPBEABE@std@@QAE@XZ PROC			; std::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit@EHPBEABE@std@@QAE@XZ ENDP			; std::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ PROC ; std::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>, COMDAT
; _this$ = eax
  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c3		 ret	 0
??0?$_Ranit_base@DHPBDABDV_Iterator_base_secure@std@@@std@@QAE@XZ ENDP ; std::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>::_Ranit_base<char,int,char const *,char const &,std::_Iterator_base_secure>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@2
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@2
$LN4@operator@2:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@2:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con
$LN4@Vector_con:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@3
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@3
$LN4@operator@3:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@3:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con@2
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con@2
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con@2
$LN4@Vector_con@2:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::_Vector_const_iterator<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@4
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@4
$LN4@operator@4:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@4:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con@3
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con@3
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con@3
$LN4@Vector_con@3:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::_Vector_const_iterator<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@5
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@5
$LN4@operator@5:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@5:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con@4
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con@4
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con@4
$LN4@Vector_con@4:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@6
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@6
$LN4@operator@6:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@6:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con@5
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con@5
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con@5
$LN4@Vector_con@5:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@7
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@7
$LN4@operator@7:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@7:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con@6
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con@6
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con@6
$LN4@Vector_con@6:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN4@operator@8
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN3@operator@8
$LN4@operator@8:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@8:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 94 c1	 sete	 cl
  0001a	8a c1		 mov	 al, cl

; 212  : 		}

  0001c	c3		 ret	 0
??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN4@Vector_con@7
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN4@Vector_con@7
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN3@Vector_con@7
$LN4@Vector_con@7:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 81   : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??G?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 200  : 
; 201  :  #if _HAS_ITERATOR_DEBUGGING
; 202  : 		_Compat(_Right);
; 203  :  #else
; 204  : 		if (this->_Mycont != _IGNORE_MYCONT)

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00005	74 0d		 je	 SHORT $LN1@operator@9

; 205  : 		{
; 206  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

  00007	85 c0		 test	 eax, eax
  00009	74 04		 je	 SHORT $LN4@operator@9
  0000b	3b 06		 cmp	 eax, DWORD PTR [esi]
  0000d	74 05		 je	 SHORT $LN1@operator@9
$LN4@operator@9:
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1@operator@9:

; 207  : 		}
; 208  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 209  : 
; 210  : 		return (_Myptr - _Right._Myptr);

  00014	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00017	2b 46 04	 sub	 eax, DWORD PTR [esi+4]

; 211  : 		}

  0001a	c3		 ret	 0
??G?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z PROC ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ebx
; __Ptr$ = edi
; __Pstring$ = esi

; 83   : 		__CLR_OR_THIS_CALL _String_const_iterator(pointer _Ptr, const _Container_base_secure *_Pstring)

  00000	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 84   : 			{	// construct with pointer _Ptr
; 85   : 			_SCL_SECURE_VALIDATE(

  00006	85 f6		 test	 esi, esi
  00008	74 29		 je	 SHORT $LN4@String_con
  0000a	85 ff		 test	 edi, edi
  0000c	74 25		 je	 SHORT $LN4@String_con
  0000e	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00011	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00014	83 fa 10	 cmp	 edx, 16			; 00000010H
  00017	72 04		 jb	 SHORT $LN14@String_con
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	eb 02		 jmp	 SHORT $LN15@String_con
$LN14@String_con:
  0001d	8b c8		 mov	 ecx, eax
$LN15@String_con:
  0001f	3b cf		 cmp	 ecx, edi
  00021	77 10		 ja	 SHORT $LN4@String_con
  00023	83 fa 10	 cmp	 edx, 16			; 00000010H
  00026	72 02		 jb	 SHORT $LN18@String_con
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
$LN18@String_con:
  0002a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002d	03 c8		 add	 ecx, eax
  0002f	3b f9		 cmp	 edi, ecx
  00031	76 05		 jbe	 SHORT $LN3@String_con
$LN4@String_con:

; 86   : 				_Pstring != NULL && 
; 87   : 				_Ptr != NULL && 
; 88   : 				((_Mystring *)_Pstring)->_Myptr() <= _Ptr && _Ptr <= (((_Mystring *)_Pstring)->_Myptr() + ((_Mystring *)_Pstring)->_Mysize));

  00033	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@String_con:

; 89   : 			this->_Mycont = _Pstring;

  00038	89 33		 mov	 DWORD PTR [ebx], esi

; 90   : 			_Myptr = _Ptr;

  0003a	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 91   : 			}

  0003d	8b c3		 mov	 eax, ebx
  0003f	c3		 ret	 0
??0?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDPBV_Container_base_secure@1@@Z ENDP ; std::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_const_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@10
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@10
$LN6@operator@10:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@10:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite
$LN6@Vector_ite:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAE@PAPA_WPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@11
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@11
$LN6@operator@11:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@11:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite@2
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite@2
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite@2
$LN6@Vector_ite@2:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite@2:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAE@PANPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::_Vector_iterator<double,std::allocator<double> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@12
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@12
$LN6@operator@12:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@12:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite@3
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite@3
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite@3
$LN6@Vector_ite@3:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite@3:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAE@PAMPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::_Vector_iterator<float,std::allocator<float> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@13
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@13
$LN6@operator@13:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@13:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite@4
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite@4
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite@4
$LN6@Vector_ite@4:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite@4:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAE@PA_KPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@14
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@14
$LN6@operator@14:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@14:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::_Vector_iterator<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite@5
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite@5
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite@5
$LN6@Vector_ite@5:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite@5:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAE@PAKPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::_Vector_iterator<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@15
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@15
$LN6@operator@15:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@15:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite@6
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite@6
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite@6
$LN6@Vector_ite@6:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite@6:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

  00000	8b 07		 mov	 eax, DWORD PTR [edi]
  00002	85 c0		 test	 eax, eax
  00004	74 04		 je	 SHORT $LN6@operator@16
  00006	3b 06		 cmp	 eax, DWORD PTR [esi]
  00008	74 05		 je	 SHORT $LN5@operator@16
$LN6@operator@16:
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@operator@16:
  0000f	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00012	33 c9		 xor	 ecx, ecx
  00014	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00017	0f 95 c1	 setne	 cl
  0001a	8a c1		 mov	 al, cl

; 217  : 		}

  0001c	c3		 ret	 0
??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = edi
; __Ptr$ = ebx
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

  00000	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00006	85 f6		 test	 esi, esi
  00008	74 0a		 je	 SHORT $LN6@Vector_ite@7
  0000a	39 5e 0c	 cmp	 DWORD PTR [esi+12], ebx
  0000d	77 05		 ja	 SHORT $LN6@Vector_ite@7
  0000f	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00012	76 05		 jbe	 SHORT $LN5@Vector_ite@7
$LN6@Vector_ite@7:
  00014	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@Vector_ite@7:
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 328  : 		}

  00020	8b c7		 mov	 eax, edi
  00022	c3		 ret	 0
??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z
_TEXT	SEGMENT
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z PROC ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ebx
; __Ptr$ = edi
; __Pstring$ = esi

; 341  : 			{	// construct with pointer _Ptr

  00000	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00006	85 f6		 test	 esi, esi
  00008	74 29		 je	 SHORT $LN6@String_ite
  0000a	85 ff		 test	 edi, edi
  0000c	74 25		 je	 SHORT $LN6@String_ite
  0000e	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00011	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00014	83 fa 10	 cmp	 edx, 16			; 00000010H
  00017	72 04		 jb	 SHORT $LN16@String_ite
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	eb 02		 jmp	 SHORT $LN17@String_ite
$LN16@String_ite:
  0001d	8b c8		 mov	 ecx, eax
$LN17@String_ite:
  0001f	3b cf		 cmp	 ecx, edi
  00021	77 10		 ja	 SHORT $LN6@String_ite
  00023	83 fa 10	 cmp	 edx, 16			; 00000010H
  00026	72 02		 jb	 SHORT $LN20@String_ite
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
$LN20@String_ite:
  0002a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002d	03 c8		 add	 ecx, eax
  0002f	3b f9		 cmp	 edi, ecx
  00031	76 05		 jbe	 SHORT $LN5@String_ite
$LN6@String_ite:
  00033	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN5@String_ite:
  00038	89 33		 mov	 DWORD PTR [ebx], esi
  0003a	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 342  : 			}

  0003d	8b c3		 mov	 eax, ebx
  0003f	c3		 ret	 0
??0?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PADPBV_Container_base_secure@1@@Z ENDP ; std::_String_iterator<char,std::char_traits<char>,std::allocator<char> >::_String_iterator<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z
_TEXT	SEGMENT
$T173750 = -12						; size = 12
?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z PROC	; std::allocator<wchar_t *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 13		 ja	 SHORT $LN5@allocate@2
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@2:
  00009	03 c9		 add	 ecx, ecx
  0000b	03 c9		 add	 ecx, ecx
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4

; 146  : 		}

  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@2:
  0001a	83 c8 ff	 or	 eax, -1
  0001d	33 d2		 xor	 edx, edx
  0001f	f7 f1		 div	 ecx
  00021	83 f8 04	 cmp	 eax, 4
  00024	73 e3		 jae	 SHORT $LN3@allocate@2
  00026	6a 00		 push	 0
  00028	8d 4c 24 04	 lea	 ecx, DWORD PTR $T173750[esp+16]
  0002c	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 44 24 04	 lea	 eax, DWORD PTR $T173750[esp+16]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@2:
$LN9@allocate@2:
  00040	cc		 int	 3
?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z ENDP	; std::allocator<wchar_t *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter
$LN8@Make_iter:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@N@std@@QAEPANI@Z
_TEXT	SEGMENT
$T173821 = -12						; size = 12
?allocate@?$allocator@N@std@@QAEPANI@Z PROC		; std::allocator<double>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 15		 ja	 SHORT $LN5@allocate@3
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@3:
  00009	03 c9		 add	 ecx, ecx
  0000b	03 c9		 add	 ecx, ecx
  0000d	03 c9		 add	 ecx, ecx
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4

; 146  : 		}

  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@3:
  0001c	83 c8 ff	 or	 eax, -1
  0001f	33 d2		 xor	 edx, edx
  00021	f7 f1		 div	 ecx
  00023	83 f8 08	 cmp	 eax, 8
  00026	73 e1		 jae	 SHORT $LN3@allocate@3
  00028	6a 00		 push	 0
  0002a	8d 4c 24 04	 lea	 ecx, DWORD PTR $T173821[esp+16]
  0002e	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00033	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00038	8d 44 24 04	 lea	 eax, DWORD PTR $T173821[esp+16]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@3:
$LN9@allocate@3:
  00042	cc		 int	 3
?allocate@?$allocator@N@std@@QAEPANI@Z ENDP		; std::allocator<double>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@@Z PROC ; std::vector<double,std::allocator<double> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter@2
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter@2
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter@2
$LN8@Make_iter@2:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@2:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@NV?$allocator@N@std@@@std@@QBE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@@Z ENDP ; std::vector<double,std::allocator<double> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
$T173892 = -12						; size = 12
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 13		 ja	 SHORT $LN5@allocate@4
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@4:
  00009	03 c9		 add	 ecx, ecx
  0000b	03 c9		 add	 ecx, ecx
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4

; 146  : 		}

  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@4:
  0001a	83 c8 ff	 or	 eax, -1
  0001d	33 d2		 xor	 edx, edx
  0001f	f7 f1		 div	 ecx
  00021	83 f8 04	 cmp	 eax, 4
  00024	73 e3		 jae	 SHORT $LN3@allocate@4
  00026	6a 00		 push	 0
  00028	8d 4c 24 04	 lea	 ecx, DWORD PTR $T173892[esp+16]
  0002c	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 44 24 04	 lea	 eax, DWORD PTR $T173892[esp+16]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@4:
$LN9@allocate@4:
  00040	cc		 int	 3
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter@3
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter@3
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter@3
$LN8@Make_iter@3:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@3:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@MV?$allocator@M@std@@@std@@QBE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_K@std@@QAEPA_KI@Z
_TEXT	SEGMENT
$T173963 = -12						; size = 12
?allocate@?$allocator@_K@std@@QAEPA_KI@Z PROC		; std::allocator<unsigned __int64>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 15		 ja	 SHORT $LN5@allocate@5
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@5:
  00009	03 c9		 add	 ecx, ecx
  0000b	03 c9		 add	 ecx, ecx
  0000d	03 c9		 add	 ecx, ecx
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4

; 146  : 		}

  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@5:
  0001c	83 c8 ff	 or	 eax, -1
  0001f	33 d2		 xor	 edx, edx
  00021	f7 f1		 div	 ecx
  00023	83 f8 08	 cmp	 eax, 8
  00026	73 e1		 jae	 SHORT $LN3@allocate@5
  00028	6a 00		 push	 0
  0002a	8d 4c 24 04	 lea	 ecx, DWORD PTR $T173963[esp+16]
  0002e	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00033	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00038	8d 44 24 04	 lea	 eax, DWORD PTR $T173963[esp+16]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@5:
$LN9@allocate@5:
  00042	cc		 int	 3
?allocate@?$allocator@_K@std@@QAEPA_KI@Z ENDP		; std::allocator<unsigned __int64>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@_KV?$allocator@_K@std@@@std@@QBE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@_KV?$allocator@_K@std@@@std@@QBE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter@4
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter@4
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter@4
$LN8@Make_iter@4:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@4:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@_KV?$allocator@_K@std@@@std@@QBE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
$T174034 = -12						; size = 12
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC		; std::allocator<unsigned long>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 13		 ja	 SHORT $LN5@allocate@6
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@6:
  00009	03 c9		 add	 ecx, ecx
  0000b	03 c9		 add	 ecx, ecx
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4

; 146  : 		}

  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@6:
  0001a	83 c8 ff	 or	 eax, -1
  0001d	33 d2		 xor	 edx, edx
  0001f	f7 f1		 div	 ecx
  00021	83 f8 04	 cmp	 eax, 4
  00024	73 e3		 jae	 SHORT $LN3@allocate@6
  00026	6a 00		 push	 0
  00028	8d 4c 24 04	 lea	 ecx, DWORD PTR $T174034[esp+16]
  0002c	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 44 24 04	 lea	 eax, DWORD PTR $T174034[esp+16]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@6:
$LN9@allocate@6:
  00040	cc		 int	 3
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter@5
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter@5
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter@5
$LN8@Make_iter@5:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@5:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@KV?$allocator@K@std@@@std@@QBE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT
$T174101 = -12						; size = 12
?allocate@?$allocator@G@std@@QAEPAGI@Z PROC		; std::allocator<unsigned short>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 11		 ja	 SHORT $LN5@allocate@7
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@7:
  00009	03 c9		 add	 ecx, ecx
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4

; 146  : 		}

  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@7:
  00018	83 c8 ff	 or	 eax, -1
  0001b	33 d2		 xor	 edx, edx
  0001d	f7 f1		 div	 ecx
  0001f	83 f8 02	 cmp	 eax, 2
  00022	73 e5		 jae	 SHORT $LN3@allocate@7
  00024	6a 00		 push	 0
  00026	8d 4c 24 04	 lea	 ecx, DWORD PTR $T174101[esp+16]
  0002a	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0002f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00034	8d 44 24 04	 lea	 eax, DWORD PTR $T174101[esp+16]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@7:
$LN9@allocate@7:
  0003e	cc		 int	 3
?allocate@?$allocator@G@std@@QAEPAGI@Z ENDP		; std::allocator<unsigned short>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter@6
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter@6
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter@6
$LN8@Make_iter@6:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@6:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
$T174172 = -12						; size = 12
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 145  : 		return (_Allocate(_Count, (pointer)0));

  00003	85 c9		 test	 ecx, ecx
  00005	77 0f		 ja	 SHORT $LN5@allocate@8
  00007	33 c9		 xor	 ecx, ecx
$LN3@allocate@8:
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000f	83 c4 04	 add	 esp, 4

; 146  : 		}

  00012	83 c4 0c	 add	 esp, 12			; 0000000cH
  00015	c3		 ret	 0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@8:
  00016	83 c8 ff	 or	 eax, -1
  00019	33 d2		 xor	 edx, edx
  0001b	f7 f1		 div	 ecx
  0001d	83 f8 01	 cmp	 eax, 1
  00020	73 e7		 jae	 SHORT $LN3@allocate@8
  00022	6a 00		 push	 0
  00024	8d 4c 24 04	 lea	 ecx, DWORD PTR $T174172[esp+16]
  00028	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0002d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00032	8d 44 24 04	 lea	 eax, DWORD PTR $T174172[esp+16]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@allocate@8:
$LN9@allocate@8:
  0003c	cc		 int	 3
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

  00000	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00006	85 ff		 test	 edi, edi
  00008	74 0e		 je	 SHORT $LN8@Make_iter@7
  0000a	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
  0000e	39 47 0c	 cmp	 DWORD PTR [edi+12], eax
  00011	77 05		 ja	 SHORT $LN8@Make_iter@7
  00013	3b 47 10	 cmp	 eax, DWORD PTR [edi+16]
  00016	76 09		 jbe	 SHORT $LN7@Make_iter@7
$LN8@Make_iter@7:
  00018	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001d	8b 44 24 08	 mov	 eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@7:
  00021	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00023	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
  00028	8b c6		 mov	 eax, esi

; 662  : 		}

  0002a	c2 08 00	 ret	 8
?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KAIV?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__P2$ = 8						; size = 8
__P1$ = 16						; size = 8
?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KAIV?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Pdif, COMDAT

; 2143 : 		return (_STR_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __P2$[esp]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $LN3@Pdif

; 2144 : 		}

  00008	c3		 ret	 0
$LN3@Pdif:

; 2143 : 		return (_STR_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);

  00009	8b 4c 24 04	 mov	 ecx, DWORD PTR __P2$[esp-4]
  0000d	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00010	74 13		 je	 SHORT $LN5@Pdif
  00012	85 c9		 test	 ecx, ecx
  00014	74 06		 je	 SHORT $LN8@Pdif
  00016	3b 4c 24 0c	 cmp	 ecx, DWORD PTR __P1$[esp-4]
  0001a	74 09		 je	 SHORT $LN5@Pdif
$LN8@Pdif:
  0001c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00021	8b 44 24 08	 mov	 eax, DWORD PTR __P2$[esp]
$LN5@Pdif:
  00025	2b 44 24 10	 sub	 eax, DWORD PTR __P1$[esp]

; 2144 : 		}

  00029	c3		 ret	 0
?_Pdif@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@KAIV?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Pdif
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase
$LN11@erase:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase
$LN30@erase:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase
$LN47@erase:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase:
  00052	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00055	3b d7		 cmp	 edx, edi
  00057	74 25		 je	 SHORT $LN72@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	c1 f8 02	 sar	 eax, 2
  00061	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00068	8d 2c 11	 lea	 ebp, DWORD PTR [ecx+edx]
  0006b	85 c0		 test	 eax, eax
  0006d	7e 0c		 jle	 SHORT $LN69@erase
  0006f	51		 push	 ecx
  00070	57		 push	 edi
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _memmove_s
  00078	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  0007b	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  0007e	5f		 pop	 edi
  0007f	8b c3		 mov	 eax, ebx
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@XZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z PROC ; std::vector<double,std::allocator<double> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase@2
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase@2
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase@2
$LN11@erase@2:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase@2:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase@2
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase@2
$LN30@erase@2:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase@2:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase@2
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase@2
$LN47@erase@2:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase@2:
  00052	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00055	3b d7		 cmp	 edx, edi
  00057	74 25		 je	 SHORT $LN72@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	c1 f8 03	 sar	 eax, 3
  00061	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00068	8d 2c 11	 lea	 ebp, DWORD PTR [ecx+edx]
  0006b	85 c0		 test	 eax, eax
  0006d	7e 0c		 jle	 SHORT $LN69@erase@2
  0006f	51		 push	 ecx
  00070	57		 push	 edi
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _memmove_s
  00078	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  0007b	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  0007e	5f		 pop	 edi
  0007f	8b c3		 mov	 eax, ebx
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z ENDP ; std::vector<double,std::allocator<double> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end@2
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end@2:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin@2
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin@2:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z PROC ; std::vector<float,std::allocator<float> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase@3
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase@3
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase@3
$LN11@erase@3:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase@3:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase@3
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase@3
$LN30@erase@3:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase@3:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase@3
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase@3
$LN47@erase@3:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase@3:
  00052	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00055	3b d7		 cmp	 edx, edi
  00057	74 25		 je	 SHORT $LN72@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	c1 f8 02	 sar	 eax, 2
  00061	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00068	8d 2c 11	 lea	 ebp, DWORD PTR [ecx+edx]
  0006b	85 c0		 test	 eax, eax
  0006d	7e 0c		 jle	 SHORT $LN69@erase@3
  0006f	51		 push	 ecx
  00070	57		 push	 edi
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _memmove_s
  00078	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase@3:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  0007b	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  0007e	5f		 pop	 edi
  0007f	8b c3		 mov	 eax, ebx
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ENDP ; std::vector<float,std::allocator<float> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end@3
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end@3:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ PROC ; std::vector<float,std::allocator<float> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin@3
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin@3:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@XZ ENDP ; std::vector<float,std::allocator<float> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase@4
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase@4
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase@4
$LN11@erase@4:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase@4:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase@4
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase@4
$LN30@erase@4:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase@4:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase@4
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase@4
$LN47@erase@4:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase@4:
  00052	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00055	3b d7		 cmp	 edx, edi
  00057	74 25		 je	 SHORT $LN72@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	c1 f8 03	 sar	 eax, 3
  00061	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00068	8d 2c 11	 lea	 ebp, DWORD PTR [ecx+edx]
  0006b	85 c0		 test	 eax, eax
  0006d	7e 0c		 jle	 SHORT $LN69@erase@4
  0006f	51		 push	 ecx
  00070	57		 push	 edi
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _memmove_s
  00078	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  0007b	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  0007e	5f		 pop	 edi
  0007f	8b c3		 mov	 eax, ebx
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end@4
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end@4:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin@4
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin@4:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@XZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase@5
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase@5
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase@5
$LN11@erase@5:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase@5:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase@5
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase@5
$LN30@erase@5:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase@5:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase@5
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase@5
$LN47@erase@5:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase@5:
  00052	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00055	3b d7		 cmp	 edx, edi
  00057	74 25		 je	 SHORT $LN72@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	c1 f8 02	 sar	 eax, 2
  00061	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00068	8d 2c 11	 lea	 ebp, DWORD PTR [ecx+edx]
  0006b	85 c0		 test	 eax, eax
  0006d	7e 0c		 jle	 SHORT $LN69@erase@5
  0006f	51		 push	 ecx
  00070	57		 push	 edi
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _memmove_s
  00078	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase@5:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  0007b	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  0007e	5f		 pop	 edi
  0007f	8b c3		 mov	 eax, ebx
  00081	5d		 pop	 ebp
  00082	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end@5
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end@5:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin@5
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin@5:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase@6
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase@6
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase@6
$LN11@erase@6:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase@6:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase@6
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase@6
$LN30@erase@6:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase@6:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase@6
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase@6
$LN47@erase@6:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase@6:
  00052	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00055	3b d7		 cmp	 edx, edi
  00057	74 20		 je	 SHORT $LN72@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	d1 f8		 sar	 eax, 1
  00060	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00063	8d 2c 11	 lea	 ebp, DWORD PTR [ecx+edx]
  00066	85 c0		 test	 eax, eax
  00068	7e 0c		 jle	 SHORT $LN69@erase@6
  0006a	51		 push	 ecx
  0006b	57		 push	 edi
  0006c	51		 push	 ecx
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _memmove_s
  00073	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase@6:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  00076	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  00079	5f		 pop	 edi
  0007a	8b c3		 mov	 eax, ebx
  0007c	5d		 pop	 ebp
  0007d	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end@6
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end@6:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin@6
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin@6:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 440  : 		}

  00009	c3		 ret	 0
??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 8
__Last_arg$ = 16					; size = 8
?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = ebx

; 1028 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 1029 : 		iterator _First = _Make_iter(_First_arg);

  00002	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00008	85 f6		 test	 esi, esi
  0000a	74 0e		 je	 SHORT $LN11@erase@7
  0000c	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
  00010	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00013	77 05		 ja	 SHORT $LN11@erase@7
  00015	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  00018	76 09		 jbe	 SHORT $LN10@erase@7
$LN11@erase@7:
  0001a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0001f	8b 44 24 10	 mov	 eax, DWORD PTR __First_arg$[esp+8]
$LN10@erase@7:

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

  00023	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
  00027	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00029	89 0b		 mov	 DWORD PTR [ebx], ecx
  0002b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0002e	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00031	77 05		 ja	 SHORT $LN30@erase@7
  00033	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00036	76 09		 jbe	 SHORT $LN29@erase@7
$LN30@erase@7:
  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0003d	8b 7c 24 18	 mov	 edi, DWORD PTR __Last_arg$[esp+8]
$LN29@erase@7:

; 1031 : 
; 1032 : 		if (_First != _Last)

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00045	85 c0		 test	 eax, eax
  00047	74 04		 je	 SHORT $LN47@erase@7
  00049	3b c1		 cmp	 eax, ecx
  0004b	74 05		 je	 SHORT $LN46@erase@7
$LN47@erase@7:
  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@erase@7:
  00052	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00055	3b cf		 cmp	 ecx, edi
  00057	74 1b		 je	 SHORT $LN72@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

  00059	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005c	2b c7		 sub	 eax, edi
  0005e	8d 2c 08	 lea	 ebp, DWORD PTR [eax+ecx]
  00061	85 c0		 test	 eax, eax
  00063	7e 0c		 jle	 SHORT $LN69@erase@7
  00065	50		 push	 eax
  00066	57		 push	 edi
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _memmove_s
  0006e	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@erase@7:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

  00071	89 6e 10	 mov	 DWORD PTR [esi+16], ebp
$LN72@erase@7:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

  00074	5f		 pop	 edi
  00075	8b c3		 mov	 eax, ebx
  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

  00000	53		 push	 ebx

; 651  : 		return (iterator(_Mylast, this));

  00001	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000d	76 05		 jbe	 SHORT $LN7@end@7
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@end@7:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 652  : 		}

  0001e	c3		 ret	 0
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

  00000	53		 push	 ebx

; 641  : 		return (iterator(_Myfirst, this));

  00001	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]
  00004	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0000d	76 05		 jbe	 SHORT $LN7@begin@7
  0000f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@begin@7:
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0001b	8b c6		 mov	 eax, esi
  0001d	5b		 pop	 ebx

; 642  : 		}

  0001e	c3		 ret	 0
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = ebx

; 1511 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp

; 1512 : 		return (_STRING_ITERATOR(_Myptr() + _Mysize));

  00001	8b 6f 18	 mov	 ebp, DWORD PTR [edi+24]
  00004	56		 push	 esi
  00005	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00008	83 fd 10	 cmp	 ebp, 16			; 00000010H
  0000b	72 04		 jb	 SHORT $LN5@end@8
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	eb 02		 jmp	 SHORT $LN6@end@8
$LN5@end@8:
  00011	8b c8		 mov	 ecx, eax
$LN6@end@8:
  00013	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00016	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  00019	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  0001f	85 f6		 test	 esi, esi
  00021	74 1c		 je	 SHORT $LN12@end@8
  00023	83 fd 10	 cmp	 ebp, 16			; 00000010H
  00026	72 04		 jb	 SHORT $LN22@end@8
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	eb 02		 jmp	 SHORT $LN23@end@8
$LN22@end@8:
  0002c	8b c8		 mov	 ecx, eax
$LN23@end@8:
  0002e	3b ce		 cmp	 ecx, esi
  00030	77 0d		 ja	 SHORT $LN12@end@8
  00032	83 fd 10	 cmp	 ebp, 16			; 00000010H
  00035	72 02		 jb	 SHORT $LN26@end@8
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
$LN26@end@8:
  00039	03 d0		 add	 edx, eax
  0003b	3b f2		 cmp	 esi, edx
  0003d	76 05		 jbe	 SHORT $LN11@end@8
$LN12@end@8:
  0003f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN11@end@8:
  00044	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00047	5e		 pop	 esi
  00048	89 3b		 mov	 DWORD PTR [ebx], edi
  0004a	8b c3		 mov	 eax, ebx
  0004c	5d		 pop	 ebp

; 1513 : 		}

  0004d	c3		 ret	 0
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = ebx

; 1502 : 		return (_STRING_ITERATOR(_Myptr()));

  00000	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00003	56		 push	 esi
  00004	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00007	83 fa 10	 cmp	 edx, 16			; 00000010H
  0000a	72 04		 jb	 SHORT $LN5@begin@8
  0000c	8b 30		 mov	 esi, DWORD PTR [eax]
  0000e	eb 02		 jmp	 SHORT $LN6@begin@8
$LN5@begin@8:
  00010	8b f0		 mov	 esi, eax
$LN6@begin@8:
  00012	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00018	85 f6		 test	 esi, esi
  0001a	74 1f		 je	 SHORT $LN12@begin@8
  0001c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0001f	72 04		 jb	 SHORT $LN22@begin@8
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	eb 02		 jmp	 SHORT $LN23@begin@8
$LN22@begin@8:
  00025	8b c8		 mov	 ecx, eax
$LN23@begin@8:
  00027	3b ce		 cmp	 ecx, esi
  00029	77 10		 ja	 SHORT $LN12@begin@8
  0002b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0002e	72 02		 jb	 SHORT $LN26@begin@8
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
$LN26@begin@8:
  00032	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00035	03 c8		 add	 ecx, eax
  00037	3b f1		 cmp	 esi, ecx
  00039	76 05		 jbe	 SHORT $LN11@begin@8
$LN12@begin@8:
  0003b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN11@begin@8:
  00040	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00043	89 3b		 mov	 DWORD PTR [ebx], edi
  00045	8b c3		 mov	 eax, ebx
  00047	5e		 pop	 esi

; 1503 : 		}

  00048	c3		 ret	 0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ PROC ; std::_Vector_val<wchar_t *,std::allocator<wchar_t *> >::~_Vector_val<wchar_t *,std::allocator<wchar_t *> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
__ehhandler$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<wchar_t *,std::allocator<wchar_t *> >::~_Vector_val<wchar_t *,std::allocator<wchar_t *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
__ehhandler$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<double,std::allocator<double> >::~_Vector_val<double,std::allocator<double> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
__ehhandler$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<float,std::allocator<float> >::~_Vector_val<float,std::allocator<float> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ PROC ; std::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >::~_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
__ehhandler$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >::~_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::~_Vector_val<unsigned long,std::allocator<unsigned long> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >
__ehhandler$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::~_Vector_val<unsigned long,std::allocator<unsigned long> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::~_Vector_val<unsigned short,std::allocator<unsigned short> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >
__ehhandler$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::~_Vector_val<unsigned short,std::allocator<unsigned short> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >, COMDAT
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00020	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00028	8b 44 24 14	 mov	 eax, DWORD PTR _this$[esp+12]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00042	59		 pop	 ecx
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
__ehhandler$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 02		 lea	 eax, DWORD PTR [edx]
  0000e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00011	33 c8		 xor	 ecx, eax
  00013	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00018	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T177190 = -12						; size = 8
?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@2
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@2:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@2
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@2:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T177190[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z
_TEXT	SEGMENT
??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	c1 f8 02	 sar	 eax, 2
  00009	3b f8		 cmp	 edi, eax
  0000b	72 05		 jb	 SHORT $LN3@operator@17
  0000d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@17:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00012	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00015	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

  00018	c3		 ret	 0
??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
__ehhandler$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T177395 = -12						; size = 8
?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ PROC	; std::vector<double,std::allocator<double> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@3
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@3:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@3
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@3:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T177395[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z ; std::vector<double,std::allocator<double> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ ENDP	; std::vector<double,std::allocator<double> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z
_TEXT	SEGMENT
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z PROC	; std::vector<double,std::allocator<double> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	c1 f8 03	 sar	 eax, 3
  00009	3b f8		 cmp	 edi, eax
  0000b	72 05		 jb	 SHORT $LN3@operator@18
  0000d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@18:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00012	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00015	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

  00018	c3		 ret	 0
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ENDP	; std::vector<double,std::allocator<double> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector@2
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector@2:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
__ehhandler$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T177600 = -12						; size = 8
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ PROC	; std::vector<float,std::allocator<float> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@4
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@4:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@4
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@4:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T177600[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ENDP	; std::vector<float,std::allocator<float> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z
_TEXT	SEGMENT
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z PROC	; std::vector<float,std::allocator<float> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	c1 f8 02	 sar	 eax, 2
  00009	3b f8		 cmp	 edi, eax
  0000b	72 05		 jb	 SHORT $LN3@operator@19
  0000d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@19:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00012	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00015	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

  00018	c3		 ret	 0
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ENDP	; std::vector<float,std::allocator<float> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector@3
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector@3:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
__ehhandler$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T177805 = -12						; size = 8
?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@5
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@5:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@5
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@5:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T177805[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z
_TEXT	SEGMENT
??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	c1 f8 03	 sar	 eax, 3
  00009	3b f8		 cmp	 edi, eax
  0000b	72 05		 jb	 SHORT $LN3@operator@20
  0000d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@20:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00012	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00015	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]

; 786  : 		}

  00018	c3		 ret	 0
??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector@4
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector@4:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
__ehhandler$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T178010 = -12						; size = 8
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@6
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@6:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@6
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@6:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T178010[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	c1 f8 02	 sar	 eax, 2
  00009	3b f8		 cmp	 edi, eax
  0000b	72 05		 jb	 SHORT $LN3@operator@21
  0000d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@21:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00012	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00015	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]

; 786  : 		}

  00018	c3		 ret	 0
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector@5
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector@5:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >
__ehhandler$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T178215 = -12						; size = 8
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@7
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@7:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@7
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@7:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T178215[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z
_TEXT	SEGMENT
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	d1 f8		 sar	 eax, 1
  00008	3b f8		 cmp	 edi, eax
  0000a	72 05		 jb	 SHORT $LN3@operator@22
  0000c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@22:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  00011	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00014	8d 04 79	 lea	 eax, DWORD PTR [ecx+edi*2]

; 786  : 		}

  00017	c3		 ret	 0
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector@6
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector@6:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >
__ehhandler$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T178420 = -12						; size = 8
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = eax

; 1059 : 		{	// erase all

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 1060 : 		erase(begin(), end());

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	57		 push	 edi
  0000c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0000f	76 05		 jbe	 SHORT $LN9@clear@8
  00011	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN9@clear@8:
  00016	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00019	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0001b	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0001e	76 05		 jbe	 SHORT $LN28@clear@8
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN28@clear@8:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	55		 push	 ebp
  00028	53		 push	 ebx
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	8d 5c 24 20	 lea	 ebx, DWORD PTR $T178420[esp+44]
  0002f	e8 00 00 00 00	 call	 ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase

; 1061 : 		}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	5b		 pop	 ebx
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003b	c3		 ret	 0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = esi
; __Pos$ = edi

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	2b 46 0c	 sub	 eax, DWORD PTR [esi+12]
  00006	3b f8		 cmp	 edi, eax
  00008	72 05		 jb	 SHORT $LN3@operator@23
  0000a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN3@operator@23:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

  0000f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00012	03 c7		 add	 eax, edi

; 786  : 		}

  00014	c3		 ret	 0
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 558  : 		{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	33 ff		 xor	 edi, edi
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi

; 559  : 		_Tidy();

  0002c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0002f	3b c7		 cmp	 eax, edi
  00031	74 09		 je	 SHORT $LN7@vector@7
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
$LN7@vector@7:
  0003c	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0003f	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00042	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 560  : 		}

  00045	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
  00009	c3		 ret	 0
__unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$1:
  0000a	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000d	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
__ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T178621 = -4						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT
; _hr$ = eax

; 63   : {

  00000	51		 push	 ecx

; 64   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 65   : #ifdef _AFX
; 66   : 	if( hr == E_OUTOFMEMORY )
; 67   : 	{
; 68   : 		AfxThrowMemoryException();
; 69   : 	}
; 70   : 	else
; 71   : 	{
; 72   : 		AfxThrowOleException( hr );
; 73   : 	}
; 74   : #else
; 75   : 	throw CAtlException( hr );

  00001	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  00006	8d 4c 24 04	 lea	 ecx, DWORD PTR $T178621[esp+8]
  0000a	51		 push	 ecx
  0000b	89 44 24 08	 mov	 DWORD PTR $T178621[esp+12], eax
  0000f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN6@AtlThrowIm:
$LN5@AtlThrowIm:
  00014	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@36
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@36
$LN26@operator@36:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@36
$LN16@operator@36:
  00015	33 d2		 xor	 edx, edx
$LN17@operator@36:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 cf		 add	 ecx, edi
  00025	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00028	77 0f		 ja	 SHORT $LN4@operator@36
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN22@operator@36
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	eb 02		 jmp	 SHORT $LN23@operator@36
$LN22@operator@36:
  00032	33 c0		 xor	 eax, eax
$LN23@operator@36:
  00034	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00037	73 05		 jae	 SHORT $LN27@operator@36
$LN4@operator@36:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  00039	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@36:

; 164  : 		_Myptr += _Off;

  0003e	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  00041	8b c6		 mov	 eax, esi
  00043	5f		 pop	 edi

; 166  : 		}

  00044	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@37
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@37
$LN26@operator@37:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@37
$LN16@operator@37:
  00015	33 d2		 xor	 edx, edx
$LN17@operator@37:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 ff		 add	 edi, edi
  00025	03 cf		 add	 ecx, edi
  00027	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  0002a	77 0f		 ja	 SHORT $LN4@operator@37
  0002c	85 c0		 test	 eax, eax
  0002e	74 04		 je	 SHORT $LN22@operator@37
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 02		 jmp	 SHORT $LN23@operator@37
$LN22@operator@37:
  00034	33 c0		 xor	 eax, eax
$LN23@operator@37:
  00036	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00039	73 05		 jae	 SHORT $LN27@operator@37
$LN4@operator@37:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  0003b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@37:

; 164  : 		_Myptr += _Off;

  00040	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  00043	8b c6		 mov	 eax, esi
  00045	5f		 pop	 edi

; 166  : 		}

  00046	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<double,std::allocator<double> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<float,std::allocator<float> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@38
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@38
$LN26@operator@38:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@38
$LN16@operator@38:
  00015	33 d2		 xor	 edx, edx
$LN17@operator@38:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 cf		 add	 ecx, edi
  00025	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00028	77 0f		 ja	 SHORT $LN4@operator@38
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN22@operator@38
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	eb 02		 jmp	 SHORT $LN23@operator@38
$LN22@operator@38:
  00032	33 c0		 xor	 eax, eax
$LN23@operator@38:
  00034	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00037	73 05		 jae	 SHORT $LN27@operator@38
$LN4@operator@38:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  00039	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@38:

; 164  : 		_Myptr += _Off;

  0003e	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  00041	8b c6		 mov	 eax, esi
  00043	5f		 pop	 edi

; 166  : 		}

  00044	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<float,std::allocator<float> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@39
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@39
$LN26@operator@39:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@39
$LN16@operator@39:
  00015	33 d2		 xor	 edx, edx
$LN17@operator@39:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 ff		 add	 edi, edi
  00025	03 cf		 add	 ecx, edi
  00027	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  0002a	77 0f		 ja	 SHORT $LN4@operator@39
  0002c	85 c0		 test	 eax, eax
  0002e	74 04		 je	 SHORT $LN22@operator@39
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 02		 jmp	 SHORT $LN23@operator@39
$LN22@operator@39:
  00034	33 c0		 xor	 eax, eax
$LN23@operator@39:
  00036	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00039	73 05		 jae	 SHORT $LN27@operator@39
$LN4@operator@39:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  0003b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@39:

; 164  : 		_Myptr += _Off;

  00040	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  00043	8b c6		 mov	 eax, esi
  00045	5f		 pop	 edi

; 166  : 		}

  00046	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@40
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@40
$LN26@operator@40:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@40
$LN16@operator@40:
  00015	33 d2		 xor	 edx, edx
$LN17@operator@40:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 cf		 add	 ecx, edi
  00025	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00028	77 0f		 ja	 SHORT $LN4@operator@40
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN22@operator@40
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	eb 02		 jmp	 SHORT $LN23@operator@40
$LN22@operator@40:
  00032	33 c0		 xor	 eax, eax
$LN23@operator@40:
  00034	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00037	73 05		 jae	 SHORT $LN27@operator@40
$LN4@operator@40:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  00039	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@40:

; 164  : 		_Myptr += _Off;

  0003e	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  00041	8b c6		 mov	 eax, esi
  00043	5f		 pop	 edi

; 166  : 		}

  00044	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned long,std::allocator<unsigned long> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@41
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@41
$LN26@operator@41:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@41
$LN16@operator@41:
  00015	33 d2		 xor	 edx, edx
$LN17@operator@41:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 cf		 add	 ecx, edi
  00023	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00026	77 0f		 ja	 SHORT $LN4@operator@41
  00028	85 c0		 test	 eax, eax
  0002a	74 04		 je	 SHORT $LN22@operator@41
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 02		 jmp	 SHORT $LN23@operator@41
$LN22@operator@41:
  00030	33 c0		 xor	 eax, eax
$LN23@operator@41:
  00032	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00035	73 05		 jae	 SHORT $LN27@operator@41
$LN4@operator@41:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  00037	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@41:

; 164  : 		_Myptr += _Off;

  0003c	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  0003f	8b c6		 mov	 eax, esi
  00041	5f		 pop	 edi

; 166  : 		}

  00042	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator+=, COMDAT
; _this$ = esi
; __Off$ = edi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN26@operator@42
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN16@operator@42
$LN26@operator@42:
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN17@operator@42
$LN16@operator@42:
  00015	33 c9		 xor	 ecx, ecx
$LN17@operator@42:
  00017	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001a	03 d7		 add	 edx, edi
  0001c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0001f	77 0f		 ja	 SHORT $LN4@operator@42
  00021	85 c0		 test	 eax, eax
  00023	74 04		 je	 SHORT $LN22@operator@42
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $LN23@operator@42
$LN22@operator@42:
  00029	33 c0		 xor	 eax, eax
$LN23@operator@42:
  0002b	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  0002e	73 05		 jae	 SHORT $LN27@operator@42
$LN4@operator@42:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN27@operator@42:

; 164  : 		_Myptr += _Off;

  00035	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 165  : 		return (*this);

  00038	8b c6		 mov	 eax, esi

; 166  : 		}

  0003a	c3		 ret	 0
??Y?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@43
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@43
$LN28@operator@43:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@43
$LN18@operator@43:
  00015	33 d2		 xor	 edx, edx
$LN19@operator@43:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 cf		 add	 ecx, edi
  00025	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00028	77 0f		 ja	 SHORT $LN6@operator@43
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN24@operator@43
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	eb 02		 jmp	 SHORT $LN25@operator@43
$LN24@operator@43:
  00032	33 c0		 xor	 eax, eax
$LN25@operator@43:
  00034	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00037	73 05		 jae	 SHORT $LN29@operator@43
$LN6@operator@43:
  00039	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@43:
  0003e	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  00041	8b c6		 mov	 eax, esi
  00043	5f		 pop	 edi

; 377  : 		}

  00044	c2 04 00	 ret	 4
??Y?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@44
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@44
$LN28@operator@44:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@44
$LN18@operator@44:
  00015	33 d2		 xor	 edx, edx
$LN19@operator@44:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 ff		 add	 edi, edi
  00025	03 cf		 add	 ecx, edi
  00027	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  0002a	77 0f		 ja	 SHORT $LN6@operator@44
  0002c	85 c0		 test	 eax, eax
  0002e	74 04		 je	 SHORT $LN24@operator@44
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 02		 jmp	 SHORT $LN25@operator@44
$LN24@operator@44:
  00034	33 c0		 xor	 eax, eax
$LN25@operator@44:
  00036	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00039	73 05		 jae	 SHORT $LN29@operator@44
$LN6@operator@44:
  0003b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@44:
  00040	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  00043	8b c6		 mov	 eax, esi
  00045	5f		 pop	 edi

; 377  : 		}

  00046	c2 04 00	 ret	 4
??Y?$_Vector_iterator@NV?$allocator@N@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@45
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@45
$LN28@operator@45:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@45
$LN18@operator@45:
  00015	33 d2		 xor	 edx, edx
$LN19@operator@45:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 cf		 add	 ecx, edi
  00025	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00028	77 0f		 ja	 SHORT $LN6@operator@45
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN24@operator@45
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	eb 02		 jmp	 SHORT $LN25@operator@45
$LN24@operator@45:
  00032	33 c0		 xor	 eax, eax
$LN25@operator@45:
  00034	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00037	73 05		 jae	 SHORT $LN29@operator@45
$LN6@operator@45:
  00039	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@45:
  0003e	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  00041	8b c6		 mov	 eax, esi
  00043	5f		 pop	 edi

; 377  : 		}

  00044	c2 04 00	 ret	 4
??Y?$_Vector_iterator@MV?$allocator@M@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@46
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@46
$LN28@operator@46:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@46
$LN18@operator@46:
  00015	33 d2		 xor	 edx, edx
$LN19@operator@46:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 ff		 add	 edi, edi
  00025	03 cf		 add	 ecx, edi
  00027	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  0002a	77 0f		 ja	 SHORT $LN6@operator@46
  0002c	85 c0		 test	 eax, eax
  0002e	74 04		 je	 SHORT $LN24@operator@46
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	eb 02		 jmp	 SHORT $LN25@operator@46
$LN24@operator@46:
  00034	33 c0		 xor	 eax, eax
$LN25@operator@46:
  00036	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00039	73 05		 jae	 SHORT $LN29@operator@46
$LN6@operator@46:
  0003b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@46:
  00040	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  00043	8b c6		 mov	 eax, esi
  00045	5f		 pop	 edi

; 377  : 		}

  00046	c2 04 00	 ret	 4
??Y?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@47
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@47
$LN28@operator@47:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@47
$LN18@operator@47:
  00015	33 d2		 xor	 edx, edx
$LN19@operator@47:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 ff		 add	 edi, edi
  00023	03 cf		 add	 ecx, edi
  00025	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00028	77 0f		 ja	 SHORT $LN6@operator@47
  0002a	85 c0		 test	 eax, eax
  0002c	74 04		 je	 SHORT $LN24@operator@47
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	eb 02		 jmp	 SHORT $LN25@operator@47
$LN24@operator@47:
  00032	33 c0		 xor	 eax, eax
$LN25@operator@47:
  00034	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00037	73 05		 jae	 SHORT $LN29@operator@47
$LN6@operator@47:
  00039	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@47:
  0003e	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  00041	8b c6		 mov	 eax, esi
  00043	5f		 pop	 edi

; 377  : 		}

  00044	c2 04 00	 ret	 4
??Y?$_Vector_iterator@KV?$allocator@K@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@48
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@48
$LN28@operator@48:
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@48
$LN18@operator@48:
  00015	33 d2		 xor	 edx, edx
$LN19@operator@48:
  00017	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001a	57		 push	 edi
  0001b	8b 7c 24 08	 mov	 edi, DWORD PTR __Off$[esp]
  0001f	03 ff		 add	 edi, edi
  00021	03 cf		 add	 ecx, edi
  00023	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00026	77 0f		 ja	 SHORT $LN6@operator@48
  00028	85 c0		 test	 eax, eax
  0002a	74 04		 je	 SHORT $LN24@operator@48
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	eb 02		 jmp	 SHORT $LN25@operator@48
$LN24@operator@48:
  00030	33 c0		 xor	 eax, eax
$LN25@operator@48:
  00032	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00035	73 05		 jae	 SHORT $LN29@operator@48
$LN6@operator@48:
  00037	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@48:
  0003c	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  0003f	8b c6		 mov	 eax, esi
  00041	5f		 pop	 edi

; 377  : 		}

  00042	c2 04 00	 ret	 4
??Y?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::operator+=, COMDAT
; _this$ = esi
; __Off$ = edi

; 375  : 		(*(_Mybase *)this) += _Off;

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	75 0b		 jne	 SHORT $LN28@operator@49
  00006	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	85 c0		 test	 eax, eax
  0000f	74 04		 je	 SHORT $LN18@operator@49
$LN28@operator@49:
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	eb 02		 jmp	 SHORT $LN19@operator@49
$LN18@operator@49:
  00015	33 c9		 xor	 ecx, ecx
$LN19@operator@49:
  00017	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001a	03 d7		 add	 edx, edi
  0001c	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0001f	77 0f		 ja	 SHORT $LN6@operator@49
  00021	85 c0		 test	 eax, eax
  00023	74 04		 je	 SHORT $LN24@operator@49
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	eb 02		 jmp	 SHORT $LN25@operator@49
$LN24@operator@49:
  00029	33 c0		 xor	 eax, eax
$LN25@operator@49:
  0002b	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  0002e	73 05		 jae	 SHORT $LN29@operator@49
$LN6@operator@49:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN29@operator@49:
  00035	01 7e 04	 add	 DWORD PTR [esi+4], edi

; 376  : 		return (*this);

  00038	8b c6		 mov	 eax, esi

; 377  : 		}

  0003a	c3		 ret	 0
??Y?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1b		 jne	 SHORT $LN30@operator@50
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@50:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	8d 3c 8f	 lea	 edi, DWORD PTR [edi+ecx*4]
  00019	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001c	77 13		 ja	 SHORT $LN8@operator@50
  0001e	85 f6		 test	 esi, esi
  00020	74 08		 je	 SHORT $LN26@operator@50
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	eb 06		 jmp	 SHORT $LN27@operator@50
$LN30@operator@50:
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb e8		 jmp	 SHORT $LN21@operator@50
$LN26@operator@50:
  0002a	33 c0		 xor	 eax, eax
$LN27@operator@50:
  0002c	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002f	73 05		 jae	 SHORT $LN7@operator@50
$LN8@operator@50:
  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@50:
  00036	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00039	5f		 pop	 edi
  0003a	89 33		 mov	 DWORD PTR [ebx], esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5e		 pop	 esi
  0003f	c2 04 00	 ret	 4
??H?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<wchar_t *,std::allocator<wchar_t *> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<double,std::allocator<double> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1b		 jne	 SHORT $LN30@operator@51
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@51:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	8d 3c cf	 lea	 edi, DWORD PTR [edi+ecx*8]
  00019	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001c	77 13		 ja	 SHORT $LN8@operator@51
  0001e	85 f6		 test	 esi, esi
  00020	74 08		 je	 SHORT $LN26@operator@51
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	eb 06		 jmp	 SHORT $LN27@operator@51
$LN30@operator@51:
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb e8		 jmp	 SHORT $LN21@operator@51
$LN26@operator@51:
  0002a	33 c0		 xor	 eax, eax
$LN27@operator@51:
  0002c	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002f	73 05		 jae	 SHORT $LN7@operator@51
$LN8@operator@51:
  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@51:
  00036	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00039	5f		 pop	 edi
  0003a	89 33		 mov	 DWORD PTR [ebx], esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5e		 pop	 esi
  0003f	c2 04 00	 ret	 4
??H?$_Vector_iterator@NV?$allocator@N@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<double,std::allocator<double> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<float,std::allocator<float> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1b		 jne	 SHORT $LN30@operator@52
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@52:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	8d 3c 8f	 lea	 edi, DWORD PTR [edi+ecx*4]
  00019	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001c	77 13		 ja	 SHORT $LN8@operator@52
  0001e	85 f6		 test	 esi, esi
  00020	74 08		 je	 SHORT $LN26@operator@52
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	eb 06		 jmp	 SHORT $LN27@operator@52
$LN30@operator@52:
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb e8		 jmp	 SHORT $LN21@operator@52
$LN26@operator@52:
  0002a	33 c0		 xor	 eax, eax
$LN27@operator@52:
  0002c	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002f	73 05		 jae	 SHORT $LN7@operator@52
$LN8@operator@52:
  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@52:
  00036	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00039	5f		 pop	 edi
  0003a	89 33		 mov	 DWORD PTR [ebx], esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5e		 pop	 esi
  0003f	c2 04 00	 ret	 4
??H?$_Vector_iterator@MV?$allocator@M@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<float,std::allocator<float> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1b		 jne	 SHORT $LN30@operator@53
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@53:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	8d 3c cf	 lea	 edi, DWORD PTR [edi+ecx*8]
  00019	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001c	77 13		 ja	 SHORT $LN8@operator@53
  0001e	85 f6		 test	 esi, esi
  00020	74 08		 je	 SHORT $LN26@operator@53
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	eb 06		 jmp	 SHORT $LN27@operator@53
$LN30@operator@53:
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb e8		 jmp	 SHORT $LN21@operator@53
$LN26@operator@53:
  0002a	33 c0		 xor	 eax, eax
$LN27@operator@53:
  0002c	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002f	73 05		 jae	 SHORT $LN7@operator@53
$LN8@operator@53:
  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@53:
  00036	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00039	5f		 pop	 edi
  0003a	89 33		 mov	 DWORD PTR [ebx], esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5e		 pop	 esi
  0003f	c2 04 00	 ret	 4
??H?$_Vector_iterator@_KV?$allocator@_K@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned __int64,std::allocator<unsigned __int64> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@KV?$allocator@K@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@KV?$allocator@K@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1b		 jne	 SHORT $LN30@operator@54
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@54:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	8d 3c 8f	 lea	 edi, DWORD PTR [edi+ecx*4]
  00019	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001c	77 13		 ja	 SHORT $LN8@operator@54
  0001e	85 f6		 test	 esi, esi
  00020	74 08		 je	 SHORT $LN26@operator@54
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	eb 06		 jmp	 SHORT $LN27@operator@54
$LN30@operator@54:
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb e8		 jmp	 SHORT $LN21@operator@54
$LN26@operator@54:
  0002a	33 c0		 xor	 eax, eax
$LN27@operator@54:
  0002c	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002f	73 05		 jae	 SHORT $LN7@operator@54
$LN8@operator@54:
  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@54:
  00036	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00039	5f		 pop	 edi
  0003a	89 33		 mov	 DWORD PTR [ebx], esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5e		 pop	 esi
  0003f	c2 04 00	 ret	 4
??H?$_Vector_iterator@KV?$allocator@K@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned long,std::allocator<unsigned long> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@GV?$allocator@G@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@GV?$allocator@G@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1b		 jne	 SHORT $LN30@operator@55
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@55:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	8d 3c 4f	 lea	 edi, DWORD PTR [edi+ecx*2]
  00019	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001c	77 13		 ja	 SHORT $LN8@operator@55
  0001e	85 f6		 test	 esi, esi
  00020	74 08		 je	 SHORT $LN26@operator@55
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	eb 06		 jmp	 SHORT $LN27@operator@55
$LN30@operator@55:
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb e8		 jmp	 SHORT $LN21@operator@55
$LN26@operator@55:
  0002a	33 c0		 xor	 eax, eax
$LN27@operator@55:
  0002c	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002f	73 05		 jae	 SHORT $LN7@operator@55
$LN8@operator@55:
  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@55:
  00036	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00039	5f		 pop	 edi
  0003a	89 33		 mov	 DWORD PTR [ebx], esi
  0003c	8b c3		 mov	 eax, ebx
  0003e	5e		 pop	 esi
  0003f	c2 04 00	 ret	 4
??H?$_Vector_iterator@GV?$allocator@G@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@EV?$allocator@E@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??H?$_Vector_iterator@EV?$allocator@E@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::operator+, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx

; 380  : 		{	// return this + integer

  00000	56		 push	 esi

; 381  : 		_Myt _Tmp = *this;

  00001	8b 30		 mov	 esi, DWORD PTR [eax]
  00003	57		 push	 edi
  00004	8b 78 04	 mov	 edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

  00007	85 f6		 test	 esi, esi
  00009	75 1a		 jne	 SHORT $LN30@operator@56
  0000b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00010	33 c0		 xor	 eax, eax
$LN21@operator@56:
  00012	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Off$[esp+4]
  00016	03 f9		 add	 edi, ecx
  00018	3b 78 10	 cmp	 edi, DWORD PTR [eax+16]
  0001b	77 13		 ja	 SHORT $LN8@operator@56
  0001d	85 f6		 test	 esi, esi
  0001f	74 08		 je	 SHORT $LN26@operator@56
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	eb 06		 jmp	 SHORT $LN27@operator@56
$LN30@operator@56:
  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	eb e9		 jmp	 SHORT $LN21@operator@56
$LN26@operator@56:
  00029	33 c0		 xor	 eax, eax
$LN27@operator@56:
  0002b	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  0002e	73 05		 jae	 SHORT $LN7@operator@56
$LN8@operator@56:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN7@operator@56:
  00035	89 7b 04	 mov	 DWORD PTR [ebx+4], edi

; 383  : 		}

  00038	5f		 pop	 edi
  00039	89 33		 mov	 DWORD PTR [ebx], esi
  0003b	8b c3		 mov	 eax, ebx
  0003d	5e		 pop	 esi
  0003e	c2 04 00	 ret	 4
??H?$_Vector_iterator@EV?$allocator@E@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<double,5>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo:
$LN1@GetUpperBo:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo:
?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<double,5>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<double,5>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo:
$LN1@GetLowerBo:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo:
?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<double,5>::GetLowerBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<float,4>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo@2

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo@2:
$LN1@GetUpperBo@2:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo@2:
?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<float,4>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<float,4>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo@2

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo@2:
$LN1@GetLowerBo@2:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo@2:
?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<float,4>::GetLowerBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<unsigned __int64,21>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo@3

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo@3:
$LN1@GetUpperBo@3:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo@3:
?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<unsigned __int64,21>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<unsigned __int64,21>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo@3

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo@3:
$LN1@GetLowerBo@3:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo@3:
?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<unsigned __int64,21>::GetLowerBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo@4

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo@4:
$LN1@GetUpperBo@4:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo@4:
?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo@4

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo@4:
$LN1@GetLowerBo@4:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo@4:
?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetLowerBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo@5

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo@5:
$LN1@GetUpperBo@5:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo@5:
?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo@5

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo@5:
$LN1@GetLowerBo@5:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo@5:
?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetLowerBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo@6

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo@6:
$LN1@GetUpperBo@6:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo@6:
?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo@6

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo@6:
$LN1@GetLowerBo@6:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo@6:
?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetLowerBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z
_TEXT	SEGMENT
_lUBound$183777 = -4					; size = 4
_lLBound$183764 = -4					; size = 4
?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z PROC		; ATL::CComSafeArray<double,5>::GetAt, COMDAT
; _this$ = edi
; _lIndex$ = eax

; 333  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN18@GetAt

; 336  : 			AtlThrow(E_FAIL);

  0000a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt:
  00014	8d 4c 24 04	 lea	 ecx, DWORD PTR _lLBound$183764[esp+8]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lLBound$183764[esp+20], 0
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002a	85 c0		 test	 eax, eax
  0002c	7d 05		 jge	 SHORT $LN12@GetAt
  0002e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt:
$LN12@GetAt:
  00033	55		 push	 ebp

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00034	8b 6c 24 08	 mov	 ebp, DWORD PTR _lLBound$183764[esp+12]
  00038	3b f5		 cmp	 esi, ebp
  0003a	7c 35		 jl	 SHORT $LN1@GetAt
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _lUBound$183777[esp+12]
  00042	52		 push	 edx
  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lUBound$183777[esp+24], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00054	85 c0		 test	 eax, eax
  00056	7d 05		 jge	 SHORT $LN22@GetAt
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt:
$LN22@GetAt:
  0005d	3b 74 24 08	 cmp	 esi, DWORD PTR _lUBound$183777[esp+12]
  00061	7f 0e		 jg	 SHORT $LN1@GetAt

; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	2b f5		 sub	 esi, ebp
  0006a	5d		 pop	 ebp
  0006b	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  0006e	5e		 pop	 esi

; 345  : 	}

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
$LN1@GetAt:

; 342  : 			AtlThrow(E_INVALIDARG);

  00071	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00076	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt:
$LN32@GetAt:
  0007b	cc		 int	 3
?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z ENDP		; ATL::CComSafeArray<double,5>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<double,5>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount:
$LN2@GetCount:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount:
$LN1@GetCount:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount:
?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<double,5>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<double,5>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach:
$LN15@Attach:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 05	 cmp	 cx, 5
  00042	74 0a		 je	 SHORT $LN7@Attach
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach:
$LN7@Attach:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach:
?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<double,5>::Attach
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z
_TEXT	SEGMENT
_lUBound$183869 = -4					; size = 4
_lLBound$183856 = -4					; size = 4
?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z PROC		; ATL::CComSafeArray<float,4>::GetAt, COMDAT
; _this$ = edi
; _lIndex$ = eax

; 333  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN18@GetAt@2

; 336  : 			AtlThrow(E_FAIL);

  0000a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt@2:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt@2:
  00014	8d 4c 24 04	 lea	 ecx, DWORD PTR _lLBound$183856[esp+8]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lLBound$183856[esp+20], 0
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002a	85 c0		 test	 eax, eax
  0002c	7d 05		 jge	 SHORT $LN12@GetAt@2
  0002e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt@2:
$LN12@GetAt@2:
  00033	55		 push	 ebp

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00034	8b 6c 24 08	 mov	 ebp, DWORD PTR _lLBound$183856[esp+12]
  00038	3b f5		 cmp	 esi, ebp
  0003a	7c 35		 jl	 SHORT $LN1@GetAt@2
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _lUBound$183869[esp+12]
  00042	52		 push	 edx
  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lUBound$183869[esp+24], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00054	85 c0		 test	 eax, eax
  00056	7d 05		 jge	 SHORT $LN22@GetAt@2
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt@2:
$LN22@GetAt@2:
  0005d	3b 74 24 08	 cmp	 esi, DWORD PTR _lUBound$183869[esp+12]
  00061	7f 0e		 jg	 SHORT $LN1@GetAt@2

; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	2b f5		 sub	 esi, ebp
  0006a	5d		 pop	 ebp
  0006b	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]
  0006e	5e		 pop	 esi

; 345  : 	}

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
$LN1@GetAt@2:

; 342  : 			AtlThrow(E_INVALIDARG);

  00071	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00076	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt@2:
$LN32@GetAt@2:
  0007b	cc		 int	 3
?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z ENDP		; ATL::CComSafeArray<float,4>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<float,4>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount@2

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount@2:
$LN2@GetCount@2:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount@2

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount@2:
$LN1@GetCount@2:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount@2:
?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<float,4>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<float,4>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach@2
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach@2:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach@2:
$LN15@Attach@2:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach@2
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach@2
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach@2
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach@2
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach@2:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 04	 cmp	 cx, 4
  00042	74 0a		 je	 SHORT $LN7@Attach@2
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach@2:
$LN7@Attach@2:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach@2
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach@2
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach@2
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach@2:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach@2:
?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<float,4>::Attach
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z
_TEXT	SEGMENT
_lUBound$183962 = -4					; size = 4
_lLBound$183949 = -4					; size = 4
?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z PROC	; ATL::CComSafeArray<unsigned __int64,21>::GetAt, COMDAT
; _this$ = edi
; _lIndex$ = eax

; 333  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN18@GetAt@3

; 336  : 			AtlThrow(E_FAIL);

  0000a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt@3:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt@3:
  00014	8d 4c 24 04	 lea	 ecx, DWORD PTR _lLBound$183949[esp+8]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lLBound$183949[esp+20], 0
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002a	85 c0		 test	 eax, eax
  0002c	7d 05		 jge	 SHORT $LN12@GetAt@3
  0002e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt@3:
$LN12@GetAt@3:
  00033	55		 push	 ebp

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00034	8b 6c 24 08	 mov	 ebp, DWORD PTR _lLBound$183949[esp+12]
  00038	3b f5		 cmp	 esi, ebp
  0003a	7c 35		 jl	 SHORT $LN1@GetAt@3
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _lUBound$183962[esp+12]
  00042	52		 push	 edx
  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lUBound$183962[esp+24], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00054	85 c0		 test	 eax, eax
  00056	7d 05		 jge	 SHORT $LN22@GetAt@3
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt@3:
$LN22@GetAt@3:
  0005d	3b 74 24 08	 cmp	 esi, DWORD PTR _lUBound$183962[esp+12]
  00061	7f 0e		 jg	 SHORT $LN1@GetAt@3

; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	2b f5		 sub	 esi, ebp
  0006a	5d		 pop	 ebp
  0006b	8d 04 f2	 lea	 eax, DWORD PTR [edx+esi*8]
  0006e	5e		 pop	 esi

; 345  : 	}

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
$LN1@GetAt@3:

; 342  : 			AtlThrow(E_INVALIDARG);

  00071	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00076	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt@3:
$LN32@GetAt@3:
  0007b	cc		 int	 3
?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z ENDP	; ATL::CComSafeArray<unsigned __int64,21>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned __int64,21>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount@3

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount@3:
$LN2@GetCount@3:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount@3

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount@3:
$LN1@GetCount@3:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount@3:
?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned __int64,21>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned __int64,21>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach@3
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach@3:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach@3:
$LN15@Attach@3:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach@3
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach@3
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach@3
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach@3
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach@3:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 15	 cmp	 cx, 21			; 00000015H
  00042	74 0a		 je	 SHORT $LN7@Attach@3
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach@3:
$LN7@Attach@3:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach@3
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach@3
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach@3
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach@3:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach@3:
?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned __int64,21>::Attach
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z
_TEXT	SEGMENT
_lUBound$184055 = -4					; size = 4
_lLBound$184042 = -4					; size = 4
?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetAt, COMDAT
; _this$ = edi
; _lIndex$ = eax

; 333  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN18@GetAt@4

; 336  : 			AtlThrow(E_FAIL);

  0000a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt@4:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt@4:
  00014	8d 4c 24 04	 lea	 ecx, DWORD PTR _lLBound$184042[esp+8]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lLBound$184042[esp+20], 0
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002a	85 c0		 test	 eax, eax
  0002c	7d 05		 jge	 SHORT $LN12@GetAt@4
  0002e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt@4:
$LN12@GetAt@4:
  00033	55		 push	 ebp

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00034	8b 6c 24 08	 mov	 ebp, DWORD PTR _lLBound$184042[esp+12]
  00038	3b f5		 cmp	 esi, ebp
  0003a	7c 35		 jl	 SHORT $LN1@GetAt@4
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _lUBound$184055[esp+12]
  00042	52		 push	 edx
  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lUBound$184055[esp+24], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00054	85 c0		 test	 eax, eax
  00056	7d 05		 jge	 SHORT $LN22@GetAt@4
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt@4:
$LN22@GetAt@4:
  0005d	3b 74 24 08	 cmp	 esi, DWORD PTR _lUBound$184055[esp+12]
  00061	7f 0e		 jg	 SHORT $LN1@GetAt@4

; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	2b f5		 sub	 esi, ebp
  0006a	5d		 pop	 ebp
  0006b	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]
  0006e	5e		 pop	 esi

; 345  : 	}

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
$LN1@GetAt@4:

; 342  : 			AtlThrow(E_INVALIDARG);

  00071	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00076	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt@4:
$LN32@GetAt@4:
  0007b	cc		 int	 3
?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount@4

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount@4:
$LN2@GetCount@4:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount@4

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount@4:
$LN1@GetCount@4:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount@4:
?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned long,19>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach@4
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach@4:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach@4:
$LN15@Attach@4:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach@4
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach@4
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach@4
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach@4
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach@4:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 13	 cmp	 cx, 19			; 00000013H
  00042	74 0a		 je	 SHORT $LN7@Attach@4
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach@4:
$LN7@Attach@4:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach@4
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach@4
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach@4
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach@4:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach@4:
?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned long,19>::Attach
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z
_TEXT	SEGMENT
_lUBound$184148 = -4					; size = 4
_lLBound$184135 = -4					; size = 4
?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetAt, COMDAT
; _this$ = edi
; _lIndex$ = eax

; 333  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN18@GetAt@5

; 336  : 			AtlThrow(E_FAIL);

  0000a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt@5:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt@5:
  00014	8d 4c 24 04	 lea	 ecx, DWORD PTR _lLBound$184135[esp+8]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lLBound$184135[esp+20], 0
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002a	85 c0		 test	 eax, eax
  0002c	7d 05		 jge	 SHORT $LN12@GetAt@5
  0002e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt@5:
$LN12@GetAt@5:
  00033	55		 push	 ebp

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00034	8b 6c 24 08	 mov	 ebp, DWORD PTR _lLBound$184135[esp+12]
  00038	3b f5		 cmp	 esi, ebp
  0003a	7c 35		 jl	 SHORT $LN1@GetAt@5
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _lUBound$184148[esp+12]
  00042	52		 push	 edx
  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lUBound$184148[esp+24], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00054	85 c0		 test	 eax, eax
  00056	7d 05		 jge	 SHORT $LN22@GetAt@5
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt@5:
$LN22@GetAt@5:
  0005d	3b 74 24 08	 cmp	 esi, DWORD PTR _lUBound$184148[esp+12]
  00061	7f 0e		 jg	 SHORT $LN1@GetAt@5

; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	2b f5		 sub	 esi, ebp
  0006a	5d		 pop	 ebp
  0006b	8d 04 72	 lea	 eax, DWORD PTR [edx+esi*2]
  0006e	5e		 pop	 esi

; 345  : 	}

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
$LN1@GetAt@5:

; 342  : 			AtlThrow(E_INVALIDARG);

  00071	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00076	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt@5:
$LN32@GetAt@5:
  0007b	cc		 int	 3
?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount@5

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount@5:
$LN2@GetCount@5:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount@5

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount@5:
$LN1@GetCount@5:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount@5:
?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned short,18>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach@5
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach@5:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach@5:
$LN15@Attach@5:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach@5
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach@5
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach@5
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach@5
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach@5:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  00042	74 0a		 je	 SHORT $LN7@Attach@5
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach@5:
$LN7@Attach@5:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach@5
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach@5
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach@5
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach@5:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach@5:
?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned short,18>::Attach
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z
_TEXT	SEGMENT
_lUBound$184241 = 8					; size = 4
_lLBound$184228 = 8					; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetAt, COMDAT
; _this$ = esi

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	55		 push	 ebp
  00003	8b 6c 24 08	 mov	 ebp, DWORD PTR _lIndex$[esp]
  00007	85 c0		 test	 eax, eax
  00009	75 0a		 jne	 SHORT $LN18@GetAt@6

; 336  : 			AtlThrow(E_FAIL);

  0000b	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00010	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt@6:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt@6:
  00015	8d 4c 24 08	 lea	 ecx, DWORD PTR _lLBound$184228[esp]
  00019	51		 push	 ecx
  0001a	6a 01		 push	 1
  0001c	50		 push	 eax
  0001d	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lLBound$184228[esp+12], 0
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN12@GetAt@6
  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt@6:
$LN12@GetAt@6:
  00034	53		 push	 ebx

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00035	8b 5c 24 0c	 mov	 ebx, DWORD PTR _lLBound$184228[esp+4]
  00039	3b eb		 cmp	 ebp, ebx
  0003b	7c 35		 jl	 SHORT $LN1@GetAt@6
  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	8d 54 24 0c	 lea	 edx, DWORD PTR _lUBound$184241[esp+4]
  00043	52		 push	 edx
  00044	6a 01		 push	 1
  00046	50		 push	 eax
  00047	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _lUBound$184241[esp+16], 0
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00055	85 c0		 test	 eax, eax
  00057	7d 05		 jge	 SHORT $LN22@GetAt@6
  00059	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt@6:
$LN22@GetAt@6:
  0005e	3b 6c 24 0c	 cmp	 ebp, DWORD PTR _lUBound$184241[esp+4]
  00062	7f 0e		 jg	 SHORT $LN1@GetAt@6

; 342  : 			AtlThrow(E_INVALIDARG);
; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00064	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00066	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00069	2b c3		 sub	 eax, ebx
  0006b	5b		 pop	 ebx
  0006c	03 c5		 add	 eax, ebp
  0006e	5d		 pop	 ebp

; 345  : 	}

  0006f	c2 04 00	 ret	 4
$LN1@GetAt@6:
  00072	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00077	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt@6:
$LN32@GetAt@6:
  0007c	cc		 int	 3
?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetAt
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount@6

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount@6:
$LN2@GetCount@6:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount@6

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount@6:
$LN1@GetCount@6:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount@6:
?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned char,17>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach@6
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach@6:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach@6:
$LN15@Attach@6:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach@6
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach@6
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach@6
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach@6
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach@6:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  00042	74 0a		 je	 SHORT $LN7@Attach@6
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach@6:
$LN7@Attach@6:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach@6
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach@6
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach@6
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach@6:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach@6:
?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned char,17>::Attach
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lUBound$ = -8						; size = 4
_lLBound$ = -4						; size = 4
?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<wchar_t *,8>::GetCount, COMDAT
; _this$ = esi

; 285  : 		ATLASSUME(m_psa != NULL);
; 286  : 		ATLASSERT(uDim < GetDimensions());
; 287  : 		LONG lLBound, lUBound;
; 288  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	83 ec 08	 sub	 esp, 8
  00005	8d 44 24 04	 lea	 eax, DWORD PTR _lLBound$[esp+8]
  00009	50		 push	 eax
  0000a	6a 01		 push	 1
  0000c	51		 push	 ecx
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 289  : 		ATLASSERT(SUCCEEDED(hRes));
; 290  : 		if(FAILED(hRes))

  00013	85 c0		 test	 eax, eax
  00015	7d 05		 jge	 SHORT $LN2@GetCount@7

; 291  : 			AtlThrow(hRes);

  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN12@GetCount@7:
$LN2@GetCount@7:

; 292  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8d 14 24	 lea	 edx, DWORD PTR _lUBound$[esp+8]
  00021	52		 push	 edx
  00022	6a 01		 push	 1
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 293  : 		ATLASSERT(SUCCEEDED(hRes));
; 294  : 		if(FAILED(hRes))

  0002b	85 c0		 test	 eax, eax
  0002d	7d 05		 jge	 SHORT $LN1@GetCount@7

; 295  : 			AtlThrow(hRes);

  0002f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@GetCount@7:
$LN1@GetCount@7:

; 296  : 		return (lUBound - lLBound + 1);

  00034	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+8]
  00037	2b 44 24 04	 sub	 eax, DWORD PTR _lLBound$[esp+8]
  0003b	40		 inc	 eax

; 297  : 	}

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
$LN11@GetCount@7:
?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<wchar_t *,8>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::Attach, COMDAT
; _this$ = edi
; _psaSrc$ = esi

; 197  : 	{

  00000	51		 push	 ecx

; 198  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00001	85 f6		 test	 esi, esi
  00003	75 0a		 jne	 SHORT $LN15@Attach@7
  00005	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN48@Attach@7:
  0000a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@Attach@7:
$LN15@Attach@7:

; 199  : 
; 200  : 		VARTYPE vt;
; 201  : 		HRESULT hRes = ::ATL::AtlSafeArrayGetActualVartype(const_cast<LPSAFEARRAY>(psaSrc), &vt);

  0000f	8d 04 24	 lea	 eax, DWORD PTR _vt$[esp+4]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0001a	85 c0		 test	 eax, eax
  0001c	7c ec		 jl	 SHORT $LN48@Attach@7
  0001e	8b 0c 24	 mov	 ecx, DWORD PTR _vt$[esp+4]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 17		 jne	 SHORT $LN11@Attach@7
  00027	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0002b	a8 40		 test	 al, 64			; 00000040H
  0002d	74 0f		 je	 SHORT $LN11@Attach@7
  0002f	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  00034	74 08		 je	 SHORT $LN11@Attach@7
  00036	b9 09 00 00 00	 mov	 ecx, 9
  0003b	89 0c 24	 mov	 DWORD PTR _vt$[esp+4], ecx
$LN11@Attach@7:

; 202  : 		ATLENSURE_SUCCEEDED(hRes);
; 203  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0003e	66 83 f9 08	 cmp	 cx, 8
  00042	74 0a		 je	 SHORT $LN7@Attach@7
  00044	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00049	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@Attach@7:
$LN7@Attach@7:

; 204  : 
; 205  : 		hRes = Destroy();

  0004e	8b 07		 mov	 eax, DWORD PTR [edi]
  00050	85 c0		 test	 eax, eax
  00052	74 1e		 je	 SHORT $LN3@Attach@7
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  0005b	85 c0		 test	 eax, eax
  0005d	7c ab		 jl	 SHORT $LN48@Attach@7
  0005f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  00068	85 c0		 test	 eax, eax
  0006a	7c 9e		 jl	 SHORT $LN48@Attach@7
  0006c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN3@Attach@7:

; 206  : 		ATLENSURE_SUCCEEDED(hRes);
; 207  : 
; 208  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);
; 209  : 		hRes = Lock();

  00072	56		 push	 esi
  00073	89 37		 mov	 DWORD PTR [edi], esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 210  : 
; 211  : 		return hRes;
; 212  : 	}

  0007b	59		 pop	 ecx
  0007c	c3		 ret	 0
$LN50@Attach@7:
?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::Attach
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@3
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@3
$LN3@Container_@3:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@3:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@4
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@4
$LN3@Container_@4:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@4:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@5
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@5
$LN3@Container_@5:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@5:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@6
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@6
$LN3@Container_@6:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@6:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::_Container_base_aux_alloc_real<std::allocator<unsigned long> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@7
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@7
$LN3@Container_@7:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@7:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::_Container_base_aux_alloc_real<std::allocator<unsigned long> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::_Container_base_aux_alloc_real<std::allocator<unsigned short> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@8
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@8
$LN3@Container_@8:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@8:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::_Container_base_aux_alloc_real<std::allocator<unsigned short> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >, COMDAT
; _this$ = esi

; 419  : 		{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c4		 xor	 eax, esp
  00015	50		 push	 eax
  00016	8d 44 24 04	 lea	 eax, DWORD PTR __$EHRec$[esp+16]
  0001a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

  00020	6a 04		 push	 4
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4
  0002a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00032	85 c0		 test	 eax, eax
  00034	74 04		 je	 SHORT $LN3@Container_@9
  00036	89 30		 mov	 DWORD PTR [eax], esi
  00038	eb 02		 jmp	 SHORT $LN4@Container_@9
$LN3@Container_@9:
  0003a	33 c0		 xor	 eax, eax
$LN4@Container_@9:
  0003c	c7 44 24 0c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+24], -1
  00044	89 06		 mov	 DWORD PTR [esi], eax

; 421  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0:
  00000	e9 00 00 00 00	 jmp	 ??3@YAXPAX0@Z		; operator delete
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z:
  00005	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00009	8d 02		 lea	 eax, DWORD PTR [edx]
  0000b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000e	33 c8		 xor	 ecx, eax
  00010	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00015	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
  0001a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
_TEXT	SEGMENT
$T184691 = -16						; size = 4
$T184686 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z PROC ; std::_Vector_val<wchar_t *,std::allocator<wchar_t *> >::_Vector_val<wchar_t *,std::allocator<wchar_t *> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184686[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184691[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
__ehhandler$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z ENDP ; std::_Vector_val<wchar_t *,std::allocator<wchar_t *> >::_Vector_val<wchar_t *,std::allocator<wchar_t *> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
_TEXT	SEGMENT
$T184709 = -16						; size = 4
$T184704 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z PROC ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184704[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184709[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
__ehhandler$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@NV?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ENDP ; std::_Vector_val<double,std::allocator<double> >::_Vector_val<double,std::allocator<double> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
_TEXT	SEGMENT
$T184727 = -16						; size = 4
$T184722 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z PROC ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184722[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184727[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
__ehhandler$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@MV?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ENDP ; std::_Vector_val<float,std::allocator<float> >::_Vector_val<float,std::allocator<float> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
_TEXT	SEGMENT
$T184745 = -16						; size = 4
$T184740 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z PROC ; std::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184740[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184745[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
__ehhandler$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@_KV?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z ENDP ; std::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >::_Vector_val<unsigned __int64,std::allocator<unsigned __int64> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
_TEXT	SEGMENT
$T184763 = -16						; size = 4
$T184758 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z PROC ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184758[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184763[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::_Container_base_aux_alloc_real<std::allocator<unsigned long> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >
__ehhandler$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@KV?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ENDP ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::_Vector_val<unsigned long,std::allocator<unsigned long> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
_TEXT	SEGMENT
$T184781 = -16						; size = 4
$T184776 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z PROC ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::_Vector_val<unsigned short,std::allocator<unsigned short> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184776[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184781[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::_Container_base_aux_alloc_real<std::allocator<unsigned short> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >
__ehhandler$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ENDP ; std::_Vector_val<unsigned short,std::allocator<unsigned short> >::_Vector_val<unsigned short,std::allocator<unsigned short> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
_TEXT	SEGMENT
$T184799 = -16						; size = 4
$T184794 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z PROC ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >, COMDAT

; 425  : 		{	// construct allocator from _Al

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T184794[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T184799[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >

; 426  : 		}

  00034	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0003c	8b c6		 mov	 eax, esi
  0003e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	5e		 pop	 esi
  0004b	83 c4 10	 add	 esp, 16			; 00000010H
  0004e	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
__ehhandler$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ENDP ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T184993 = -8						; size = 8
$T184992 = -8						; size = 8
$T184952 = -8						; size = 8
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1285 : 		{	// erase substring [_First, _Last)

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx

; 1286 : 		size_type _Count = _Pdif(_First, begin());

  00004	8b 5c 24 10	 mov	 ebx, DWORD PTR _this$[esp+8]
  00008	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  0000b	55		 push	 ebp
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	8d 6b 04	 lea	 ebp, DWORD PTR [ebx+4]
  00011	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00014	72 05		 jb	 SHORT $LN7@erase@10
  00016	8b 7d 00	 mov	 edi, DWORD PTR [ebp]
  00019	eb 02		 jmp	 SHORT $LN8@erase@10
$LN7@erase@10:
  0001b	8b fd		 mov	 edi, ebp
$LN8@erase@10:
  0001d	85 ff		 test	 edi, edi
  0001f	74 25		 je	 SHORT $LN14@erase@10
  00021	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00024	72 05		 jb	 SHORT $LN24@erase@10
  00026	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00029	eb 02		 jmp	 SHORT $LN25@erase@10
$LN24@erase@10:
  0002b	8b c5		 mov	 eax, ebp
$LN25@erase@10:
  0002d	3b c7		 cmp	 eax, edi
  0002f	77 15		 ja	 SHORT $LN14@erase@10
  00031	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00034	72 05		 jb	 SHORT $LN28@erase@10
  00036	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00039	eb 02		 jmp	 SHORT $LN29@erase@10
$LN28@erase@10:
  0003b	8b c5		 mov	 eax, ebp
$LN29@erase@10:
  0003d	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00040	03 c8		 add	 ecx, eax
  00042	3b f9		 cmp	 edi, ecx
  00044	76 05		 jbe	 SHORT $LN13@erase@10
$LN14@erase@10:
  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN13@erase@10:
  0004b	8b 4c 24 28	 mov	 ecx, DWORD PTR __First$[esp+24]
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR __First$[esp+20]
  00053	89 44 24 10	 mov	 DWORD PTR $T184952[esp+24], eax
  00057	8b f1		 mov	 esi, ecx
  00059	85 c9		 test	 ecx, ecx
  0005b	75 04		 jne	 SHORT $LN32@erase@10
  0005d	33 db		 xor	 ebx, ebx
  0005f	eb 1e		 jmp	 SHORT $LN33@erase@10
$LN32@erase@10:
  00061	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00064	74 15		 je	 SHORT $LN34@erase@10
  00066	85 c0		 test	 eax, eax
  00068	74 04		 je	 SHORT $LN37@erase@10
  0006a	3b c3		 cmp	 eax, ebx
  0006c	74 0d		 je	 SHORT $LN34@erase@10
$LN37@erase@10:
  0006e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00073	8b 4c 24 28	 mov	 ecx, DWORD PTR __First$[esp+24]
  00077	8b 44 24 24	 mov	 eax, DWORD PTR __First$[esp+20]
$LN34@erase@10:
  0007b	2b f7		 sub	 esi, edi
  0007d	8b de		 mov	 ebx, esi
$LN33@erase@10:

; 1287 : 		erase(_Count, _Pdif(_Last, _First));

  0007f	8b 54 24 2c	 mov	 edx, DWORD PTR __Last$[esp+20]
  00083	8b f9		 mov	 edi, ecx
  00085	8b 4c 24 30	 mov	 ecx, DWORD PTR __Last$[esp+24]
  00089	89 44 24 10	 mov	 DWORD PTR $T184993[esp+24], eax
  0008d	89 54 24 10	 mov	 DWORD PTR $T184992[esp+24], edx
  00091	8b f1		 mov	 esi, ecx
  00093	85 c9		 test	 ecx, ecx
  00095	74 14		 je	 SHORT $LN49@erase@10
$LN48@erase@10:
  00097	83 fa fc	 cmp	 edx, -4			; fffffffcH
  0009a	74 0d		 je	 SHORT $LN50@erase@10
  0009c	85 d2		 test	 edx, edx
  0009e	74 04		 je	 SHORT $LN53@erase@10
  000a0	3b d0		 cmp	 edx, eax
  000a2	74 05		 je	 SHORT $LN50@erase@10
$LN53@erase@10:
  000a4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN50@erase@10:
  000a9	2b f7		 sub	 esi, edi
$LN49@erase@10:
  000ab	8b 7c 24 1c	 mov	 edi, DWORD PTR _this$[esp+20]
  000af	56		 push	 esi
  000b0	53		 push	 ebx
  000b1	8b cf		 mov	 ecx, edi
  000b3	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1288 : 		return (_STRING_ITERATOR(_Myptr() + _Count));

  000b8	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  000bb	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000be	72 05		 jb	 SHORT $LN64@erase@10
  000c0	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000c3	eb 02		 jmp	 SHORT $LN65@erase@10
$LN64@erase@10:
  000c5	8b c5		 mov	 eax, ebp
$LN65@erase@10:
  000c7	8d 34 18	 lea	 esi, DWORD PTR [eax+ebx]
  000ca	8b 5c 24 20	 mov	 ebx, DWORD PTR ___$ReturnUdt$[esp+20]
  000ce	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  000d4	85 f6		 test	 esi, esi
  000d6	74 25		 je	 SHORT $LN71@erase@10
  000d8	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000db	72 05		 jb	 SHORT $LN81@erase@10
  000dd	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000e0	eb 02		 jmp	 SHORT $LN82@erase@10
$LN81@erase@10:
  000e2	8b c5		 mov	 eax, ebp
$LN82@erase@10:
  000e4	3b c6		 cmp	 eax, esi
  000e6	77 15		 ja	 SHORT $LN71@erase@10
  000e8	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000eb	72 05		 jb	 SHORT $LN85@erase@10
  000ed	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000f0	eb 02		 jmp	 SHORT $LN86@erase@10
$LN85@erase@10:
  000f2	8b c5		 mov	 eax, ebp
$LN86@erase@10:
  000f4	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  000f7	03 d0		 add	 edx, eax
  000f9	3b f2		 cmp	 esi, edx
  000fb	76 05		 jbe	 SHORT $LN70@erase@10
$LN71@erase@10:
  000fd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN70@erase@10:
  00102	89 3b		 mov	 DWORD PTR [ebx], edi

; 1289 : 		}

  00104	5f		 pop	 edi
  00105	89 73 04	 mov	 DWORD PTR [ebx+4], esi
  00108	5e		 pop	 esi
  00109	5d		 pop	 ebp
  0010a	8b c3		 mov	 eax, ebx
  0010c	5b		 pop	 ebx
  0010d	83 c4 08	 add	 esp, 8
  00110	c2 18 00	 ret	 24			; 00000018H
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
_TEXT	ENDS
;	COMDAT ?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::GetUpperBound, COMDAT
; _this$ = ecx

; 275  : 	{

  00000	51		 push	 ecx

; 276  : 		ATLASSUME(m_psa != NULL);
; 277  : 		LONG lUBound = 0;
; 278  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lUBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lUBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 279  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetUpperBo@7

; 280  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetUpperBo@7:
$LN1@GetUpperBo@7:

; 281  : 		return lUBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lUBound$[esp+4]

; 282  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetUpperBo@7:
?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::GetUpperBound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::GetLowerBound, COMDAT
; _this$ = ecx

; 266  : 	{

  00000	51		 push	 ecx

; 267  : 		ATLASSUME(m_psa != NULL);
; 268  : 		LONG lLBound = 0;
; 269  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00001	8b 11		 mov	 edx, DWORD PTR [ecx]
  00003	8d 04 24	 lea	 eax, DWORD PTR _lLBound$[esp+4]
  00006	50		 push	 eax
  00007	6a 01		 push	 1
  00009	52		 push	 edx
  0000a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _lLBound$[esp+16], 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 270  : 		if (FAILED(hRes))

  00018	85 c0		 test	 eax, eax
  0001a	7d 05		 jge	 SHORT $LN1@GetLowerBo@7

; 271  : 			AtlThrow(hRes);

  0001c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetLowerBo@7:
$LN1@GetLowerBo@7:

; 272  : 		return lLBound;

  00021	8b 04 24	 mov	 eax, DWORD PTR _lLBound$[esp+4]

; 273  : 	}

  00024	59		 pop	 ecx
  00025	c3		 ret	 0
$LN10@GetLowerBo@7:
?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::GetLowerBound
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
_TEXT	ENDS
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T185083 = -12						; size = 8
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = edi

; 1293 : 		erase(begin(), end());

  00000	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0000c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0000f	72 04		 jb	 SHORT $LN7@clear@10
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	eb 02		 jmp	 SHORT $LN8@clear@10
$LN7@clear@10:
  00015	8b c6		 mov	 eax, esi
$LN8@clear@10:
  00017	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0001a	8d 2c 01	 lea	 ebp, DWORD PTR [ecx+eax]
  0001d	85 ed		 test	 ebp, ebp
  0001f	74 20		 je	 SHORT $LN14@clear@10
  00021	83 fa 10	 cmp	 edx, 16			; 00000010H
  00024	72 04		 jb	 SHORT $LN24@clear@10
  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	eb 02		 jmp	 SHORT $LN25@clear@10
$LN24@clear@10:
  0002a	8b c6		 mov	 eax, esi
$LN25@clear@10:
  0002c	3b c5		 cmp	 eax, ebp
  0002e	77 11		 ja	 SHORT $LN14@clear@10
  00030	83 fa 10	 cmp	 edx, 16			; 00000010H
  00033	72 04		 jb	 SHORT $LN28@clear@10
  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	eb 02		 jmp	 SHORT $LN29@clear@10
$LN28@clear@10:
  00039	8b c6		 mov	 eax, esi
$LN29@clear@10:
  0003b	03 c8		 add	 ecx, eax
  0003d	3b e9		 cmp	 ebp, ecx
  0003f	76 05		 jbe	 SHORT $LN13@clear@10
$LN14@clear@10:
  00041	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN13@clear@10:
  00046	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00049	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0004c	72 04		 jb	 SHORT $LN34@clear@10
  0004e	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00050	eb 02		 jmp	 SHORT $LN35@clear@10
$LN34@clear@10:
  00052	8b de		 mov	 ebx, esi
$LN35@clear@10:
  00054	85 db		 test	 ebx, ebx
  00056	74 1f		 je	 SHORT $LN41@clear@10
  00058	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0005b	72 04		 jb	 SHORT $LN51@clear@10
  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	eb 02		 jmp	 SHORT $LN52@clear@10
$LN51@clear@10:
  00061	8b c6		 mov	 eax, esi
$LN52@clear@10:
  00063	3b c3		 cmp	 eax, ebx
  00065	77 10		 ja	 SHORT $LN41@clear@10
  00067	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0006a	72 02		 jb	 SHORT $LN55@clear@10
  0006c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN55@clear@10:
  0006e	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00071	03 c6		 add	 eax, esi
  00073	3b d8		 cmp	 ebx, eax
  00075	76 05		 jbe	 SHORT $LN40@clear@10
$LN41@clear@10:
  00077	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN40@clear@10:
  0007c	55		 push	 ebp
  0007d	57		 push	 edi
  0007e	53		 push	 ebx
  0007f	57		 push	 edi
  00080	8d 4c 24 20	 lea	 ecx, DWORD PTR $T185083[esp+44]
  00084	51		 push	 ecx
  00085	57		 push	 edi
  00086	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$_String_const_iterator@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1294 : 		}

  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	5b		 pop	 ebx
  0008e	83 c4 10	 add	 esp, 16			; 00000010H
  00091	c3		 ret	 0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z
_TEXT	SEGMENT
_lUBound$191785 = -4					; size = 4
_lLBound$191772 = -4					; size = 4
?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::GetAt, COMDAT
; _this$ = edi
; _lIndex$ = eax

; 333  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f0		 mov	 esi, eax

; 334  : 		ATLASSUME(m_psa != NULL);
; 335  : 		if(m_psa == NULL)

  00004	8b 07		 mov	 eax, DWORD PTR [edi]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN18@GetAt@7

; 336  : 			AtlThrow(E_FAIL);

  0000a	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN33@GetAt@7:

; 337  : 			
; 338  : 		LONG lLBound = GetLowerBound();

$LN18@GetAt@7:
  00014	8d 4c 24 04	 lea	 ecx, DWORD PTR _lLBound$191772[esp+8]
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _lLBound$191772[esp+20], 0
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  0002a	85 c0		 test	 eax, eax
  0002c	7d 05		 jge	 SHORT $LN12@GetAt@7
  0002e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN34@GetAt@7:
$LN12@GetAt@7:
  00033	55		 push	 ebp

; 339  : 		ATLASSERT(lIndex >= lLBound);
; 340  : 		ATLASSERT(lIndex <= GetUpperBound());
; 341  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00034	8b 6c 24 08	 mov	 ebp, DWORD PTR _lLBound$191772[esp+12]
  00038	3b f5		 cmp	 esi, ebp
  0003a	7c 35		 jl	 SHORT $LN1@GetAt@7
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	8d 54 24 08	 lea	 edx, DWORD PTR _lUBound$191785[esp+12]
  00042	52		 push	 edx
  00043	6a 01		 push	 1
  00045	50		 push	 eax
  00046	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _lUBound$191785[esp+24], 0
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00054	85 c0		 test	 eax, eax
  00056	7d 05		 jge	 SHORT $LN22@GetAt@7
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN35@GetAt@7:
$LN22@GetAt@7:
  0005d	3b 74 24 08	 cmp	 esi, DWORD PTR _lUBound$191785[esp+12]
  00061	7f 0e		 jg	 SHORT $LN1@GetAt@7

; 343  : 		
; 344  : 		return ((_ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00068	2b f5		 sub	 esi, ebp
  0006a	5d		 pop	 ebp
  0006b	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]
  0006e	5e		 pop	 esi

; 345  : 	}

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
$LN1@GetAt@7:

; 342  : 			AtlThrow(E_INVALIDARG);

  00071	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00076	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN36@GetAt@7:
$LN32@GetAt@7:
  0007b	cc		 int	 3
?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::GetAt
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T195422 = -80						; size = 28
$T195421 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T195422[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T195422[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T195422[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T195422[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T195422[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195421[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T195421[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195421[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@2:
$LN44@Xlen@2:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T195422[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T195421[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T195583 = -80						; size = 28
$T195582 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ PROC	; std::vector<double,std::allocator<double> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T195583[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T195583[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T195583[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T195583[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T195583[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195582[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T195582[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195582[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@3:
$LN44@Xlen@3:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T195583[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T195582[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ENDP	; std::vector<double,std::allocator<double> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T195744 = -80						; size = 28
$T195743 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ PROC	; std::vector<float,std::allocator<float> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T195744[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T195744[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T195744[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T195744[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T195744[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195743[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T195743[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195743[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@4:
$LN44@Xlen@4:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T195744[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T195743[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ENDP	; std::vector<float,std::allocator<float> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T195905 = -80						; size = 28
$T195904 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T195905[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T195905[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T195905[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T195905[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T195905[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195904[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T195904[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T195904[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@5:
$LN44@Xlen@5:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T195905[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T195904[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T196066 = -80						; size = 28
$T196065 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T196066[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T196066[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T196066[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T196066[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T196066[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T196065[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T196065[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T196065[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@6:
$LN44@Xlen@6:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T196066[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T196065[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T196227 = -80						; size = 28
$T196226 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T196227[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T196227[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T196227[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T196227[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T196227[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T196226[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T196226[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T196226[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@7:
$LN44@Xlen@7:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T196227[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T196226[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ$1
__ehfuncinfo$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T196388 = -80						; size = 28
$T196387 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 48	 sub	 esp, 72			; 00000048H
  00011	53		 push	 ebx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c4		 xor	 eax, esp
  00019	50		 push	 eax
  0001a	8d 44 24 50	 lea	 eax, DWORD PTR __$EHRec$[esp+92]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

  00024	6a 12		 push	 18			; 00000012H
  00026	33 db		 xor	 ebx, ebx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	8d 4c 24 14	 lea	 ecx, DWORD PTR $T196388[esp+100]
  00031	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T196388[esp+124], 15 ; 0000000fH
  00039	89 5c 24 28	 mov	 DWORD PTR $T196388[esp+120], ebx
  0003d	88 5c 24 18	 mov	 BYTE PTR $T196388[esp+104], bl
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00046	89 5c 24 58	 mov	 DWORD PTR __$EHRec$[esp+100], ebx
  0004a	8d 44 24 0c	 lea	 eax, DWORD PTR $T196388[esp+92]
  0004e	50		 push	 eax
  0004f	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T196387[esp+96]
  00053	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00058	c6 44 24 58 01	 mov	 BYTE PTR __$EHRec$[esp+100], 1
  0005d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR $T196387[esp+92], OFFSET ??_7length_error@std@@6B@
  00065	88 5c 24 58	 mov	 BYTE PTR __$EHRec$[esp+100], bl
  00069	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0006e	8d 4c 24 2c	 lea	 ecx, DWORD PTR $T196387[esp+96]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN45@Xlen@8:
$LN44@Xlen@8:
  00078	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ$0:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR $T196388[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ$1:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T196387[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
__ehhandler$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 b4	 lea	 eax, DWORD PTR [edx-76]
  00017	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196587 = -12						; size = 12
?_Buy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAE_NI@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00009	76 05		 jbe	 SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

  0000b	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlen
$LN27@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00010	8b ce		 mov	 ecx, esi
  00012	85 f6		 test	 esi, esi
  00014	77 21		 ja	 SHORT $LN21@Buy
  00016	33 c9		 xor	 ecx, ecx
$LN19@Buy:
  00018	03 c9		 add	 ecx, ecx
  0001a	03 c9		 add	 ecx, ecx
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

  00022	8d 14 b0	 lea	 edx, DWORD PTR [eax+esi*4]
  00025	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00028	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

  00031	b0 01		 mov	 al, 1

; 1115 : 		}

  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy:
  00037	83 c8 ff	 or	 eax, -1
  0003a	33 d2		 xor	 edx, edx
  0003c	f7 f6		 div	 esi
  0003e	83 f8 04	 cmp	 eax, 4
  00041	73 d5		 jae	 SHORT $LN19@Buy
  00043	6a 00		 push	 0
  00045	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196587[esp+16]
  00049	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00053	8d 44 24 04	 lea	 eax, DWORD PTR $T196587[esp+16]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy:
$LN26@Buy:
  0005d	cc		 int	 3
?_Buy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAE_NI@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196630 = -12						; size = 12
?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z PROC	; std::vector<double,std::allocator<double> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00009	76 05		 jbe	 SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

  0000b	e8 00 00 00 00	 call	 ?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN27@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00010	8b ce		 mov	 ecx, esi
  00012	85 f6		 test	 esi, esi
  00014	77 23		 ja	 SHORT $LN21@Buy@2
  00016	33 c9		 xor	 ecx, ecx
$LN19@Buy@2:
  00018	03 c9		 add	 ecx, ecx
  0001a	03 c9		 add	 ecx, ecx
  0001c	03 c9		 add	 ecx, ecx
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

  00024	8d 14 f0	 lea	 edx, DWORD PTR [eax+esi*8]
  00027	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0002a	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0002d	83 c4 04	 add	 esp, 4
  00030	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

  00033	b0 01		 mov	 al, 1

; 1115 : 		}

  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy@2:
  00039	83 c8 ff	 or	 eax, -1
  0003c	33 d2		 xor	 edx, edx
  0003e	f7 f6		 div	 esi
  00040	83 f8 08	 cmp	 eax, 8
  00043	73 d3		 jae	 SHORT $LN19@Buy@2
  00045	6a 00		 push	 0
  00047	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196630[esp+16]
  0004b	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00050	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00055	8d 44 24 04	 lea	 eax, DWORD PTR $T196630[esp+16]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy@2:
$LN26@Buy@2:
  0005f	cc		 int	 3
?_Buy@?$vector@NV?$allocator@N@std@@@std@@IAE_NI@Z ENDP	; std::vector<double,std::allocator<double> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196678 = -12						; size = 12
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z PROC	; std::vector<float,std::allocator<float> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00009	76 05		 jbe	 SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

  0000b	e8 00 00 00 00	 call	 ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN27@Buy@3:
$LN2@Buy@3:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00010	8b ce		 mov	 ecx, esi
  00012	85 f6		 test	 esi, esi
  00014	77 21		 ja	 SHORT $LN21@Buy@3
  00016	33 c9		 xor	 ecx, ecx
$LN19@Buy@3:
  00018	03 c9		 add	 ecx, ecx
  0001a	03 c9		 add	 ecx, ecx
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

  00022	8d 14 b0	 lea	 edx, DWORD PTR [eax+esi*4]
  00025	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00028	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

  00031	b0 01		 mov	 al, 1

; 1115 : 		}

  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy@3:
  00037	83 c8 ff	 or	 eax, -1
  0003a	33 d2		 xor	 edx, edx
  0003c	f7 f6		 div	 esi
  0003e	83 f8 04	 cmp	 eax, 4
  00041	73 d5		 jae	 SHORT $LN19@Buy@3
  00043	6a 00		 push	 0
  00045	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196678[esp+16]
  00049	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00053	8d 44 24 04	 lea	 eax, DWORD PTR $T196678[esp+16]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy@3:
$LN26@Buy@3:
  0005d	cc		 int	 3
?_Buy@?$vector@MV?$allocator@M@std@@@std@@IAE_NI@Z ENDP	; std::vector<float,std::allocator<float> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@_KV?$allocator@_K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196726 = -12						; size = 12
?_Buy@?$vector@_KV?$allocator@_K@std@@@std@@IAE_NI@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00009	76 05		 jbe	 SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

  0000b	e8 00 00 00 00	 call	 ?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlen
$LN27@Buy@4:
$LN2@Buy@4:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00010	8b ce		 mov	 ecx, esi
  00012	85 f6		 test	 esi, esi
  00014	77 23		 ja	 SHORT $LN21@Buy@4
  00016	33 c9		 xor	 ecx, ecx
$LN19@Buy@4:
  00018	03 c9		 add	 ecx, ecx
  0001a	03 c9		 add	 ecx, ecx
  0001c	03 c9		 add	 ecx, ecx
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

  00024	8d 14 f0	 lea	 edx, DWORD PTR [eax+esi*8]
  00027	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0002a	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0002d	83 c4 04	 add	 esp, 4
  00030	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

  00033	b0 01		 mov	 al, 1

; 1115 : 		}

  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy@4:
  00039	83 c8 ff	 or	 eax, -1
  0003c	33 d2		 xor	 edx, edx
  0003e	f7 f6		 div	 esi
  00040	83 f8 08	 cmp	 eax, 8
  00043	73 d3		 jae	 SHORT $LN19@Buy@4
  00045	6a 00		 push	 0
  00047	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196726[esp+16]
  0004b	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00050	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00055	8d 44 24 04	 lea	 eax, DWORD PTR $T196726[esp+16]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy@4:
$LN26@Buy@4:
  0005f	cc		 int	 3
?_Buy@?$vector@_KV?$allocator@_K@std@@@std@@IAE_NI@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196774 = -12						; size = 12
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00009	76 05		 jbe	 SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

  0000b	e8 00 00 00 00	 call	 ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$LN27@Buy@5:
$LN2@Buy@5:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00010	8b ce		 mov	 ecx, esi
  00012	85 f6		 test	 esi, esi
  00014	77 21		 ja	 SHORT $LN21@Buy@5
  00016	33 c9		 xor	 ecx, ecx
$LN19@Buy@5:
  00018	03 c9		 add	 ecx, ecx
  0001a	03 c9		 add	 ecx, ecx
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

  00022	8d 14 b0	 lea	 edx, DWORD PTR [eax+esi*4]
  00025	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00028	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

  00031	b0 01		 mov	 al, 1

; 1115 : 		}

  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy@5:
  00037	83 c8 ff	 or	 eax, -1
  0003a	33 d2		 xor	 edx, edx
  0003c	f7 f6		 div	 esi
  0003e	83 f8 04	 cmp	 eax, 4
  00041	73 d5		 jae	 SHORT $LN19@Buy@5
  00043	6a 00		 push	 0
  00045	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196774[esp+16]
  00049	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00053	8d 44 24 04	 lea	 eax, DWORD PTR $T196774[esp+16]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy@5:
$LN26@Buy@5:
  0005d	cc		 int	 3
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196822 = -12						; size = 12
?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00009	76 05		 jbe	 SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

  0000b	e8 00 00 00 00	 call	 ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
$LN27@Buy@6:
$LN2@Buy@6:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  00010	8b ce		 mov	 ecx, esi
  00012	85 f6		 test	 esi, esi
  00014	77 1f		 ja	 SHORT $LN21@Buy@6
  00016	33 c9		 xor	 ecx, ecx
$LN19@Buy@6:
  00018	03 c9		 add	 ecx, ecx
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

  00020	8d 14 70	 lea	 edx, DWORD PTR [eax+esi*2]
  00023	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00026	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00029	83 c4 04	 add	 esp, 4
  0002c	89 57 14	 mov	 DWORD PTR [edi+20], edx

; 1113 : 			}
; 1114 : 		return (true);

  0002f	b0 01		 mov	 al, 1

; 1115 : 		}

  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy@6:
  00035	83 c8 ff	 or	 eax, -1
  00038	33 d2		 xor	 edx, edx
  0003a	f7 f6		 div	 esi
  0003c	83 f8 02	 cmp	 eax, 2
  0003f	73 d7		 jae	 SHORT $LN19@Buy@6
  00041	6a 00		 push	 0
  00043	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196822[esp+16]
  00047	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  0004c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00051	8d 44 24 04	 lea	 eax, DWORD PTR $T196822[esp+16]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy@6:
$LN26@Buy@6:
  0005b	cc		 int	 3
?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
$T196870 = -12						; size = 12
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = esi

; 1102 : 		{	// allocate array with _Capacity elements

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)
; 1105 : 			return (false);
; 1106 : 		else if (max_size() < _Capacity)

  00003	83 fe ff	 cmp	 esi, -1
  00006	76 05		 jbe	 SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

  00008	e8 00 00 00 00	 call	 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
$LN27@Buy@7:
$LN2@Buy@7:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0000d	8b ce		 mov	 ecx, esi
  0000f	85 f6		 test	 esi, esi
  00011	77 1c		 ja	 SHORT $LN21@Buy@7
  00013	33 c9		 xor	 ecx, ecx
$LN19@Buy@7:
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001b	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 1111 : 			_Mylast = _Myfirst;

  0001e	89 47 10	 mov	 DWORD PTR [edi+16], eax
  00021	83 c4 04	 add	 esp, 4

; 1112 : 			_Myend = _Myfirst + _Capacity;

  00024	03 c6		 add	 eax, esi
  00026	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 1113 : 			}
; 1114 : 		return (true);

  00029	b0 01		 mov	 al, 1

; 1115 : 		}

  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	c3		 ret	 0

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN21@Buy@7:
  0002f	83 c8 ff	 or	 eax, -1
  00032	33 d2		 xor	 edx, edx
  00034	f7 f6		 div	 esi
  00036	83 f8 01	 cmp	 eax, 1
  00039	73 da		 jae	 SHORT $LN19@Buy@7
  0003b	6a 00		 push	 0
  0003d	8d 4c 24 04	 lea	 ecx, DWORD PTR $T196870[esp+16]
  00041	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@PBD@Z ; std::bad_alloc::bad_alloc
  00046	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004b	8d 44 24 04	 lea	 eax, DWORD PTR $T196870[esp+16]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Buy@7:
$LN26@Buy@7:
  00055	cc		 int	 3
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T196896 = -16						; size = 4
$T196901 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T196901[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T196896[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@V?$allocator@PA_W@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@PA_W@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t *> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t *> >
__unwindfunclet$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T196941 = -16						; size = 4
$T196946 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T196946[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T196941[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@V?$allocator@N@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<double> >::_Container_base_aux_alloc_real<std::allocator<double> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<double> >::~_Container_base_aux_alloc_real<std::allocator<double> >
__unwindfunclet$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@NV?$allocator@N@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T196986 = -16						; size = 4
$T196991 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T196991[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T196986[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@V?$allocator@M@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<float> >::_Container_base_aux_alloc_real<std::allocator<float> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@M@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<float> >::~_Container_base_aux_alloc_real<std::allocator<float> >
__unwindfunclet$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@MV?$allocator@M@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T197031 = -16						; size = 4
$T197036 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T197036[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T197031[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@V?$allocator@_K@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@_K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >::~_Container_base_aux_alloc_real<std::allocator<unsigned __int64> >
__unwindfunclet$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T197076 = -16						; size = 4
$T197081 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T197081[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T197076[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@V?$allocator@K@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::_Container_base_aux_alloc_real<std::allocator<unsigned long> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@K@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned long> >::~_Container_base_aux_alloc_real<std::allocator<unsigned long> >
__unwindfunclet$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T197121 = -16						; size = 4
$T197127 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T197127[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T197121[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::_Container_base_aux_alloc_real<std::allocator<unsigned short> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@G@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned short> >::~_Container_base_aux_alloc_real<std::allocator<unsigned short> >
__unwindfunclet$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@GV?$allocator@G@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T197166 = -16						; size = 4
$T197172 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 470  : 		{	// construct empty vector

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	56		 push	 esi
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	50		 push	 eax
  00018	8d 44 24 0c	 lea	 eax, DWORD PTR __$EHRec$[esp+24]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	8b 74 24 1c	 mov	 esi, DWORD PTR _this$[esp+20]
  00026	51		 push	 ecx
  00027	89 64 24 0c	 mov	 DWORD PTR $T197172[esp+28], esp
  0002b	89 64 24 0c	 mov	 DWORD PTR $T197166[esp+28], esp
  0002f	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >
  00034	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 1

; 471  : 		_Buy(0);

  0003c	33 c0		 xor	 eax, eax
  0003e	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00041	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00044	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 472  : 		}

  00047	c7 44 24 14 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+32], -1
  0004f	8b c6		 mov	 eax, esi
  00051	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$1:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
__unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
  00011	c3		 ret	 0
__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; __Ptr$ = edx

; 921  : 		return (assign(_Ptr));

  00000	8b c2		 mov	 eax, edx
  00002	56		 push	 esi
  00003	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL7@operator@69:
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	40		 inc	 eax
  00009	84 c9		 test	 cl, cl
  0000b	75 f9		 jne	 SHORT $LL7@operator@69
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR _this$[esp]
  00011	2b c6		 sub	 eax, esi
  00013	50		 push	 eax
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0001a	5e		 pop	 esi

; 922  : 		}

  0001b	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$0
__catchsym$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$2
__tryblocktable$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$5
__ehfuncinfo$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z
_TEXT	SEGMENT
$T209099 = -40						; size = 4
$T209100 = -36						; size = 4
__Whereoff$147288 = -32					; size = 4
__Ncopied$147289 = -28					; size = 4
__Newvec$147287 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv516 = 8						; size = 4
__Count$ = 8						; size = 4
__Tmp$147312 = 12					; size = 4
__Tmp$147302 = 12					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00030	85 c9		 test	 ecx, ecx
  00032	75 04		 jne	 SHORT $LN29@Insert_n@3
  00034	33 ff		 xor	 edi, edi
  00036	eb 0a		 jmp	 SHORT $LN30@Insert_n@3
$LN29@Insert_n@3:
  00038	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0003b	2b c1		 sub	 eax, ecx
  0003d	c1 f8 02	 sar	 eax, 2
  00040	8b f8		 mov	 edi, eax
$LN30@Insert_n@3:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00042	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00045	85 d2		 test	 edx, edx
  00047	0f 84 ef 01 00
	00		 je	 $LN126@Insert_n@3

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  0004d	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00050	8b c6		 mov	 eax, esi
  00052	2b c1		 sub	 eax, ecx
  00054	c1 f8 02	 sar	 eax, 2
  00057	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  0005c	2b c8		 sub	 ecx, eax
  0005e	3b ca		 cmp	 ecx, edx
  00060	73 05		 jae	 SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

  00062	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PA_WV?$allocator@PA_W@std@@@std@@KAXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlen
$LN141@Insert_n@3:
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

  00067	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0006a	3b f9		 cmp	 edi, ecx
  0006c	0f 83 e7 00 00
	00		 jae	 $LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00072	8b c7		 mov	 eax, edi
  00074	d1 e8		 shr	 eax, 1
  00076	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0007b	2b d0		 sub	 edx, eax
  0007d	3b d7		 cmp	 edx, edi
  0007f	73 0c		 jae	 SHORT $LN17@Insert_n@3
  00081	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  00088	8b 7d ec	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0008b	eb 05		 jmp	 SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
  0008d	03 f8		 add	 edi, eax
  0008f	89 7d ec	 mov	 DWORD PTR __Capacity$[ebp], edi
$LN18@Insert_n@3:

; 1171 : 			if (_Capacity < size() + _Count)

  00092	3b f9		 cmp	 edi, ecx
  00094	73 05		 jae	 SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

  00096	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
  00099	8b f9		 mov	 edi, ecx
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 ?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z ; std::allocator<wchar_t *>::allocate
  000a2	89 45 e8	 mov	 DWORD PTR __Newvec$147287[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  000a5	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  000a8	2b 4b 0c	 sub	 ecx, DWORD PTR [ebx+12]
  000ab	c1 f9 02	 sar	 ecx, 2
  000ae	89 4d e0	 mov	 DWORD PTR __Whereoff$147288[ebp], ecx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

  000b1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000b8	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]
  000bb	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  000be	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  000c1	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_WIABQA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Ufill

; 1179 : 			++_Ncopied;

  000c6	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR __Ncopied$147289[ebp], 1

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000cd	8b 75 e8	 mov	 esi, DWORD PTR __Newvec$147287[ebp]
  000d0	8b d6		 mov	 edx, esi
  000d2	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000d5	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000d8	e8 00 00 00 00	 call	 ??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>

; 1182 : 			++_Ncopied;

  000dd	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR __Ncopied$147289[ebp], 2

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000e4	8b 45 e0	 mov	 eax, DWORD PTR __Whereoff$147288[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  000ea	03 c1		 add	 eax, ecx
  000ec	8d 14 86	 lea	 edx, DWORD PTR [esi+eax*4]
  000ef	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000f2	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  000f5	e8 00 00 00 00	 call	 ??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>
  000fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  00101	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00104	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00107	2b d0		 sub	 edx, eax
  00109	c1 fa 02	 sar	 edx, 2
  0010c	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  0010f	03 fa		 add	 edi, edx

; 1195 : 			if (_Myfirst != 0)

  00111	85 c0		 test	 eax, eax
  00113	74 09		 je	 SHORT $LN55@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011b	83 c4 04	 add	 esp, 4
$LN55@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  0011e	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00121	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  00124	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

  00127	8d 14 be	 lea	 edx, DWORD PTR [esi+edi*4]
  0012a	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 1207 : 			_Myfirst = _Newvec;

  0012d	89 73 0c	 mov	 DWORD PTR [ebx+12], esi

; 1249 : 			}
; 1250 : 		}

  00130	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00133	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013a	59		 pop	 ecx
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 10 00	 ret	 16			; 00000010H
__catch$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00144	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$147287[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014d	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z$2:

; 1191 : 			_RERAISE;

  00150	6a 00		 push	 0
  00152	6a 00		 push	 0
  00154	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN142@Insert_n@3:
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00159	8b ce		 mov	 ecx, esi
  0015b	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  0015e	2b cf		 sub	 ecx, edi
  00160	c1 f9 02	 sar	 ecx, 2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00163	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00166	3b ca		 cmp	 ecx, edx

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00168	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016a	89 4d 0c	 mov	 DWORD PTR __Tmp$147302[ebp], ecx

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  0016d	73 75		 jae	 SHORT $LN3@Insert_n@3

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  0016f	8d 14 97	 lea	 edx, DWORD PTR [edi+edx*4]
  00172	8b c6		 mov	 eax, esi
  00174	e8 00 00 00 00	 call	 ??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

  00179	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  00180	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00183	8b f1		 mov	 esi, ecx
  00185	2b 75 14	 sub	 esi, DWORD PTR __Where$[ebp+4]
  00188	c1 fe 02	 sar	 esi, 2
  0018b	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  0018e	8b c2		 mov	 eax, edx
  00190	2b c6		 sub	 eax, esi
$LN140@Insert_n@3:
  00192	89 45 dc	 mov	 DWORD PTR $T209100[ebp], eax
  00195	89 4d d8	 mov	 DWORD PTR $T209099[ebp], ecx
  00198	85 c0		 test	 eax, eax
  0019a	76 0b		 jbe	 SHORT $LN75@Insert_n@3
  0019c	8b 75 0c	 mov	 esi, DWORD PTR __Tmp$147302[ebp]
  0019f	89 31		 mov	 DWORD PTR [ecx], esi
  001a1	48		 dec	 eax
  001a2	83 c1 04	 add	 ecx, 4
  001a5	eb eb		 jmp	 SHORT $LN140@Insert_n@3
$LN75@Insert_n@3:
  001a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  001ae	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  001b5	01 43 10	 add	 DWORD PTR [ebx+16], eax
  001b8	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  001bb	2b d8		 sub	 ebx, eax
  001bd	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001c0	3b c3		 cmp	 eax, ebx
  001c2	74 78		 je	 SHORT $LN126@Insert_n@3
$LL92@Insert_n@3:
  001c4	8b 55 0c	 mov	 edx, DWORD PTR __Tmp$147302[ebp]
  001c7	89 10		 mov	 DWORD PTR [eax], edx
  001c9	83 c0 04	 add	 eax, 4
  001cc	3b c3		 cmp	 eax, ebx
  001ce	75 f4		 jne	 SHORT $LL92@Insert_n@3

; 1249 : 			}
; 1250 : 		}

  001d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001da	59		 pop	 ecx
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	5b		 pop	 ebx
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c2 10 00	 ret	 16			; 00000010H
$LN3@Insert_n@3:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001e4	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  001eb	89 45 08	 mov	 DWORD PTR tv516[ebp], eax
  001ee	8b fe		 mov	 edi, esi
  001f0	2b f8		 sub	 edi, eax
  001f2	8b d6		 mov	 edx, esi
  001f4	8b c6		 mov	 eax, esi
  001f6	e8 00 00 00 00	 call	 ??$_Umove@PAPA_W@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEPAPA_WPAPA_W00@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove<wchar_t * *>
  001fb	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  001fe	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  00201	2b f8		 sub	 edi, eax
  00203	c1 ff 02	 sar	 edi, 2
  00206	85 ff		 test	 edi, edi
  00208	7e 18		 jle	 SHORT $LN113@Insert_n@3
  0020a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00211	51		 push	 ecx
  00212	50		 push	 eax
  00213	51		 push	 ecx
  00214	2b f1		 sub	 esi, ecx
  00216	56		 push	 esi
  00217	e8 00 00 00 00	 call	 _memmove_s
  0021c	83 c4 10	 add	 esp, 16			; 00000010H
  0021f	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
$LN113@Insert_n@3:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  00222	8b 55 08	 mov	 edx, DWORD PTR tv516[ebp]
  00225	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00228	3b c1		 cmp	 eax, ecx
  0022a	74 10		 je	 SHORT $LN126@Insert_n@3
  0022c	8d 64 24 00	 npad	 4
$LL128@Insert_n@3:
  00230	8b 55 0c	 mov	 edx, DWORD PTR __Tmp$147312[ebp]
  00233	89 10		 mov	 DWORD PTR [eax], edx
  00235	83 c0 04	 add	 eax, 4
  00238	3b c1		 cmp	 eax, ecx
  0023a	75 f4		 jne	 SHORT $LL128@Insert_n@3
$LN126@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

  0023c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0023f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00246	59		 pop	 ecx
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c2 10 00	 ret	 16			; 00000010H
$LN139@Insert_n@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$0
__catchsym$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$2
__tryblocktable$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$5
__ehfuncinfo$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
_TEXT	SEGMENT
$T209714 = -48						; size = 4
$T209715 = -44						; size = 4
$T209539 = -40						; size = 4
$T209540 = -36						; size = 4
__Tmp$147269 = -32					; size = 8
__Tmp$147259 = -32					; size = 8
__Newvec$147244 = -28					; size = 4
__Ncopied$147246 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv554 = 8						; size = 4
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z PROC ; std::vector<double,std::allocator<double> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002d	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00030	85 d2		 test	 edx, edx
  00032	75 04		 jne	 SHORT $LN29@Insert_n@4
  00034	33 c9		 xor	 ecx, ecx
  00036	eb 0a		 jmp	 SHORT $LN30@Insert_n@4
$LN29@Insert_n@4:
  00038	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0003b	2b c2		 sub	 eax, edx
  0003d	c1 f8 03	 sar	 eax, 3
  00040	8b c8		 mov	 ecx, eax
$LN30@Insert_n@4:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00042	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00045	85 ff		 test	 edi, edi
  00047	0f 84 e3 01 00
	00		 je	 $LN149@Insert_n@4

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  0004d	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00050	8b c6		 mov	 eax, esi
  00052	2b c2		 sub	 eax, edx
  00054	c1 f8 03	 sar	 eax, 3
  00057	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0005c	2b d0		 sub	 edx, eax
  0005e	3b d7		 cmp	 edx, edi
  00060	73 05		 jae	 SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

  00062	e8 00 00 00 00	 call	 ?_Xlen@?$vector@NV?$allocator@N@std@@@std@@KAXXZ ; std::vector<double,std::allocator<double> >::_Xlen
$LN203@Insert_n@4:
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

  00067	03 c7		 add	 eax, edi
  00069	3b c8		 cmp	 ecx, eax
  0006b	0f 83 e7 00 00
	00		 jae	 $LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00071	8b d1		 mov	 edx, ecx
  00073	d1 ea		 shr	 edx, 1
  00075	be ff ff ff 1f	 mov	 esi, 536870911		; 1fffffffH
  0007a	2b f2		 sub	 esi, edx
  0007c	3b f1		 cmp	 esi, ecx
  0007e	73 0c		 jae	 SHORT $LN17@Insert_n@4
  00080	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  00087	8b 4d ec	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0008a	eb 05		 jmp	 SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
  0008c	03 ca		 add	 ecx, edx
  0008e	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@4:

; 1171 : 			if (_Capacity < size() + _Count)

  00091	3b c8		 cmp	 ecx, eax
  00093	73 05		 jae	 SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

  00095	89 45 ec	 mov	 DWORD PTR __Capacity$[ebp], eax
  00098	8b c8		 mov	 ecx, eax
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0009a	e8 00 00 00 00	 call	 ?allocate@?$allocator@N@std@@QAEPANI@Z ; std::allocator<double>::allocate
  0009f	89 45 e4	 mov	 DWORD PTR __Newvec$147244[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  000a2	8b 75 14	 mov	 esi, DWORD PTR __Where$[ebp+4]
  000a5	2b 73 0c	 sub	 esi, DWORD PTR [ebx+12]
  000a8	c1 fe 03	 sar	 esi, 3

; 1175 : 			int _Ncopied = 0;

  000ab	33 c9		 xor	 ecx, ecx
  000ad	89 4d e8	 mov	 DWORD PTR __Ncopied$147246[ebp], ecx

; 1176 : 
; 1177 : 			_TRY_BEGIN

  000b0	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ecx
  000b3	9b		 fwait

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000b4	8d 0c f0	 lea	 ecx, DWORD PTR [eax+esi*8]
$LN201@Insert_n@4:
  000b7	89 7d dc	 mov	 DWORD PTR $T209540[ebp], edi
  000ba	89 4d d8	 mov	 DWORD PTR $T209539[ebp], ecx
  000bd	85 ff		 test	 edi, edi
  000bf	76 0d		 jbe	 SHORT $LN69@Insert_n@4
  000c1	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  000c4	dd 02		 fld	 QWORD PTR [edx]
  000c6	dd 19		 fstp	 QWORD PTR [ecx]
  000c8	4f		 dec	 edi
  000c9	83 c1 08	 add	 ecx, 8
  000cc	eb e9		 jmp	 SHORT $LN201@Insert_n@4
$LN69@Insert_n@4:

; 1179 : 			++_Ncopied;

  000ce	ff 45 e8	 inc	 DWORD PTR __Ncopied$147246[ebp]

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000d1	8b d0		 mov	 edx, eax
  000d3	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000d6	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000d9	e8 00 00 00 00	 call	 ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>

; 1182 : 			++_Ncopied;

  000de	ff 45 e8	 inc	 DWORD PTR __Ncopied$147246[ebp]

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000e1	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000e4	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000e7	8b 75 e4	 mov	 esi, DWORD PTR __Newvec$147244[ebp]
  000ea	8d 14 ce	 lea	 edx, DWORD PTR [esi+ecx*8]
  000ed	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000f0	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  000f3	e8 00 00 00 00	 call	 ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>

; 1185 : 			_CATCH_ALL

  000f8	9b		 fwait
  000f9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  00100	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00103	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00106	2b d0		 sub	 edx, eax
  00108	c1 fa 03	 sar	 edx, 3
  0010b	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  0010e	03 fa		 add	 edi, edx

; 1195 : 			if (_Myfirst != 0)

  00110	85 c0		 test	 eax, eax
  00112	74 09		 je	 SHORT $LN78@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011a	83 c4 04	 add	 esp, 4
$LN78@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  0011d	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00120	8d 0c c6	 lea	 ecx, DWORD PTR [esi+eax*8]
  00123	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

  00126	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  00129	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 1207 : 			_Myfirst = _Newvec;

  0012c	89 73 0c	 mov	 DWORD PTR [ebx+12], esi

; 1249 : 			}
; 1250 : 		}

  0012f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00132	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00139	59		 pop	 ecx
  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 10 00	 ret	 16			; 00000010H
__catch$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$0:

; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00143	8b 45 e4	 mov	 eax, DWORD PTR __Newvec$147244[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014c	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z$2:

; 1191 : 			_RERAISE;

  0014f	6a 00		 push	 0
  00151	6a 00		 push	 0
  00153	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN204@Insert_n@4:
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00158	8b d6		 mov	 edx, esi
  0015a	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  0015d	2b d1		 sub	 edx, ecx
  0015f	c1 fa 03	 sar	 edx, 3
  00162	3b d7		 cmp	 edx, edi
  00164	73 6c		 jae	 SHORT $LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00166	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00169	dd 00		 fld	 QWORD PTR [eax]
  0016b	dd 5d e0	 fstp	 QWORD PTR __Tmp$147259[ebp]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  0016e	8d 14 f9	 lea	 edx, DWORD PTR [ecx+edi*8]
  00171	8b c6		 mov	 eax, esi
  00173	8b f9		 mov	 edi, ecx
  00175	e8 00 00 00 00	 call	 ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

  0017a	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  00181	9b		 fwait

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  00182	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00185	8b f1		 mov	 esi, ecx
  00187	2b 75 14	 sub	 esi, DWORD PTR __Where$[ebp+4]
  0018a	c1 fe 03	 sar	 esi, 3
  0018d	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00190	8b c2		 mov	 eax, edx
  00192	2b c6		 sub	 eax, esi
  00194	dd 45 e0	 fld	 QWORD PTR __Tmp$147259[ebp]
$LN202@Insert_n@4:
  00197	89 45 d4	 mov	 DWORD PTR $T209715[ebp], eax
  0019a	89 4d d0	 mov	 DWORD PTR $T209714[ebp], ecx
  0019d	85 c0		 test	 eax, eax
  0019f	76 08		 jbe	 SHORT $LN98@Insert_n@4
  001a1	dd 11		 fst	 QWORD PTR [ecx]
  001a3	48		 dec	 eax
  001a4	83 c1 08	 add	 ecx, 8
  001a7	eb ee		 jmp	 SHORT $LN202@Insert_n@4
$LN98@Insert_n@4:

; 1219 : 			_CATCH_ALL

  001a9	9b		 fwait
  001aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  001b1	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  001b8	01 43 10	 add	 DWORD PTR [ebx+16], eax
  001bb	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  001be	2b d8		 sub	 ebx, eax
  001c0	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001c3	3b c3		 cmp	 eax, ebx
  001c5	74 67		 je	 SHORT $LN199@Insert_n@4
$LN115@Insert_n@4:
  001c7	dd 10		 fst	 QWORD PTR [eax]
  001c9	83 c0 08	 add	 eax, 8
  001cc	3b c3		 cmp	 eax, ebx
  001ce	75 f7		 jne	 SHORT $LN115@Insert_n@4

; 1232 : 			}
; 1233 : 		else

  001d0	eb 5c		 jmp	 SHORT $LN199@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  001d2	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  001d5	dd 01		 fld	 QWORD PTR [ecx]
  001d7	dd 5d e0	 fstp	 QWORD PTR __Tmp$147269[ebp]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001da	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  001e1	89 45 08	 mov	 DWORD PTR tv554[ebp], eax
  001e4	8b fe		 mov	 edi, esi
  001e6	2b f8		 sub	 edi, eax
  001e8	8b d6		 mov	 edx, esi
  001ea	8b c6		 mov	 eax, esi
  001ec	e8 00 00 00 00	 call	 ??$_Umove@PAN@?$vector@NV?$allocator@N@std@@@std@@IAEPANPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove<double *>
  001f1	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  001f4	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001f7	2b f8		 sub	 edi, eax
  001f9	c1 ff 03	 sar	 edi, 3
  001fc	85 ff		 test	 edi, edi
  001fe	7e 18		 jle	 SHORT $LN136@Insert_n@4
  00200	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  00207	51		 push	 ecx
  00208	50		 push	 eax
  00209	51		 push	 ecx
  0020a	2b f1		 sub	 esi, ecx
  0020c	56		 push	 esi
  0020d	e8 00 00 00 00	 call	 _memmove_s
  00212	83 c4 10	 add	 esp, 16			; 00000010H
  00215	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
$LN136@Insert_n@4:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  00218	8b 55 08	 mov	 edx, DWORD PTR tv554[ebp]
  0021b	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  0021e	3b c1		 cmp	 eax, ecx
  00220	74 0e		 je	 SHORT $LN149@Insert_n@4
  00222	dd 45 e0	 fld	 QWORD PTR __Tmp$147269[ebp]
$LN151@Insert_n@4:
  00225	dd 10		 fst	 QWORD PTR [eax]
  00227	83 c0 08	 add	 eax, 8
  0022a	3b c1		 cmp	 eax, ecx
  0022c	75 f7		 jne	 SHORT $LN151@Insert_n@4
$LN199@Insert_n@4:
  0022e	dd d8		 fstp	 ST(0)
$LN149@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

  00230	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00233	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023a	59		 pop	 ecx
  0023b	5f		 pop	 edi
  0023c	5e		 pop	 esi
  0023d	5b		 pop	 ebx
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c2 10 00	 ret	 16			; 00000010H
$LN200@Insert_n@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ENDP ; std::vector<double,std::allocator<double> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$0
__catchsym$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$2
__tryblocktable$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$5
__ehfuncinfo$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z
_TEXT	SEGMENT
$T210368 = -44						; size = 4
$T210369 = -40						; size = 4
$T210193 = -36						; size = 4
$T210194 = -32						; size = 4
__Newvec$147201 = -28					; size = 4
__Ncopied$147203 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv554 = 8						; size = 4
__Count$ = 8						; size = 4
__Tmp$147226 = 12					; size = 4
__Tmp$147216 = 12					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z PROC ; std::vector<float,std::allocator<float> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002d	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00030	85 d2		 test	 edx, edx
  00032	75 04		 jne	 SHORT $LN29@Insert_n@5
  00034	33 c9		 xor	 ecx, ecx
  00036	eb 0a		 jmp	 SHORT $LN30@Insert_n@5
$LN29@Insert_n@5:
  00038	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0003b	2b c2		 sub	 eax, edx
  0003d	c1 f8 02	 sar	 eax, 2
  00040	8b c8		 mov	 ecx, eax
$LN30@Insert_n@5:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00042	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00045	85 ff		 test	 edi, edi
  00047	0f 84 e3 01 00
	00		 je	 $LN149@Insert_n@5

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  0004d	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00050	8b c6		 mov	 eax, esi
  00052	2b c2		 sub	 eax, edx
  00054	c1 f8 02	 sar	 eax, 2
  00057	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0005c	2b d0		 sub	 edx, eax
  0005e	3b d7		 cmp	 edx, edi
  00060	73 05		 jae	 SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

  00062	e8 00 00 00 00	 call	 ?_Xlen@?$vector@MV?$allocator@M@std@@@std@@KAXXZ ; std::vector<float,std::allocator<float> >::_Xlen
$LN203@Insert_n@5:
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

  00067	03 c7		 add	 eax, edi
  00069	3b c8		 cmp	 ecx, eax
  0006b	0f 83 e7 00 00
	00		 jae	 $LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00071	8b d1		 mov	 edx, ecx
  00073	d1 ea		 shr	 edx, 1
  00075	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  0007a	2b f2		 sub	 esi, edx
  0007c	3b f1		 cmp	 esi, ecx
  0007e	73 0c		 jae	 SHORT $LN17@Insert_n@5
  00080	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  00087	8b 4d ec	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0008a	eb 05		 jmp	 SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
  0008c	03 ca		 add	 ecx, edx
  0008e	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@5:

; 1171 : 			if (_Capacity < size() + _Count)

  00091	3b c8		 cmp	 ecx, eax
  00093	73 05		 jae	 SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

  00095	89 45 ec	 mov	 DWORD PTR __Capacity$[ebp], eax
  00098	8b c8		 mov	 ecx, eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0009a	e8 00 00 00 00	 call	 ?allocate@?$allocator@M@std@@QAEPAMI@Z ; std::allocator<float>::allocate
  0009f	89 45 e4	 mov	 DWORD PTR __Newvec$147201[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  000a2	8b 75 14	 mov	 esi, DWORD PTR __Where$[ebp+4]
  000a5	2b 73 0c	 sub	 esi, DWORD PTR [ebx+12]
  000a8	c1 fe 02	 sar	 esi, 2

; 1175 : 			int _Ncopied = 0;

  000ab	33 c9		 xor	 ecx, ecx
  000ad	89 4d e8	 mov	 DWORD PTR __Ncopied$147203[ebp], ecx

; 1176 : 
; 1177 : 			_TRY_BEGIN

  000b0	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ecx
  000b3	9b		 fwait

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000b4	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
$LN201@Insert_n@5:
  000b7	89 7d e0	 mov	 DWORD PTR $T210194[ebp], edi
  000ba	89 4d dc	 mov	 DWORD PTR $T210193[ebp], ecx
  000bd	85 ff		 test	 edi, edi
  000bf	76 0d		 jbe	 SHORT $LN69@Insert_n@5
  000c1	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  000c4	d9 02		 fld	 DWORD PTR [edx]
  000c6	d9 19		 fstp	 DWORD PTR [ecx]
  000c8	4f		 dec	 edi
  000c9	83 c1 04	 add	 ecx, 4
  000cc	eb e9		 jmp	 SHORT $LN201@Insert_n@5
$LN69@Insert_n@5:

; 1179 : 			++_Ncopied;

  000ce	ff 45 e8	 inc	 DWORD PTR __Ncopied$147203[ebp]

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000d1	8b d0		 mov	 edx, eax
  000d3	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000d6	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000d9	e8 00 00 00 00	 call	 ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>

; 1182 : 			++_Ncopied;

  000de	ff 45 e8	 inc	 DWORD PTR __Ncopied$147203[ebp]

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000e1	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000e4	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000e7	8b 75 e4	 mov	 esi, DWORD PTR __Newvec$147201[ebp]
  000ea	8d 14 8e	 lea	 edx, DWORD PTR [esi+ecx*4]
  000ed	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000f0	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  000f3	e8 00 00 00 00	 call	 ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>

; 1185 : 			_CATCH_ALL

  000f8	9b		 fwait
  000f9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  00100	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00103	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00106	2b d0		 sub	 edx, eax
  00108	c1 fa 02	 sar	 edx, 2
  0010b	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  0010e	03 fa		 add	 edi, edx

; 1195 : 			if (_Myfirst != 0)

  00110	85 c0		 test	 eax, eax
  00112	74 09		 je	 SHORT $LN78@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011a	83 c4 04	 add	 esp, 4
$LN78@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  0011d	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00120	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  00123	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

  00126	8d 14 be	 lea	 edx, DWORD PTR [esi+edi*4]
  00129	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 1207 : 			_Myfirst = _Newvec;

  0012c	89 73 0c	 mov	 DWORD PTR [ebx+12], esi

; 1249 : 			}
; 1250 : 		}

  0012f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00132	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00139	59		 pop	 ecx
  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c2 10 00	 ret	 16			; 00000010H
__catch$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$0:

; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00143	8b 45 e4	 mov	 eax, DWORD PTR __Newvec$147201[ebp]
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014c	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z$2:

; 1191 : 			_RERAISE;

  0014f	6a 00		 push	 0
  00151	6a 00		 push	 0
  00153	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN204@Insert_n@5:
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00158	8b d6		 mov	 edx, esi
  0015a	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  0015d	2b d1		 sub	 edx, ecx
  0015f	c1 fa 02	 sar	 edx, 2
  00162	3b d7		 cmp	 edx, edi
  00164	73 6c		 jae	 SHORT $LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00166	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00169	d9 00		 fld	 DWORD PTR [eax]
  0016b	d9 5d 0c	 fstp	 DWORD PTR __Tmp$147216[ebp]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  0016e	8d 14 b9	 lea	 edx, DWORD PTR [ecx+edi*4]
  00171	8b c6		 mov	 eax, esi
  00173	8b f9		 mov	 edi, ecx
  00175	e8 00 00 00 00	 call	 ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

  0017a	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
  00181	9b		 fwait

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  00182	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00185	8b f1		 mov	 esi, ecx
  00187	2b 75 14	 sub	 esi, DWORD PTR __Where$[ebp+4]
  0018a	c1 fe 02	 sar	 esi, 2
  0018d	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00190	8b c2		 mov	 eax, edx
  00192	2b c6		 sub	 eax, esi
  00194	d9 45 0c	 fld	 DWORD PTR __Tmp$147216[ebp]
$LN202@Insert_n@5:
  00197	89 45 d8	 mov	 DWORD PTR $T210369[ebp], eax
  0019a	89 4d d4	 mov	 DWORD PTR $T210368[ebp], ecx
  0019d	85 c0		 test	 eax, eax
  0019f	76 08		 jbe	 SHORT $LN98@Insert_n@5
  001a1	d9 11		 fst	 DWORD PTR [ecx]
  001a3	48		 dec	 eax
  001a4	83 c1 04	 add	 ecx, 4
  001a7	eb ee		 jmp	 SHORT $LN202@Insert_n@5
$LN98@Insert_n@5:

; 1219 : 			_CATCH_ALL

  001a9	9b		 fwait
  001aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  001b1	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  001b8	01 43 10	 add	 DWORD PTR [ebx+16], eax
  001bb	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  001be	2b d8		 sub	 ebx, eax
  001c0	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001c3	3b c3		 cmp	 eax, ebx
  001c5	74 67		 je	 SHORT $LN199@Insert_n@5
$LN115@Insert_n@5:
  001c7	d9 10		 fst	 DWORD PTR [eax]
  001c9	83 c0 04	 add	 eax, 4
  001cc	3b c3		 cmp	 eax, ebx
  001ce	75 f7		 jne	 SHORT $LN115@Insert_n@5

; 1232 : 			}
; 1233 : 		else

  001d0	eb 5c		 jmp	 SHORT $LN199@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  001d2	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  001d5	d9 01		 fld	 DWORD PTR [ecx]
  001d7	d9 5d 0c	 fstp	 DWORD PTR __Tmp$147226[ebp]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001da	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  001e1	89 45 08	 mov	 DWORD PTR tv554[ebp], eax
  001e4	8b fe		 mov	 edi, esi
  001e6	2b f8		 sub	 edi, eax
  001e8	8b d6		 mov	 edx, esi
  001ea	8b c6		 mov	 eax, esi
  001ec	e8 00 00 00 00	 call	 ??$_Umove@PAM@?$vector@MV?$allocator@M@std@@@std@@IAEPAMPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove<float *>
  001f1	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  001f4	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001f7	2b f8		 sub	 edi, eax
  001f9	c1 ff 02	 sar	 edi, 2
  001fc	85 ff		 test	 edi, edi
  001fe	7e 18		 jle	 SHORT $LN136@Insert_n@5
  00200	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00207	51		 push	 ecx
  00208	50		 push	 eax
  00209	51		 push	 ecx
  0020a	2b f1		 sub	 esi, ecx
  0020c	56		 push	 esi
  0020d	e8 00 00 00 00	 call	 _memmove_s
  00212	83 c4 10	 add	 esp, 16			; 00000010H
  00215	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
$LN136@Insert_n@5:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  00218	8b 55 08	 mov	 edx, DWORD PTR tv554[ebp]
  0021b	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  0021e	3b c1		 cmp	 eax, ecx
  00220	74 0e		 je	 SHORT $LN149@Insert_n@5
  00222	d9 45 0c	 fld	 DWORD PTR __Tmp$147226[ebp]
$LN151@Insert_n@5:
  00225	d9 10		 fst	 DWORD PTR [eax]
  00227	83 c0 04	 add	 eax, 4
  0022a	3b c1		 cmp	 eax, ecx
  0022c	75 f7		 jne	 SHORT $LN151@Insert_n@5
$LN199@Insert_n@5:
  0022e	dd d8		 fstp	 ST(0)
$LN149@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

  00230	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00233	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023a	59		 pop	 ecx
  0023b	5f		 pop	 edi
  0023c	5e		 pop	 esi
  0023d	5b		 pop	 ebx
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c2 10 00	 ret	 16			; 00000010H
$LN200@Insert_n@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z ENDP ; std::vector<float,std::allocator<float> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$0
__catchsym$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$2
__tryblocktable$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$5
__ehfuncinfo$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z
_TEXT	SEGMENT
__Tmp$147183 = -40					; size = 8
__Tmp$147173 = -40					; size = 8
__Whereoff$147159 = -36					; size = 4
__Ncopied$147160 = -28					; size = 4
__Newvec$147158 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
tv452 = 12						; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00030	85 c9		 test	 ecx, ecx
  00032	75 04		 jne	 SHORT $LN29@Insert_n@6
  00034	33 ff		 xor	 edi, edi
  00036	eb 0a		 jmp	 SHORT $LN30@Insert_n@6
$LN29@Insert_n@6:
  00038	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0003b	2b c1		 sub	 eax, ecx
  0003d	c1 f8 03	 sar	 eax, 3
  00040	8b f8		 mov	 edi, eax
$LN30@Insert_n@6:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00042	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00045	85 d2		 test	 edx, edx
  00047	0f 84 e9 01 00
	00		 je	 $LN103@Insert_n@6

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  0004d	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00050	8b c6		 mov	 eax, esi
  00052	2b c1		 sub	 eax, ecx
  00054	c1 f8 03	 sar	 eax, 3
  00057	b9 ff ff ff 1f	 mov	 ecx, 536870911		; 1fffffffH
  0005c	2b c8		 sub	 ecx, eax
  0005e	3b ca		 cmp	 ecx, edx
  00060	73 05		 jae	 SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

  00062	e8 00 00 00 00	 call	 ?_Xlen@?$vector@_KV?$allocator@_K@std@@@std@@KAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlen
$LN116@Insert_n@6:
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

  00067	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0006a	3b f9		 cmp	 edi, ecx
  0006c	0f 83 e7 00 00
	00		 jae	 $LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00072	8b c7		 mov	 eax, edi
  00074	d1 e8		 shr	 eax, 1
  00076	ba ff ff ff 1f	 mov	 edx, 536870911		; 1fffffffH
  0007b	2b d0		 sub	 edx, eax
  0007d	3b d7		 cmp	 edx, edi
  0007f	73 0c		 jae	 SHORT $LN17@Insert_n@6
  00081	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  00088	8b 7d ec	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0008b	eb 05		 jmp	 SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
  0008d	03 f8		 add	 edi, eax
  0008f	89 7d ec	 mov	 DWORD PTR __Capacity$[ebp], edi
$LN18@Insert_n@6:

; 1171 : 			if (_Capacity < size() + _Count)

  00092	3b f9		 cmp	 edi, ecx
  00094	73 05		 jae	 SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

  00096	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
  00099	8b f9		 mov	 edi, ecx
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 ?allocate@?$allocator@_K@std@@QAEPA_KI@Z ; std::allocator<unsigned __int64>::allocate
  000a2	89 45 e8	 mov	 DWORD PTR __Newvec$147158[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  000a5	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  000a8	2b 4b 0c	 sub	 ecx, DWORD PTR [ebx+12]
  000ab	c1 f9 03	 sar	 ecx, 3
  000ae	89 4d dc	 mov	 DWORD PTR __Whereoff$147159[ebp], ecx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

  000b1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000b8	8d 3c c8	 lea	 edi, DWORD PTR [eax+ecx*8]
  000bb	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  000be	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  000c1	e8 00 00 00 00	 call	 ?_Ufill@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_KIAB_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Ufill

; 1179 : 			++_Ncopied;

  000c6	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR __Ncopied$147160[ebp], 1

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000cd	8b 75 e8	 mov	 esi, DWORD PTR __Newvec$147158[ebp]
  000d0	8b d6		 mov	 edx, esi
  000d2	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000d5	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000d8	e8 00 00 00 00	 call	 ??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>

; 1182 : 			++_Ncopied;

  000dd	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR __Ncopied$147160[ebp], 2

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000e4	8b 45 dc	 mov	 eax, DWORD PTR __Whereoff$147159[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  000ea	03 c1		 add	 eax, ecx
  000ec	8d 14 c6	 lea	 edx, DWORD PTR [esi+eax*8]
  000ef	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000f2	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  000f5	e8 00 00 00 00	 call	 ??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>
  000fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  00101	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00104	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00107	2b d0		 sub	 edx, eax
  00109	c1 fa 03	 sar	 edx, 3
  0010c	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  0010f	03 fa		 add	 edi, edx

; 1195 : 			if (_Myfirst != 0)

  00111	85 c0		 test	 eax, eax
  00113	74 09		 je	 SHORT $LN55@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011b	83 c4 04	 add	 esp, 4
$LN55@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  0011e	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00121	8d 0c c6	 lea	 ecx, DWORD PTR [esi+eax*8]
  00124	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

  00127	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  0012a	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 1207 : 			_Myfirst = _Newvec;

  0012d	89 73 0c	 mov	 DWORD PTR [ebx+12], esi

; 1249 : 			}
; 1250 : 		}

  00130	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00133	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013a	59		 pop	 ecx
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 10 00	 ret	 16			; 00000010H
__catch$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00144	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$147158[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014d	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z$2:

; 1191 : 			_RERAISE;

  00150	6a 00		 push	 0
  00152	6a 00		 push	 0
  00154	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN117@Insert_n@6:
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00159	8b ce		 mov	 ecx, esi
  0015b	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  0015e	2b cf		 sub	 ecx, edi
  00160	c1 f9 03	 sar	 ecx, 3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00163	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00166	3b ca		 cmp	 ecx, edx

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00168	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016a	89 4d d8	 mov	 DWORD PTR __Tmp$147173[ebp], ecx
  0016d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00170	89 45 dc	 mov	 DWORD PTR __Tmp$147173[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  00173	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  0017a	89 45 0c	 mov	 DWORD PTR tv452[ebp], eax

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  0017d	73 68		 jae	 SHORT $LN3@Insert_n@6

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  0017f	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00182	8b c6		 mov	 eax, esi
  00184	e8 00 00 00 00	 call	 ??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

  00189	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  00190	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00193	8b cf		 mov	 ecx, edi
  00195	2b 4d 14	 sub	 ecx, DWORD PTR __Where$[ebp+4]
  00198	c1 f9 03	 sar	 ecx, 3
  0019b	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  0019e	2b f1		 sub	 esi, ecx
  001a0	8d 55 d8	 lea	 edx, DWORD PTR __Tmp$147173[ebp]
  001a3	e8 00 00 00 00	 call	 ?_Ufill@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_KIAB_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Ufill
  001a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  001af	8b 45 0c	 mov	 eax, DWORD PTR tv452[ebp]
  001b2	01 43 10	 add	 DWORD PTR [ebx+16], eax
  001b5	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  001b8	2b d8		 sub	 ebx, eax
  001ba	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001bd	3b c3		 cmp	 eax, ebx
  001bf	74 75		 je	 SHORT $LN103@Insert_n@6
$LL69@Insert_n@6:
  001c1	8b 55 d8	 mov	 edx, DWORD PTR __Tmp$147173[ebp]
  001c4	89 10		 mov	 DWORD PTR [eax], edx
  001c6	8b 4d dc	 mov	 ecx, DWORD PTR __Tmp$147173[ebp+4]
  001c9	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001cc	83 c0 08	 add	 eax, 8
  001cf	3b c3		 cmp	 eax, ebx
  001d1	75 ee		 jne	 SHORT $LL69@Insert_n@6

; 1249 : 			}
; 1250 : 		}

  001d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001dd	59		 pop	 ecx
  001de	5f		 pop	 edi
  001df	5e		 pop	 esi
  001e0	5b		 pop	 ebx
  001e1	8b e5		 mov	 esp, ebp
  001e3	5d		 pop	 ebp
  001e4	c2 10 00	 ret	 16			; 00000010H
$LN3@Insert_n@6:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001e7	8b fe		 mov	 edi, esi
  001e9	2b f8		 sub	 edi, eax
  001eb	8b d6		 mov	 edx, esi
  001ed	8b c6		 mov	 eax, esi
  001ef	e8 00 00 00 00	 call	 ??$_Umove@PA_K@?$vector@_KV?$allocator@_K@std@@@std@@IAEPA_KPA_K00@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove<unsigned __int64 *>
  001f4	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  001f7	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001fa	2b f8		 sub	 edi, eax
  001fc	c1 ff 03	 sar	 edi, 3
  001ff	85 ff		 test	 edi, edi
  00201	7e 18		 jle	 SHORT $LN90@Insert_n@6
  00203	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  0020a	51		 push	 ecx
  0020b	50		 push	 eax
  0020c	51		 push	 ecx
  0020d	2b f1		 sub	 esi, ecx
  0020f	56		 push	 esi
  00210	e8 00 00 00 00	 call	 _memmove_s
  00215	83 c4 10	 add	 esp, 16			; 00000010H
  00218	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
$LN90@Insert_n@6:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  0021b	8b 4d 0c	 mov	 ecx, DWORD PTR tv452[ebp]
  0021e	03 c8		 add	 ecx, eax
  00220	3b c1		 cmp	 eax, ecx
  00222	74 12		 je	 SHORT $LN103@Insert_n@6
$LL105@Insert_n@6:
  00224	8b 55 d8	 mov	 edx, DWORD PTR __Tmp$147183[ebp]
  00227	89 10		 mov	 DWORD PTR [eax], edx
  00229	8b 55 dc	 mov	 edx, DWORD PTR __Tmp$147183[ebp+4]
  0022c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0022f	83 c0 08	 add	 eax, 8
  00232	3b c1		 cmp	 eax, ecx
  00234	75 ee		 jne	 SHORT $LL105@Insert_n@6
$LN103@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

  00236	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00239	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00240	59		 pop	 ecx
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx
  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c2 10 00	 ret	 16			; 00000010H
$LN115@Insert_n@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$0
__catchsym$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$2
__tryblocktable$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$5
__ehfuncinfo$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z
_TEXT	SEGMENT
$T211142 = -40						; size = 4
$T211143 = -36						; size = 4
__Whereoff$147116 = -32					; size = 4
__Ncopied$147117 = -28					; size = 4
__Newvec$147115 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv516 = 8						; size = 4
__Count$ = 8						; size = 4
__Tmp$147140 = 12					; size = 4
__Tmp$147130 = 12					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002d	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00030	85 c9		 test	 ecx, ecx
  00032	75 04		 jne	 SHORT $LN29@Insert_n@7
  00034	33 ff		 xor	 edi, edi
  00036	eb 0a		 jmp	 SHORT $LN30@Insert_n@7
$LN29@Insert_n@7:
  00038	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0003b	2b c1		 sub	 eax, ecx
  0003d	c1 f8 02	 sar	 eax, 2
  00040	8b f8		 mov	 edi, eax
$LN30@Insert_n@7:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00042	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00045	85 d2		 test	 edx, edx
  00047	0f 84 ef 01 00
	00		 je	 $LN126@Insert_n@7

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  0004d	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00050	8b c6		 mov	 eax, esi
  00052	2b c1		 sub	 eax, ecx
  00054	c1 f8 02	 sar	 eax, 2
  00057	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
  0005c	2b c8		 sub	 ecx, eax
  0005e	3b ca		 cmp	 ecx, edx
  00060	73 05		 jae	 SHORT $LN12@Insert_n@7

; 1166 : 			_Xlen();	// result too long

  00062	e8 00 00 00 00	 call	 ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$LN141@Insert_n@7:
$LN12@Insert_n@7:

; 1167 : 		else if (_Capacity < size() + _Count)

  00067	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  0006a	3b f9		 cmp	 edi, ecx
  0006c	0f 83 e7 00 00
	00		 jae	 $LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00072	8b c7		 mov	 eax, edi
  00074	d1 e8		 shr	 eax, 1
  00076	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0007b	2b d0		 sub	 edx, eax
  0007d	3b d7		 cmp	 edx, edi
  0007f	73 0c		 jae	 SHORT $LN17@Insert_n@7
  00081	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  00088	8b 7d ec	 mov	 edi, DWORD PTR __Capacity$[ebp]
  0008b	eb 05		 jmp	 SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
  0008d	03 f8		 add	 edi, eax
  0008f	89 7d ec	 mov	 DWORD PTR __Capacity$[ebp], edi
$LN18@Insert_n@7:

; 1171 : 			if (_Capacity < size() + _Count)

  00092	3b f9		 cmp	 edi, ecx
  00094	73 05		 jae	 SHORT $LN9@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

  00096	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
  00099	8b f9		 mov	 edi, ecx
$LN9@Insert_n@7:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0009b	8b cf		 mov	 ecx, edi
  0009d	e8 00 00 00 00	 call	 ?allocate@?$allocator@K@std@@QAEPAKI@Z ; std::allocator<unsigned long>::allocate
  000a2	89 45 e8	 mov	 DWORD PTR __Newvec$147115[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  000a5	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  000a8	2b 4b 0c	 sub	 ecx, DWORD PTR [ebx+12]
  000ab	c1 f9 02	 sar	 ecx, 2
  000ae	89 4d e0	 mov	 DWORD PTR __Whereoff$147116[ebp], ecx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

  000b1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000b8	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]
  000bb	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  000be	8b 75 08	 mov	 esi, DWORD PTR __Count$[ebp]
  000c1	e8 00 00 00 00	 call	 ?_Ufill@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAKIABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Ufill

; 1179 : 			++_Ncopied;

  000c6	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR __Ncopied$147117[ebp], 1

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000cd	8b 75 e8	 mov	 esi, DWORD PTR __Newvec$147115[ebp]
  000d0	8b d6		 mov	 edx, esi
  000d2	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000d5	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  000d8	e8 00 00 00 00	 call	 ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>

; 1182 : 			++_Ncopied;

  000dd	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR __Ncopied$147117[ebp], 2

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000e4	8b 45 e0	 mov	 eax, DWORD PTR __Whereoff$147116[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  000ea	03 c1		 add	 eax, ecx
  000ec	8d 14 86	 lea	 edx, DWORD PTR [esi+eax*4]
  000ef	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000f2	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  000f5	e8 00 00 00 00	 call	 ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
  000fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  00101	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00104	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00107	2b d0		 sub	 edx, eax
  00109	c1 fa 02	 sar	 edx, 2
  0010c	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  0010f	03 fa		 add	 edi, edx

; 1195 : 			if (_Myfirst != 0)

  00111	85 c0		 test	 eax, eax
  00113	74 09		 je	 SHORT $LN55@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0011b	83 c4 04	 add	 esp, 4
$LN55@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  0011e	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00121	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  00124	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

  00127	8d 14 be	 lea	 edx, DWORD PTR [esi+edi*4]
  0012a	89 53 10	 mov	 DWORD PTR [ebx+16], edx

; 1207 : 			_Myfirst = _Newvec;

  0012d	89 73 0c	 mov	 DWORD PTR [ebx+12], esi

; 1249 : 			}
; 1250 : 		}

  00130	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00133	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013a	59		 pop	 ecx
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c2 10 00	 ret	 16			; 00000010H
__catch$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00144	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$147115[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014d	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z$2:

; 1191 : 			_RERAISE;

  00150	6a 00		 push	 0
  00152	6a 00		 push	 0
  00154	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN142@Insert_n@7:
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00159	8b ce		 mov	 ecx, esi
  0015b	8b 7d 14	 mov	 edi, DWORD PTR __Where$[ebp+4]
  0015e	2b cf		 sub	 ecx, edi
  00160	c1 f9 02	 sar	 ecx, 2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00163	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00166	3b ca		 cmp	 ecx, edx

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00168	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016a	89 4d 0c	 mov	 DWORD PTR __Tmp$147130[ebp], ecx

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  0016d	73 75		 jae	 SHORT $LN3@Insert_n@7

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  0016f	8d 14 97	 lea	 edx, DWORD PTR [edi+edx*4]
  00172	8b c6		 mov	 eax, esi
  00174	e8 00 00 00 00	 call	 ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

  00179	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  00180	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00183	8b f1		 mov	 esi, ecx
  00185	2b 75 14	 sub	 esi, DWORD PTR __Where$[ebp+4]
  00188	c1 fe 02	 sar	 esi, 2
  0018b	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  0018e	8b c2		 mov	 eax, edx
  00190	2b c6		 sub	 eax, esi
$LN140@Insert_n@7:
  00192	89 45 dc	 mov	 DWORD PTR $T211143[ebp], eax
  00195	89 4d d8	 mov	 DWORD PTR $T211142[ebp], ecx
  00198	85 c0		 test	 eax, eax
  0019a	76 0b		 jbe	 SHORT $LN75@Insert_n@7
  0019c	8b 75 0c	 mov	 esi, DWORD PTR __Tmp$147130[ebp]
  0019f	89 31		 mov	 DWORD PTR [ecx], esi
  001a1	48		 dec	 eax
  001a2	83 c1 04	 add	 ecx, 4
  001a5	eb eb		 jmp	 SHORT $LN140@Insert_n@7
$LN75@Insert_n@7:
  001a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  001ae	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  001b5	01 43 10	 add	 DWORD PTR [ebx+16], eax
  001b8	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  001bb	2b d8		 sub	 ebx, eax
  001bd	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001c0	3b c3		 cmp	 eax, ebx
  001c2	74 78		 je	 SHORT $LN126@Insert_n@7
$LL92@Insert_n@7:
  001c4	8b 55 0c	 mov	 edx, DWORD PTR __Tmp$147130[ebp]
  001c7	89 10		 mov	 DWORD PTR [eax], edx
  001c9	83 c0 04	 add	 eax, 4
  001cc	3b c3		 cmp	 eax, ebx
  001ce	75 f4		 jne	 SHORT $LL92@Insert_n@7

; 1249 : 			}
; 1250 : 		}

  001d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001da	59		 pop	 ecx
  001db	5f		 pop	 edi
  001dc	5e		 pop	 esi
  001dd	5b		 pop	 ebx
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c2 10 00	 ret	 16			; 00000010H
$LN3@Insert_n@7:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001e4	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  001eb	89 45 08	 mov	 DWORD PTR tv516[ebp], eax
  001ee	8b fe		 mov	 edi, esi
  001f0	2b f8		 sub	 edi, eax
  001f2	8b d6		 mov	 edx, esi
  001f4	8b c6		 mov	 eax, esi
  001f6	e8 00 00 00 00	 call	 ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
  001fb	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  001fe	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  00201	2b f8		 sub	 edi, eax
  00203	c1 ff 02	 sar	 edi, 2
  00206	85 ff		 test	 edi, edi
  00208	7e 18		 jle	 SHORT $LN113@Insert_n@7
  0020a	8d 0c bd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*4]
  00211	51		 push	 ecx
  00212	50		 push	 eax
  00213	51		 push	 ecx
  00214	2b f1		 sub	 esi, ecx
  00216	56		 push	 esi
  00217	e8 00 00 00 00	 call	 _memmove_s
  0021c	83 c4 10	 add	 esp, 16			; 00000010H
  0021f	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
$LN113@Insert_n@7:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  00222	8b 55 08	 mov	 edx, DWORD PTR tv516[ebp]
  00225	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00228	3b c1		 cmp	 eax, ecx
  0022a	74 10		 je	 SHORT $LN126@Insert_n@7
  0022c	8d 64 24 00	 npad	 4
$LL128@Insert_n@7:
  00230	8b 55 0c	 mov	 edx, DWORD PTR __Tmp$147140[ebp]
  00233	89 10		 mov	 DWORD PTR [eax], edx
  00235	83 c0 04	 add	 eax, 4
  00238	3b c1		 cmp	 eax, ecx
  0023a	75 f4		 jne	 SHORT $LL128@Insert_n@7
$LN126@Insert_n@7:

; 1249 : 			}
; 1250 : 		}

  0023c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0023f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00246	59		 pop	 ecx
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c2 10 00	 ret	 16			; 00000010H
$LN139@Insert_n@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$0
__catchsym$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$2
__tryblocktable$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$5
__ehfuncinfo$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z
_TEXT	SEGMENT
__Result$212008 = -32					; size = 4
__Whereoff$147073 = -32					; size = 4
__Ncopied$147074 = -28					; size = 4
__Tmp$147097 = -24					; size = 2
__Tmp$147087 = -24					; size = 2
__Newvec$147072 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
tv580 = 8						; size = 4
__Val$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Insert_n, COMDAT
; _this$ = edx
; __Count$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	8b da		 mov	 ebx, edx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002f	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  00032	85 d2		 test	 edx, edx
  00034	75 04		 jne	 SHORT $LN29@Insert_n@8
  00036	33 c9		 xor	 ecx, ecx
  00038	eb 09		 jmp	 SHORT $LN30@Insert_n@8
$LN29@Insert_n@8:
  0003a	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0003d	2b c2		 sub	 eax, edx
  0003f	d1 f8		 sar	 eax, 1
  00041	8b c8		 mov	 ecx, eax
$LN30@Insert_n@8:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00043	85 f6		 test	 esi, esi
  00045	0f 84 05 02 00
	00		 je	 $LN165@Insert_n@8

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  0004b	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0004e	8b c7		 mov	 eax, edi
  00050	2b c2		 sub	 eax, edx
  00052	d1 f8		 sar	 eax, 1
  00054	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  00059	2b d0		 sub	 edx, eax
  0005b	3b d6		 cmp	 edx, esi
  0005d	73 05		 jae	 SHORT $LN12@Insert_n@8

; 1166 : 			_Xlen();	// result too long

  0005f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
$LN179@Insert_n@8:
$LN12@Insert_n@8:

; 1167 : 		else if (_Capacity < size() + _Count)

  00064	03 c6		 add	 eax, esi
  00066	3b c8		 cmp	 ecx, eax
  00068	0f 83 da 00 00
	00		 jae	 $LN10@Insert_n@8

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0006e	8b d1		 mov	 edx, ecx
  00070	d1 ea		 shr	 edx, 1
  00072	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00077	2b fa		 sub	 edi, edx
  00079	3b f9		 cmp	 edi, ecx
  0007b	73 0c		 jae	 SHORT $LN17@Insert_n@8
  0007d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  00084	8b 4d ec	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00087	eb 05		 jmp	 SHORT $LN18@Insert_n@8
$LN17@Insert_n@8:
  00089	03 ca		 add	 ecx, edx
  0008b	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@8:

; 1171 : 			if (_Capacity < size() + _Count)

  0008e	3b c8		 cmp	 ecx, eax
  00090	73 05		 jae	 SHORT $LN9@Insert_n@8

; 1172 : 				_Capacity = size() + _Count;

  00092	89 45 ec	 mov	 DWORD PTR __Capacity$[ebp], eax
  00095	8b c8		 mov	 ecx, eax
$LN9@Insert_n@8:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  00097	e8 00 00 00 00	 call	 ?allocate@?$allocator@G@std@@QAEPAGI@Z ; std::allocator<unsigned short>::allocate
  0009c	89 45 e8	 mov	 DWORD PTR __Newvec$147072[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  0009f	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  000a2	2b 4b 0c	 sub	 ecx, DWORD PTR [ebx+12]
  000a5	d1 f9		 sar	 ecx, 1
  000a7	89 4d e0	 mov	 DWORD PTR __Whereoff$147073[ebp], ecx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

  000aa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000b1	8d 3c 48	 lea	 edi, DWORD PTR [eax+ecx*2]
  000b4	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Ufill@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAGIABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ufill

; 1179 : 			++_Ncopied;

  000bc	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR __Ncopied$147074[ebp], 1

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000c3	8b 7d e8	 mov	 edi, DWORD PTR __Newvec$147072[ebp]
  000c6	8b cf		 mov	 ecx, edi
  000c8	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000cb	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  000ce	e8 00 00 00 00	 call	 ??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>

; 1182 : 			++_Ncopied;

  000d3	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR __Ncopied$147074[ebp], 2

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000da	8b 45 e0	 mov	 eax, DWORD PTR __Whereoff$147073[ebp]
  000dd	03 c6		 add	 eax, esi
  000df	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  000e2	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  000e5	8b 55 10	 mov	 edx, DWORD PTR __Where$[ebp+4]
  000e8	e8 00 00 00 00	 call	 ??$_Umove@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove<unsigned short *>
  000ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  000f4	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000f7	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  000fa	2b c8		 sub	 ecx, eax
  000fc	d1 f9		 sar	 ecx, 1
  000fe	03 f1		 add	 esi, ecx

; 1195 : 			if (_Myfirst != 0)

  00100	85 c0		 test	 eax, eax
  00102	74 09		 je	 SHORT $LN55@Insert_n@8

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0010a	83 c4 04	 add	 esp, 4
$LN55@Insert_n@8:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  0010d	8b 55 ec	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00110	8d 04 57	 lea	 eax, DWORD PTR [edi+edx*2]
  00113	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 1206 : 			_Mylast = _Newvec + _Count;

  00116	8d 0c 77	 lea	 ecx, DWORD PTR [edi+esi*2]
  00119	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx

; 1207 : 			_Myfirst = _Newvec;

  0011c	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi

; 1249 : 			}
; 1250 : 		}

  0011f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00122	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00129	59		 pop	 ecx
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 0c 00	 ret	 12			; 0000000cH
__catch$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00133	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$147072[ebp]
  00136	52		 push	 edx
  00137	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013c	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z$2:

; 1191 : 			_RERAISE;

  0013f	6a 00		 push	 0
  00141	6a 00		 push	 0
  00143	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN180@Insert_n@8:
$LN10@Insert_n@8:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  00148	8b c7		 mov	 eax, edi
  0014a	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  0014d	2b c1		 sub	 eax, ecx
  0014f	d1 f8		 sar	 eax, 1
  00151	3b c6		 cmp	 eax, esi
  00153	0f 83 89 00 00
	00		 jae	 $LN3@Insert_n@8

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00159	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0015c	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0015f	89 45 e8	 mov	 DWORD PTR __Tmp$147087[ebp], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  00162	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00165	89 45 08	 mov	 DWORD PTR tv580[ebp], eax
  00168	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0016b	2b f9		 sub	 edi, ecx
  0016d	d1 ff		 sar	 edi, 1
  0016f	74 0f		 je	 SHORT $LN85@Insert_n@8
  00171	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00174	50		 push	 eax
  00175	51		 push	 ecx
  00176	50		 push	 eax
  00177	52		 push	 edx
  00178	e8 00 00 00 00	 call	 _memmove_s
  0017d	83 c4 10	 add	 esp, 16			; 00000010H
$LN85@Insert_n@8:

; 1215 : 
; 1216 : 			_TRY_BEGIN

  00180	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  00187	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  0018a	8b cf		 mov	 ecx, edi
  0018c	2b 4d 10	 sub	 ecx, DWORD PTR __Where$[ebp+4]
  0018f	d1 f9		 sar	 ecx, 1
  00191	2b f1		 sub	 esi, ecx
  00193	8d 55 e8	 lea	 edx, DWORD PTR __Tmp$147087[ebp]
  00196	e8 00 00 00 00	 call	 ?_Ufill@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAGIABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ufill
  0019b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  001a2	8b 45 08	 mov	 eax, DWORD PTR tv580[ebp]
  001a5	01 43 10	 add	 DWORD PTR [ebx+16], eax
  001a8	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  001ab	2b d8		 sub	 ebx, eax
  001ad	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp+4]
  001b0	3b c3		 cmp	 eax, ebx
  001b2	0f 84 98 00 00
	00		 je	 $LN165@Insert_n@8
  001b8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL100@Insert_n@8:
  001c0	66 8b 55 e8	 mov	 dx, WORD PTR __Tmp$147087[ebp]
  001c4	66 89 10	 mov	 WORD PTR [eax], dx
  001c7	83 c0 02	 add	 eax, 2
  001ca	3b c3		 cmp	 eax, ebx
  001cc	75 f2		 jne	 SHORT $LL100@Insert_n@8

; 1249 : 			}
; 1250 : 		}

  001ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d8	59		 pop	 ecx
  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Insert_n@8:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  001e2	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  001e5	0f b7 10	 movzx	 edx, WORD PTR [eax]
  001e8	89 55 e8	 mov	 DWORD PTR __Tmp$147097[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001eb	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  001ee	89 45 08	 mov	 DWORD PTR tv580[ebp], eax
  001f1	8b f7		 mov	 esi, edi
  001f3	2b f0		 sub	 esi, eax
  001f5	8b c7		 mov	 eax, edi
  001f7	2b c6		 sub	 eax, esi
  001f9	d1 f8		 sar	 eax, 1
  001fb	8d 04 00	 lea	 eax, DWORD PTR [eax+eax]
  001fe	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00201	89 55 e0	 mov	 DWORD PTR __Result$212008[ebp], edx
  00204	74 0f		 je	 SHORT $LN131@Insert_n@8
  00206	50		 push	 eax
  00207	56		 push	 esi
  00208	50		 push	 eax
  00209	57		 push	 edi
  0020a	e8 00 00 00 00	 call	 _memmove_s
  0020f	83 c4 10	 add	 esp, 16			; 00000010H
  00212	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+4]
$LN131@Insert_n@8:
  00215	8b 45 e0	 mov	 eax, DWORD PTR __Result$212008[ebp]
  00218	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  0021b	2b f1		 sub	 esi, ecx
  0021d	d1 fe		 sar	 esi, 1
  0021f	85 f6		 test	 esi, esi
  00221	7e 14		 jle	 SHORT $LN152@Insert_n@8
  00223	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00226	50		 push	 eax
  00227	51		 push	 ecx
  00228	50		 push	 eax
  00229	2b f8		 sub	 edi, eax
  0022b	57		 push	 edi
  0022c	e8 00 00 00 00	 call	 _memmove_s
  00231	83 c4 10	 add	 esp, 16			; 00000010H
  00234	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+4]
$LN152@Insert_n@8:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  00237	8b 55 08	 mov	 edx, DWORD PTR tv580[ebp]
  0023a	03 d1		 add	 edx, ecx
  0023c	8b c1		 mov	 eax, ecx
  0023e	3b ca		 cmp	 ecx, edx
  00240	74 0e		 je	 SHORT $LN165@Insert_n@8
$LL167@Insert_n@8:
  00242	66 8b 4d e8	 mov	 cx, WORD PTR __Tmp$147097[ebp]
  00246	66 89 08	 mov	 WORD PTR [eax], cx
  00249	83 c0 02	 add	 eax, 2
  0024c	3b c2		 cmp	 eax, edx
  0024e	75 f2		 jne	 SHORT $LL167@Insert_n@8
$LN165@Insert_n@8:

; 1249 : 			}
; 1250 : 		}

  00250	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00253	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025a	59		 pop	 ecx
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5b		 pop	 ebx
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c2 0c 00	 ret	 12			; 0000000cH
$LN178@Insert_n@8:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$0
__catchsym$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$2
__tryblocktable$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$5
__ehfuncinfo$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z
_TEXT	SEGMENT
$T212487 = -40						; size = 4
$T212488 = -36						; size = 4
tv601 = -32						; size = 4
__Ncopied$147031 = -28					; size = 4
__Newvec$147029 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Tmp$147054 = 12					; size = 1
__Val$ = 12						; size = 4
__Tmp$147044 = 15					; size = 1
__Where$ = 16						; size = 8
?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n, COMDAT
; __Count$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

  0002d	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00030	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00033	85 c0		 test	 eax, eax
  00035	75 04		 jne	 SHORT $LN29@Insert_n@9
  00037	33 c9		 xor	 ecx, ecx
  00039	eb 05		 jmp	 SHORT $LN30@Insert_n@9
$LN29@Insert_n@9:
  0003b	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0003e	2b c8		 sub	 ecx, eax
$LN30@Insert_n@9:

; 1162 : 
; 1163 : 		if (_Count == 0)

  00040	85 db		 test	 ebx, ebx
  00042	0f 84 cf 01 00
	00		 je	 $LN190@Insert_n@9

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

  00048	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  0004b	8b d0		 mov	 edx, eax
  0004d	2b d6		 sub	 edx, esi
  0004f	4a		 dec	 edx
  00050	3b d3		 cmp	 edx, ebx
  00052	73 05		 jae	 SHORT $LN12@Insert_n@9

; 1166 : 			_Xlen();	// result too long

  00054	e8 00 00 00 00	 call	 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
$LN203@Insert_n@9:
$LN12@Insert_n@9:

; 1167 : 		else if (_Capacity < size() + _Count)

  00059	8b d6		 mov	 edx, esi
  0005b	2b d0		 sub	 edx, eax
  0005d	03 d3		 add	 edx, ebx
  0005f	3b ca		 cmp	 ecx, edx
  00061	0f 83 d7 00 00
	00		 jae	 $LN10@Insert_n@9

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00067	8b c1		 mov	 eax, ecx
  00069	d1 e8		 shr	 eax, 1
  0006b	83 ce ff	 or	 esi, -1
  0006e	2b f0		 sub	 esi, eax
  00070	3b f1		 cmp	 esi, ecx
  00072	73 0c		 jae	 SHORT $LN17@Insert_n@9
  00074	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$[ebp], 0
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0007e	eb 05		 jmp	 SHORT $LN18@Insert_n@9
$LN17@Insert_n@9:
  00080	03 c8		 add	 ecx, eax
  00082	89 4d ec	 mov	 DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@9:

; 1171 : 			if (_Capacity < size() + _Count)

  00085	3b ca		 cmp	 ecx, edx
  00087	73 05		 jae	 SHORT $LN9@Insert_n@9

; 1172 : 				_Capacity = size() + _Count;

  00089	89 55 ec	 mov	 DWORD PTR __Capacity$[ebp], edx
  0008c	8b ca		 mov	 ecx, edx
$LN9@Insert_n@9:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0008e	e8 00 00 00 00	 call	 ?allocate@?$allocator@E@std@@QAEPAEI@Z ; std::allocator<unsigned char>::allocate
  00093	89 45 e8	 mov	 DWORD PTR __Newvec$147029[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

  00096	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  00099	2b 4f 0c	 sub	 ecx, DWORD PTR [edi+12]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN

  0009c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

  000a3	03 c1		 add	 eax, ecx
  000a5	89 45 e0	 mov	 DWORD PTR tv601[ebp], eax
  000a8	50		 push	 eax
  000a9	8b 7d 0c	 mov	 edi, DWORD PTR __Val$[ebp]
  000ac	8b f3		 mov	 esi, ebx
  000ae	e8 00 00 00 00	 call	 ?_Ufill@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAEIABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ufill

; 1179 : 			++_Ncopied;

  000b3	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR __Ncopied$147031[ebp], 1

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

  000ba	8b 7d e8	 mov	 edi, DWORD PTR __Newvec$147029[ebp]
  000bd	8b cf		 mov	 ecx, edi
  000bf	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  000c2	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  000c5	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000c8	e8 00 00 00 00	 call	 ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>

; 1182 : 			++_Ncopied;

  000cd	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR __Ncopied$147031[ebp], 2

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv601[ebp]
  000d7	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  000da	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  000dd	8b 55 14	 mov	 edx, DWORD PTR __Where$[ebp+4]
  000e0	e8 00 00 00 00	 call	 ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove<unsigned char *>
  000e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

  000ec	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000ef	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000f2	2b c8		 sub	 ecx, eax
  000f4	03 d9		 add	 ebx, ecx

; 1195 : 			if (_Myfirst != 0)

  000f6	85 c0		 test	 eax, eax
  000f8	74 09		 je	 SHORT $LN55@Insert_n@9

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00100	83 c4 04	 add	 esp, 4
$LN55@Insert_n@9:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

  00103	8b 55 ec	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00106	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00109	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1206 : 			_Mylast = _Newvec + _Count;

  0010c	8d 0c 1f	 lea	 ecx, DWORD PTR [edi+ebx]
  0010f	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 1207 : 			_Myfirst = _Newvec;

  00112	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 1249 : 			}
; 1250 : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c2 10 00	 ret	 16			; 00000010H
__catch$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00129	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$147029[ebp]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00132	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z$2:

; 1191 : 			_RERAISE;

  00135	6a 00		 push	 0
  00137	6a 00		 push	 0
  00139	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN204@Insert_n@9:
$LN10@Insert_n@9:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

  0013e	8b c6		 mov	 eax, esi
  00140	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
  00143	2b c1		 sub	 eax, ecx
  00145	3b c3		 cmp	 eax, ebx
  00147	73 72		 jae	 SHORT $LN3@Insert_n@9

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00149	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  0014c	8a 12		 mov	 dl, BYTE PTR [edx]
  0014e	88 55 0f	 mov	 BYTE PTR __Tmp$147044[ebp], dl

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

  00151	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00154	2b f1		 sub	 esi, ecx
  00156	74 0f		 je	 SHORT $LN85@Insert_n@9
  00158	56		 push	 esi
  00159	51		 push	 ecx
  0015a	56		 push	 esi
  0015b	50		 push	 eax
  0015c	e8 00 00 00 00	 call	 _memmove_s
  00161	83 c4 10	 add	 esp, 16			; 00000010H
  00164	8a 55 0f	 mov	 dl, BYTE PTR __Tmp$147044[ebp]
$LN85@Insert_n@9:

; 1215 : 
; 1216 : 			_TRY_BEGIN

  00167	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

  0016e	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00171	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  00174	2b c6		 sub	 eax, esi
  00176	03 c3		 add	 eax, ebx
$LN202@Insert_n@9:
  00178	89 45 dc	 mov	 DWORD PTR $T212488[ebp], eax
  0017b	89 75 d8	 mov	 DWORD PTR $T212487[ebp], esi
  0017e	85 c0		 test	 eax, eax
  00180	76 06		 jbe	 SHORT $LN106@Insert_n@9
  00182	88 16		 mov	 BYTE PTR [esi], dl
  00184	48		 dec	 eax
  00185	46		 inc	 esi
  00186	eb f0		 jmp	 SHORT $LN202@Insert_n@9
$LN106@Insert_n@9:
  00188	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

  0018f	01 5f 10	 add	 DWORD PTR [edi+16], ebx
  00192	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

  00195	2b c3		 sub	 eax, ebx
  00197	8b c8		 mov	 ecx, eax
  00199	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+4]
  0019c	3b c1		 cmp	 eax, ecx
  0019e	74 77		 je	 SHORT $LN190@Insert_n@9
$LL123@Insert_n@9:
  001a0	88 10		 mov	 BYTE PTR [eax], dl
  001a2	40		 inc	 eax
  001a3	3b c1		 cmp	 eax, ecx
  001a5	75 f9		 jne	 SHORT $LL123@Insert_n@9

; 1249 : 			}
; 1250 : 		}

  001a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b1	59		 pop	 ecx
  001b2	5f		 pop	 edi
  001b3	5e		 pop	 esi
  001b4	5b		 pop	 ebx
  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	c2 10 00	 ret	 16			; 00000010H
$LN3@Insert_n@9:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  001bb	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  001be	8a 10		 mov	 dl, BYTE PTR [eax]
  001c0	88 55 0c	 mov	 BYTE PTR __Tmp$147054[ebp], dl

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

  001c3	8b d6		 mov	 edx, esi
  001c5	2b d3		 sub	 edx, ebx
  001c7	8b c6		 mov	 eax, esi
  001c9	2b c2		 sub	 eax, edx
  001cb	8d 3c 30	 lea	 edi, DWORD PTR [eax+esi]
  001ce	74 0f		 je	 SHORT $LN154@Insert_n@9
  001d0	50		 push	 eax
  001d1	52		 push	 edx
  001d2	50		 push	 eax
  001d3	56		 push	 esi
  001d4	e8 00 00 00 00	 call	 _memmove_s
  001d9	83 c4 10	 add	 esp, 16			; 00000010H
  001dc	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
$LN154@Insert_n@9:
  001df	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  001e2	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

  001e5	8b c6		 mov	 eax, esi
  001e7	2b c1		 sub	 eax, ecx
  001e9	2b c3		 sub	 eax, ebx
  001eb	85 c0		 test	 eax, eax
  001ed	7e 11		 jle	 SHORT $LN175@Insert_n@9
  001ef	50		 push	 eax
  001f0	51		 push	 ecx
  001f1	50		 push	 eax
  001f2	2b f0		 sub	 esi, eax
  001f4	56		 push	 esi
  001f5	e8 00 00 00 00	 call	 _memmove_s
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
  001fd	8b 4d 14	 mov	 ecx, DWORD PTR __Where$[ebp+4]
$LN175@Insert_n@9:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

  00200	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00203	3b c8		 cmp	 ecx, eax
  00205	74 10		 je	 SHORT $LN190@Insert_n@9
  00207	2b c1		 sub	 eax, ecx
  00209	50		 push	 eax
  0020a	8b 55 0c	 mov	 edx, DWORD PTR __Tmp$147054[ebp]
  0020d	52		 push	 edx
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 _memset
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN190@Insert_n@9:

; 1249 : 			}
; 1250 : 		}

  00217	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0021a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00221	59		 pop	 ecx
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c2 10 00	 ret	 16			; 00000010H
$LN201@Insert_n@9:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXIPA_W@Z
_TEXT	SEGMENT
__Tmp$213385 = -24					; size = 8
__Val$ = -24						; size = 4
tv355 = -16						; size = 4
$T213043 = -12						; size = 8
$T213039 = -12						; size = 8
?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXIPA_W@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 718  : 		if (size() < _Newsize)

  00008	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000b	8b d8		 mov	 ebx, eax
  0000d	57		 push	 edi
  0000e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00011	8b c7		 mov	 eax, edi
  00013	2b c1		 sub	 eax, ecx
  00015	c1 f8 02	 sar	 eax, 2
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __Val$[esp+44], 0
  00020	89 7c 24 1c	 mov	 DWORD PTR tv355[esp+44], edi
  00024	3b d8		 cmp	 ebx, eax
  00026	76 2d		 jbe	 SHORT $LN99@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00028	3b cf		 cmp	 ecx, edi
  0002a	76 05		 jbe	 SHORT $LN14@resize
  0002c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize:
  00031	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  00039	57		 push	 edi
  0003a	50		 push	 eax
  0003b	c1 f9 02	 sar	 ecx, 2
  0003e	8d 44 24 1c	 lea	 eax, DWORD PTR __Val$[esp+52]
  00042	2b d9		 sub	 ebx, ecx
  00044	50		 push	 eax
  00045	53		 push	 ebx
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PA_WV?$allocator@PA_W@std@@@std@@IAEXV?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@IABQA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Insert_n

; 722  : 		}

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	5b		 pop	 ebx
  00051	83 c4 1c	 add	 esp, 28			; 0000001cH
  00054	c3		 ret	 0
$LN99@resize:

; 720  : 		else if (_Newsize < size())

  00055	73 6b		 jae	 SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

  00057	3b cf		 cmp	 ecx, edi
  00059	76 05		 jbe	 SHORT $LN37@resize
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize:
  00060	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00063	8b 16		 mov	 edx, DWORD PTR [esi]
  00065	89 54 24 20	 mov	 DWORD PTR $T213039[esp+44], edx
  00069	3b 6e 10	 cmp	 ebp, DWORD PTR [esi+16]
  0006c	76 05		 jbe	 SHORT $LN56@resize
  0006e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize:
  00073	8b 3e		 mov	 edi, DWORD PTR [esi]
  00075	89 7c 24 14	 mov	 DWORD PTR __Tmp$213385[esp+44], edi
  00079	89 6c 24 18	 mov	 DWORD PTR __Tmp$213385[esp+48], ebp
  0007d	85 ff		 test	 edi, edi
  0007f	75 18		 jne	 SHORT $LN98@resize
  00081	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00086	33 c0		 xor	 eax, eax
$LN89@resize:
  00088	8d 5c 9d 00	 lea	 ebx, DWORD PTR [ebp+ebx*4]
  0008c	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  0008f	77 13		 ja	 SHORT $LN76@resize
  00091	85 ff		 test	 edi, edi
  00093	74 08		 je	 SHORT $LN94@resize
  00095	8b 3f		 mov	 edi, DWORD PTR [edi]
  00097	eb 06		 jmp	 SHORT $LN95@resize
$LN98@resize:
  00099	8b 07		 mov	 eax, DWORD PTR [edi]
  0009b	eb eb		 jmp	 SHORT $LN89@resize
$LN94@resize:
  0009d	33 ff		 xor	 edi, edi
$LN95@resize:
  0009f	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  000a2	73 05		 jae	 SHORT $LN75@resize
$LN76@resize:
  000a4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize:
  000a9	8b 44 24 1c	 mov	 eax, DWORD PTR tv355[esp+44]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR $T213039[esp+44]
  000b1	8b 54 24 14	 mov	 edx, DWORD PTR __Tmp$213385[esp+44]
  000b5	50		 push	 eax
  000b6	51		 push	 ecx
  000b7	53		 push	 ebx
  000b8	52		 push	 edx
  000b9	8d 5c 24 30	 lea	 ebx, DWORD PTR $T213043[esp+60]
  000bd	e8 00 00 00 00	 call	 ?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::erase
$LN1@resize:

; 722  : 		}

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5d		 pop	 ebp
  000c5	5b		 pop	 ebx
  000c6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c9	c3		 ret	 0
?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXIPA_W@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXIN@Z
_TEXT	SEGMENT
tv355 = -16						; size = 4
$T213394 = -12						; size = 8
__Tmp$213740 = 8					; size = 8
$T213398 = 8						; size = 8
__Val$ = 8						; size = 8
?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXIN@Z PROC ; std::vector<double,std::allocator<double> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 718  : 		if (size() < _Newsize)

  00008	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000b	8b d8		 mov	 ebx, eax
  0000d	57		 push	 edi
  0000e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00011	8b c7		 mov	 eax, edi
  00013	2b c1		 sub	 eax, ecx
  00015	c1 f8 03	 sar	 eax, 3
  00018	89 7c 24 14	 mov	 DWORD PTR tv355[esp+36], edi
  0001c	3b d8		 cmp	 ebx, eax
  0001e	76 2f		 jbe	 SHORT $LN99@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00020	3b cf		 cmp	 ecx, edi
  00022	76 05		 jbe	 SHORT $LN14@resize@2
  00024	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize@2:
  00029	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  00031	57		 push	 edi
  00032	50		 push	 eax
  00033	c1 f9 03	 sar	 ecx, 3
  00036	8d 44 24 30	 lea	 eax, DWORD PTR __Val$[esp+40]
  0003a	2b d9		 sub	 ebx, ecx
  0003c	50		 push	 eax
  0003d	53		 push	 ebx
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@NV?$allocator@N@std@@@std@@IAEXV?$_Vector_const_iterator@NV?$allocator@N@std@@@2@IABN@Z ; std::vector<double,std::allocator<double> >::_Insert_n

; 722  : 		}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	5b		 pop	 ebx
  00049	83 c4 14	 add	 esp, 20			; 00000014H
  0004c	c2 08 00	 ret	 8
$LN99@resize@2:

; 720  : 		else if (_Newsize < size())

  0004f	73 6b		 jae	 SHORT $LN1@resize@2

; 721  : 			erase(begin() + _Newsize, end());

  00051	3b cf		 cmp	 ecx, edi
  00053	76 05		 jbe	 SHORT $LN37@resize@2
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize@2:
  0005a	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  0005d	8b 16		 mov	 edx, DWORD PTR [esi]
  0005f	89 54 24 18	 mov	 DWORD PTR $T213394[esp+36], edx
  00063	3b 6e 10	 cmp	 ebp, DWORD PTR [esi+16]
  00066	76 05		 jbe	 SHORT $LN56@resize@2
  00068	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize@2:
  0006d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0006f	89 7c 24 28	 mov	 DWORD PTR __Tmp$213740[esp+32], edi
  00073	89 6c 24 2c	 mov	 DWORD PTR __Tmp$213740[esp+36], ebp
  00077	85 ff		 test	 edi, edi
  00079	75 18		 jne	 SHORT $LN98@resize@2
  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00080	33 c0		 xor	 eax, eax
$LN89@resize@2:
  00082	8d 5c dd 00	 lea	 ebx, DWORD PTR [ebp+ebx*8]
  00086	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  00089	77 13		 ja	 SHORT $LN76@resize@2
  0008b	85 ff		 test	 edi, edi
  0008d	74 08		 je	 SHORT $LN94@resize@2
  0008f	8b 3f		 mov	 edi, DWORD PTR [edi]
  00091	eb 06		 jmp	 SHORT $LN95@resize@2
$LN98@resize@2:
  00093	8b 07		 mov	 eax, DWORD PTR [edi]
  00095	eb eb		 jmp	 SHORT $LN89@resize@2
$LN94@resize@2:
  00097	33 ff		 xor	 edi, edi
$LN95@resize@2:
  00099	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  0009c	73 05		 jae	 SHORT $LN75@resize@2
$LN76@resize@2:
  0009e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize@2:
  000a3	8b 44 24 14	 mov	 eax, DWORD PTR tv355[esp+36]
  000a7	8b 4c 24 18	 mov	 ecx, DWORD PTR $T213394[esp+36]
  000ab	8b 54 24 28	 mov	 edx, DWORD PTR __Tmp$213740[esp+32]
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	53		 push	 ebx
  000b2	52		 push	 edx
  000b3	8d 5c 24 38	 lea	 ebx, DWORD PTR $T213398[esp+48]
  000b7	e8 00 00 00 00	 call	 ?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z ; std::vector<double,std::allocator<double> >::erase
$LN1@resize@2:

; 722  : 		}

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5d		 pop	 ebp
  000bf	5b		 pop	 ebx
  000c0	83 c4 14	 add	 esp, 20			; 00000014H
  000c3	c2 08 00	 ret	 8
?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXIN@Z ENDP ; std::vector<double,std::allocator<double> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXIM@Z
_TEXT	SEGMENT
tv355 = -20						; size = 4
__Tmp$214094 = -16					; size = 8
$T213753 = -8						; size = 8
$T213749 = -8						; size = 8
__Val$ = 8						; size = 4
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXIM@Z PROC ; std::vector<float,std::allocator<float> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 718  : 		if (size() < _Newsize)

  00008	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000b	8b d8		 mov	 ebx, eax
  0000d	57		 push	 edi
  0000e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00011	8b c7		 mov	 eax, edi
  00013	2b c1		 sub	 eax, ecx
  00015	c1 f8 02	 sar	 eax, 2
  00018	89 7c 24 14	 mov	 DWORD PTR tv355[esp+40], edi
  0001c	3b d8		 cmp	 ebx, eax
  0001e	76 2f		 jbe	 SHORT $LN99@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00020	3b cf		 cmp	 ecx, edi
  00022	76 05		 jbe	 SHORT $LN14@resize@3
  00024	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize@3:
  00029	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  00031	57		 push	 edi
  00032	50		 push	 eax
  00033	c1 f9 02	 sar	 ecx, 2
  00036	8d 44 24 34	 lea	 eax, DWORD PTR __Val$[esp+44]
  0003a	2b d9		 sub	 ebx, ecx
  0003c	50		 push	 eax
  0003d	53		 push	 ebx
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@MV?$allocator@M@std@@@std@@IAEXV?$_Vector_const_iterator@MV?$allocator@M@std@@@2@IABM@Z ; std::vector<float,std::allocator<float> >::_Insert_n

; 722  : 		}

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5d		 pop	 ebp
  00048	5b		 pop	 ebx
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	c2 04 00	 ret	 4
$LN99@resize@3:

; 720  : 		else if (_Newsize < size())

  0004f	73 6b		 jae	 SHORT $LN1@resize@3

; 721  : 			erase(begin() + _Newsize, end());

  00051	3b cf		 cmp	 ecx, edi
  00053	76 05		 jbe	 SHORT $LN37@resize@3
  00055	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize@3:
  0005a	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  0005d	8b 16		 mov	 edx, DWORD PTR [esi]
  0005f	89 54 24 20	 mov	 DWORD PTR $T213749[esp+40], edx
  00063	3b 6e 10	 cmp	 ebp, DWORD PTR [esi+16]
  00066	76 05		 jbe	 SHORT $LN56@resize@3
  00068	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize@3:
  0006d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0006f	89 7c 24 18	 mov	 DWORD PTR __Tmp$214094[esp+40], edi
  00073	89 6c 24 1c	 mov	 DWORD PTR __Tmp$214094[esp+44], ebp
  00077	85 ff		 test	 edi, edi
  00079	75 18		 jne	 SHORT $LN98@resize@3
  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00080	33 c0		 xor	 eax, eax
$LN89@resize@3:
  00082	8d 5c 9d 00	 lea	 ebx, DWORD PTR [ebp+ebx*4]
  00086	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  00089	77 13		 ja	 SHORT $LN76@resize@3
  0008b	85 ff		 test	 edi, edi
  0008d	74 08		 je	 SHORT $LN94@resize@3
  0008f	8b 3f		 mov	 edi, DWORD PTR [edi]
  00091	eb 06		 jmp	 SHORT $LN95@resize@3
$LN98@resize@3:
  00093	8b 07		 mov	 eax, DWORD PTR [edi]
  00095	eb eb		 jmp	 SHORT $LN89@resize@3
$LN94@resize@3:
  00097	33 ff		 xor	 edi, edi
$LN95@resize@3:
  00099	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  0009c	73 05		 jae	 SHORT $LN75@resize@3
$LN76@resize@3:
  0009e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize@3:
  000a3	8b 44 24 14	 mov	 eax, DWORD PTR tv355[esp+40]
  000a7	8b 4c 24 20	 mov	 ecx, DWORD PTR $T213749[esp+40]
  000ab	8b 54 24 18	 mov	 edx, DWORD PTR __Tmp$214094[esp+40]
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	53		 push	 ebx
  000b2	52		 push	 edx
  000b3	8d 5c 24 30	 lea	 ebx, DWORD PTR $T213753[esp+56]
  000b7	e8 00 00 00 00	 call	 ?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase
$LN1@resize@3:

; 722  : 		}

  000bc	5f		 pop	 edi
  000bd	5e		 pop	 esi
  000be	5d		 pop	 ebp
  000bf	5b		 pop	 ebx
  000c0	83 c4 18	 add	 esp, 24			; 00000018H
  000c3	c2 04 00	 ret	 4
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXIM@Z ENDP ; std::vector<float,std::allocator<float> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI_K@Z
_TEXT	SEGMENT
tv355 = -24						; size = 4
__Tmp$214450 = -20					; size = 8
__Val$ = -20						; size = 8
$T214108 = -12						; size = 8
$T214104 = -12						; size = 8
?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI_K@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	8b d8		 mov	 ebx, eax

; 721  : 			erase(begin() + _Newsize, end());

  00007	33 c0		 xor	 eax, eax
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000f	57		 push	 edi
  00010	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00013	89 44 24 18	 mov	 DWORD PTR __Val$[esp+44], eax
  00017	89 44 24 1c	 mov	 DWORD PTR __Val$[esp+48], eax
  0001b	8b c7		 mov	 eax, edi
  0001d	2b c1		 sub	 eax, ecx
  0001f	c1 f8 03	 sar	 eax, 3
  00022	89 7c 24 14	 mov	 DWORD PTR tv355[esp+44], edi
  00026	3b d8		 cmp	 ebx, eax
  00028	76 2d		 jbe	 SHORT $LN99@resize@4

; 718  : 		if (size() < _Newsize)
; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  0002a	3b cf		 cmp	 ecx, edi
  0002c	76 05		 jbe	 SHORT $LN14@resize@4
  0002e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize@4:
  00033	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  0003b	57		 push	 edi
  0003c	50		 push	 eax
  0003d	c1 f9 03	 sar	 ecx, 3
  00040	8d 44 24 20	 lea	 eax, DWORD PTR __Val$[esp+52]
  00044	2b d9		 sub	 ebx, ecx
  00046	50		 push	 eax
  00047	53		 push	 ebx
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@_KV?$allocator@_K@std@@@std@@IAEXV?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@IAB_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Insert_n

; 722  : 		}

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5d		 pop	 ebp
  00052	5b		 pop	 ebx
  00053	83 c4 1c	 add	 esp, 28			; 0000001cH
  00056	c3		 ret	 0
$LN99@resize@4:

; 720  : 		else if (_Newsize < size())

  00057	73 6b		 jae	 SHORT $LN1@resize@4

; 721  : 			erase(begin() + _Newsize, end());

  00059	3b cf		 cmp	 ecx, edi
  0005b	76 05		 jbe	 SHORT $LN37@resize@4
  0005d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize@4:
  00062	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00065	8b 16		 mov	 edx, DWORD PTR [esi]
  00067	89 54 24 20	 mov	 DWORD PTR $T214104[esp+44], edx
  0006b	3b 6e 10	 cmp	 ebp, DWORD PTR [esi+16]
  0006e	76 05		 jbe	 SHORT $LN56@resize@4
  00070	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize@4:
  00075	8b 3e		 mov	 edi, DWORD PTR [esi]
  00077	89 7c 24 18	 mov	 DWORD PTR __Tmp$214450[esp+44], edi
  0007b	89 6c 24 1c	 mov	 DWORD PTR __Tmp$214450[esp+48], ebp
  0007f	85 ff		 test	 edi, edi
  00081	75 18		 jne	 SHORT $LN98@resize@4
  00083	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00088	33 c0		 xor	 eax, eax
$LN89@resize@4:
  0008a	8d 5c dd 00	 lea	 ebx, DWORD PTR [ebp+ebx*8]
  0008e	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  00091	77 13		 ja	 SHORT $LN76@resize@4
  00093	85 ff		 test	 edi, edi
  00095	74 08		 je	 SHORT $LN94@resize@4
  00097	8b 3f		 mov	 edi, DWORD PTR [edi]
  00099	eb 06		 jmp	 SHORT $LN95@resize@4
$LN98@resize@4:
  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	eb eb		 jmp	 SHORT $LN89@resize@4
$LN94@resize@4:
  0009f	33 ff		 xor	 edi, edi
$LN95@resize@4:
  000a1	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  000a4	73 05		 jae	 SHORT $LN75@resize@4
$LN76@resize@4:
  000a6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize@4:
  000ab	8b 44 24 14	 mov	 eax, DWORD PTR tv355[esp+44]
  000af	8b 4c 24 20	 mov	 ecx, DWORD PTR $T214104[esp+44]
  000b3	8b 54 24 18	 mov	 edx, DWORD PTR __Tmp$214450[esp+44]
  000b7	50		 push	 eax
  000b8	51		 push	 ecx
  000b9	53		 push	 ebx
  000ba	52		 push	 edx
  000bb	8d 5c 24 30	 lea	 ebx, DWORD PTR $T214108[esp+60]
  000bf	e8 00 00 00 00	 call	 ?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::erase
$LN1@resize@4:

; 722  : 		}

  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	5d		 pop	 ebp
  000c7	5b		 pop	 ebx
  000c8	83 c4 1c	 add	 esp, 28			; 0000001cH
  000cb	c3		 ret	 0
?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI_K@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXIK@Z
_TEXT	SEGMENT
__Tmp$214805 = -24					; size = 8
__Val$ = -24						; size = 4
tv355 = -16						; size = 4
$T214463 = -12						; size = 8
$T214459 = -12						; size = 8
?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXIK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 718  : 		if (size() < _Newsize)

  00008	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000b	8b d8		 mov	 ebx, eax
  0000d	57		 push	 edi
  0000e	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00011	8b c7		 mov	 eax, edi
  00013	2b c1		 sub	 eax, ecx
  00015	c1 f8 02	 sar	 eax, 2
  00018	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __Val$[esp+44], 0
  00020	89 7c 24 1c	 mov	 DWORD PTR tv355[esp+44], edi
  00024	3b d8		 cmp	 ebx, eax
  00026	76 2d		 jbe	 SHORT $LN99@resize@5

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00028	3b cf		 cmp	 ecx, edi
  0002a	76 05		 jbe	 SHORT $LN14@resize@5
  0002c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize@5:
  00031	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  00039	57		 push	 edi
  0003a	50		 push	 eax
  0003b	c1 f9 02	 sar	 ecx, 2
  0003e	8d 44 24 1c	 lea	 eax, DWORD PTR __Val$[esp+52]
  00042	2b d9		 sub	 ebx, ecx
  00044	50		 push	 eax
  00045	53		 push	 ebx
  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@KV?$allocator@K@std@@@std@@IAEXV?$_Vector_const_iterator@KV?$allocator@K@std@@@2@IABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Insert_n

; 722  : 		}

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5d		 pop	 ebp
  00050	5b		 pop	 ebx
  00051	83 c4 1c	 add	 esp, 28			; 0000001cH
  00054	c3		 ret	 0
$LN99@resize@5:

; 720  : 		else if (_Newsize < size())

  00055	73 6b		 jae	 SHORT $LN1@resize@5

; 721  : 			erase(begin() + _Newsize, end());

  00057	3b cf		 cmp	 ecx, edi
  00059	76 05		 jbe	 SHORT $LN37@resize@5
  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize@5:
  00060	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  00063	8b 16		 mov	 edx, DWORD PTR [esi]
  00065	89 54 24 20	 mov	 DWORD PTR $T214459[esp+44], edx
  00069	3b 6e 10	 cmp	 ebp, DWORD PTR [esi+16]
  0006c	76 05		 jbe	 SHORT $LN56@resize@5
  0006e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize@5:
  00073	8b 3e		 mov	 edi, DWORD PTR [esi]
  00075	89 7c 24 14	 mov	 DWORD PTR __Tmp$214805[esp+44], edi
  00079	89 6c 24 18	 mov	 DWORD PTR __Tmp$214805[esp+48], ebp
  0007d	85 ff		 test	 edi, edi
  0007f	75 18		 jne	 SHORT $LN98@resize@5
  00081	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00086	33 c0		 xor	 eax, eax
$LN89@resize@5:
  00088	8d 5c 9d 00	 lea	 ebx, DWORD PTR [ebp+ebx*4]
  0008c	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  0008f	77 13		 ja	 SHORT $LN76@resize@5
  00091	85 ff		 test	 edi, edi
  00093	74 08		 je	 SHORT $LN94@resize@5
  00095	8b 3f		 mov	 edi, DWORD PTR [edi]
  00097	eb 06		 jmp	 SHORT $LN95@resize@5
$LN98@resize@5:
  00099	8b 07		 mov	 eax, DWORD PTR [edi]
  0009b	eb eb		 jmp	 SHORT $LN89@resize@5
$LN94@resize@5:
  0009d	33 ff		 xor	 edi, edi
$LN95@resize@5:
  0009f	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  000a2	73 05		 jae	 SHORT $LN75@resize@5
$LN76@resize@5:
  000a4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize@5:
  000a9	8b 44 24 1c	 mov	 eax, DWORD PTR tv355[esp+44]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR $T214459[esp+44]
  000b1	8b 54 24 14	 mov	 edx, DWORD PTR __Tmp$214805[esp+44]
  000b5	50		 push	 eax
  000b6	51		 push	 ecx
  000b7	53		 push	 ebx
  000b8	52		 push	 edx
  000b9	8d 5c 24 30	 lea	 ebx, DWORD PTR $T214463[esp+60]
  000bd	e8 00 00 00 00	 call	 ?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::erase
$LN1@resize@5:

; 722  : 		}

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5d		 pop	 ebp
  000c5	5b		 pop	 ebx
  000c6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000c9	c3		 ret	 0
?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXIK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXIG@Z
_TEXT	SEGMENT
__Val$ = -16						; size = 2
__Tmp$215160 = -16					; size = 8
$T214818 = -8						; size = 8
$T214814 = -8						; size = 8
__Newsize$ = 8						; size = 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXIG@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::resize, COMDAT
; _this$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 718  : 		if (size() < _Newsize)

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000e	8b c5		 mov	 eax, ebp
  00010	2b c1		 sub	 eax, ecx
  00012	57		 push	 edi
  00013	8b 7c 24 24	 mov	 edi, DWORD PTR __Newsize$[esp+28]
  00017	d1 f8		 sar	 eax, 1
  00019	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __Val$[esp+32], 0
  00021	3b f8		 cmp	 edi, eax
  00023	76 2f		 jbe	 SHORT $LN99@resize@6

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00025	3b cd		 cmp	 ecx, ebp
  00027	76 05		 jbe	 SHORT $LN14@resize@6
  00029	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize@6:
  0002e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00031	2b 56 0c	 sub	 edx, DWORD PTR [esi+12]
  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	55		 push	 ebp
  00037	50		 push	 eax
  00038	d1 fa		 sar	 edx, 1
  0003a	8d 44 24 18	 lea	 eax, DWORD PTR __Val$[esp+40]
  0003e	8b cf		 mov	 ecx, edi
  00040	2b ca		 sub	 ecx, edx
  00042	50		 push	 eax
  00043	8b d6		 mov	 edx, esi
  00045	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@GV?$allocator@G@std@@@std@@IAEXV?$_Vector_const_iterator@GV?$allocator@G@std@@@2@IABG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Insert_n

; 722  : 		}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5d		 pop	 ebp
  0004d	5b		 pop	 ebx
  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	c2 04 00	 ret	 4
$LN99@resize@6:

; 720  : 		else if (_Newsize < size())

  00054	73 6a		 jae	 SHORT $LN1@resize@6

; 721  : 			erase(begin() + _Newsize, end());

  00056	3b cd		 cmp	 ecx, ebp
  00058	76 05		 jbe	 SHORT $LN37@resize@6
  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize@6:
  0005f	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	89 44 24 18	 mov	 DWORD PTR $T214814[esp+32], eax
  00068	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  0006b	76 05		 jbe	 SHORT $LN56@resize@6
  0006d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize@6:
  00072	8b 3e		 mov	 edi, DWORD PTR [esi]
  00074	89 7c 24 10	 mov	 DWORD PTR __Tmp$215160[esp+32], edi
  00078	89 5c 24 14	 mov	 DWORD PTR __Tmp$215160[esp+36], ebx
  0007c	85 ff		 test	 edi, edi
  0007e	75 1b		 jne	 SHORT $LN98@resize@6
  00080	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00085	33 c0		 xor	 eax, eax
$LN89@resize@6:
  00087	8b 4c 24 24	 mov	 ecx, DWORD PTR __Newsize$[esp+28]
  0008b	8d 1c 4b	 lea	 ebx, DWORD PTR [ebx+ecx*2]
  0008e	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  00091	77 13		 ja	 SHORT $LN76@resize@6
  00093	85 ff		 test	 edi, edi
  00095	74 08		 je	 SHORT $LN94@resize@6
  00097	8b 3f		 mov	 edi, DWORD PTR [edi]
  00099	eb 06		 jmp	 SHORT $LN95@resize@6
$LN98@resize@6:
  0009b	8b 07		 mov	 eax, DWORD PTR [edi]
  0009d	eb e8		 jmp	 SHORT $LN89@resize@6
$LN94@resize@6:
  0009f	33 ff		 xor	 edi, edi
$LN95@resize@6:
  000a1	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  000a4	73 05		 jae	 SHORT $LN75@resize@6
$LN76@resize@6:
  000a6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize@6:
  000ab	8b 54 24 18	 mov	 edx, DWORD PTR $T214814[esp+32]
  000af	8b 44 24 10	 mov	 eax, DWORD PTR __Tmp$215160[esp+32]
  000b3	55		 push	 ebp
  000b4	52		 push	 edx
  000b5	53		 push	 ebx
  000b6	50		 push	 eax
  000b7	8d 5c 24 28	 lea	 ebx, DWORD PTR $T214818[esp+48]
  000bb	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
$LN1@resize@6:

; 722  : 		}

  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5d		 pop	 ebp
  000c3	5b		 pop	 ebx
  000c4	83 c4 10	 add	 esp, 16			; 00000010H
  000c7	c2 04 00	 ret	 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXIG@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z
_TEXT	SEGMENT
__Val$ = -20						; size = 1
__Tmp$215515 = -16					; size = 8
$T215173 = -8						; size = 8
$T215169 = -8						; size = 8
__Newsize$ = 8						; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = eax

; 717  : 		{	// determine new length, padding with _Val elements as needed

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f0		 mov	 esi, eax

; 718  : 		if (size() < _Newsize)

  00008	8b 6e 10	 mov	 ebp, DWORD PTR [esi+16]
  0000b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000e	8b c5		 mov	 eax, ebp
  00010	57		 push	 edi
  00011	8b 7c 24 2c	 mov	 edi, DWORD PTR __Newsize$[esp+36]
  00015	2b c1		 sub	 eax, ecx
  00017	c6 44 24 14 00	 mov	 BYTE PTR __Val$[esp+40], 0
  0001c	3b f8		 cmp	 edi, eax
  0001e	76 2a		 jbe	 SHORT $LN99@resize@7

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

  00020	3b cd		 cmp	 ecx, ebp
  00022	76 05		 jbe	 SHORT $LN14@resize@7
  00024	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN14@resize@7:
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0002e	2b 4e 10	 sub	 ecx, DWORD PTR [esi+16]
  00031	55		 push	 ebp
  00032	50		 push	 eax
  00033	8d 44 24 1c	 lea	 eax, DWORD PTR __Val$[esp+48]
  00037	50		 push	 eax
  00038	03 cf		 add	 ecx, edi
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@EV?$allocator@E@std@@@std@@IAEXV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@IABE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Insert_n

; 722  : 		}

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp
  00043	5b		 pop	 ebx
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	c2 04 00	 ret	 4
$LN99@resize@7:

; 720  : 		else if (_Newsize < size())

  0004a	73 69		 jae	 SHORT $LN1@resize@7

; 721  : 			erase(begin() + _Newsize, end());

  0004c	3b cd		 cmp	 ecx, ebp
  0004e	76 05		 jbe	 SHORT $LN37@resize@7
  00050	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN37@resize@7:
  00055	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00058	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005a	89 4c 24 20	 mov	 DWORD PTR $T215169[esp+40], ecx
  0005e	3b 5e 10	 cmp	 ebx, DWORD PTR [esi+16]
  00061	76 05		 jbe	 SHORT $LN56@resize@7
  00063	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN56@resize@7:
  00068	8b 3e		 mov	 edi, DWORD PTR [esi]
  0006a	89 7c 24 18	 mov	 DWORD PTR __Tmp$215515[esp+40], edi
  0006e	89 5c 24 1c	 mov	 DWORD PTR __Tmp$215515[esp+44], ebx
  00072	85 ff		 test	 edi, edi
  00074	75 1a		 jne	 SHORT $LN98@resize@7
  00076	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0007b	33 c0		 xor	 eax, eax
$LN89@resize@7:
  0007d	8b 54 24 2c	 mov	 edx, DWORD PTR __Newsize$[esp+36]
  00081	03 da		 add	 ebx, edx
  00083	3b 58 10	 cmp	 ebx, DWORD PTR [eax+16]
  00086	77 13		 ja	 SHORT $LN76@resize@7
  00088	85 ff		 test	 edi, edi
  0008a	74 08		 je	 SHORT $LN94@resize@7
  0008c	8b 3f		 mov	 edi, DWORD PTR [edi]
  0008e	eb 06		 jmp	 SHORT $LN95@resize@7
$LN98@resize@7:
  00090	8b 07		 mov	 eax, DWORD PTR [edi]
  00092	eb e9		 jmp	 SHORT $LN89@resize@7
$LN94@resize@7:
  00094	33 ff		 xor	 edi, edi
$LN95@resize@7:
  00096	3b 5f 0c	 cmp	 ebx, DWORD PTR [edi+12]
  00099	73 05		 jae	 SHORT $LN75@resize@7
$LN76@resize@7:
  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN75@resize@7:
  000a0	8b 44 24 20	 mov	 eax, DWORD PTR $T215169[esp+40]
  000a4	8b 4c 24 18	 mov	 ecx, DWORD PTR __Tmp$215515[esp+40]
  000a8	55		 push	 ebp
  000a9	50		 push	 eax
  000aa	53		 push	 ebx
  000ab	51		 push	 ecx
  000ac	8d 5c 24 30	 lea	 ebx, DWORD PTR $T215173[esp+56]
  000b0	e8 00 00 00 00	 call	 ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
$LN1@resize@7:

; 722  : 		}

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5d		 pop	 ebp
  000b8	5b		 pop	 ebx
  000b9	83 c4 18	 add	 esp, 24			; 00000018H
  000bc	c2 04 00	 ret	 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

  00000	51		 push	 ecx

; 713  : 		resize(_Newsize, _Ty());

  00001	e8 00 00 00 00	 call	 ?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXIPA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
  00006	59		 pop	 ecx

; 714  : 		}

  00007	c3		 ret	 0
?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
_TEXT	ENDS
PUBLIC	__real@0000000000000000
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z PROC ; std::vector<double,std::allocator<double> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

  00000	51		 push	 ecx

; 713  : 		resize(_Newsize, _Ty());

  00001	d9 ee		 fldz
  00003	83 ec 08	 sub	 esp, 8
  00006	dd 1c 24	 fstp	 QWORD PTR [esp]
  00009	e8 00 00 00 00	 call	 ?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXIN@Z ; std::vector<double,std::allocator<double> >::resize
  0000e	59		 pop	 ecx

; 714  : 		}

  0000f	c3		 ret	 0
?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z ENDP ; std::vector<double,std::allocator<double> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z PROC ; std::vector<float,std::allocator<float> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

  00000	51		 push	 ecx

; 713  : 		resize(_Newsize, _Ty());

  00001	d9 ee		 fldz
  00003	51		 push	 ecx
  00004	d9 1c 24	 fstp	 DWORD PTR [esp]
  00007	e8 00 00 00 00	 call	 ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXIM@Z ; std::vector<float,std::allocator<float> >::resize
  0000c	59		 pop	 ecx

; 714  : 		}

  0000d	c3		 ret	 0
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z ENDP ; std::vector<float,std::allocator<float> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

  00000	51		 push	 ecx

; 713  : 		resize(_Newsize, _Ty());

  00001	e8 00 00 00 00	 call	 ?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
  00006	59		 pop	 ecx

; 714  : 		}

  00007	c3		 ret	 0
?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

  00000	51		 push	 ecx

; 713  : 		resize(_Newsize, _Ty());

  00001	e8 00 00 00 00	 call	 ?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXIK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
  00006	59		 pop	 ecx

; 714  : 		}

  00007	c3		 ret	 0
?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::resize, COMDAT
; __Newsize$ = eax

; 713  : 		resize(_Newsize, _Ty());

  00000	50		 push	 eax
  00001	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00005	e8 00 00 00 00	 call	 ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXIG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize

; 714  : 		}

  0000a	c2 04 00	 ret	 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; __Newsize$ = eax

; 713  : 		resize(_Newsize, _Ty());

  00000	50		 push	 eax
  00001	8b 44 24 08	 mov	 eax, DWORD PTR _this$[esp]
  00005	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 714  : 		}

  0000a	c2 04 00	 ret	 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -24					; size = 4
_lUBound$215558 = -20					; size = 4
_lLBound$215557 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z PROC ; FromVariant<wchar_t *>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b 6c 24 34	 mov	 ebp, DWORD PTR _Vec$[esp+44]

; 14   :     CComSafeArray<T> SafeArray;

  0002b	33 db		 xor	 ebx, ebx
  0002d	89 5c 24 18	 mov	 DWORD PTR _SafeArray$[esp+48], ebx
  00031	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx

; 15   :     SafeArray.Attach(Var.parray);

  00035	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00039	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  0003d	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<wchar_t *,8>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  00042	8b 7c 24 18	 mov	 edi, DWORD PTR _SafeArray$[esp+48]
  00046	8d 44 24 20	 lea	 eax, DWORD PTR _lLBound$215557[esp+48]
  0004a	50		 push	 eax
  0004b	6a 01		 push	 1
  0004d	57		 push	 edi
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00054	3b c3		 cmp	 eax, ebx
  00056	7d 05		 jge	 SHORT $LN10@FromVarian
  00058	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian:
$LN10@FromVarian:
  0005d	8d 4c 24 1c	 lea	 ecx, DWORD PTR _lUBound$215558[esp+48]
  00061	51		 push	 ecx
  00062	6a 01		 push	 1
  00064	57		 push	 edi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  0006b	3b c3		 cmp	 eax, ebx
  0006d	7d 05		 jge	 SHORT $LN9@FromVarian
  0006f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN52@FromVarian:
$LN9@FromVarian:
  00074	8b 5c 24 1c	 mov	 ebx, DWORD PTR _lUBound$215558[esp+48]
  00078	2b 5c 24 20	 sub	 ebx, DWORD PTR _lLBound$215557[esp+48]

; 17   :     Vec.resize(Count);

  0007c	8b cd		 mov	 ecx, ebp
  0007e	43		 inc	 ebx
  0007f	8b c3		 mov	 eax, ebx
  00081	e8 00 00 00 00	 call	 ?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXIPA_W@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  00086	33 f6		 xor	 esi, esi
  00088	85 db		 test	 ebx, ebx
  0008a	76 32		 jbe	 SHORT $LN1@FromVarian
  0008c	8d 64 24 00	 npad	 4
$LL3@FromVarian:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  00090	8b c6		 mov	 eax, esi
  00092	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00096	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z ; ATL::CComSafeArray<wchar_t *,8>::GetAt
  0009b	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
  0009e	2b 55 0c	 sub	 edx, DWORD PTR [ebp+12]
  000a1	8b 38		 mov	 edi, DWORD PTR [eax]
  000a3	c1 fa 02	 sar	 edx, 2
  000a6	3b f2		 cmp	 esi, edx
  000a8	72 05		 jb	 SHORT $LN26@FromVarian
  000aa	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN26@FromVarian:
  000af	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  000b2	89 3c b0	 mov	 DWORD PTR [eax+esi*4], edi
  000b5	46		 inc	 esi
  000b6	3b f3		 cmp	 esi, ebx
  000b8	72 d6		 jb	 SHORT $LL3@FromVarian

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000ba	8b 7c 24 18	 mov	 edi, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian:

; 21   :     }
; 22   : }

  000be	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000c6	85 ff		 test	 edi, edi
  000c8	74 1e		 je	 SHORT $LN34@FromVarian
  000ca	57		 push	 edi
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000d1	85 c0		 test	 eax, eax
  000d3	7c 13		 jl	 SHORT $LN34@FromVarian
  000d5	57		 push	 edi
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000dc	85 c0		 test	 eax, eax
  000de	7c 08		 jl	 SHORT $LN34@FromVarian
  000e0	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN34@FromVarian:
  000e8	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f3	59		 pop	 ecx
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5d		 pop	 ebp
  000f7	5b		 pop	 ebx
  000f8	83 c4 1c	 add	 esp, 28			; 0000001cH
  000fb	c3		 ret	 0
$LN50@FromVarian:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z$0:
  00000	8d 75 e8	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ ; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>
__ehhandler$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ENDP ; FromVariant<wchar_t *>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -28					; size = 4
_lUBound$215652 = -24					; size = 4
_lLBound$215651 = -20					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z PROC ; FromVariant<double>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   :     CComSafeArray<T> SafeArray;

  00027	33 db		 xor	 ebx, ebx
  00029	89 5c 24 14	 mov	 DWORD PTR _SafeArray$[esp+48], ebx
  0002d	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx

; 15   :     SafeArray.Attach(Var.parray);

  00031	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00035	8d 7c 24 14	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00039	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<double,5>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  0003e	8b 6c 24 14	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
  00042	8d 44 24 1c	 lea	 eax, DWORD PTR _lLBound$215651[esp+48]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	55		 push	 ebp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00050	3b c3		 cmp	 eax, ebx
  00052	7d 05		 jge	 SHORT $LN10@FromVarian@2
  00054	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN50@FromVarian@2:
$LN10@FromVarian@2:
  00059	8d 4c 24 18	 lea	 ecx, DWORD PTR _lUBound$215652[esp+48]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	55		 push	 ebp
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00067	3b c3		 cmp	 eax, ebx
  00069	7d 05		 jge	 SHORT $LN9@FromVarian@2
  0006b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian@2:
$LN9@FromVarian@2:
  00070	8b 5c 24 18	 mov	 ebx, DWORD PTR _lUBound$215652[esp+48]

; 17   :     Vec.resize(Count);

  00074	d9 ee		 fldz
  00076	2b 5c 24 1c	 sub	 ebx, DWORD PTR _lLBound$215651[esp+48]
  0007a	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
  0007e	43		 inc	 ebx
  0007f	83 ec 08	 sub	 esp, 8
  00082	8b c3		 mov	 eax, ebx
  00084	dd 1c 24	 fstp	 QWORD PTR [esp]
  00087	8b cf		 mov	 ecx, edi
  00089	e8 00 00 00 00	 call	 ?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXIN@Z ; std::vector<double,std::allocator<double> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  0008e	33 f6		 xor	 esi, esi
  00090	85 db		 test	 ebx, ebx
  00092	76 37		 jbe	 SHORT $LN1@FromVarian@2
  00094	eb 04		 jmp	 SHORT $LN3@FromVarian@2
$LL47@FromVarian@2:
  00096	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
$LN3@FromVarian@2:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  0009a	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0009d	2b 57 0c	 sub	 edx, DWORD PTR [edi+12]
  000a0	c1 fa 03	 sar	 edx, 3
  000a3	3b f2		 cmp	 esi, edx
  000a5	72 05		 jb	 SHORT $LN24@FromVarian@2
  000a7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@FromVarian@2:
  000ac	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000af	8d 2c f0	 lea	 ebp, DWORD PTR [eax+esi*8]
  000b2	8b c6		 mov	 eax, esi
  000b4	8d 7c 24 14	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  000b8	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z ; ATL::CComSafeArray<double,5>::GetAt
  000bd	dd 00		 fld	 QWORD PTR [eax]
  000bf	46		 inc	 esi
  000c0	dd 5d 00	 fstp	 QWORD PTR [ebp]
  000c3	3b f3		 cmp	 esi, ebx
  000c5	72 cf		 jb	 SHORT $LL47@FromVarian@2

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000c7	8b 6c 24 14	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian@2:

; 21   :     }
; 22   : }

  000cb	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000d3	85 ed		 test	 ebp, ebp
  000d5	74 1e		 je	 SHORT $LN32@FromVarian@2
  000d7	55		 push	 ebp
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000de	85 c0		 test	 eax, eax
  000e0	7c 13		 jl	 SHORT $LN32@FromVarian@2
  000e2	55		 push	 ebp
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000e9	85 c0		 test	 eax, eax
  000eb	7c 08		 jl	 SHORT $LN32@FromVarian@2
  000ed	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN32@FromVarian@2:
  000f5	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00100	59		 pop	 ecx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5d		 pop	 ebp
  00104	5b		 pop	 ebx
  00105	83 c4 1c	 add	 esp, 28			; 0000001cH
  00108	c3		 ret	 0
$LN49@FromVarian@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z$0:
  00000	8d 75 e4	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@N$04@ATL@@QAE@XZ ; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>
__ehhandler$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z ENDP ; FromVariant<double>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -24					; size = 4
_lUBound$215744 = -20					; size = 4
_lLBound$215743 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z PROC ; FromVariant<float>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   :     CComSafeArray<T> SafeArray;

  00027	33 db		 xor	 ebx, ebx
  00029	89 5c 24 18	 mov	 DWORD PTR _SafeArray$[esp+48], ebx
  0002d	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx

; 15   :     SafeArray.Attach(Var.parray);

  00031	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00035	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00039	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<float,4>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  0003e	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
  00042	8d 44 24 20	 lea	 eax, DWORD PTR _lLBound$215743[esp+48]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	55		 push	 ebp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00050	3b c3		 cmp	 eax, ebx
  00052	7d 05		 jge	 SHORT $LN10@FromVarian@3
  00054	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN50@FromVarian@3:
$LN10@FromVarian@3:
  00059	8d 4c 24 1c	 lea	 ecx, DWORD PTR _lUBound$215744[esp+48]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	55		 push	 ebp
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00067	3b c3		 cmp	 eax, ebx
  00069	7d 05		 jge	 SHORT $LN9@FromVarian@3
  0006b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian@3:
$LN9@FromVarian@3:
  00070	8b 5c 24 1c	 mov	 ebx, DWORD PTR _lUBound$215744[esp+48]

; 17   :     Vec.resize(Count);

  00074	d9 ee		 fldz
  00076	2b 5c 24 20	 sub	 ebx, DWORD PTR _lLBound$215743[esp+48]
  0007a	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
  0007e	51		 push	 ecx
  0007f	43		 inc	 ebx
  00080	d9 1c 24	 fstp	 DWORD PTR [esp]
  00083	8b c3		 mov	 eax, ebx
  00085	8b cf		 mov	 ecx, edi
  00087	e8 00 00 00 00	 call	 ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXIM@Z ; std::vector<float,std::allocator<float> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  0008c	33 f6		 xor	 esi, esi
  0008e	85 db		 test	 ebx, ebx
  00090	76 37		 jbe	 SHORT $LN1@FromVarian@3
  00092	eb 04		 jmp	 SHORT $LN3@FromVarian@3
$LL47@FromVarian@3:
  00094	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
$LN3@FromVarian@3:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  00098	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  0009b	2b 57 0c	 sub	 edx, DWORD PTR [edi+12]
  0009e	c1 fa 02	 sar	 edx, 2
  000a1	3b f2		 cmp	 esi, edx
  000a3	72 05		 jb	 SHORT $LN24@FromVarian@3
  000a5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@FromVarian@3:
  000aa	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000ad	8d 2c b0	 lea	 ebp, DWORD PTR [eax+esi*4]
  000b0	8b c6		 mov	 eax, esi
  000b2	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  000b6	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z ; ATL::CComSafeArray<float,4>::GetAt
  000bb	d9 00		 fld	 DWORD PTR [eax]
  000bd	46		 inc	 esi
  000be	d9 5d 00	 fstp	 DWORD PTR [ebp]
  000c1	3b f3		 cmp	 esi, ebx
  000c3	72 cf		 jb	 SHORT $LL47@FromVarian@3

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000c5	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian@3:

; 21   :     }
; 22   : }

  000c9	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000d1	85 ed		 test	 ebp, ebp
  000d3	74 1e		 je	 SHORT $LN32@FromVarian@3
  000d5	55		 push	 ebp
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000dc	85 c0		 test	 eax, eax
  000de	7c 13		 jl	 SHORT $LN32@FromVarian@3
  000e0	55		 push	 ebp
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000e7	85 c0		 test	 eax, eax
  000e9	7c 08		 jl	 SHORT $LN32@FromVarian@3
  000eb	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN32@FromVarian@3:
  000f3	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000f7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fe	59		 pop	 ecx
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5d		 pop	 ebp
  00102	5b		 pop	 ebx
  00103	83 c4 1c	 add	 esp, 28			; 0000001cH
  00106	c3		 ret	 0
$LN49@FromVarian@3:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z$0:
  00000	8d 75 e8	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@M$03@ATL@@QAE@XZ ; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>
__ehhandler$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z ENDP ; FromVariant<float>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -24					; size = 4
_lUBound$215835 = -20					; size = 4
_lLBound$215834 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z PROC ; FromVariant<unsigned __int64>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   :     CComSafeArray<T> SafeArray;

  00027	33 db		 xor	 ebx, ebx
  00029	89 5c 24 18	 mov	 DWORD PTR _SafeArray$[esp+48], ebx
  0002d	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx

; 15   :     SafeArray.Attach(Var.parray);

  00031	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00035	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00039	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned __int64,21>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  0003e	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
  00042	8d 44 24 20	 lea	 eax, DWORD PTR _lLBound$215834[esp+48]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	55		 push	 ebp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00050	3b c3		 cmp	 eax, ebx
  00052	7d 05		 jge	 SHORT $LN10@FromVarian@4
  00054	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN50@FromVarian@4:
$LN10@FromVarian@4:
  00059	8d 4c 24 1c	 lea	 ecx, DWORD PTR _lUBound$215835[esp+48]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	55		 push	 ebp
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00067	3b c3		 cmp	 eax, ebx
  00069	7d 05		 jge	 SHORT $LN9@FromVarian@4
  0006b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian@4:
$LN9@FromVarian@4:
  00070	8b 5c 24 1c	 mov	 ebx, DWORD PTR _lUBound$215835[esp+48]
  00074	2b 5c 24 20	 sub	 ebx, DWORD PTR _lLBound$215834[esp+48]

; 17   :     Vec.resize(Count);

  00078	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
  0007c	43		 inc	 ebx
  0007d	8b c3		 mov	 eax, ebx
  0007f	8b cf		 mov	 ecx, edi
  00081	e8 00 00 00 00	 call	 ?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI_K@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  00086	33 f6		 xor	 esi, esi
  00088	85 db		 test	 ebx, ebx
  0008a	76 3f		 jbe	 SHORT $LN1@FromVarian@4
  0008c	eb 06		 jmp	 SHORT $LN3@FromVarian@4
  0008e	8b ff		 npad	 2
$LL47@FromVarian@4:
  00090	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
$LN3@FromVarian@4:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  00094	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00097	2b 57 0c	 sub	 edx, DWORD PTR [edi+12]
  0009a	c1 fa 03	 sar	 edx, 3
  0009d	3b f2		 cmp	 esi, edx
  0009f	72 05		 jb	 SHORT $LN24@FromVarian@4
  000a1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@FromVarian@4:
  000a6	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000a9	8d 2c f0	 lea	 ebp, DWORD PTR [eax+esi*8]
  000ac	8b c6		 mov	 eax, esi
  000ae	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  000b2	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z ; ATL::CComSafeArray<unsigned __int64,21>::GetAt
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  000bc	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000bf	46		 inc	 esi
  000c0	89 55 04	 mov	 DWORD PTR [ebp+4], edx
  000c3	3b f3		 cmp	 esi, ebx
  000c5	72 c9		 jb	 SHORT $LL47@FromVarian@4

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000c7	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian@4:

; 21   :     }
; 22   : }

  000cb	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000d3	85 ed		 test	 ebp, ebp
  000d5	74 1e		 je	 SHORT $LN32@FromVarian@4
  000d7	55		 push	 ebp
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000de	85 c0		 test	 eax, eax
  000e0	7c 13		 jl	 SHORT $LN32@FromVarian@4
  000e2	55		 push	 ebp
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000e9	85 c0		 test	 eax, eax
  000eb	7c 08		 jl	 SHORT $LN32@FromVarian@4
  000ed	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN32@FromVarian@4:
  000f5	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00100	59		 pop	 ecx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5d		 pop	 ebp
  00104	5b		 pop	 ebx
  00105	83 c4 1c	 add	 esp, 28			; 0000001cH
  00108	c3		 ret	 0
$LN49@FromVarian@4:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z$0:
  00000	8d 75 e8	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>
__ehhandler$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ENDP ; FromVariant<unsigned __int64>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -24					; size = 4
_lUBound$215929 = -20					; size = 4
_lLBound$215928 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; FromVariant<unsigned long>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   :     CComSafeArray<T> SafeArray;

  00027	33 db		 xor	 ebx, ebx
  00029	89 5c 24 18	 mov	 DWORD PTR _SafeArray$[esp+48], ebx
  0002d	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx

; 15   :     SafeArray.Attach(Var.parray);

  00031	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00035	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00039	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned long,19>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  0003e	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
  00042	8d 44 24 20	 lea	 eax, DWORD PTR _lLBound$215928[esp+48]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	55		 push	 ebp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00050	3b c3		 cmp	 eax, ebx
  00052	7d 05		 jge	 SHORT $LN10@FromVarian@5
  00054	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN50@FromVarian@5:
$LN10@FromVarian@5:
  00059	8d 4c 24 1c	 lea	 ecx, DWORD PTR _lUBound$215929[esp+48]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	55		 push	 ebp
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00067	3b c3		 cmp	 eax, ebx
  00069	7d 05		 jge	 SHORT $LN9@FromVarian@5
  0006b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian@5:
$LN9@FromVarian@5:
  00070	8b 5c 24 1c	 mov	 ebx, DWORD PTR _lUBound$215929[esp+48]
  00074	2b 5c 24 20	 sub	 ebx, DWORD PTR _lLBound$215928[esp+48]

; 17   :     Vec.resize(Count);

  00078	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
  0007c	43		 inc	 ebx
  0007d	8b c3		 mov	 eax, ebx
  0007f	8b cf		 mov	 ecx, edi
  00081	e8 00 00 00 00	 call	 ?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXIK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  00086	33 f6		 xor	 esi, esi
  00088	85 db		 test	 ebx, ebx
  0008a	76 39		 jbe	 SHORT $LN1@FromVarian@5
  0008c	eb 06		 jmp	 SHORT $LN3@FromVarian@5
  0008e	8b ff		 npad	 2
$LL47@FromVarian@5:
  00090	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
$LN3@FromVarian@5:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  00094	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00097	2b 57 0c	 sub	 edx, DWORD PTR [edi+12]
  0009a	c1 fa 02	 sar	 edx, 2
  0009d	3b f2		 cmp	 esi, edx
  0009f	72 05		 jb	 SHORT $LN24@FromVarian@5
  000a1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@FromVarian@5:
  000a6	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000a9	8d 2c b0	 lea	 ebp, DWORD PTR [eax+esi*4]
  000ac	8b c6		 mov	 eax, esi
  000ae	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  000b2	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z ; ATL::CComSafeArray<unsigned long,19>::GetAt
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	46		 inc	 esi
  000ba	89 4d 00	 mov	 DWORD PTR [ebp], ecx
  000bd	3b f3		 cmp	 esi, ebx
  000bf	72 cf		 jb	 SHORT $LL47@FromVarian@5

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000c1	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian@5:

; 21   :     }
; 22   : }

  000c5	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000cd	85 ed		 test	 ebp, ebp
  000cf	74 1e		 je	 SHORT $LN32@FromVarian@5
  000d1	55		 push	 ebp
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000d8	85 c0		 test	 eax, eax
  000da	7c 13		 jl	 SHORT $LN32@FromVarian@5
  000dc	55		 push	 ebp
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000e3	85 c0		 test	 eax, eax
  000e5	7c 08		 jl	 SHORT $LN32@FromVarian@5
  000e7	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN32@FromVarian@5:
  000ef	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fa	59		 pop	 ecx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5d		 pop	 ebp
  000fe	5b		 pop	 ebx
  000ff	83 c4 1c	 add	 esp, 28			; 0000001cH
  00102	c3		 ret	 0
$LN49@FromVarian@5:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z$0:
  00000	8d 75 e8	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>
__ehhandler$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; FromVariant<unsigned long>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -24					; size = 4
_lUBound$216020 = -20					; size = 4
_lLBound$216019 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z PROC ; FromVariant<unsigned short>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   :     CComSafeArray<T> SafeArray;

  00027	33 db		 xor	 ebx, ebx
  00029	89 5c 24 18	 mov	 DWORD PTR _SafeArray$[esp+48], ebx
  0002d	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx

; 15   :     SafeArray.Attach(Var.parray);

  00031	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00035	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00039	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned short,18>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  0003e	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
  00042	8d 44 24 20	 lea	 eax, DWORD PTR _lLBound$216019[esp+48]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	55		 push	 ebp
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00050	3b c3		 cmp	 eax, ebx
  00052	7d 05		 jge	 SHORT $LN10@FromVarian@6
  00054	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN50@FromVarian@6:
$LN10@FromVarian@6:
  00059	8d 4c 24 1c	 lea	 ecx, DWORD PTR _lUBound$216020[esp+48]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	55		 push	 ebp
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00067	3b c3		 cmp	 eax, ebx
  00069	7d 05		 jge	 SHORT $LN9@FromVarian@6
  0006b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian@6:
$LN9@FromVarian@6:
  00070	8b 5c 24 1c	 mov	 ebx, DWORD PTR _lUBound$216020[esp+48]
  00074	2b 5c 24 20	 sub	 ebx, DWORD PTR _lLBound$216019[esp+48]

; 17   :     Vec.resize(Count);

  00078	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
  0007c	43		 inc	 ebx
  0007d	53		 push	 ebx
  0007e	8b c7		 mov	 eax, edi
  00080	e8 00 00 00 00	 call	 ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXIG@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  00085	33 f6		 xor	 esi, esi
  00087	85 db		 test	 ebx, ebx
  00089	76 3b		 jbe	 SHORT $LN1@FromVarian@6
  0008b	eb 07		 jmp	 SHORT $LN3@FromVarian@6
  0008d	8d 49 00	 npad	 3
$LL47@FromVarian@6:
  00090	8b 7c 24 34	 mov	 edi, DWORD PTR _Vec$[esp+44]
$LN3@FromVarian@6:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  00094	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00097	2b 57 0c	 sub	 edx, DWORD PTR [edi+12]
  0009a	d1 fa		 sar	 edx, 1
  0009c	3b f2		 cmp	 esi, edx
  0009e	72 05		 jb	 SHORT $LN24@FromVarian@6
  000a0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@FromVarian@6:
  000a5	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  000a8	8d 2c 70	 lea	 ebp, DWORD PTR [eax+esi*2]
  000ab	8b c6		 mov	 eax, esi
  000ad	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  000b1	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z ; ATL::CComSafeArray<unsigned short,18>::GetAt
  000b6	66 8b 08	 mov	 cx, WORD PTR [eax]
  000b9	46		 inc	 esi
  000ba	66 89 4d 00	 mov	 WORD PTR [ebp], cx
  000be	3b f3		 cmp	 esi, ebx
  000c0	72 ce		 jb	 SHORT $LL47@FromVarian@6

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000c2	8b 6c 24 18	 mov	 ebp, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian@6:

; 21   :     }
; 22   : }

  000c6	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000ce	85 ed		 test	 ebp, ebp
  000d0	74 1e		 je	 SHORT $LN32@FromVarian@6
  000d2	55		 push	 ebp
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000d9	85 c0		 test	 eax, eax
  000db	7c 13		 jl	 SHORT $LN32@FromVarian@6
  000dd	55		 push	 ebp
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000e4	85 c0		 test	 eax, eax
  000e6	7c 08		 jl	 SHORT $LN32@FromVarian@6
  000e8	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN32@FromVarian@6:
  000f0	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000f4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fb	59		 pop	 ecx
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5d		 pop	 ebp
  000ff	5b		 pop	 ebx
  00100	83 c4 1c	 add	 esp, 28			; 0000001cH
  00103	c3		 ret	 0
$LN49@FromVarian@6:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z$0:
  00000	8d 75 e8	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>
__ehhandler$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z ENDP ; FromVariant<unsigned short>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\atlmfc\include\atlsafe.h
xdata$x	SEGMENT
__unwindtable$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z$0
__ehfuncinfo$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
_SafeArray$ = -24					; size = 4
_lUBound$216113 = -20					; size = 4
_lLBound$216112 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_Vec$ = 8						; size = 4
_Var$ = 12						; size = 16
??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; FromVariant<unsigned char>, COMDAT

; 13   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 10	 sub	 esp, 16			; 00000010H
  00011	53		 push	 ebx
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c4		 xor	 eax, esp
  0001c	50		 push	 eax
  0001d	8d 44 24 24	 lea	 eax, DWORD PTR __$EHRec$[esp+48]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   :     CComSafeArray<T> SafeArray;

  00027	33 ed		 xor	 ebp, ebp
  00029	89 6c 24 18	 mov	 DWORD PTR _SafeArray$[esp+48], ebp
  0002d	89 6c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebp

; 15   :     SafeArray.Attach(Var.parray);

  00031	8b 74 24 40	 mov	 esi, DWORD PTR _Var$[esp+52]
  00035	8d 7c 24 18	 lea	 edi, DWORD PTR _SafeArray$[esp+48]
  00039	e8 00 00 00 00	 call	 ?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned char,17>::Attach

; 16   :     ULONG Count = SafeArray.GetCount();

  0003e	8b 5c 24 18	 mov	 ebx, DWORD PTR _SafeArray$[esp+48]
  00042	8d 44 24 20	 lea	 eax, DWORD PTR _lLBound$216112[esp+48]
  00046	50		 push	 eax
  00047	6a 01		 push	 1
  00049	53		 push	 ebx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12
  00050	3b c5		 cmp	 eax, ebp
  00052	7d 05		 jge	 SHORT $LN10@FromVarian@7
  00054	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN50@FromVarian@7:
$LN10@FromVarian@7:
  00059	8d 4c 24 1c	 lea	 ecx, DWORD PTR _lUBound$216113[esp+48]
  0005d	51		 push	 ecx
  0005e	6a 01		 push	 1
  00060	53		 push	 ebx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00067	3b c5		 cmp	 eax, ebp
  00069	7d 05		 jge	 SHORT $LN9@FromVarian@7
  0006b	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN51@FromVarian@7:
$LN9@FromVarian@7:
  00070	8b 6c 24 1c	 mov	 ebp, DWORD PTR _lUBound$216113[esp+48]
  00074	2b 6c 24 20	 sub	 ebp, DWORD PTR _lLBound$216112[esp+48]

; 17   :     Vec.resize(Count);

  00078	8b 74 24 34	 mov	 esi, DWORD PTR _Vec$[esp+44]
  0007c	45		 inc	 ebp
  0007d	55		 push	 ebp
  0007e	8b c6		 mov	 eax, esi
  00080	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXIE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  00085	33 ff		 xor	 edi, edi
  00087	85 ed		 test	 ebp, ebp
  00089	76 34		 jbe	 SHORT $LN1@FromVarian@7
  0008b	eb 07		 jmp	 SHORT $LN3@FromVarian@7
  0008d	8d 49 00	 npad	 3
$LL47@FromVarian@7:
  00090	8b 74 24 34	 mov	 esi, DWORD PTR _Vec$[esp+44]
$LN3@FromVarian@7:

; 19   :     {
; 20   :         Vec[Index] = SafeArray.GetAt(Index);

  00094	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00097	2b 56 0c	 sub	 edx, DWORD PTR [esi+12]
  0009a	3b fa		 cmp	 edi, edx
  0009c	72 05		 jb	 SHORT $LN24@FromVarian@7
  0009e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN24@FromVarian@7:
  000a3	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000a6	57		 push	 edi
  000a7	8d 74 24 1c	 lea	 esi, DWORD PTR _SafeArray$[esp+52]
  000ab	03 df		 add	 ebx, edi
  000ad	e8 00 00 00 00	 call	 ?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z ; ATL::CComSafeArray<unsigned char,17>::GetAt
  000b2	8a 00		 mov	 al, BYTE PTR [eax]
  000b4	47		 inc	 edi
  000b5	88 03		 mov	 BYTE PTR [ebx], al
  000b7	3b fd		 cmp	 edi, ebp
  000b9	72 d5		 jb	 SHORT $LL47@FromVarian@7

; 18   :     for(ULONG Index = 0; Index < Count; Index++)

  000bb	8b 5c 24 18	 mov	 ebx, DWORD PTR _SafeArray$[esp+48]
$LN1@FromVarian@7:

; 21   :     }
; 22   : }

  000bf	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000c7	85 db		 test	 ebx, ebx
  000c9	74 1e		 je	 SHORT $LN32@FromVarian@7
  000cb	53		 push	 ebx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4
  000d2	85 c0		 test	 eax, eax
  000d4	7c 13		 jl	 SHORT $LN32@FromVarian@7
  000d6	53		 push	 ebx
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4
  000dd	85 c0		 test	 eax, eax
  000df	7c 08		 jl	 SHORT $LN32@FromVarian@7
  000e1	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _SafeArray$[esp+48], 0
$LN32@FromVarian@7:
  000e9	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f4	59		 pop	 ecx
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5d		 pop	 ebp
  000f8	5b		 pop	 ebx
  000f9	83 c4 1c	 add	 esp, 28			; 0000001cH
  000fc	c3		 ret	 0
$LN49@FromVarian@7:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z$0:
  00000	8d 75 e8	 lea	 esi, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>
__ehhandler$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 e0	 lea	 eax, DWORD PTR [edx-32]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; FromVariant<unsigned char>
; Function compile flags: /Ogtpy
;	COMDAT ??_Gxmlwriter@@QAEPAXI@Z
_TEXT	SEGMENT
??_Gxmlwriter@@QAEPAXI@Z PROC				; xmlwriter::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	e8 00 00 00 00	 call	 ??1xmlwriter@@QAE@XZ	; xmlwriter::~xmlwriter
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	83 c4 04	 add	 esp, 4
  00010	8b c6		 mov	 eax, esi
  00012	59		 pop	 ecx
  00013	c3		 ret	 0
??_Gxmlwriter@@QAEPAXI@Z ENDP				; xmlwriter::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_lpulProperties$GSCopy$
PUBLIC	_xml$GSCopy$
PUBLIC	_lpszOption$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z		; WMIex
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$7
	DD	0ffffffffH
	DD	00H
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$10
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$12
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$13
	DD	0cH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$15
	DD	0eH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$16
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$17
	DD	010H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$18
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$19
	DD	012H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$20
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$21
	DD	014H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$22
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$23
	DD	016H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$24
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$25
	DD	018H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$26
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$27
	DD	01aH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$28
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$29
	DD	01cH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$30
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$31
	DD	01eH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$32
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$33
	DD	020H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$34
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$35
	DD	07H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$36
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$37
	DD	024H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$38
	DD	025H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$39
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$40
	DD	027H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$41
	DD	028H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$42
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$43
	DD	02aH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$44
	DD	02bH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$45
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$46
	DD	02dH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$47
	DD	02eH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$48
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$49
	DD	030H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$50
	DD	031H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$51
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$52
	DD	033H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$53
	DD	034H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$54
	DD	023H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$55
	DD	036H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$56
	DD	037H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$57
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$58
	DD	03aH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$59
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$60
	DD	03cH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$61
__catchsym$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$62 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$0
__tryblocktable$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z DD 06H
	DD	038H
	DD	039H
	DD	01H
	DD	FLAT:__catchsym$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$62
__ehfuncinfo$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z DD 019930522H
	DD	03eH
	DD	FLAT:__unwindtable$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z
	DD	01H
	DD	FLAT:__tryblocktable$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z
_TEXT	SEGMENT
$T218051 = -31580					; size = 8
$T217379 = -31572					; size = 8
$T217827 = -31564					; size = 8
$T217174 = -31556					; size = 8
$T217603 = -31548					; size = 8
$T216931 = -31540					; size = 8
$T217173 = -31532					; size = 8
$T218048 = -31524					; size = 8
$T217600 = -31516					; size = 8
$T217826 = -31508					; size = 8
$T217376 = -31500					; size = 8
$T217602 = -31492					; size = 8
$T218260 = -31484					; size = 8
$T217378 = -31476					; size = 8
$T218303 = -31468					; size = 8
$T218261 = -31460					; size = 8
_tickEnd$139573 = -31460				; size = 8
$T218050 = -31448					; size = 8
$T217824 = -31440					; size = 8
_vbstr$139533 = -31432					; size = 24
_i$139544 = -31408					; size = 4
_i$138847 = -31404					; size = 4
_i$137803 = -31400					; size = 4
_i$138499 = -31396					; size = 4
_i$137454 = -31392					; size = 4
_i$138151 = -31388					; size = 4
_i$139195 = -31384					; size = 4
_vui2$137793 = -31380					; size = 24
_vui8$138489 = -31356					; size = 24
_vr8$139185 = -31332					; size = 24
_vui4$138141 = -31308					; size = 24
_vui1$137444 = -31284					; size = 24
_vr4$138837 = -31260					; size = 24
_tickStart$ = -31236					; size = 8
_hWmiMutex$ = -31224					; size = 4
_pEnumerator$ = -31220					; size = 4
_lpszOption$GSCopy$ = -31216				; size = 4
_uReturn$136990 = -31212				; size = 4
$T216196 = -31212					; size = 4
_pSvc$ = -31208						; size = 4
_pLoc$ = -31204						; size = 4
_properties$ = -31200					; size = 4
_lpulProperties$GSCopy$ = -31196			; size = 4
$T216246 = -31196					; size = 4
_seconds$139575 = -31196				; size = 4
$T216245 = -31196					; size = 4
_pclsObj$136989 = -31192				; size = 4
$T216197 = -31192					; size = 4
$T216195 = -31192					; size = 4
_x$136995 = -31188					; size = 4
_hres$ = -31188						; size = 4
_xml$GSCopy$ = -31184					; size = 4
$T217171 = -31180					; size = 8
$T216229 = -31176					; size = 4
$T216227 = -31176					; size = 4
$T216223 = -31176					; size = 4
$T216219 = -31176					; size = 4
$T216217 = -31176					; size = 4
$T216215 = -31176					; size = 4
$T216213 = -31176					; size = 4
$T216211 = -31176					; size = 4
$T216209 = -31176					; size = 4
$T216207 = -31176					; size = 4
$T216205 = -31176					; size = 4
$T216203 = -31176					; size = 4
$T216201 = -31176					; size = 4
tv3611 = -31174						; size = 2
tv3597 = -31174						; size = 2
_vtProp$137000 = -31172					; size = 16
tv3606 = -31156						; size = 8
tv3592 = -31156						; size = 8
$T216928 = -31156					; size = 8
tv3608 = -31152						; size = 4
tv3594 = -31152						; size = 4
tv1636 = -31152						; size = 4
_timeElapsed$139574 = -31152				; size = 4
$T216243 = -31152					; size = 4
$T216241 = -31152					; size = 4
$T216239 = -31152					; size = 4
$T216237 = -31152					; size = 4
$T216235 = -31152					; size = 4
$T216233 = -31152					; size = 4
$T216231 = -31152					; size = 4
$T216230 = -31152					; size = 4
$T216228 = -31152					; size = 4
$T216226 = -31152					; size = 4
$T216222 = -31152					; size = 4
$T216218 = -31152					; size = 4
$T216216 = -31152					; size = 4
$T216214 = -31152					; size = 4
$T216212 = -31152					; size = 4
$T216210 = -31152					; size = 4
$T216208 = -31152					; size = 4
$T216206 = -31152					; size = 4
$T216204 = -31152					; size = 4
$T216202 = -31152					; size = 4
$T216200 = -31152					; size = 4
$T216199 = -31152					; size = 4
$T216198 = -31152					; size = 4
$T216930 = -31148					; size = 8
tv3356 = -31144						; size = 4
$T216244 = -31144					; size = 4
$T216242 = -31144					; size = 4
$T216240 = -31144					; size = 4
$T216238 = -31144					; size = 4
$T216236 = -31144					; size = 4
$T216234 = -31144					; size = 4
$T216232 = -31144					; size = 4
_temp$139571 = -31140					; size = 28
_temp$139567 = -31140					; size = 28
_id$137110 = -31140					; size = 28
_tag$136981 = -31140					; size = 28
_value$137009 = -31112					; size = 28
_tszProperty$137001 = -31084				; size = 20000
_szValue$137002 = -11084				; size = 10000
_szSelect$ = -1084					; size = 260
_processed$ = -820					; size = 260
_temp$137010 = -556					; size = 260
_elapsedTime$139572 = -292				; size = 260
_idx$137109 = -292					; size = 260
__$ArrayPad$ = -24					; size = 4
__$EHRec$ = -16						; size = 16
_lpulProperties$ = 8					; size = 4
?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z PROC			; WMIex, COMDAT
; _lpszOption$ = ecx
; _xml$ = edx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 4c 7b 00 00	 mov	 eax, 31564		; 00007b4cH
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 e8	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	8b d9		 mov	 ebx, ecx

; 30   :     unsigned long properties = 0;

  00038	89 9d 10 86 ff
	ff		 mov	 DWORD PTR _lpszOption$GSCopy$[ebp], ebx
  0003e	8b f2		 mov	 esi, edx
  00040	89 b5 30 86 ff
	ff		 mov	 DWORD PTR _xml$GSCopy$[ebp], esi

; 54   :     }
; 55   : 
; 56   :     unsigned __int64 tickStart = SysTick;

  00046	8b 45 08	 mov	 eax, DWORD PTR _lpulProperties$[ebp]
  00049	89 85 24 86 ff
	ff		 mov	 DWORD PTR _lpulProperties$GSCopy$[ebp], eax

; 30   :     unsigned long properties = 0;

  0004f	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _properties$[ebp], 0

; 31   :     HRESULT hres;
; 32   : 
; 33   :     if(_thGetInt(&gbTerminate)==TRUE)

  00059	b9 00 00 00 00	 mov	 ecx, OFFSET ?gbTerminate@@3HA ; gbTerminate
  0005e	e8 00 00 00 00	 call	 ?_thGetInt@@YAHPAH@Z	; _thGetInt
  00063	83 f8 01	 cmp	 eax, 1

; 34   :     {
; 35   :         //process is ending - do not process because it spends to much time
; 36   :         return true;

  00066	0f 84 ce 1f 00
	00		 je	 $LN792@WMIex

; 37   :     }
; 38   : 
; 39   :     Log(LOG_DEBUG_WMI,__LINE__,">> WMI, %s",lpszOption);

  0006c	53		 push	 ebx
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs?$AA@
  00072	6a 27		 push	 39			; 00000027H
  00074	6a 40		 push	 64			; 00000040H
  00076	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0007b	83 c4 10	 add	 esp, 16			; 00000010H

; 40   : 
; 41   :     if(!lpszOption)

  0007e	85 db		 test	 ebx, ebx
  00080	75 0e		 jne	 SHORT $LN119@WMIex

; 42   :     {
; 43   :         Log(LOG_DEBUG,__LINE__,"<< WMI, Inv class name");

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MIMIOLHO@?$DM?$DM?5WMI?0?5Inv?5class?5name?$AA@
  00087	6a 2b		 push	 43			; 0000002bH
  00089	6a 10		 push	 16			; 00000010H

; 44   :         return true;

  0008b	e9 a2 1f 00 00	 jmp	 $LN793@WMIex
$LN119@WMIex:

; 45   :     }
; 46   : 
; 47   :     HANDLE hWmiMutex = CreateMutex(NULL,FALSE,"SysStatus_WMI_Mutex");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex?$AA@
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0009f	8b f8		 mov	 edi, eax
  000a1	89 bd 08 86 ff
	ff		 mov	 DWORD PTR _hWmiMutex$[ebp], edi

; 48   :     if(WaitForSingleObject(hWmiMutex,MINUTE)!=WAIT_OBJECT_0)

  000a7	68 60 ea 00 00	 push	 60000			; 0000ea60H
  000ac	57		 push	 edi
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  000b3	85 c0		 test	 eax, eax
  000b5	74 20		 je	 SHORT $LN118@WMIex

; 49   :     {
; 50   :         //need to be restarted
; 51   :         Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, %s Mutex timeout",lpszOption);

  000b7	53		 push	 ebx
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CAANICIM@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?5timeout?$AA@
  000bd	6a 33		 push	 51			; 00000033H
  000bf	6a 40		 push	 64			; 00000040H
  000c1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000c6	83 c4 10	 add	 esp, 16			; 00000010H

; 52   :         CloseHandle(hWmiMutex);

  000c9	57		 push	 edi
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 53   :         return false;

  000d0	32 c0		 xor	 al, al
  000d2	e9 65 1f 00 00	 jmp	 $LN121@WMIex
$LN118@WMIex:

; 54   :     }
; 55   : 
; 56   :     unsigned __int64 tickStart = SysTick;

  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000dd	89 85 fc 85 ff
	ff		 mov	 DWORD PTR _tickStart$[ebp], eax
  000e3	33 db		 xor	 ebx, ebx
  000e5	89 9d 00 86 ff
	ff		 mov	 DWORD PTR _tickStart$[ebp+4], ebx

; 57   : 
; 58   :     // Initialize COM.
; 59   :     hres =  CoInitializeEx(0, COINIT_MULTITHREADED|COINIT_SPEED_OVER_MEMORY); 

  000eb	6a 08		 push	 8
  000ed	53		 push	 ebx
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeEx@8

; 60   :     if (FAILED(hres))

  000f4	3b c3		 cmp	 eax, ebx
  000f6	7d 25		 jge	 SHORT $LN117@WMIex

; 61   :     {
; 62   :         Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, Failed to initialize COM library, 0x%.8X",hres);

  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5COM@
  000fe	6a 3e		 push	 62			; 0000003eH
  00100	6a 40		 push	 64			; 00000040H
  00102	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00107	83 c4 10	 add	 esp, 16			; 00000010H

; 63   :         ReleaseMutex(hWmiMutex);

  0010a	57		 push	 edi
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 64   :         CloseHandle(hWmiMutex);

  00111	57		 push	 edi
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 65   :         return true;

  00118	e9 1d 1f 00 00	 jmp	 $LN792@WMIex
$LN117@WMIex:

; 66   :     }
; 67   : 
; 68   :     // Initialize 
; 69   :     hres =  CoInitializeSecurity(
; 70   :         NULL,     
; 71   :         -1,      // COM negotiates service                  
; 72   :         NULL,    // Authentication services
; 73   :         NULL,    // Reserved
; 74   :         RPC_C_AUTHN_LEVEL_DEFAULT,    // authentication
; 75   :         RPC_C_IMP_LEVEL_IMPERSONATE,  // Impersonation
; 76   :         NULL,             // Authentication info 
; 77   :         EOAC_NONE,        // Additional capabilities
; 78   :         NULL              // Reserved
; 79   :         );

  0011d	53		 push	 ebx
  0011e	53		 push	 ebx
  0011f	53		 push	 ebx
  00120	6a 03		 push	 3
  00122	53		 push	 ebx
  00123	53		 push	 ebx
  00124	53		 push	 ebx
  00125	6a ff		 push	 -1
  00127	53		 push	 ebx
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeSecurity@36

; 80   : 
; 81   :                       
; 82   :     if (FAILED(hres))

  0012e	3b c3		 cmp	 eax, ebx
  00130	7d 2b		 jge	 SHORT $LN116@WMIex

; 83   :     {
; 84   :         Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, Failed to initialize security, 0x%.8x",hres);

  00132	50		 push	 eax
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5sec@
  00138	6a 54		 push	 84			; 00000054H
$LN801@WMIex:
  0013a	6a 40		 push	 64			; 00000040H
  0013c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00141	83 c4 10	 add	 esp, 16			; 00000010H

; 85   :         CoUninitialize();

  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 86   :         ReleaseMutex(hWmiMutex);

  0014a	57		 push	 edi
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 87   :         CloseHandle(hWmiMutex);

  00151	57		 push	 edi
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 88   :         return true;

  00158	e9 dd 1e 00 00	 jmp	 $LN792@WMIex
$LN116@WMIex:

; 89   :     }
; 90   : 
; 91   :     // Obtain the initial locator to Windows Management
; 92   :     // on a particular host computer.
; 93   :     IWbemLocator *pLoc = 0;

  0015d	89 9d 1c 86 ff
	ff		 mov	 DWORD PTR _pLoc$[ebp], ebx

; 94   : 
; 95   :     hres = CoCreateInstance(
; 96   :         CLSID_WbemLocator,             
; 97   :         0, 
; 98   :         CLSCTX_INPROC_SERVER, 
; 99   :         IID_IWbemLocator, (LPVOID *) &pLoc);

  00163	8d 8d 1c 86 ff
	ff		 lea	 ecx, DWORD PTR _pLoc$[ebp]
  00169	51		 push	 ecx
  0016a	68 00 00 00 00	 push	 OFFSET _IID_IWbemLocator
  0016f	6a 01		 push	 1
  00171	53		 push	 ebx
  00172	68 00 00 00 00	 push	 OFFSET _CLSID_WbemLocator
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 100  :  
; 101  :     if (FAILED(hres))

  0017d	3b c3		 cmp	 eax, ebx
  0017f	7d 0a		 jge	 SHORT $LN115@WMIex

; 102  :     {
; 103  :         Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, Failed to create IWbemLocator object,0x%.8x",hres);

  00181	50		 push	 eax
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemLo@
  00187	6a 67		 push	 103			; 00000067H

; 104  :         CoUninitialize();
; 105  :         ReleaseMutex(hWmiMutex);
; 106  :         CloseHandle(hWmiMutex);
; 107  :         return true;

  00189	eb af		 jmp	 SHORT $LN801@WMIex
$LN115@WMIex:

; 108  :     }
; 109  : 
; 110  :     IWbemServices *pSvc = 0;

  0018b	89 9d 18 86 ff
	ff		 mov	 DWORD PTR _pSvc$[ebp], ebx

; 111  : 
; 112  :     // Connect to the root\cimv2 namespace with the
; 113  :     // current user and obtain pointer pSvc
; 114  :     // to make IWbemServices calls.
; 115  : 
; 116  :     hres = pLoc->ConnectServer(
; 117  :         
; 118  :         _bstr_t(L"ROOT\\CIMV2"), // WMI namespace
; 119  :         NULL,                    // User name
; 120  :         NULL,                    // User password
; 121  :         0,                       // Locale
; 122  :         NULL,                    // Security flags                 
; 123  :         0,                       // Authority       
; 124  :         0,                       // Context object
; 125  :         &pSvc                    // IWbemServices proxy
; 126  :         );                              

  00191	8d 9d 28 86 ff
	ff		 lea	 ebx, DWORD PTR $T216195[ebp]
  00197	e8 00 00 00 00	 call	 ??0_bstr_t@@QAE@PB_W@Z	; _bstr_t::_bstr_t
  0019c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001a3	8b 00		 mov	 eax, DWORD PTR [eax]
  001a5	85 c0		 test	 eax, eax
  001a7	74 04		 je	 SHORT $LN193@WMIex
  001a9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ab	eb 02		 jmp	 SHORT $LN194@WMIex
$LN193@WMIex:
  001ad	33 c9		 xor	 ecx, ecx
$LN194@WMIex:
  001af	8b 85 1c 86 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  001b5	8b 10		 mov	 edx, DWORD PTR [eax]
  001b7	8d bd 18 86 ff
	ff		 lea	 edi, DWORD PTR _pSvc$[ebp]
  001bd	57		 push	 edi
  001be	6a 00		 push	 0
  001c0	6a 00		 push	 0
  001c2	6a 00		 push	 0
  001c4	6a 00		 push	 0
  001c6	6a 00		 push	 0
  001c8	6a 00		 push	 0
  001ca	51		 push	 ecx
  001cb	50		 push	 eax
  001cc	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001cf	ff d0		 call	 eax
  001d1	8b d8		 mov	 ebx, eax
  001d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001da	8d bd 28 86 ff
	ff		 lea	 edi, DWORD PTR $T216195[ebp]
  001e0	e8 00 00 00 00	 call	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t

; 127  :     
; 128  :     if (FAILED(hres))

  001e5	85 db		 test	 ebx, ebx
  001e7	7d 42		 jge	 SHORT $LN114@WMIex

; 129  :     {
; 130  :         Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, Could not connect, 0x%.8x",hres);

  001e9	53		 push	 ebx
  001ea	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?48@
  001ef	68 82 00 00 00	 push	 130			; 00000082H
  001f4	6a 40		 push	 64			; 00000040H
  001f6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001fb	83 c4 10	 add	 esp, 16			; 00000010H

; 131  :         pLoc->Release();     

  001fe	8b 85 1c 86 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  00204	8b 08		 mov	 ecx, DWORD PTR [eax]
  00206	50		 push	 eax
  00207	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0020a	ff d2		 call	 edx

; 132  :         CoUninitialize();

  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 133  :         ReleaseMutex(hWmiMutex);

  00212	8b b5 08 86 ff
	ff		 mov	 esi, DWORD PTR _hWmiMutex$[ebp]
  00218	56		 push	 esi
  00219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 134  :         CloseHandle(hWmiMutex);

  0021f	56		 push	 esi

; 87   :         CloseHandle(hWmiMutex);

  00220	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 88   :         return true;

  00226	e9 0f 1e 00 00	 jmp	 $LN792@WMIex
$LN114@WMIex:

; 135  :         return true;
; 136  :     }
; 137  : 
; 138  :     Log(LOG_DEBUG_WMI,__LINE__,"-- WMI, Connected to ROOT\\CIMV2 WMI namespace");

  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2?5@
  00230	68 8a 00 00 00	 push	 138			; 0000008aH
  00235	6a 40		 push	 64			; 00000040H
  00237	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0023c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : 
; 140  :     // Set the IWbemServices proxy so that impersonation
; 141  :     // of the user (client) occurs.
; 142  :     hres = CoSetProxyBlanket(
; 143  :        
; 144  :        pSvc,                         // the proxy to set
; 145  :        RPC_C_AUTHN_WINNT,            // authentication service
; 146  :        RPC_C_AUTHZ_NONE,             // authorization service
; 147  :        NULL,                         // Server principal name
; 148  :        RPC_C_AUTHN_LEVEL_CALL,       // authentication level
; 149  :        RPC_C_IMP_LEVEL_IMPERSONATE,  // impersonation level
; 150  :        NULL,                         // client identity 
; 151  :        EOAC_NONE                     // proxy capabilities     
; 152  :     );

  0023f	6a 00		 push	 0
  00241	6a 00		 push	 0
  00243	6a 03		 push	 3
  00245	6a 03		 push	 3
  00247	6a 00		 push	 0
  00249	6a 00		 push	 0
  0024b	6a 0a		 push	 10			; 0000000aH
  0024d	8b 85 18 86 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  00253	50		 push	 eax
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoSetProxyBlanket@32

; 153  : 
; 154  :     if (FAILED(hres))

  0025a	85 c0		 test	 eax, eax
  0025c	7d 50		 jge	 SHORT $LN113@WMIex

; 155  :     {
; 156  :         Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, Could not set proxy blanket, 0x%.8x",hres);

  0025e	50		 push	 eax
  0025f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5blan@
  00264	68 9c 00 00 00	 push	 156			; 0000009cH
  00269	6a 40		 push	 64			; 00000040H
  0026b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00270	83 c4 10	 add	 esp, 16			; 00000010H

; 157  :         pSvc->Release();

  00273	8b 85 18 86 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  00279	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027b	50		 push	 eax
  0027c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0027f	ff d2		 call	 edx

; 158  :         pLoc->Release();     

  00281	8b 85 1c 86 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  00287	8b 08		 mov	 ecx, DWORD PTR [eax]
  00289	50		 push	 eax
  0028a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0028d	ff d2		 call	 edx

; 159  :         CoUninitialize();

  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 160  :         ReleaseMutex(hWmiMutex);

  00295	8b b5 08 86 ff
	ff		 mov	 esi, DWORD PTR _hWmiMutex$[ebp]
  0029b	56		 push	 esi
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 161  :         CloseHandle(hWmiMutex);

  002a2	56		 push	 esi

; 87   :         CloseHandle(hWmiMutex);

  002a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 88   :         return true;

  002a9	e9 8c 1d 00 00	 jmp	 $LN792@WMIex
$LN113@WMIex:

; 162  :         return true;
; 163  :     }
; 164  : 
; 165  : 
; 166  :     // Use the IWbemServices pointer to make requests of WMI. 
; 167  :     // Make requests here:
; 168  : 
; 169  :     char szSelect[_MAX_PATH] = {0};

  002ae	c6 85 c4 fb ff
	ff 00		 mov	 BYTE PTR _szSelect$[ebp], 0
  002b5	68 03 01 00 00	 push	 259			; 00000103H
  002ba	6a 00		 push	 0
  002bc	8d 85 c5 fb ff
	ff		 lea	 eax, DWORD PTR _szSelect$[ebp+1]
  002c2	50		 push	 eax
  002c3	e8 00 00 00 00	 call	 _memset
  002c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 170  :     _snprintf(szSelect,sizeof(szSelect),"SELECT * FROM %s",lpszOption);

  002cb	8b bd 10 86 ff
	ff		 mov	 edi, DWORD PTR _lpszOption$GSCopy$[ebp]
  002d1	57		 push	 edi
  002d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs?$AA@
  002d7	68 04 01 00 00	 push	 260			; 00000104H
  002dc	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR _szSelect$[ebp]
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 __snprintf

; 171  :     Log(LOG_DEBUG_WMI,__LINE__,"-- WMI, Querying properties for %s",lpszOption);

  002e8	57		 push	 edi
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for?5@
  002ee	68 ab 00 00 00	 push	 171			; 000000abH
  002f3	6a 40		 push	 64			; 00000040H
  002f5	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002fa	83 c4 20	 add	 esp, 32			; 00000020H

; 172  : 
; 173  :     // Query for all properties
; 174  :     IEnumWbemClassObject* pEnumerator = NULL;

  002fd	c7 85 0c 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pEnumerator$[ebp], 0

; 175  :     hres = pSvc->ExecQuery(
; 176  :         bstr_t("WQL"), 
; 177  :         bstr_t(szSelect),
; 178  :         WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
; 179  :         NULL,
; 180  :         &pEnumerator);

  00307	8d 95 c4 fb ff
	ff		 lea	 edx, DWORD PTR _szSelect$[ebp]
  0030d	52		 push	 edx
  0030e	8d 9d 14 86 ff
	ff		 lea	 ebx, DWORD PTR $T216196[ebp]
  00314	e8 00 00 00 00	 call	 ??0_bstr_t@@QAE@PBD@Z	; _bstr_t::_bstr_t
  00319	8b f8		 mov	 edi, eax
  0031b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  00322	68 00 00 00 00	 push	 OFFSET ??_C@_03LJNDFDHG@WQL?$AA@
  00327	8d 9d 28 86 ff
	ff		 lea	 ebx, DWORD PTR $T216197[ebp]
  0032d	e8 00 00 00 00	 call	 ??0_bstr_t@@QAE@PBD@Z	; _bstr_t::_bstr_t
  00332	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00336	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00338	85 c9		 test	 ecx, ecx
  0033a	74 04		 je	 SHORT $LN199@WMIex
  0033c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0033e	eb 02		 jmp	 SHORT $LN200@WMIex
$LN199@WMIex:
  00340	33 c9		 xor	 ecx, ecx
$LN200@WMIex:
  00342	8b 00		 mov	 eax, DWORD PTR [eax]
  00344	85 c0		 test	 eax, eax
  00346	74 04		 je	 SHORT $LN205@WMIex
  00348	8b 10		 mov	 edx, DWORD PTR [eax]
  0034a	eb 02		 jmp	 SHORT $LN206@WMIex
$LN205@WMIex:
  0034c	33 d2		 xor	 edx, edx
$LN206@WMIex:
  0034e	8b 85 18 86 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  00354	8b 38		 mov	 edi, DWORD PTR [eax]
  00356	8d 9d 0c 86 ff
	ff		 lea	 ebx, DWORD PTR _pEnumerator$[ebp]
  0035c	53		 push	 ebx
  0035d	6a 00		 push	 0
  0035f	6a 30		 push	 48			; 00000030H
  00361	51		 push	 ecx
  00362	52		 push	 edx
  00363	50		 push	 eax
  00364	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00367	ff d0		 call	 eax
  00369	89 85 2c 86 ff
	ff		 mov	 DWORD PTR _hres$[ebp], eax
  0036f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00373	8d bd 28 86 ff
	ff		 lea	 edi, DWORD PTR $T216197[ebp]
  00379	e8 00 00 00 00	 call	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
  0037e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00385	8d bd 14 86 ff
	ff		 lea	 edi, DWORD PTR $T216196[ebp]
  0038b	e8 00 00 00 00	 call	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t

; 181  :     
; 182  :     if(xml)

  00390	85 f6		 test	 esi, esi
  00392	0f 84 a2 00 00
	00		 je	 $LN112@WMIex

; 183  :     {
; 184  :         string tag;

  00398	c7 85 74 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _tag$136981[ebp+24], 15 ; 0000000fH
  003a2	c7 85 70 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tag$136981[ebp+20], 0
  003ac	c6 85 60 86 ff
	ff 00		 mov	 BYTE PTR _tag$136981[ebp+4], 0
  003b3	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 185  :         tag.assign(&lpszOption[6]); //minus: Win32_

  003ba	8b 9d 10 86 ff
	ff		 mov	 ebx, DWORD PTR _lpszOption$GSCopy$[ebp]
  003c0	8d 4b 06	 lea	 ecx, DWORD PTR [ebx+6]
  003c3	51		 push	 ecx
  003c4	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _tag$136981[ebp]
  003ca	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 186  :         xml->Createtag(tag);

  003cf	83 ec 1c	 sub	 esp, 28			; 0000001cH
  003d2	8b cc		 mov	 ecx, esp
  003d4	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216198[ebp], esp
  003da	8d 95 5c 86 ff
	ff		 lea	 edx, DWORD PTR _tag$136981[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003e6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  003ea	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  003ee	8b ce		 mov	 ecx, esi
  003f0	e8 00 00 00 00	 call	 ?Createtag@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::Createtag

; 187  : 
; 188  :         tag.clear();

  003f5	8d bd 5c 86 ff
	ff		 lea	 edi, DWORD PTR _tag$136981[ebp]
  003fb	e8 00 00 00 00	 call	 ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear

; 189  :         tag.assign(lpszOption);

  00400	53		 push	 ebx
  00401	8b cf		 mov	 ecx, edi
  00403	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 190  :         xml->AddComment(tag);

  00408	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0040b	8b cc		 mov	 ecx, esp
  0040d	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216199[ebp], esp
  00413	8b c7		 mov	 eax, edi
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0041b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0041f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  00423	8b ce		 mov	 ecx, esi
  00425	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 191  :     }

  0042a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00431	8b cf		 mov	 ecx, edi
  00433	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 192  :     else

  00438	eb 16		 jmp	 SHORT $LN111@WMIex
$LN112@WMIex:

; 193  :     {
; 194  :         Log(LOG_HEADER,__LINE__,lpszOption);

  0043a	8b 9d 10 86 ff
	ff		 mov	 ebx, DWORD PTR _lpszOption$GSCopy$[ebp]
  00440	53		 push	 ebx
  00441	68 c2 00 00 00	 push	 194			; 000000c2H
  00446	6a 02		 push	 2
  00448	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0044d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN111@WMIex:

; 195  :     }
; 196  : 
; 197  :     if (FAILED(hres))

  00450	8b 85 2c 86 ff
	ff		 mov	 eax, DWORD PTR _hres$[ebp]
  00456	85 c0		 test	 eax, eax
  00458	7d 6b		 jge	 SHORT $LN110@WMIex

; 198  :     {
; 199  :         Log(LOG_DEBUG_WMI,__LINE__,"-- WMI, Query for %s failed, 0x%.8x",lpszOption,hres);

  0045a	50		 push	 eax
  0045b	53		 push	 ebx
  0045c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x?$CF@
  00461	68 c7 00 00 00	 push	 199			; 000000c7H
  00466	6a 40		 push	 64			; 00000040H
  00468	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0046d	83 c4 14	 add	 esp, 20			; 00000014H
$LN107@WMIex:

; 636  :     }
; 637  :  
; 638  :     //process the number of properties processed
; 639  :     if(lpulProperties) {

  00470	8b 85 24 86 ff
	ff		 mov	 eax, DWORD PTR _lpulProperties$GSCopy$[ebp]

; 640  :         *lpulProperties = properties;

  00476	8b bd 20 86 ff
	ff		 mov	 edi, DWORD PTR _properties$[ebp]

; 636  :     }
; 637  :  
; 638  :     //process the number of properties processed
; 639  :     if(lpulProperties) {

  0047c	85 c0		 test	 eax, eax
  0047e	74 02		 je	 SHORT $LN7@WMIex

; 640  :         *lpulProperties = properties;

  00480	89 38		 mov	 DWORD PTR [eax], edi
$LN7@WMIex:

; 641  :     }
; 642  : 
; 643  :     char processed[_MAX_PATH] = {0};

  00482	c6 85 cc fc ff
	ff 00		 mov	 BYTE PTR _processed$[ebp], 0
  00489	68 03 01 00 00	 push	 259			; 00000103H
  0048e	6a 00		 push	 0
  00490	8d 8d cd fc ff
	ff		 lea	 ecx, DWORD PTR _processed$[ebp+1]
  00496	51		 push	 ecx
  00497	e8 00 00 00 00	 call	 _memset
  0049c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 644  :     if(properties==0)

  0049f	85 ff		 test	 edi, edi
  004a1	0f 85 5c 19 00
	00		 jne	 $LN6@WMIex

; 645  :     {
; 646  :         _snprintf(processed,sizeof(processed),"No properties processed");

  004a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NBKPEDCE@No?5properties?5processed?$AA@
  004ac	68 04 01 00 00	 push	 260			; 00000104H
  004b1	8d 95 cc fc ff
	ff		 lea	 edx, DWORD PTR _processed$[ebp]
  004b7	52		 push	 edx
  004b8	e8 00 00 00 00	 call	 __snprintf
  004bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  :     }
; 648  :     else

  004c0	e9 58 19 00 00	 jmp	 $LN5@WMIex
$LN110@WMIex:

; 200  :     }
; 201  :     else
; 202  :     { 
; 203  :         IWbemClassObject *pclsObj;
; 204  :         ULONG uReturn = 0;

  004c5	c7 85 14 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _uReturn$136990[ebp], 0
  004cf	90		 npad	 1
$LL108@WMIex:

; 205  : 
; 206  :         while (pEnumerator && _thGetInt(&gbTerminate)==FALSE)

  004d0	83 bd 0c 86 ff
	ff 00		 cmp	 DWORD PTR _pEnumerator$[ebp], 0
  004d7	74 97		 je	 SHORT $LN107@WMIex
  004d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?gbTerminate@@3HA ; gbTerminate
  004de	e8 00 00 00 00	 call	 ?_thGetInt@@YAHPAH@Z	; _thGetInt
  004e3	85 c0		 test	 eax, eax
  004e5	75 89		 jne	 SHORT $LN107@WMIex

; 207  :         {
; 208  :             hres = pEnumerator->Next(WBEM_INFINITE, 1, 
; 209  :                 &pclsObj, &uReturn);

  004e7	8b 85 0c 86 ff
	ff		 mov	 eax, DWORD PTR _pEnumerator$[ebp]
  004ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  004ef	8d 95 14 86 ff
	ff		 lea	 edx, DWORD PTR _uReturn$136990[ebp]
  004f5	52		 push	 edx
  004f6	8d 95 28 86 ff
	ff		 lea	 edx, DWORD PTR _pclsObj$136989[ebp]
  004fc	52		 push	 edx
  004fd	6a 01		 push	 1
  004ff	6a ff		 push	 -1
  00501	50		 push	 eax
  00502	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00505	ff d0		 call	 eax

; 210  : 
; 211  :             if(0 == uReturn)

  00507	83 bd 14 86 ff
	ff 00		 cmp	 DWORD PTR _uReturn$136990[ebp], 0
  0050e	0f 84 5c ff ff
	ff		 je	 $LN107@WMIex

; 212  :             {
; 213  :                 break;
; 214  :             }
; 215  : 
; 216  :             //line.clear();
; 217  :             for(int x=0;wmiClasses[x].pClass!=NULL && _thGetInt(&gbTerminate)==FALSE;x++)

  00514	33 ff		 xor	 edi, edi
  00516	89 bd 2c 86 ff
	ff		 mov	 DWORD PTR _x$136995[ebp], edi
  0051c	8d 64 24 00	 npad	 4
$LL105@WMIex:
  00520	83 3c fd 00 00
	00 00 00	 cmp	 DWORD PTR _wmiClasses[edi*8], 0
  00528	0f 84 c2 18 00
	00		 je	 $LN103@WMIex
  0052e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gbTerminate@@3HA ; gbTerminate
  00533	e8 00 00 00 00	 call	 ?_thGetInt@@YAHPAH@Z	; _thGetInt
  00538	85 c0		 test	 eax, eax
  0053a	0f 85 b0 18 00
	00		 jne	 $LN103@WMIex

; 218  :             {
; 219  :                 if(strcmp(wmiClasses[x].pClass,lpszOption)!=0)

  00540	8b 1c fd 00 00
	00 00		 mov	 ebx, DWORD PTR _wmiClasses[edi*8]
  00547	8b 8d 10 86 ff
	ff		 mov	 ecx, DWORD PTR _lpszOption$GSCopy$[ebp]
  0054d	8b c3		 mov	 eax, ebx
  0054f	90		 npad	 1
$LL779@WMIex:
  00550	8a 10		 mov	 dl, BYTE PTR [eax]
  00552	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00554	75 1a		 jne	 SHORT $LN780@WMIex
  00556	84 d2		 test	 dl, dl
  00558	74 12		 je	 SHORT $LN781@WMIex
  0055a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0055d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00560	75 0e		 jne	 SHORT $LN780@WMIex
  00562	83 c0 02	 add	 eax, 2
  00565	83 c1 02	 add	 ecx, 2
  00568	84 d2		 test	 dl, dl
  0056a	75 e4		 jne	 SHORT $LL779@WMIex
$LN781@WMIex:
  0056c	33 c0		 xor	 eax, eax
  0056e	eb 05		 jmp	 SHORT $LN782@WMIex
$LN780@WMIex:
  00570	1b c0		 sbb	 eax, eax
  00572	83 d8 ff	 sbb	 eax, -1
$LN782@WMIex:
  00575	85 c0		 test	 eax, eax
  00577	74 16		 je	 SHORT $LN102@WMIex

; 220  :                 {
; 221  :                     Sleep(MILLISECOND);

  00579	6a 01		 push	 1
  0057b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 212  :             {
; 213  :                 break;
; 214  :             }
; 215  : 
; 216  :             //line.clear();
; 217  :             for(int x=0;wmiClasses[x].pClass!=NULL && _thGetInt(&gbTerminate)==FALSE;x++)

  00581	ff 85 2c 86 ff
	ff		 inc	 DWORD PTR _x$136995[ebp]
  00587	8b bd 2c 86 ff
	ff		 mov	 edi, DWORD PTR _x$136995[ebp]
  0058d	eb 91		 jmp	 SHORT $LL105@WMIex
$LN102@WMIex:

; 222  :                     continue;
; 223  :                 }
; 224  :                 VARIANT vtProp;
; 225  :                 WCHAR tszProperty[10000];
; 226  :                 CHAR szValue[10000];
; 227  : 
; 228  :                 properties++;

  0058f	8b 85 20 86 ff
	ff		 mov	 eax, DWORD PTR _properties$[ebp]
  00595	40		 inc	 eax
  00596	89 85 20 86 ff
	ff		 mov	 DWORD PTR _properties$[ebp], eax

; 229  :                 Log(LOG_DEBUG_WMI,__LINE__,"-- WMI, Processing %.5u %s (%i) %s",properties,wmiClasses[x].pClass,x+1,wmiClasses[x].pProperty);

  0059c	8d 0c fd 04 00
	00 00		 lea	 ecx, DWORD PTR _wmiClasses[edi*8+4]
  005a3	89 8d 58 86 ff
	ff		 mov	 DWORD PTR tv3356[ebp], ecx
  005a9	8b 09		 mov	 ecx, DWORD PTR [ecx]
  005ab	51		 push	 ecx
  005ac	47		 inc	 edi
  005ad	57		 push	 edi
  005ae	53		 push	 ebx
  005af	50		 push	 eax
  005b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ?5@
  005b5	68 e5 00 00 00	 push	 229			; 000000e5H
  005ba	6a 40		 push	 64			; 00000040H
  005bc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  005c1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 230  : 
; 231  :                 memset(tszProperty,0x00,sizeof(tszProperty));

  005c4	68 20 4e 00 00	 push	 20000			; 00004e20H
  005c9	6a 00		 push	 0
  005cb	8d 95 94 86 ff
	ff		 lea	 edx, DWORD PTR _tszProperty$137001[ebp]
  005d1	52		 push	 edx
  005d2	e8 00 00 00 00	 call	 _memset
  005d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  :                 memset(szValue,0x00,sizeof(szValue));

  005da	68 10 27 00 00	 push	 10000			; 00002710H
  005df	6a 00		 push	 0
  005e1	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  005e7	50		 push	 eax
  005e8	e8 00 00 00 00	 call	 _memset
  005ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 233  : 
; 234  :                 //Convert Name Poperty to Unicode
; 235  :                 MultiByteToWideChar(CP_ACP,0,(LPCSTR)wmiClasses[x].pProperty,-1,(LPWSTR)tszProperty,sizeof(tszProperty));

  005f0	68 20 4e 00 00	 push	 20000			; 00004e20H
  005f5	8d 8d 94 86 ff
	ff		 lea	 ecx, DWORD PTR _tszProperty$137001[ebp]
  005fb	51		 push	 ecx
  005fc	6a ff		 push	 -1
  005fe	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00604	8b 02		 mov	 eax, DWORD PTR [edx]
  00606	50		 push	 eax
  00607	6a 00		 push	 0
  00609	6a 00		 push	 0
  0060b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 236  : 
; 237  :                 // Get the value of the Name property
; 238  :                 hres = pclsObj->Get(tszProperty, 0, &vtProp, 0, 0);

  00611	8b 85 28 86 ff
	ff		 mov	 eax, DWORD PTR _pclsObj$136989[ebp]
  00617	8b 08		 mov	 ecx, DWORD PTR [eax]
  00619	6a 00		 push	 0
  0061b	6a 00		 push	 0
  0061d	8d 95 3c 86 ff
	ff		 lea	 edx, DWORD PTR _vtProp$137000[ebp]
  00623	52		 push	 edx
  00624	6a 00		 push	 0
  00626	8d 95 94 86 ff
	ff		 lea	 edx, DWORD PTR _tszProperty$137001[ebp]
  0062c	52		 push	 edx
  0062d	50		 push	 eax
  0062e	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00631	ff d0		 call	 eax

; 239  :                 if(FAILED(hres))

  00633	85 c0		 test	 eax, eax
  00635	0f 8c a4 17 00
	00		 jl	 $LN104@WMIex

; 240  :                 {
; 241  :                     //read next property of option
; 242  :                     continue;
; 243  :                 }
; 244  : 
; 245  :                 try
; 246  :                 {

  0063b	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6
  00642	9b		 fwait

; 247  :                     string value;

  00643	c7 85 90 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _value$137009[ebp+24], 15 ; 0000000fH
  0064d	c7 85 8c 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _value$137009[ebp+20], 0
  00657	c6 85 7c 86 ff
	ff 00		 mov	 BYTE PTR _value$137009[ebp+4], 0
  0065e	b3 07		 mov	 bl, 7
  00660	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl

; 248  :                     char temp[_MAX_PATH] = {0};

  00663	c6 85 d4 fd ff
	ff 00		 mov	 BYTE PTR _temp$137010[ebp], 0
  0066a	68 03 01 00 00	 push	 259			; 00000103H
  0066f	6a 00		 push	 0
  00671	8d 8d d5 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp+1]
  00677	51		 push	 ecx
  00678	e8 00 00 00 00	 call	 _memset
  0067d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 249  : 
; 250  :                     switch(vtProp.vt)

  00680	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
  00686	0f b7 c1	 movzx	 eax, cx
  00689	83 c0 fe	 add	 eax, -2			; fffffffeH
  0068c	83 f8 13	 cmp	 eax, 19			; 00000013H
  0068f	0f 87 e9 08 00
	00		 ja	 $LN57@WMIex
  00695	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN803@WMIex[eax*4]
$LN97@WMIex:

; 251  :                     {
; 252  :                     case VT_I1:
; 253  :                         if(xml)

  0069c	85 f6		 test	 esi, esi
  0069e	74 79		 je	 SHORT $LN96@WMIex

; 254  :                         {
; 255  :                             _snprintf(temp,sizeof(temp),"0x%.2X",vtProp.cVal);

  006a0	0f be 95 44 86
	ff ff		 movsx	 edx, BYTE PTR _vtProp$137000[ebp+8]
  006a7	52		 push	 edx
  006a8	68 00 00 00 00	 push	 OFFSET ??_C@_06DBMAJEKE@0x?$CF?42X?$AA@
  006ad	68 04 01 00 00	 push	 260			; 00000104H
  006b2	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$137010[ebp]
  006b8	50		 push	 eax
  006b9	e8 00 00 00 00	 call	 __snprintf
  006be	83 c4 10	 add	 esp, 16			; 00000010H

; 256  :                             value.assign(temp);

  006c1	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  006c7	51		 push	 ecx
  006c8	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  006ce	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 257  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  006d3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  006d6	8b cc		 mov	 ecx, esp
  006d8	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216200[ebp], esp
  006de	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  006e4	52		 push	 edx
  006e5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  006ea	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  006ee	83 ec 1c	 sub	 esp, 28			; 0000001cH
  006f1	8b cc		 mov	 ecx, esp
  006f3	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216201[ebp], esp
  006f9	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  006ff	8b 10		 mov	 edx, DWORD PTR [eax]
  00701	52		 push	 edx
  00702	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00707	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  0070b	56		 push	 esi
  0070c	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  0070f	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 258  :                         }
; 259  :                         else

  00714	e9 49 16 00 00	 jmp	 $LN56@WMIex
$LN96@WMIex:

; 260  :                         {
; 261  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.2X",wmiClasses[x].pProperty,vtProp.cVal);

  00719	0f be 85 44 86
	ff ff		 movsx	 eax, BYTE PTR _vtProp$137000[ebp+8]
  00720	50		 push	 eax
  00721	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR tv3356[ebp]
  00727	8b 11		 mov	 edx, DWORD PTR [ecx]
  00729	52		 push	 edx
  0072a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X?$AA@
  0072f	68 05 01 00 00	 push	 261			; 00000105H
  00734	6a 01		 push	 1
  00736	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0073b	83 c4 14	 add	 esp, 20			; 00000014H

; 262  :                         }
; 263  :                         break;

  0073e	e9 1f 16 00 00	 jmp	 $LN56@WMIex
$LN94@WMIex:

; 264  : 
; 265  :                     case VT_UI1:
; 266  :                         if(xml)

  00743	85 f6		 test	 esi, esi
  00745	74 79		 je	 SHORT $LN93@WMIex

; 267  :                         {
; 268  :                             _snprintf(temp,sizeof(temp),"0x%.2X",vtProp.bVal);

  00747	0f b6 85 44 86
	ff ff		 movzx	 eax, BYTE PTR _vtProp$137000[ebp+8]
  0074e	50		 push	 eax
  0074f	68 00 00 00 00	 push	 OFFSET ??_C@_06DBMAJEKE@0x?$CF?42X?$AA@
  00754	68 04 01 00 00	 push	 260			; 00000104H
  00759	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  0075f	51		 push	 ecx
  00760	e8 00 00 00 00	 call	 __snprintf
  00765	83 c4 10	 add	 esp, 16			; 00000010H

; 269  :                             value.assign(temp);

  00768	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  0076e	52		 push	 edx
  0076f	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00775	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 270  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  0077a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0077d	8b cc		 mov	 ecx, esp
  0077f	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216202[ebp], esp
  00785	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  0078b	50		 push	 eax
  0078c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00791	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  00795	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00798	8b cc		 mov	 ecx, esp
  0079a	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216203[ebp], esp
  007a0	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  007a6	8b 02		 mov	 eax, DWORD PTR [edx]
  007a8	50		 push	 eax
  007a9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  007ae	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  007b2	56		 push	 esi
  007b3	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  007b6	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 271  :                         }
; 272  :                         else

  007bb	e9 a2 15 00 00	 jmp	 $LN56@WMIex
$LN93@WMIex:

; 273  :                         {
; 274  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.2X",wmiClasses[x].pProperty,vtProp.bVal);

  007c0	0f b6 8d 44 86
	ff ff		 movzx	 ecx, BYTE PTR _vtProp$137000[ebp+8]
  007c7	51		 push	 ecx
  007c8	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  007ce	8b 02		 mov	 eax, DWORD PTR [edx]
  007d0	50		 push	 eax
  007d1	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X?$AA@
  007d6	68 12 01 00 00	 push	 274			; 00000112H
  007db	6a 01		 push	 1
  007dd	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  007e2	83 c4 14	 add	 esp, 20			; 00000014H

; 275  :                         }
; 276  :                         break;

  007e5	e9 78 15 00 00	 jmp	 $LN56@WMIex
$LN91@WMIex:

; 277  : 
; 278  :                     case VT_I2:
; 279  :                         if(xml)

  007ea	85 f6		 test	 esi, esi
  007ec	74 79		 je	 SHORT $LN90@WMIex

; 280  :                         {
; 281  :                             _snprintf(temp,sizeof(temp),"0x%.4X",vtProp.iVal);

  007ee	0f bf 8d 44 86
	ff ff		 movsx	 ecx, WORD PTR _vtProp$137000[ebp+8]
  007f5	51		 push	 ecx
  007f6	68 00 00 00 00	 push	 OFFSET ??_C@_06DFENOIBG@0x?$CF?44X?$AA@
  007fb	68 04 01 00 00	 push	 260			; 00000104H
  00800	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  00806	52		 push	 edx
  00807	e8 00 00 00 00	 call	 __snprintf
  0080c	83 c4 10	 add	 esp, 16			; 00000010H

; 282  :                             value.assign(temp);

  0080f	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$137010[ebp]
  00815	50		 push	 eax
  00816	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  0081c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 283  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00821	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00824	8b cc		 mov	 ecx, esp
  00826	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216204[ebp], esp
  0082c	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  00832	52		 push	 edx
  00833	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00838	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  0083c	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0083f	8b cc		 mov	 ecx, esp
  00841	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216205[ebp], esp
  00847	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  0084d	8b 10		 mov	 edx, DWORD PTR [eax]
  0084f	52		 push	 edx
  00850	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00855	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  00859	56		 push	 esi
  0085a	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  0085d	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 284  :                         }
; 285  :                         else

  00862	e9 fb 14 00 00	 jmp	 $LN56@WMIex
$LN90@WMIex:

; 286  :                         {
; 287  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.4X",wmiClasses[x].pProperty,vtProp.iVal);

  00867	0f bf 85 44 86
	ff ff		 movsx	 eax, WORD PTR _vtProp$137000[ebp+8]
  0086e	50		 push	 eax
  0086f	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR tv3356[ebp]
  00875	8b 11		 mov	 edx, DWORD PTR [ecx]
  00877	52		 push	 edx
  00878	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X?$AA@
  0087d	68 1f 01 00 00	 push	 287			; 0000011fH
  00882	6a 01		 push	 1
  00884	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00889	83 c4 14	 add	 esp, 20			; 00000014H

; 288  :                         }
; 289  :                         break;

  0088c	e9 d1 14 00 00	 jmp	 $LN56@WMIex
$LN88@WMIex:

; 290  : 
; 291  :                     case VT_UI2:
; 292  :                         if(xml)

  00891	85 f6		 test	 esi, esi
  00893	74 79		 je	 SHORT $LN87@WMIex

; 293  :                         {
; 294  :                             _snprintf(temp,sizeof(temp),"0x%.4X",vtProp.uiVal);

  00895	0f b7 85 44 86
	ff ff		 movzx	 eax, WORD PTR _vtProp$137000[ebp+8]
  0089c	50		 push	 eax
  0089d	68 00 00 00 00	 push	 OFFSET ??_C@_06DFENOIBG@0x?$CF?44X?$AA@
  008a2	68 04 01 00 00	 push	 260			; 00000104H
  008a7	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  008ad	51		 push	 ecx
  008ae	e8 00 00 00 00	 call	 __snprintf
  008b3	83 c4 10	 add	 esp, 16			; 00000010H

; 295  :                             value.assign(temp);

  008b6	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  008bc	52		 push	 edx
  008bd	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  008c3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 296  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  008c8	83 ec 1c	 sub	 esp, 28			; 0000001cH
  008cb	8b cc		 mov	 ecx, esp
  008cd	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216206[ebp], esp
  008d3	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  008d9	50		 push	 eax
  008da	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  008df	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  008e3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  008e6	8b cc		 mov	 ecx, esp
  008e8	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216207[ebp], esp
  008ee	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  008f4	8b 02		 mov	 eax, DWORD PTR [edx]
  008f6	50		 push	 eax
  008f7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  008fc	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  00900	56		 push	 esi
  00901	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00904	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 297  :                         }
; 298  :                         else

  00909	e9 54 14 00 00	 jmp	 $LN56@WMIex
$LN87@WMIex:

; 299  :                         {
; 300  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.4X",wmiClasses[x].pProperty,vtProp.uiVal);

  0090e	0f b7 8d 44 86
	ff ff		 movzx	 ecx, WORD PTR _vtProp$137000[ebp+8]
  00915	51		 push	 ecx
  00916	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  0091c	8b 02		 mov	 eax, DWORD PTR [edx]
  0091e	50		 push	 eax
  0091f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X?$AA@
  00924	68 2c 01 00 00	 push	 300			; 0000012cH
  00929	6a 01		 push	 1
  0092b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00930	83 c4 14	 add	 esp, 20			; 00000014H

; 301  :                         }
; 302  :                         break;

  00933	e9 2a 14 00 00	 jmp	 $LN56@WMIex
$LN85@WMIex:

; 303  : 
; 304  :                     case VT_I4:
; 305  :                         if(xml)

  00938	85 f6		 test	 esi, esi
  0093a	74 78		 je	 SHORT $LN84@WMIex

; 306  :                         {
; 307  :                             _snprintf(temp,sizeof(temp),"0x%.8X",vtProp.lVal);

  0093c	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  00942	51		 push	 ecx
  00943	68 00 00 00 00	 push	 OFFSET ??_C@_06DMFHBBHC@0x?$CF?48X?$AA@
  00948	68 04 01 00 00	 push	 260			; 00000104H
  0094d	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  00953	52		 push	 edx
  00954	e8 00 00 00 00	 call	 __snprintf
  00959	83 c4 10	 add	 esp, 16			; 00000010H

; 308  :                             value.assign(temp);

  0095c	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$137010[ebp]
  00962	50		 push	 eax
  00963	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00969	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 309  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  0096e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00971	8b cc		 mov	 ecx, esp
  00973	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216208[ebp], esp
  00979	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  0097f	52		 push	 edx
  00980	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00985	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  00989	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0098c	8b cc		 mov	 ecx, esp
  0098e	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216209[ebp], esp
  00994	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  0099a	8b 10		 mov	 edx, DWORD PTR [eax]
  0099c	52		 push	 edx
  0099d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  009a2	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+12], 17 ; 00000011H
  009a6	56		 push	 esi
  009a7	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  009aa	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 310  :                         }
; 311  :                         else

  009af	e9 ae 13 00 00	 jmp	 $LN56@WMIex
$LN84@WMIex:

; 312  :                         {
; 313  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.8X",wmiClasses[x].pProperty,vtProp.lVal);

  009b4	8b 85 44 86 ff
	ff		 mov	 eax, DWORD PTR _vtProp$137000[ebp+8]
  009ba	50		 push	 eax
  009bb	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR tv3356[ebp]
  009c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  009c3	52		 push	 edx
  009c4	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X?$AA@
  009c9	68 39 01 00 00	 push	 313			; 00000139H
  009ce	6a 01		 push	 1
  009d0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  009d5	83 c4 14	 add	 esp, 20			; 00000014H

; 314  :                         }
; 315  :                         break;

  009d8	e9 85 13 00 00	 jmp	 $LN56@WMIex
$LN82@WMIex:

; 316  : 
; 317  :                     case VT_UI4:
; 318  :                         if(xml)

  009dd	85 f6		 test	 esi, esi
  009df	74 78		 je	 SHORT $LN81@WMIex

; 319  :                         {
; 320  :                             _snprintf(temp,sizeof(temp),"0x%.8X",vtProp.ulVal);

  009e1	8b 85 44 86 ff
	ff		 mov	 eax, DWORD PTR _vtProp$137000[ebp+8]
  009e7	50		 push	 eax
  009e8	68 00 00 00 00	 push	 OFFSET ??_C@_06DMFHBBHC@0x?$CF?48X?$AA@
  009ed	68 04 01 00 00	 push	 260			; 00000104H
  009f2	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  009f8	51		 push	 ecx
  009f9	e8 00 00 00 00	 call	 __snprintf
  009fe	83 c4 10	 add	 esp, 16			; 00000010H

; 321  :                             value.assign(temp);

  00a01	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  00a07	52		 push	 edx
  00a08	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00a0e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 322  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00a13	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00a16	8b cc		 mov	 ecx, esp
  00a18	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216210[ebp], esp
  00a1e	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  00a24	50		 push	 eax
  00a25	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a2a	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
  00a2e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00a31	8b cc		 mov	 ecx, esp
  00a33	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216211[ebp], esp
  00a39	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00a3f	8b 02		 mov	 eax, DWORD PTR [edx]
  00a41	50		 push	 eax
  00a42	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a47	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+12], 19 ; 00000013H
  00a4b	56		 push	 esi
  00a4c	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00a4f	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 323  :                         }
; 324  :                         else

  00a54	e9 09 13 00 00	 jmp	 $LN56@WMIex
$LN81@WMIex:

; 325  :                         {
; 326  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.8X",wmiClasses[x].pProperty,vtProp.ulVal);

  00a59	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  00a5f	51		 push	 ecx
  00a60	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00a66	8b 02		 mov	 eax, DWORD PTR [edx]
  00a68	50		 push	 eax
  00a69	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X?$AA@
  00a6e	68 46 01 00 00	 push	 326			; 00000146H
  00a73	6a 01		 push	 1
  00a75	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00a7a	83 c4 14	 add	 esp, 20			; 00000014H

; 327  :                         }
; 328  :                         break;

  00a7d	e9 e0 12 00 00	 jmp	 $LN56@WMIex
$LN79@WMIex:

; 329  : 
; 330  :                     case VT_I8:
; 331  :                         if(xml)

  00a82	85 f6		 test	 esi, esi
  00a84	0f 84 7f 00 00
	00		 je	 $LN78@WMIex

; 332  :                         {
; 333  :                             _snprintf(temp,sizeof(temp),"0x%.16X",vtProp.llVal);

  00a8a	8b 8d 48 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+12]
  00a90	51		 push	 ecx
  00a91	8b 95 44 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+8]
  00a97	52		 push	 edx
  00a98	68 00 00 00 00	 push	 OFFSET ??_C@_07PDBEDJPN@0x?$CF?416X?$AA@
  00a9d	68 04 01 00 00	 push	 260			; 00000104H
  00aa2	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$137010[ebp]
  00aa8	50		 push	 eax
  00aa9	e8 00 00 00 00	 call	 __snprintf
  00aae	83 c4 14	 add	 esp, 20			; 00000014H

; 334  :                             value.assign(temp);

  00ab1	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  00ab7	51		 push	 ecx
  00ab8	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00abe	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 335  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00ac3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00ac6	8b cc		 mov	 ecx, esp
  00ac8	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216212[ebp], esp
  00ace	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  00ad4	52		 push	 edx
  00ad5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ada	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+12], 20 ; 00000014H
  00ade	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00ae1	8b cc		 mov	 ecx, esp
  00ae3	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216213[ebp], esp
  00ae9	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00aef	8b 10		 mov	 edx, DWORD PTR [eax]
  00af1	52		 push	 edx
  00af2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00af7	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
  00afb	56		 push	 esi
  00afc	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00aff	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 336  :                         }
; 337  :                         else

  00b04	e9 59 12 00 00	 jmp	 $LN56@WMIex
$LN78@WMIex:

; 338  :                         {
; 339  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.16X",wmiClasses[x].pProperty,vtProp.llVal);

  00b09	8b 85 48 86 ff
	ff		 mov	 eax, DWORD PTR _vtProp$137000[ebp+12]
  00b0f	50		 push	 eax
  00b10	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  00b16	51		 push	 ecx
  00b17	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00b1d	8b 02		 mov	 eax, DWORD PTR [edx]
  00b1f	50		 push	 eax
  00b20	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X?$AA@
  00b25	68 53 01 00 00	 push	 339			; 00000153H
  00b2a	6a 01		 push	 1
  00b2c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00b31	83 c4 18	 add	 esp, 24			; 00000018H

; 340  :                         }
; 341  :                         break;

  00b34	e9 29 12 00 00	 jmp	 $LN56@WMIex
$LN76@WMIex:

; 342  : 
; 343  :                     case VT_UI8:
; 344  :                         if(xml)

  00b39	85 f6		 test	 esi, esi
  00b3b	0f 84 7f 00 00
	00		 je	 $LN75@WMIex

; 345  :                         {
; 346  :                             _snprintf(temp,sizeof(temp),"0x%.16X",vtProp.ullVal);

  00b41	8b 8d 48 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+12]
  00b47	51		 push	 ecx
  00b48	8b 95 44 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+8]
  00b4e	52		 push	 edx
  00b4f	68 00 00 00 00	 push	 OFFSET ??_C@_07PDBEDJPN@0x?$CF?416X?$AA@
  00b54	68 04 01 00 00	 push	 260			; 00000104H
  00b59	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$137010[ebp]
  00b5f	50		 push	 eax
  00b60	e8 00 00 00 00	 call	 __snprintf
  00b65	83 c4 14	 add	 esp, 20			; 00000014H

; 347  :                             value.assign(temp);

  00b68	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  00b6e	51		 push	 ecx
  00b6f	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00b75	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 348  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00b7a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00b7d	8b cc		 mov	 ecx, esp
  00b7f	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216214[ebp], esp
  00b85	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  00b8b	52		 push	 edx
  00b8c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b91	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+12], 22 ; 00000016H
  00b95	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00b98	8b cc		 mov	 ecx, esp
  00b9a	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216215[ebp], esp
  00ba0	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00ba6	8b 10		 mov	 edx, DWORD PTR [eax]
  00ba8	52		 push	 edx
  00ba9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00bae	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+12], 23 ; 00000017H
  00bb2	56		 push	 esi
  00bb3	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00bb6	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 349  :                         }
; 350  :                         else

  00bbb	e9 a2 11 00 00	 jmp	 $LN56@WMIex
$LN75@WMIex:

; 351  :                         {
; 352  :                             Log(LOG_MESSAGE,__LINE__,"%s = 0x%.16X",wmiClasses[x].pProperty,vtProp.ullVal);

  00bc0	8b 85 48 86 ff
	ff		 mov	 eax, DWORD PTR _vtProp$137000[ebp+12]
  00bc6	50		 push	 eax
  00bc7	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  00bcd	51		 push	 ecx
  00bce	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00bd4	8b 02		 mov	 eax, DWORD PTR [edx]
  00bd6	50		 push	 eax
  00bd7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X?$AA@
  00bdc	68 60 01 00 00	 push	 352			; 00000160H
  00be1	6a 01		 push	 1
  00be3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00be8	83 c4 18	 add	 esp, 24			; 00000018H

; 353  :                         }
; 354  :                         break;

  00beb	e9 72 11 00 00	 jmp	 $LN56@WMIex
$LN73@WMIex:

; 358  :                         {
; 359  :                             _snprintf(temp,sizeof(temp),"%f",vtProp.fltVal);

  00bf0	d9 85 44 86 ff
	ff		 fld	 DWORD PTR _vtProp$137000[ebp+8]
  00bf6	83 ec 08	 sub	 esp, 8
  00bf9	dd 1c 24	 fstp	 QWORD PTR [esp]

; 355  : 
; 356  :                     case VT_R4:
; 357  :                         if(xml)

  00bfc	85 f6		 test	 esi, esi
  00bfe	74 71		 je	 SHORT $LN72@WMIex

; 358  :                         {
; 359  :                             _snprintf(temp,sizeof(temp),"%f",vtProp.fltVal);

  00c00	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
  00c05	68 04 01 00 00	 push	 260			; 00000104H
  00c0a	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  00c10	51		 push	 ecx
  00c11	e8 00 00 00 00	 call	 __snprintf
  00c16	83 c4 14	 add	 esp, 20			; 00000014H

; 360  :                             value.assign(temp);

  00c19	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  00c1f	52		 push	 edx
  00c20	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00c26	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 361  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00c2b	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00c2e	8b cc		 mov	 ecx, esp
  00c30	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216216[ebp], esp
  00c36	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  00c3c	50		 push	 eax
  00c3d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c42	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+12], 24 ; 00000018H
  00c46	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00c49	8b cc		 mov	 ecx, esp
  00c4b	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216217[ebp], esp
  00c51	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00c57	8b 02		 mov	 eax, DWORD PTR [edx]
  00c59	50		 push	 eax
  00c5a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c5f	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+12], 25 ; 00000019H
  00c63	56		 push	 esi
  00c64	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00c67	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 362  :                         }
; 363  :                         else

  00c6c	e9 f1 10 00 00	 jmp	 $LN56@WMIex
$LN72@WMIex:

; 364  :                         {
; 365  :                             Log(LOG_MESSAGE,__LINE__,"%s = %f",wmiClasses[x].pProperty,vtProp.fltVal);

  00c71	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR tv3356[ebp]
  00c77	8b 11		 mov	 edx, DWORD PTR [ecx]
  00c79	52		 push	 edx
  00c7a	68 00 00 00 00	 push	 OFFSET ??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf?$AA@
  00c7f	68 6d 01 00 00	 push	 365			; 0000016dH
  00c84	6a 01		 push	 1
  00c86	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00c8b	83 c4 18	 add	 esp, 24			; 00000018H

; 366  :                         }
; 367  :                         break;

  00c8e	e9 cf 10 00 00	 jmp	 $LN56@WMIex
$LN70@WMIex:

; 371  :                         {
; 372  :                             _snprintf(temp,sizeof(temp),"%e",vtProp.dblVal);

  00c93	83 ec 08	 sub	 esp, 8
  00c96	dd 85 44 86 ff
	ff		 fld	 QWORD PTR _vtProp$137000[ebp+8]
  00c9c	dd 1c 24	 fstp	 QWORD PTR [esp]

; 368  : 
; 369  :                     case VT_R8:
; 370  :                         if(xml)

  00c9f	85 f6		 test	 esi, esi
  00ca1	74 71		 je	 SHORT $LN69@WMIex

; 371  :                         {
; 372  :                             _snprintf(temp,sizeof(temp),"%e",vtProp.dblVal);

  00ca3	68 00 00 00 00	 push	 OFFSET ??_C@_02CGLCDNAE@?$CFe?$AA@
  00ca8	68 04 01 00 00	 push	 260			; 00000104H
  00cad	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _temp$137010[ebp]
  00cb3	50		 push	 eax
  00cb4	e8 00 00 00 00	 call	 __snprintf
  00cb9	83 c4 14	 add	 esp, 20			; 00000014H

; 373  :                             value.assign(temp);

  00cbc	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  00cc2	51		 push	 ecx
  00cc3	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00cc9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 374  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00cce	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00cd1	8b cc		 mov	 ecx, esp
  00cd3	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216218[ebp], esp
  00cd9	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  00cdf	52		 push	 edx
  00ce0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ce5	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+12], 26 ; 0000001aH
  00ce9	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00cec	8b cc		 mov	 ecx, esp
  00cee	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216219[ebp], esp
  00cf4	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00cfa	8b 10		 mov	 edx, DWORD PTR [eax]
  00cfc	52		 push	 edx
  00cfd	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d02	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+12], 27 ; 0000001bH
  00d06	56		 push	 esi
  00d07	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00d0a	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 375  :                         }
; 376  :                         else

  00d0f	e9 4e 10 00 00	 jmp	 $LN56@WMIex
$LN69@WMIex:

; 377  :                         {
; 378  :                             Log(LOG_MESSAGE,__LINE__,"%s = %e",wmiClasses[x].pProperty,vtProp.dblVal);

  00d14	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00d1a	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d1c	51		 push	 ecx
  00d1d	68 00 00 00 00	 push	 OFFSET ??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe?$AA@
  00d22	68 7a 01 00 00	 push	 378			; 0000017aH
  00d27	6a 01		 push	 1
  00d29	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00d2e	83 c4 18	 add	 esp, 24			; 00000018H

; 379  :                         }
; 380  :                         break;

  00d31	e9 2c 10 00 00	 jmp	 $LN56@WMIex
$LN67@WMIex:

; 384  :                         {
; 385  :                             value.assign(vtProp.boolVal==VARIANT_TRUE?"True":"False");

  00d36	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04HPMIDMKH@True?$AA@

; 381  : 
; 382  :                     case VT_BOOL:
; 383  :                         if(xml)

  00d3b	85 f6		 test	 esi, esi
  00d3d	74 61		 je	 SHORT $LN66@WMIex

; 384  :                         {
; 385  :                             value.assign(vtProp.boolVal==VARIANT_TRUE?"True":"False");

  00d3f	66 83 bd 44 86
	ff ff ff	 cmp	 WORD PTR _vtProp$137000[ebp+8], -1
  00d47	74 05		 je	 SHORT $LN124@WMIex
  00d49	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05MKDOIIA@False?$AA@
$LN124@WMIex:
  00d4e	50		 push	 eax
  00d4f	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00d55	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 386  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00d5a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00d5d	8b cc		 mov	 ecx, esp
  00d5f	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216222[ebp], esp
  00d65	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  00d6b	52		 push	 edx
  00d6c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d71	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+12], 28 ; 0000001cH
  00d75	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00d78	8b cc		 mov	 ecx, esp
  00d7a	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216223[ebp], esp
  00d80	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00d86	8b 10		 mov	 edx, DWORD PTR [eax]
  00d88	52		 push	 edx
  00d89	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d8e	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+12], 29 ; 0000001dH
  00d92	56		 push	 esi
  00d93	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00d96	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 387  :                         }
; 388  :                         else

  00d9b	e9 c2 0f 00 00	 jmp	 $LN56@WMIex
$LN66@WMIex:

; 389  :                         {
; 390  :                             Log(LOG_MESSAGE,__LINE__,"%s = %s",wmiClasses[x].pProperty,vtProp.boolVal==VARIANT_TRUE?"True":"False");

  00da0	66 83 bd 44 86
	ff ff ff	 cmp	 WORD PTR _vtProp$137000[ebp+8], -1
  00da8	74 05		 je	 SHORT $LN126@WMIex
  00daa	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05MKDOIIA@False?$AA@
$LN126@WMIex:
  00daf	50		 push	 eax
  00db0	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00db6	8b 08		 mov	 ecx, DWORD PTR [eax]
  00db8	51		 push	 ecx
  00db9	68 00 00 00 00	 push	 OFFSET ??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs?$AA@
  00dbe	68 86 01 00 00	 push	 390			; 00000186H
  00dc3	6a 01		 push	 1
  00dc5	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00dca	83 c4 14	 add	 esp, 20			; 00000014H

; 391  :                         }
; 392  :                         break;

  00dcd	e9 90 0f 00 00	 jmp	 $LN56@WMIex
$LN64@WMIex:

; 393  : 
; 394  :                     case VT_BSTR:
; 395  :                         if(vtProp.bstrVal)

  00dd2	8b 85 44 86 ff
	ff		 mov	 eax, DWORD PTR _vtProp$137000[ebp+8]
  00dd8	85 c0		 test	 eax, eax
  00dda	0f 84 82 0f 00
	00		 je	 $LN56@WMIex

; 396  :                         {
; 397  :                             WideCharToMultiByte(CP_ACP,0,(LPCWSTR)vtProp.bstrVal,-1,(LPSTR)szValue,sizeof(szValue),NULL,NULL);

  00de0	6a 00		 push	 0
  00de2	6a 00		 push	 0
  00de4	68 10 27 00 00	 push	 10000			; 00002710H
  00de9	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  00def	52		 push	 edx
  00df0	6a ff		 push	 -1
  00df2	50		 push	 eax
  00df3	6a 00		 push	 0
  00df5	6a 00		 push	 0
  00df7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 399  :                             {
; 400  :                                 value.assign(szValue);

  00dfd	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  00e03	50		 push	 eax

; 398  :                             if(xml)

  00e04	85 f6		 test	 esi, esi
  00e06	74 51		 je	 SHORT $LN62@WMIex

; 399  :                             {
; 400  :                                 value.assign(szValue);

  00e08	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00e0e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 401  :                                 xml->CreateChild(wmiClasses[x].pProperty,value);

  00e13	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00e16	8b cc		 mov	 ecx, esp
  00e18	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216226[ebp], esp
  00e1e	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  00e24	52		 push	 edx
  00e25	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e2a	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+12], 30 ; 0000001eH
  00e2e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00e31	8b cc		 mov	 ecx, esp
  00e33	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216227[ebp], esp
  00e39	8b 85 58 86 ff
	ff		 mov	 eax, DWORD PTR tv3356[ebp]
  00e3f	8b 10		 mov	 edx, DWORD PTR [eax]
  00e41	52		 push	 edx
  00e42	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00e47	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+12], 31 ; 0000001fH
  00e4b	56		 push	 esi
  00e4c	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00e4f	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 402  :                             }
; 403  :                             else

  00e54	e9 09 0f 00 00	 jmp	 $LN56@WMIex
$LN62@WMIex:

; 404  :                             {
; 405  :                                 Log(LOG_MESSAGE,__LINE__,"%s = %s",wmiClasses[x].pProperty,szValue);

  00e59	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR tv3356[ebp]
  00e5f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e61	52		 push	 edx
  00e62	68 00 00 00 00	 push	 OFFSET ??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs?$AA@
  00e67	68 95 01 00 00	 push	 405			; 00000195H
  00e6c	6a 01		 push	 1
  00e6e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00e73	83 c4 14	 add	 esp, 20			; 00000014H

; 406  :                             }
; 407  :                         }
; 408  :                         break;

  00e76	e9 e7 0e 00 00	 jmp	 $LN56@WMIex
$LN60@WMIex:

; 412  :                         {
; 413  :                             _snprintf(temp,sizeof(temp),"%u",(unsigned long)vtProp.date);

  00e7b	dd 85 44 86 ff
	ff		 fld	 QWORD PTR _vtProp$137000[ebp+8]

; 409  : 
; 410  :                     case VT_DATE:
; 411  :                         if(xml)

  00e81	85 f6		 test	 esi, esi
  00e83	0f 84 a2 00 00
	00		 je	 $LN59@WMIex

; 412  :                         {
; 413  :                             _snprintf(temp,sizeof(temp),"%u",(unsigned long)vtProp.date);

  00e89	d9 bd 3a 86 ff
	ff		 fnstcw	 WORD PTR tv3611[ebp]
  00e8f	0f b7 85 3a 86
	ff ff		 movzx	 eax, WORD PTR tv3611[ebp]
  00e96	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00e9b	89 85 50 86 ff
	ff		 mov	 DWORD PTR tv3608[ebp], eax
  00ea1	d9 ad 50 86 ff
	ff		 fldcw	 WORD PTR tv3608[ebp]
  00ea7	df bd 4c 86 ff
	ff		 fistp	 QWORD PTR tv3606[ebp]
  00ead	d9 ad 3a 86 ff
	ff		 fldcw	 WORD PTR tv3611[ebp]
  00eb3	8b 85 4c 86 ff
	ff		 mov	 eax, DWORD PTR tv3606[ebp]
  00eb9	50		 push	 eax
  00eba	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
  00ebf	68 04 01 00 00	 push	 260			; 00000104H
  00ec4	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _temp$137010[ebp]
  00eca	51		 push	 ecx
  00ecb	e8 00 00 00 00	 call	 __snprintf
  00ed0	83 c4 10	 add	 esp, 16			; 00000010H

; 414  :                             value.assign(temp);

  00ed3	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _temp$137010[ebp]
  00ed9	52		 push	 edx
  00eda	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00ee0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 415  :                             xml->CreateChild(wmiClasses[x].pProperty,value);

  00ee5	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00ee8	8b cc		 mov	 ecx, esp
  00eea	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216228[ebp], esp
  00ef0	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  00ef6	50		 push	 eax
  00ef7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00efc	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+12], 32 ; 00000020H
  00f00	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00f03	8b cc		 mov	 ecx, esp
  00f05	89 a5 38 86 ff
	ff		 mov	 DWORD PTR $T216229[ebp], esp
  00f0b	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00f11	8b 02		 mov	 eax, DWORD PTR [edx]
  00f13	50		 push	 eax
  00f14	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00f19	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+12], 33 ; 00000021H
  00f1d	56		 push	 esi
  00f1e	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00f21	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 416  :                         }
; 417  :                         else

  00f26	e9 37 0e 00 00	 jmp	 $LN56@WMIex
$LN59@WMIex:

; 418  :                         {
; 419  :                             Log(LOG_MESSAGE,__LINE__,"%s = %u",wmiClasses[x].pProperty,(unsigned long)vtProp.date);

  00f2b	d9 bd 3a 86 ff
	ff		 fnstcw	 WORD PTR tv3597[ebp]
  00f31	0f b7 85 3a 86
	ff ff		 movzx	 eax, WORD PTR tv3597[ebp]
  00f38	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00f3d	89 85 50 86 ff
	ff		 mov	 DWORD PTR tv3594[ebp], eax
  00f43	d9 ad 50 86 ff
	ff		 fldcw	 WORD PTR tv3594[ebp]
  00f49	df bd 4c 86 ff
	ff		 fistp	 QWORD PTR tv3592[ebp]
  00f4f	d9 ad 3a 86 ff
	ff		 fldcw	 WORD PTR tv3597[ebp]
  00f55	8b 8d 4c 86 ff
	ff		 mov	 ecx, DWORD PTR tv3592[ebp]
  00f5b	51		 push	 ecx
  00f5c	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00f62	8b 02		 mov	 eax, DWORD PTR [edx]
  00f64	50		 push	 eax
  00f65	68 00 00 00 00	 push	 OFFSET ??_C@_07GECKFJJF@?$CFs?5?$DN?5?$CFu?$AA@
  00f6a	68 a3 01 00 00	 push	 419			; 000001a3H
  00f6f	6a 01		 push	 1
  00f71	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00f76	83 c4 14	 add	 esp, 20			; 00000014H

; 420  :                         }
; 421  :                         break;

  00f79	e9 e4 0d 00 00	 jmp	 $LN56@WMIex
$LN57@WMIex:

; 422  : 
; 423  :                     default:
; 424  :                         if(vtProp.vt & VT_BYREF)

  00f7e	f7 c1 00 40 00
	00		 test	 ecx, 16384		; 00004000H
  00f84	0f 84 d8 0d 00
	00		 je	 $LN56@WMIex

; 425  :                         {
; 426  :                             if(xml)

  00f8a	85 f6		 test	 esi, esi
  00f8c	74 2d		 je	 SHORT $LN55@WMIex

; 427  :                             {
; 428  :                                 xml->Createtag(wmiClasses[x].pProperty);

  00f8e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00f91	8b cc		 mov	 ecx, esp
  00f93	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216230[ebp], esp
  00f99	8b 95 58 86 ff
	ff		 mov	 edx, DWORD PTR tv3356[ebp]
  00f9f	8b 02		 mov	 eax, DWORD PTR [edx]
  00fa1	50		 push	 eax
  00fa2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00fa7	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+12], 34 ; 00000022H
  00fab	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00fae	8b ce		 mov	 ecx, esi
  00fb0	e8 00 00 00 00	 call	 ?Createtag@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::Createtag
  00fb5	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
$LN55@WMIex:

; 429  :                             }
; 430  :                             unsigned short type = (vtProp.vt-VT_BYREF);

  00fbb	81 c1 00 c0 ff
	ff		 add	 ecx, -16384		; ffffc000H
  00fc1	0f b7 f9	 movzx	 edi, cx

; 431  :                             char idx[_MAX_PATH] = {0};

  00fc4	c6 85 dc fe ff
	ff 00		 mov	 BYTE PTR _idx$137109[ebp], 0
  00fcb	68 03 01 00 00	 push	 259			; 00000103H
  00fd0	6a 00		 push	 0
  00fd2	8d 8d dd fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp+1]
  00fd8	51		 push	 ecx
  00fd9	e8 00 00 00 00	 call	 _memset
  00fde	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  :                             string id;

  00fe1	c7 85 74 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _id$137110[ebp+24], 15 ; 0000000fH
  00feb	c7 85 70 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _id$137110[ebp+20], 0
  00ff5	c6 85 60 86 ff
	ff 00		 mov	 BYTE PTR _id$137110[ebp+4], 0
  00ffc	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H

; 433  : 
; 434  :                             switch(type)

  01000	0f b7 c7	 movzx	 eax, di
  01003	83 c0 fe	 add	 eax, -2			; fffffffeH
  01006	83 f8 13	 cmp	 eax, 19			; 00000013H
  01009	0f 87 f5 0c 00
	00		 ja	 $LN53@WMIex
  0100f	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN783@WMIex[eax]
  01016	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN804@WMIex[edx*4]
$LN52@WMIex:

; 435  :                             {
; 436  :                             case VT_I1:
; 437  :                             case VT_UI1:
; 438  :                                 {
; 439  :                                     vector<BYTE> vui1;

  0101d	8d 85 cc 85 ff
	ff		 lea	 eax, DWORD PTR _vui1$137444[ebp]
  01023	50		 push	 eax
  01024	e8 00 00 00 00	 call	 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  01029	b3 24		 mov	 bl, 36			; 00000024H
  0102b	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl

; 440  :                                     FromVariant(vtProp,vui1);

  0102e	83 ec 10	 sub	 esp, 16			; 00000010H
  01031	8b c4		 mov	 eax, esp
  01033	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
  01039	89 08		 mov	 DWORD PTR [eax], ecx
  0103b	8b 95 40 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+4]
  01041	89 50 04	 mov	 DWORD PTR [eax+4], edx
  01044	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  0104a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0104d	8b 95 48 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+12]
  01053	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  01056	8d 85 cc 85 ff
	ff		 lea	 eax, DWORD PTR _vui1$137444[ebp]
  0105c	50		 push	 eax
  0105d	e8 00 00 00 00	 call	 ??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ; FromVariant<unsigned char>
  01062	83 c4 14	 add	 esp, 20			; 00000014H

; 441  :                                     for(unsigned int i=0;i<vui1.size();i++)

  01065	33 ff		 xor	 edi, edi
$LN794@WMIex:
  01067	89 bd 60 85 ff
	ff		 mov	 DWORD PTR _i$137454[ebp], edi
  0106d	8b 8d dc 85 ff
	ff		 mov	 ecx, DWORD PTR _vui1$137444[ebp+16]
  01073	8b d1		 mov	 edx, ecx
  01075	8b 85 d8 85 ff
	ff		 mov	 eax, DWORD PTR _vui1$137444[ebp+12]
  0107b	2b d0		 sub	 edx, eax
  0107d	3b fa		 cmp	 edi, edx
  0107f	0f 83 ee 00 00
	00		 jae	 $LN49@WMIex

; 442  :                                     {
; 443  :                                         if(xml)

  01085	85 f6		 test	 esi, esi
  01087	0f 84 bf 00 00
	00		 je	 $LN48@WMIex

; 444  :                                         {
; 445  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  0108d	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  01090	50		 push	 eax
  01091	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  01096	68 04 01 00 00	 push	 260			; 00000104H
  0109b	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  010a1	51		 push	 ecx
  010a2	e8 00 00 00 00	 call	 __snprintf
  010a7	83 c4 10	 add	 esp, 16			; 00000010H

; 446  :                                             _snprintf(szValue,sizeof(szValue),"0x%.2X",vui1[i]);

  010aa	8b 95 dc 85 ff
	ff		 mov	 edx, DWORD PTR _vui1$137444[ebp+16]
  010b0	2b 95 d8 85 ff
	ff		 sub	 edx, DWORD PTR _vui1$137444[ebp+12]
  010b6	3b fa		 cmp	 edi, edx
  010b8	72 05		 jb	 SHORT $LN309@WMIex
  010ba	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN309@WMIex:
  010bf	8b 85 d8 85 ff
	ff		 mov	 eax, DWORD PTR _vui1$137444[ebp+12]
  010c5	0f b6 0c 07	 movzx	 ecx, BYTE PTR [edi+eax]
  010c9	51		 push	 ecx
  010ca	68 00 00 00 00	 push	 OFFSET ??_C@_06DBMAJEKE@0x?$CF?42X?$AA@
  010cf	68 10 27 00 00	 push	 10000			; 00002710H
  010d4	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  010da	52		 push	 edx
  010db	e8 00 00 00 00	 call	 __snprintf
  010e0	83 c4 10	 add	 esp, 16			; 00000010H

; 447  : 
; 448  :                                             id.assign(idx);

  010e3	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  010e9	50		 push	 eax
  010ea	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  010f0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 449  :                                             value.assign(szValue);

  010f5	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  010fb	51		 push	 ecx
  010fc	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  01102	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 450  :                                             xml->CreateChild(idx,value);

  01107	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0110a	8b cc		 mov	 ecx, esp
  0110c	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216231[ebp], esp
  01112	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  01118	52		 push	 edx
  01119	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0111e	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+12], 37 ; 00000025H
  01122	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01125	8b cc		 mov	 ecx, esp
  01127	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216232[ebp], esp
  0112d	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  01133	50		 push	 eax
  01134	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01139	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+12], 38 ; 00000026H
  0113d	56		 push	 esi
  0113e	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  01141	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 441  :                                     for(unsigned int i=0;i<vui1.size();i++)

  01146	47		 inc	 edi
  01147	e9 1b ff ff ff	 jmp	 $LN794@WMIex
$LN48@WMIex:

; 451  :                                         }
; 452  :                                         else
; 453  :                                         {
; 454  :                                             _snprintf(szValue,sizeof(szValue),"%s.0x%.2X",szValue,vui1[i]);

  0114c	0f b6 0c 07	 movzx	 ecx, BYTE PTR [edi+eax]
  01150	51		 push	 ecx
  01151	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  01157	52		 push	 edx
  01158	68 00 00 00 00	 push	 OFFSET ??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X?$AA@
  0115d	68 10 27 00 00	 push	 10000			; 00002710H
  01162	8b c2		 mov	 eax, edx
  01164	50		 push	 eax
  01165	e8 00 00 00 00	 call	 __snprintf
  0116a	83 c4 14	 add	 esp, 20			; 00000014H

; 441  :                                     for(unsigned int i=0;i<vui1.size();i++)

  0116d	47		 inc	 edi
  0116e	e9 f4 fe ff ff	 jmp	 $LN794@WMIex
$LN49@WMIex:

; 455  :                                         }
; 456  :                                     }
; 457  :                                     vui1.clear();

  01173	8b d9		 mov	 ebx, ecx
  01175	c7 85 4c 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T216928[ebp], 0
  0117f	3b c1		 cmp	 eax, ecx
  01181	76 11		 jbe	 SHORT $LN331@WMIex
  01183	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01188	8b 8d dc 85 ff
	ff		 mov	 ecx, DWORD PTR _vui1$137444[ebp+16]
  0118e	8b 85 d8 85 ff
	ff		 mov	 eax, DWORD PTR _vui1$137444[ebp+12]
$LN331@WMIex:
  01194	8b b5 cc 85 ff
	ff		 mov	 esi, DWORD PTR _vui1$137444[ebp]
  0119a	89 b5 4c 86 ff
	ff		 mov	 DWORD PTR $T216928[ebp], esi
  011a0	8b f8		 mov	 edi, eax
  011a2	c7 85 54 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T216930[ebp], 0
  011ac	3b c1		 cmp	 eax, ecx
  011ae	76 05		 jbe	 SHORT $LN350@WMIex
  011b0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN350@WMIex:
  011b5	8b 85 cc 85 ff
	ff		 mov	 eax, DWORD PTR _vui1$137444[ebp]
  011bb	89 85 54 86 ff
	ff		 mov	 DWORD PTR $T216930[ebp], eax
  011c1	53		 push	 ebx
  011c2	56		 push	 esi
  011c3	57		 push	 edi
  011c4	50		 push	 eax
  011c5	8d 9d cc 84 ff
	ff		 lea	 ebx, DWORD PTR $T216931[ebp]
  011cb	8d b5 cc 85 ff
	ff		 lea	 esi, DWORD PTR _vui1$137444[ebp]
  011d1	e8 00 00 00 00	 call	 ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase

; 458  :                                 }

  011d6	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  011da	8b ce		 mov	 ecx, esi
  011dc	51		 push	 ecx
  011dd	e8 00 00 00 00	 call	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >

; 459  :                                 break;

  011e2	e9 15 0b 00 00	 jmp	 $LN795@WMIex
$LN46@WMIex:

; 460  : 
; 461  :                             case VT_I2:
; 462  :                             case VT_UI2:
; 463  :                                 {
; 464  :                                     vector<USHORT> vui2;

  011e7	8d 95 6c 85 ff
	ff		 lea	 edx, DWORD PTR _vui2$137793[ebp]
  011ed	52		 push	 edx
  011ee	e8 00 00 00 00	 call	 ??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
  011f3	b3 27		 mov	 bl, 39			; 00000027H
  011f5	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl

; 465  :                                     FromVariant(vtProp,vui2);

  011f8	83 ec 10	 sub	 esp, 16			; 00000010H
  011fb	8b c4		 mov	 eax, esp
  011fd	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
  01203	89 08		 mov	 DWORD PTR [eax], ecx
  01205	8b 95 40 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+4]
  0120b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0120e	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  01214	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  01217	8b 95 48 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+12]
  0121d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  01220	8d 85 6c 85 ff
	ff		 lea	 eax, DWORD PTR _vui2$137793[ebp]
  01226	50		 push	 eax
  01227	e8 00 00 00 00	 call	 ??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z ; FromVariant<unsigned short>
  0122c	83 c4 14	 add	 esp, 20			; 00000014H

; 466  :                                     for(unsigned int i=0;i<vui2.size();i++)

  0122f	33 ff		 xor	 edi, edi
$LN796@WMIex:
  01231	89 bd 58 85 ff
	ff		 mov	 DWORD PTR _i$137803[ebp], edi
  01237	8b 8d 7c 85 ff
	ff		 mov	 ecx, DWORD PTR _vui2$137793[ebp+16]
  0123d	8b d1		 mov	 edx, ecx
  0123f	8b 85 78 85 ff
	ff		 mov	 eax, DWORD PTR _vui2$137793[ebp+12]
  01245	2b d0		 sub	 edx, eax
  01247	d1 fa		 sar	 edx, 1
  01249	3b fa		 cmp	 edi, edx
  0124b	0f 83 f0 00 00
	00		 jae	 $LN43@WMIex

; 467  :                                     {
; 468  :                                         if(xml)

  01251	85 f6		 test	 esi, esi
  01253	0f 84 c1 00 00
	00		 je	 $LN42@WMIex

; 469  :                                         {
; 470  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  01259	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0125c	50		 push	 eax
  0125d	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  01262	68 04 01 00 00	 push	 260			; 00000104H
  01267	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  0126d	51		 push	 ecx
  0126e	e8 00 00 00 00	 call	 __snprintf
  01273	83 c4 10	 add	 esp, 16			; 00000010H

; 471  :                                             _snprintf(szValue,sizeof(szValue),"0x%.4X",vui2[i]);

  01276	8b 95 7c 85 ff
	ff		 mov	 edx, DWORD PTR _vui2$137793[ebp+16]
  0127c	2b 95 78 85 ff
	ff		 sub	 edx, DWORD PTR _vui2$137793[ebp+12]
  01282	d1 fa		 sar	 edx, 1
  01284	3b fa		 cmp	 edi, edx
  01286	72 05		 jb	 SHORT $LN367@WMIex
  01288	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN367@WMIex:
  0128d	8b 85 78 85 ff
	ff		 mov	 eax, DWORD PTR _vui2$137793[ebp+12]
  01293	0f b7 0c 78	 movzx	 ecx, WORD PTR [eax+edi*2]
  01297	51		 push	 ecx
  01298	68 00 00 00 00	 push	 OFFSET ??_C@_06DFENOIBG@0x?$CF?44X?$AA@
  0129d	68 10 27 00 00	 push	 10000			; 00002710H
  012a2	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  012a8	52		 push	 edx
  012a9	e8 00 00 00 00	 call	 __snprintf
  012ae	83 c4 10	 add	 esp, 16			; 00000010H

; 472  : 
; 473  :                                             id.assign(idx);

  012b1	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  012b7	50		 push	 eax
  012b8	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  012be	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 474  :                                             value.assign(szValue);

  012c3	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  012c9	51		 push	 ecx
  012ca	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  012d0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 475  :                                             xml->CreateChild(idx,value);

  012d5	83 ec 1c	 sub	 esp, 28			; 0000001cH
  012d8	8b cc		 mov	 ecx, esp
  012da	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216233[ebp], esp
  012e0	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  012e6	52		 push	 edx
  012e7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  012ec	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+12], 40 ; 00000028H
  012f0	83 ec 1c	 sub	 esp, 28			; 0000001cH
  012f3	8b cc		 mov	 ecx, esp
  012f5	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216234[ebp], esp
  012fb	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  01301	50		 push	 eax
  01302	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01307	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+12], 41 ; 00000029H
  0130b	56		 push	 esi
  0130c	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  0130f	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 466  :                                     for(unsigned int i=0;i<vui2.size();i++)

  01314	47		 inc	 edi
  01315	e9 17 ff ff ff	 jmp	 $LN796@WMIex
$LN42@WMIex:

; 476  :                                         }
; 477  :                                         else
; 478  :                                         {
; 479  :                                             _snprintf(szValue,sizeof(szValue),"%s.0x%.4X",szValue,vui2[i]);

  0131a	0f b7 0c 78	 movzx	 ecx, WORD PTR [eax+edi*2]
  0131e	51		 push	 ecx
  0131f	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  01325	52		 push	 edx
  01326	68 00 00 00 00	 push	 OFFSET ??_C@_09MHANBIPO@?$CFs?40x?$CF?44X?$AA@
  0132b	68 10 27 00 00	 push	 10000			; 00002710H
  01330	8b c2		 mov	 eax, edx
  01332	50		 push	 eax
  01333	e8 00 00 00 00	 call	 __snprintf
  01338	83 c4 14	 add	 esp, 20			; 00000014H

; 466  :                                     for(unsigned int i=0;i<vui2.size();i++)

  0133b	47		 inc	 edi
  0133c	e9 f0 fe ff ff	 jmp	 $LN796@WMIex
$LN43@WMIex:

; 480  :                                         }
; 481  :                                     }
; 482  :                                     vui2.clear();

  01341	8b d9		 mov	 ebx, ecx
  01343	c7 85 34 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217171[ebp], 0
  0134d	3b c1		 cmp	 eax, ecx
  0134f	76 11		 jbe	 SHORT $LN389@WMIex
  01351	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01356	8b 8d 7c 85 ff
	ff		 mov	 ecx, DWORD PTR _vui2$137793[ebp+16]
  0135c	8b 85 78 85 ff
	ff		 mov	 eax, DWORD PTR _vui2$137793[ebp+12]
$LN389@WMIex:
  01362	8b b5 6c 85 ff
	ff		 mov	 esi, DWORD PTR _vui2$137793[ebp]
  01368	89 b5 34 86 ff
	ff		 mov	 DWORD PTR $T217171[ebp], esi
  0136e	8b f8		 mov	 edi, eax
  01370	c7 85 d4 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217173[ebp], 0
  0137a	3b c1		 cmp	 eax, ecx
  0137c	76 05		 jbe	 SHORT $LN408@WMIex
  0137e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN408@WMIex:
  01383	8b 85 6c 85 ff
	ff		 mov	 eax, DWORD PTR _vui2$137793[ebp]
  01389	89 85 d4 84 ff
	ff		 mov	 DWORD PTR $T217173[ebp], eax
  0138f	53		 push	 ebx
  01390	56		 push	 esi
  01391	57		 push	 edi
  01392	50		 push	 eax
  01393	8d 9d bc 84 ff
	ff		 lea	 ebx, DWORD PTR $T217174[ebp]
  01399	8d b5 6c 85 ff
	ff		 lea	 esi, DWORD PTR _vui2$137793[ebp]
  0139f	e8 00 00 00 00	 call	 ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 483  :                                 }

  013a4	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  013a8	8b ce		 mov	 ecx, esi
  013aa	51		 push	 ecx
  013ab	e8 00 00 00 00	 call	 ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >

; 484  :                                 break;

  013b0	e9 47 09 00 00	 jmp	 $LN795@WMIex
$LN40@WMIex:

; 485  : 
; 486  :                             case VT_I4:
; 487  :                             case VT_UI4:
; 488  :                                 {
; 489  :                                     vector<ULONG> vui4;

  013b5	8d 95 b4 85 ff
	ff		 lea	 edx, DWORD PTR _vui4$138141[ebp]
  013bb	52		 push	 edx
  013bc	e8 00 00 00 00	 call	 ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
  013c1	b3 2a		 mov	 bl, 42			; 0000002aH
  013c3	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl

; 490  :                                     FromVariant(vtProp,vui4);

  013c6	83 ec 10	 sub	 esp, 16			; 00000010H
  013c9	8b c4		 mov	 eax, esp
  013cb	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
  013d1	89 08		 mov	 DWORD PTR [eax], ecx
  013d3	8b 95 40 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+4]
  013d9	89 50 04	 mov	 DWORD PTR [eax+4], edx
  013dc	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  013e2	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  013e5	8b 95 48 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+12]
  013eb	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  013ee	8d 85 b4 85 ff
	ff		 lea	 eax, DWORD PTR _vui4$138141[ebp]
  013f4	50		 push	 eax
  013f5	e8 00 00 00 00	 call	 ??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z ; FromVariant<unsigned long>
  013fa	83 c4 14	 add	 esp, 20			; 00000014H

; 491  :                                     for(unsigned int i=0;i<vui4.size();i++)

  013fd	33 ff		 xor	 edi, edi
$LN797@WMIex:
  013ff	89 bd 64 85 ff
	ff		 mov	 DWORD PTR _i$138151[ebp], edi
  01405	8b 8d c4 85 ff
	ff		 mov	 ecx, DWORD PTR _vui4$138141[ebp+16]
  0140b	8b d1		 mov	 edx, ecx
  0140d	8b 85 c0 85 ff
	ff		 mov	 eax, DWORD PTR _vui4$138141[ebp+12]
  01413	2b d0		 sub	 edx, eax
  01415	c1 fa 02	 sar	 edx, 2
  01418	3b fa		 cmp	 edi, edx
  0141a	0f 83 ef 00 00
	00		 jae	 $LN37@WMIex

; 492  :                                     {
; 493  :                                         if(xml)

  01420	85 f6		 test	 esi, esi
  01422	0f 84 c1 00 00
	00		 je	 $LN36@WMIex

; 494  :                                         {
; 495  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  01428	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0142b	50		 push	 eax
  0142c	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  01431	68 04 01 00 00	 push	 260			; 00000104H
  01436	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  0143c	51		 push	 ecx
  0143d	e8 00 00 00 00	 call	 __snprintf
  01442	83 c4 10	 add	 esp, 16			; 00000010H

; 496  :                                             _snprintf(szValue,sizeof(szValue),"0x%.8X",vui4[i]);

  01445	8b 95 c4 85 ff
	ff		 mov	 edx, DWORD PTR _vui4$138141[ebp+16]
  0144b	2b 95 c0 85 ff
	ff		 sub	 edx, DWORD PTR _vui4$138141[ebp+12]
  01451	c1 fa 02	 sar	 edx, 2
  01454	3b fa		 cmp	 edi, edx
  01456	72 05		 jb	 SHORT $LN425@WMIex
  01458	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN425@WMIex:
  0145d	8b 85 c0 85 ff
	ff		 mov	 eax, DWORD PTR _vui4$138141[ebp+12]
  01463	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  01466	51		 push	 ecx
  01467	68 00 00 00 00	 push	 OFFSET ??_C@_06DMFHBBHC@0x?$CF?48X?$AA@
  0146c	68 10 27 00 00	 push	 10000			; 00002710H
  01471	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  01477	52		 push	 edx
  01478	e8 00 00 00 00	 call	 __snprintf
  0147d	83 c4 10	 add	 esp, 16			; 00000010H

; 497  : 
; 498  :                                             id.assign(idx);

  01480	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  01486	50		 push	 eax
  01487	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  0148d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 499  :                                             value.assign(szValue);

  01492	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  01498	51		 push	 ecx
  01499	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  0149f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 500  :                                             xml->CreateChild(idx,value);

  014a4	83 ec 1c	 sub	 esp, 28			; 0000001cH
  014a7	8b cc		 mov	 ecx, esp
  014a9	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216235[ebp], esp
  014af	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  014b5	52		 push	 edx
  014b6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  014bb	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+12], 43 ; 0000002bH
  014bf	83 ec 1c	 sub	 esp, 28			; 0000001cH
  014c2	8b cc		 mov	 ecx, esp
  014c4	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216236[ebp], esp
  014ca	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  014d0	50		 push	 eax
  014d1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  014d6	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+12], 44 ; 0000002cH
  014da	56		 push	 esi
  014db	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  014de	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 491  :                                     for(unsigned int i=0;i<vui4.size();i++)

  014e3	47		 inc	 edi
  014e4	e9 16 ff ff ff	 jmp	 $LN797@WMIex
$LN36@WMIex:

; 501  :                                         }
; 502  :                                         else
; 503  :                                         {
; 504  :                                             _snprintf(szValue,sizeof(szValue),"%s.0x%.8X",szValue,vui4[i]);

  014e9	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  014ec	51		 push	 ecx
  014ed	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  014f3	52		 push	 edx
  014f4	68 00 00 00 00	 push	 OFFSET ??_C@_09MOBHOBJK@?$CFs?40x?$CF?48X?$AA@
  014f9	68 10 27 00 00	 push	 10000			; 00002710H
  014fe	8b c2		 mov	 eax, edx
  01500	50		 push	 eax
  01501	e8 00 00 00 00	 call	 __snprintf
  01506	83 c4 14	 add	 esp, 20			; 00000014H

; 491  :                                     for(unsigned int i=0;i<vui4.size();i++)

  01509	47		 inc	 edi
  0150a	e9 f0 fe ff ff	 jmp	 $LN797@WMIex
$LN37@WMIex:

; 505  :                                         }
; 506  :                                     }
; 507  :                                     vui4.clear();

  0150f	8b d9		 mov	 ebx, ecx
  01511	c7 85 f4 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217376[ebp], 0
  0151b	3b c1		 cmp	 eax, ecx
  0151d	76 11		 jbe	 SHORT $LN447@WMIex
  0151f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01524	8b 8d c4 85 ff
	ff		 mov	 ecx, DWORD PTR _vui4$138141[ebp+16]
  0152a	8b 85 c0 85 ff
	ff		 mov	 eax, DWORD PTR _vui4$138141[ebp+12]
$LN447@WMIex:
  01530	8b b5 b4 85 ff
	ff		 mov	 esi, DWORD PTR _vui4$138141[ebp]
  01536	89 b5 f4 84 ff
	ff		 mov	 DWORD PTR $T217376[ebp], esi
  0153c	8b f8		 mov	 edi, eax
  0153e	c7 85 0c 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217378[ebp], 0
  01548	3b c1		 cmp	 eax, ecx
  0154a	76 05		 jbe	 SHORT $LN466@WMIex
  0154c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN466@WMIex:
  01551	8b 85 b4 85 ff
	ff		 mov	 eax, DWORD PTR _vui4$138141[ebp]
  01557	89 85 0c 85 ff
	ff		 mov	 DWORD PTR $T217378[ebp], eax
  0155d	53		 push	 ebx
  0155e	56		 push	 esi
  0155f	57		 push	 edi
  01560	50		 push	 eax
  01561	8d 9d ac 84 ff
	ff		 lea	 ebx, DWORD PTR $T217379[ebp]
  01567	8d b5 b4 85 ff
	ff		 lea	 esi, DWORD PTR _vui4$138141[ebp]
  0156d	e8 00 00 00 00	 call	 ?erase@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@KV?$allocator@K@std@@@2@V?$_Vector_const_iterator@KV?$allocator@K@std@@@2@0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::erase

; 508  :                                 }

  01572	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  01576	8b ce		 mov	 ecx, esi
  01578	51		 push	 ecx
  01579	e8 00 00 00 00	 call	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >

; 509  :                                 break;

  0157e	e9 79 07 00 00	 jmp	 $LN795@WMIex
$LN34@WMIex:

; 510  : 
; 511  :                             case VT_I8:
; 512  :                             case VT_UI8:
; 513  :                                 {
; 514  :                                     vector<ULONGLONG> vui8;

  01583	8d 95 84 85 ff
	ff		 lea	 edx, DWORD PTR _vui8$138489[ebp]
  01589	52		 push	 edx
  0158a	e8 00 00 00 00	 call	 ??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >
  0158f	b3 2d		 mov	 bl, 45			; 0000002dH
  01591	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl

; 515  :                                     FromVariant(vtProp,vui8);

  01594	83 ec 10	 sub	 esp, 16			; 00000010H
  01597	8b c4		 mov	 eax, esp
  01599	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
  0159f	89 08		 mov	 DWORD PTR [eax], ecx
  015a1	8b 95 40 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+4]
  015a7	89 50 04	 mov	 DWORD PTR [eax+4], edx
  015aa	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  015b0	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  015b3	8b 95 48 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+12]
  015b9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  015bc	8d 85 84 85 ff
	ff		 lea	 eax, DWORD PTR _vui8$138489[ebp]
  015c2	50		 push	 eax
  015c3	e8 00 00 00 00	 call	 ??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ; FromVariant<unsigned __int64>
  015c8	83 c4 14	 add	 esp, 20			; 00000014H

; 516  :                                     for(unsigned int i=0;i<vui8.size();i++)

  015cb	33 ff		 xor	 edi, edi
$LN798@WMIex:
  015cd	89 bd 5c 85 ff
	ff		 mov	 DWORD PTR _i$138499[ebp], edi
  015d3	8b 8d 94 85 ff
	ff		 mov	 ecx, DWORD PTR _vui8$138489[ebp+16]
  015d9	8b d1		 mov	 edx, ecx
  015db	8b 85 90 85 ff
	ff		 mov	 eax, DWORD PTR _vui8$138489[ebp+12]
  015e1	2b d0		 sub	 edx, eax
  015e3	c1 fa 03	 sar	 edx, 3
  015e6	3b fa		 cmp	 edi, edx
  015e8	0f 83 fb 00 00
	00		 jae	 $LN31@WMIex

; 517  :                                     {
; 518  :                                         if(xml)

  015ee	85 f6		 test	 esi, esi
  015f0	0f 84 c8 00 00
	00		 je	 $LN30@WMIex

; 519  :                                         {
; 520  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  015f6	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  015f9	50		 push	 eax
  015fa	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  015ff	68 04 01 00 00	 push	 260			; 00000104H
  01604	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  0160a	51		 push	 ecx
  0160b	e8 00 00 00 00	 call	 __snprintf
  01610	83 c4 10	 add	 esp, 16			; 00000010H

; 521  :                                             _snprintf(szValue,sizeof(szValue),"0x%.16X",vui8[i]);

  01613	8b 95 94 85 ff
	ff		 mov	 edx, DWORD PTR _vui8$138489[ebp+16]
  01619	8b 85 90 85 ff
	ff		 mov	 eax, DWORD PTR _vui8$138489[ebp+12]
  0161f	2b d0		 sub	 edx, eax
  01621	c1 fa 03	 sar	 edx, 3
  01624	3b fa		 cmp	 edi, edx
  01626	72 0b		 jb	 SHORT $LN483@WMIex
  01628	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  0162d	8b 85 90 85 ff
	ff		 mov	 eax, DWORD PTR _vui8$138489[ebp+12]
$LN483@WMIex:
  01633	8b 4c f8 04	 mov	 ecx, DWORD PTR [eax+edi*8+4]
  01637	51		 push	 ecx
  01638	8b 14 f8	 mov	 edx, DWORD PTR [eax+edi*8]
  0163b	52		 push	 edx
  0163c	68 00 00 00 00	 push	 OFFSET ??_C@_07PDBEDJPN@0x?$CF?416X?$AA@
  01641	68 10 27 00 00	 push	 10000			; 00002710H
  01646	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  0164c	50		 push	 eax
  0164d	e8 00 00 00 00	 call	 __snprintf
  01652	83 c4 14	 add	 esp, 20			; 00000014H

; 522  : 
; 523  :                                             id.assign(idx);

  01655	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  0165b	51		 push	 ecx
  0165c	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  01662	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 524  :                                             value.assign(szValue);

  01667	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  0166d	52		 push	 edx
  0166e	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  01674	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 525  :                                             xml->CreateChild(idx,value);

  01679	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0167c	8b cc		 mov	 ecx, esp
  0167e	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216237[ebp], esp
  01684	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  0168a	50		 push	 eax
  0168b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01690	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+12], 46 ; 0000002eH
  01694	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01697	8b cc		 mov	 ecx, esp
  01699	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216238[ebp], esp
  0169f	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _idx$137109[ebp]
  016a5	52		 push	 edx
  016a6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  016ab	c6 45 fc 2f	 mov	 BYTE PTR __$EHRec$[ebp+12], 47 ; 0000002fH
  016af	56		 push	 esi
  016b0	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  016b3	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 516  :                                     for(unsigned int i=0;i<vui8.size();i++)

  016b8	47		 inc	 edi
  016b9	e9 0f ff ff ff	 jmp	 $LN798@WMIex
$LN30@WMIex:

; 526  :                                         }
; 527  :                                         else
; 528  :                                         {
; 529  :                                             _snprintf(szValue,sizeof(szValue),"%s.0x%.16X",szValue,vui8[i]);

  016be	8b 4c f8 04	 mov	 ecx, DWORD PTR [eax+edi*8+4]
  016c2	51		 push	 ecx
  016c3	8b 14 f8	 mov	 edx, DWORD PTR [eax+edi*8]
  016c6	52		 push	 edx
  016c7	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  016cd	50		 push	 eax
  016ce	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FNDHBDEH@?$CFs?40x?$CF?416X?$AA@
  016d3	68 10 27 00 00	 push	 10000			; 00002710H
  016d8	8b c8		 mov	 ecx, eax
  016da	51		 push	 ecx
  016db	e8 00 00 00 00	 call	 __snprintf
  016e0	83 c4 18	 add	 esp, 24			; 00000018H

; 516  :                                     for(unsigned int i=0;i<vui8.size();i++)

  016e3	47		 inc	 edi
  016e4	e9 e4 fe ff ff	 jmp	 $LN798@WMIex
$LN31@WMIex:

; 530  :                                         }
; 531  :                                     }
; 532  :                                     vui8.clear();

  016e9	8b d9		 mov	 ebx, ecx
  016eb	c7 85 e4 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217600[ebp], 0
  016f5	3b c1		 cmp	 eax, ecx
  016f7	76 11		 jbe	 SHORT $LN505@WMIex
  016f9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  016fe	8b 8d 94 85 ff
	ff		 mov	 ecx, DWORD PTR _vui8$138489[ebp+16]
  01704	8b 85 90 85 ff
	ff		 mov	 eax, DWORD PTR _vui8$138489[ebp+12]
$LN505@WMIex:
  0170a	8b b5 84 85 ff
	ff		 mov	 esi, DWORD PTR _vui8$138489[ebp]
  01710	89 b5 e4 84 ff
	ff		 mov	 DWORD PTR $T217600[ebp], esi
  01716	8b f8		 mov	 edi, eax
  01718	c7 85 fc 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217602[ebp], 0
  01722	3b c1		 cmp	 eax, ecx
  01724	76 05		 jbe	 SHORT $LN524@WMIex
  01726	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN524@WMIex:
  0172b	8b 85 84 85 ff
	ff		 mov	 eax, DWORD PTR _vui8$138489[ebp]
  01731	89 85 fc 84 ff
	ff		 mov	 DWORD PTR $T217602[ebp], eax
  01737	53		 push	 ebx
  01738	56		 push	 esi
  01739	57		 push	 edi
  0173a	50		 push	 eax
  0173b	8d 9d c4 84 ff
	ff		 lea	 ebx, DWORD PTR $T217603[ebp]
  01741	8d b5 84 85 ff
	ff		 lea	 esi, DWORD PTR _vui8$138489[ebp]
  01747	e8 00 00 00 00	 call	 ?erase@?$vector@_KV?$allocator@_K@std@@@std@@QAE?AV?$_Vector_iterator@_KV?$allocator@_K@std@@@2@V?$_Vector_const_iterator@_KV?$allocator@_K@std@@@2@0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::erase

; 533  :                                 }

  0174c	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  01750	8b d6		 mov	 edx, esi
  01752	52		 push	 edx
  01753	e8 00 00 00 00	 call	 ??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >

; 534  :                                 break;

  01758	e9 9f 05 00 00	 jmp	 $LN795@WMIex
$LN28@WMIex:

; 535  : 
; 536  :                             case VT_R4:
; 537  :                                 {
; 538  :                                     vector<float> vr4;

  0175d	8d 85 e4 85 ff
	ff		 lea	 eax, DWORD PTR _vr4$138837[ebp]
  01763	50		 push	 eax
  01764	e8 00 00 00 00	 call	 ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
  01769	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+12], 48 ; 00000030H

; 539  :                                     FromVariant(vtProp,vr4);

  0176d	83 ec 10	 sub	 esp, 16			; 00000010H
  01770	8b c4		 mov	 eax, esp
  01772	8b 8d 3c 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp]
  01778	89 08		 mov	 DWORD PTR [eax], ecx
  0177a	8b 95 40 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+4]
  01780	89 50 04	 mov	 DWORD PTR [eax+4], edx
  01783	8b 8d 44 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+8]
  01789	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0178c	8b 95 48 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+12]
  01792	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  01795	8d 85 e4 85 ff
	ff		 lea	 eax, DWORD PTR _vr4$138837[ebp]
  0179b	50		 push	 eax
  0179c	e8 00 00 00 00	 call	 ??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z ; FromVariant<float>
  017a1	83 c4 14	 add	 esp, 20			; 00000014H

; 540  :                                     for(unsigned int i=0;i<vr4.size();i++)

  017a4	33 ff		 xor	 edi, edi
$LN799@WMIex:
  017a6	89 bd 54 85 ff
	ff		 mov	 DWORD PTR _i$138847[ebp], edi
  017ac	8b 8d f4 85 ff
	ff		 mov	 ecx, DWORD PTR _vr4$138837[ebp+16]
  017b2	8b d1		 mov	 edx, ecx
  017b4	8b 85 f0 85 ff
	ff		 mov	 eax, DWORD PTR _vr4$138837[ebp+12]
  017ba	2b d0		 sub	 edx, eax
  017bc	c1 fa 02	 sar	 edx, 2
  017bf	3b fa		 cmp	 edi, edx
  017c1	0f 83 fa 00 00
	00		 jae	 $LN25@WMIex

; 541  :                                     {
; 542  :                                         if(xml)

  017c7	85 f6		 test	 esi, esi
  017c9	0f 84 c7 00 00
	00		 je	 $LN24@WMIex

; 543  :                                         {
; 544  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  017cf	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  017d2	50		 push	 eax
  017d3	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  017d8	68 04 01 00 00	 push	 260			; 00000104H
  017dd	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  017e3	51		 push	 ecx
  017e4	e8 00 00 00 00	 call	 __snprintf
  017e9	83 c4 10	 add	 esp, 16			; 00000010H

; 545  :                                             _snprintf(szValue,sizeof(szValue),"%f",vr4[i]);

  017ec	8b 95 f4 85 ff
	ff		 mov	 edx, DWORD PTR _vr4$138837[ebp+16]
  017f2	2b 95 f0 85 ff
	ff		 sub	 edx, DWORD PTR _vr4$138837[ebp+12]
  017f8	c1 fa 02	 sar	 edx, 2
  017fb	3b fa		 cmp	 edi, edx
  017fd	72 05		 jb	 SHORT $LN541@WMIex
  017ff	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN541@WMIex:
  01804	8b 85 f0 85 ff
	ff		 mov	 eax, DWORD PTR _vr4$138837[ebp+12]
  0180a	d9 04 b8	 fld	 DWORD PTR [eax+edi*4]
  0180d	83 ec 08	 sub	 esp, 8
  01810	dd 1c 24	 fstp	 QWORD PTR [esp]
  01813	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
  01818	68 10 27 00 00	 push	 10000			; 00002710H
  0181d	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  01823	51		 push	 ecx
  01824	e8 00 00 00 00	 call	 __snprintf
  01829	83 c4 14	 add	 esp, 20			; 00000014H

; 546  : 
; 547  :                                             id.assign(idx);

  0182c	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _idx$137109[ebp]
  01832	52		 push	 edx
  01833	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  01839	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 548  :                                             value.assign(szValue);

  0183e	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  01844	50		 push	 eax
  01845	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  0184b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 549  :                                             xml->CreateChild(idx,value);

  01850	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01853	8b cc		 mov	 ecx, esp
  01855	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216239[ebp], esp
  0185b	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  01861	52		 push	 edx
  01862	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01867	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+12], 49 ; 00000031H
  0186b	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0186e	8b cc		 mov	 ecx, esp
  01870	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216240[ebp], esp
  01876	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  0187c	50		 push	 eax
  0187d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01882	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+12], 50 ; 00000032H
  01886	56		 push	 esi
  01887	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+12], 48 ; 00000030H
  0188b	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 540  :                                     for(unsigned int i=0;i<vr4.size();i++)

  01890	47		 inc	 edi
  01891	e9 10 ff ff ff	 jmp	 $LN799@WMIex
$LN24@WMIex:

; 550  :                                         }
; 551  :                                         else
; 552  :                                         {
; 553  :                                             _snprintf(szValue,sizeof(szValue),"%s.%f",szValue,vr4[i]);

  01896	d9 04 b8	 fld	 DWORD PTR [eax+edi*4]
  01899	83 ec 08	 sub	 esp, 8
  0189c	dd 1c 24	 fstp	 QWORD PTR [esp]
  0189f	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  018a5	51		 push	 ecx
  018a6	68 00 00 00 00	 push	 OFFSET ??_C@_05OKOCMAOB@?$CFs?4?$CFf?$AA@
  018ab	68 10 27 00 00	 push	 10000			; 00002710H
  018b0	8b d1		 mov	 edx, ecx
  018b2	52		 push	 edx
  018b3	e8 00 00 00 00	 call	 __snprintf
  018b8	83 c4 18	 add	 esp, 24			; 00000018H

; 540  :                                     for(unsigned int i=0;i<vr4.size();i++)

  018bb	47		 inc	 edi
  018bc	e9 e5 fe ff ff	 jmp	 $LN799@WMIex
$LN25@WMIex:

; 554  :                                         }
; 555  :                                     }
; 556  :                                     vr4.clear();

  018c1	8b d9		 mov	 ebx, ecx
  018c3	c7 85 30 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217824[ebp], 0
  018cd	3b c1		 cmp	 eax, ecx
  018cf	76 11		 jbe	 SHORT $LN563@WMIex
  018d1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  018d6	8b 8d f4 85 ff
	ff		 mov	 ecx, DWORD PTR _vr4$138837[ebp+16]
  018dc	8b 85 f0 85 ff
	ff		 mov	 eax, DWORD PTR _vr4$138837[ebp+12]
$LN563@WMIex:
  018e2	8b b5 e4 85 ff
	ff		 mov	 esi, DWORD PTR _vr4$138837[ebp]
  018e8	89 b5 30 85 ff
	ff		 mov	 DWORD PTR $T217824[ebp], esi
  018ee	8b f8		 mov	 edi, eax
  018f0	c7 85 ec 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T217826[ebp], 0
  018fa	3b c1		 cmp	 eax, ecx
  018fc	76 05		 jbe	 SHORT $LN582@WMIex
  018fe	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN582@WMIex:
  01903	8b 85 e4 85 ff
	ff		 mov	 eax, DWORD PTR _vr4$138837[ebp]
  01909	89 85 ec 84 ff
	ff		 mov	 DWORD PTR $T217826[ebp], eax
  0190f	53		 push	 ebx
  01910	56		 push	 esi
  01911	57		 push	 edi
  01912	50		 push	 eax
  01913	8d 9d b4 84 ff
	ff		 lea	 ebx, DWORD PTR $T217827[ebp]
  01919	8d b5 e4 85 ff
	ff		 lea	 esi, DWORD PTR _vr4$138837[ebp]
  0191f	e8 00 00 00 00	 call	 ?erase@?$vector@MV?$allocator@M@std@@@std@@QAE?AV?$_Vector_iterator@MV?$allocator@M@std@@@2@V?$_Vector_const_iterator@MV?$allocator@M@std@@@2@0@Z ; std::vector<float,std::allocator<float> >::erase

; 557  :                                 }

  01924	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  01928	8b c6		 mov	 eax, esi
  0192a	50		 push	 eax
  0192b	e8 00 00 00 00	 call	 ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >

; 558  :                                 break;

  01930	e9 c7 03 00 00	 jmp	 $LN795@WMIex
$LN22@WMIex:

; 559  : 
; 560  :                             case VT_R8:
; 561  :                             case VT_DATE:
; 562  :                                 {
; 563  :                                     vector<double> vr8;

  01935	8d 8d 9c 85 ff
	ff		 lea	 ecx, DWORD PTR _vr8$139185[ebp]
  0193b	51		 push	 ecx
  0193c	e8 00 00 00 00	 call	 ??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
  01941	b3 33		 mov	 bl, 51			; 00000033H
  01943	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl

; 564  :                                     FromVariant(vtProp,vr8);

  01946	83 ec 10	 sub	 esp, 16			; 00000010H
  01949	8b c4		 mov	 eax, esp
  0194b	8b 95 3c 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp]
  01951	89 10		 mov	 DWORD PTR [eax], edx
  01953	8b 8d 40 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+4]
  01959	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0195c	8b 95 44 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+8]
  01962	89 50 08	 mov	 DWORD PTR [eax+8], edx
  01965	8b 8d 48 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+12]
  0196b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0196e	8d 95 9c 85 ff
	ff		 lea	 edx, DWORD PTR _vr8$139185[ebp]
  01974	52		 push	 edx
  01975	e8 00 00 00 00	 call	 ??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z ; FromVariant<double>
  0197a	83 c4 14	 add	 esp, 20			; 00000014H

; 565  :                                     for(unsigned int i=0;i<vr8.size();i++)

  0197d	33 ff		 xor	 edi, edi
$LN800@WMIex:
  0197f	89 bd 68 85 ff
	ff		 mov	 DWORD PTR _i$139195[ebp], edi
  01985	8b 8d ac 85 ff
	ff		 mov	 ecx, DWORD PTR _vr8$139185[ebp+16]
  0198b	8b d1		 mov	 edx, ecx
  0198d	8b 85 a8 85 ff
	ff		 mov	 eax, DWORD PTR _vr8$139185[ebp+12]
  01993	2b d0		 sub	 edx, eax
  01995	c1 fa 03	 sar	 edx, 3
  01998	3b fa		 cmp	 edi, edx
  0199a	0f 83 f9 00 00
	00		 jae	 $LN19@WMIex

; 566  :                                     {
; 567  :                                         if(xml)

  019a0	85 f6		 test	 esi, esi
  019a2	0f 84 c6 00 00
	00		 je	 $LN18@WMIex

; 568  :                                         {
; 569  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  019a8	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  019ab	50		 push	 eax
  019ac	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  019b1	68 04 01 00 00	 push	 260			; 00000104H
  019b6	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  019bc	51		 push	 ecx
  019bd	e8 00 00 00 00	 call	 __snprintf
  019c2	83 c4 10	 add	 esp, 16			; 00000010H

; 570  :                                             _snprintf(szValue,sizeof(szValue),"%e",vr8[i]);

  019c5	8b 95 ac 85 ff
	ff		 mov	 edx, DWORD PTR _vr8$139185[ebp+16]
  019cb	2b 95 a8 85 ff
	ff		 sub	 edx, DWORD PTR _vr8$139185[ebp+12]
  019d1	c1 fa 03	 sar	 edx, 3
  019d4	3b fa		 cmp	 edi, edx
  019d6	72 05		 jb	 SHORT $LN599@WMIex
  019d8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN599@WMIex:
  019dd	83 ec 08	 sub	 esp, 8
  019e0	8b 85 a8 85 ff
	ff		 mov	 eax, DWORD PTR _vr8$139185[ebp+12]
  019e6	dd 04 f8	 fld	 QWORD PTR [eax+edi*8]
  019e9	dd 1c 24	 fstp	 QWORD PTR [esp]
  019ec	68 00 00 00 00	 push	 OFFSET ??_C@_02CGLCDNAE@?$CFe?$AA@
  019f1	68 10 27 00 00	 push	 10000			; 00002710H
  019f6	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  019fc	51		 push	 ecx
  019fd	e8 00 00 00 00	 call	 __snprintf
  01a02	83 c4 14	 add	 esp, 20			; 00000014H

; 571  : 
; 572  :                                             id.assign(idx);

  01a05	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _idx$137109[ebp]
  01a0b	52		 push	 edx
  01a0c	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  01a12	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 573  :                                             value.assign(szValue);

  01a17	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  01a1d	50		 push	 eax
  01a1e	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  01a24	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 574  :                                             xml->CreateChild(idx,value);

  01a29	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01a2c	8b cc		 mov	 ecx, esp
  01a2e	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216241[ebp], esp
  01a34	8d 95 78 86 ff
	ff		 lea	 edx, DWORD PTR _value$137009[ebp]
  01a3a	52		 push	 edx
  01a3b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01a40	c6 45 fc 34	 mov	 BYTE PTR __$EHRec$[ebp+12], 52 ; 00000034H
  01a44	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01a47	8b cc		 mov	 ecx, esp
  01a49	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216242[ebp], esp
  01a4f	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  01a55	50		 push	 eax
  01a56	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01a5b	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+12], 53 ; 00000035H
  01a5f	56		 push	 esi
  01a60	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  01a63	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 565  :                                     for(unsigned int i=0;i<vr8.size();i++)

  01a68	47		 inc	 edi
  01a69	e9 11 ff ff ff	 jmp	 $LN800@WMIex
$LN18@WMIex:

; 575  :                                         }
; 576  :                                         else
; 577  :                                         {
; 578  :                                             _snprintf(szValue,sizeof(szValue),"%s.%e",szValue,vr8[i]);

  01a6e	83 ec 08	 sub	 esp, 8
  01a71	dd 04 f8	 fld	 QWORD PTR [eax+edi*8]
  01a74	dd 1c 24	 fstp	 QWORD PTR [esp]
  01a77	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  01a7d	51		 push	 ecx
  01a7e	68 00 00 00 00	 push	 OFFSET ??_C@_05MBMPJDCC@?$CFs?4?$CFe?$AA@
  01a83	68 10 27 00 00	 push	 10000			; 00002710H
  01a88	8b d1		 mov	 edx, ecx
  01a8a	52		 push	 edx
  01a8b	e8 00 00 00 00	 call	 __snprintf
  01a90	83 c4 18	 add	 esp, 24			; 00000018H

; 565  :                                     for(unsigned int i=0;i<vr8.size();i++)

  01a93	47		 inc	 edi
  01a94	e9 e6 fe ff ff	 jmp	 $LN800@WMIex
$LN19@WMIex:

; 579  :                                         }
; 580  :                                     }
; 581  :                                     vr8.clear();

  01a99	8b d9		 mov	 ebx, ecx
  01a9b	c7 85 dc 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T218048[ebp], 0
  01aa5	3b c1		 cmp	 eax, ecx
  01aa7	76 11		 jbe	 SHORT $LN621@WMIex
  01aa9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01aae	8b 8d ac 85 ff
	ff		 mov	 ecx, DWORD PTR _vr8$139185[ebp+16]
  01ab4	8b 85 a8 85 ff
	ff		 mov	 eax, DWORD PTR _vr8$139185[ebp+12]
$LN621@WMIex:
  01aba	8b b5 9c 85 ff
	ff		 mov	 esi, DWORD PTR _vr8$139185[ebp]
  01ac0	89 b5 dc 84 ff
	ff		 mov	 DWORD PTR $T218048[ebp], esi
  01ac6	8b f8		 mov	 edi, eax
  01ac8	c7 85 28 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T218050[ebp], 0
  01ad2	3b c1		 cmp	 eax, ecx
  01ad4	76 05		 jbe	 SHORT $LN640@WMIex
  01ad6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN640@WMIex:
  01adb	8b 85 9c 85 ff
	ff		 mov	 eax, DWORD PTR _vr8$139185[ebp]
  01ae1	89 85 28 85 ff
	ff		 mov	 DWORD PTR $T218050[ebp], eax
  01ae7	53		 push	 ebx
  01ae8	56		 push	 esi
  01ae9	57		 push	 edi
  01aea	50		 push	 eax
  01aeb	8d 9d a4 84 ff
	ff		 lea	 ebx, DWORD PTR $T218051[ebp]
  01af1	8d b5 9c 85 ff
	ff		 lea	 esi, DWORD PTR _vr8$139185[ebp]
  01af7	e8 00 00 00 00	 call	 ?erase@?$vector@NV?$allocator@N@std@@@std@@QAE?AV?$_Vector_iterator@NV?$allocator@N@std@@@2@V?$_Vector_const_iterator@NV?$allocator@N@std@@@2@0@Z ; std::vector<double,std::allocator<double> >::erase

; 582  :                                 }

  01afc	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  01b00	8b c6		 mov	 eax, esi
  01b02	50		 push	 eax
  01b03	e8 00 00 00 00	 call	 ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >

; 583  :                                 break;

  01b08	e9 ef 01 00 00	 jmp	 $LN795@WMIex
$LN16@WMIex:

; 584  : 
; 585  :                             case VT_BSTR:
; 586  :                                 {
; 587  :                                     vector<BSTR> vbstr;

  01b0d	8d 8d 38 85 ff
	ff		 lea	 ecx, DWORD PTR _vbstr$139533[ebp]
  01b13	51		 push	 ecx
  01b14	e8 00 00 00 00	 call	 ??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >
  01b19	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+12], 54 ; 00000036H

; 588  :                                     FromVariant(vtProp,vbstr);

  01b1d	83 ec 10	 sub	 esp, 16			; 00000010H
  01b20	8b c4		 mov	 eax, esp
  01b22	8b 95 3c 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp]
  01b28	89 10		 mov	 DWORD PTR [eax], edx
  01b2a	8b 8d 40 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+4]
  01b30	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01b33	8b 95 44 86 ff
	ff		 mov	 edx, DWORD PTR _vtProp$137000[ebp+8]
  01b39	89 50 08	 mov	 DWORD PTR [eax+8], edx
  01b3c	8b 8d 48 86 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$137000[ebp+12]
  01b42	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01b45	8d 95 38 85 ff
	ff		 lea	 edx, DWORD PTR _vbstr$139533[ebp]
  01b4b	52		 push	 edx
  01b4c	e8 00 00 00 00	 call	 ??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ; FromVariant<wchar_t *>
  01b51	83 c4 14	 add	 esp, 20			; 00000014H

; 589  : 
; 590  :                                     Log(LOG_MESSAGE,__LINE__,"%s, %d:",wmiClasses[x].pProperty,vbstr.size());

  01b54	8b 85 48 85 ff
	ff		 mov	 eax, DWORD PTR _vbstr$139533[ebp+16]
  01b5a	2b 85 44 85 ff
	ff		 sub	 eax, DWORD PTR _vbstr$139533[ebp+12]
  01b60	c1 f8 02	 sar	 eax, 2
  01b63	50		 push	 eax
  01b64	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR tv3356[ebp]
  01b6a	8b 11		 mov	 edx, DWORD PTR [ecx]
  01b6c	52		 push	 edx
  01b6d	68 00 00 00 00	 push	 OFFSET ??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3?$AA@
  01b72	68 4e 02 00 00	 push	 590			; 0000024eH
  01b77	6a 01		 push	 1
  01b79	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01b7e	83 c4 14	 add	 esp, 20			; 00000014H

; 591  :                                     for(unsigned int i=0;i<vbstr.size();i++)

  01b81	33 ff		 xor	 edi, edi
  01b83	89 bd 50 85 ff
	ff		 mov	 DWORD PTR _i$139544[ebp], edi
  01b89	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__WideCharToMultiByte@32
  01b8f	90		 npad	 1
$LL15@WMIex:
  01b90	8b 8d 48 85 ff
	ff		 mov	 ecx, DWORD PTR _vbstr$139533[ebp+16]
  01b96	8b d1		 mov	 edx, ecx
  01b98	8b 85 44 85 ff
	ff		 mov	 eax, DWORD PTR _vbstr$139533[ebp+12]
  01b9e	2b d0		 sub	 edx, eax
  01ba0	c1 fa 02	 sar	 edx, 2
  01ba3	3b fa		 cmp	 edi, edx
  01ba5	0f 83 e2 00 00
	00		 jae	 $LN13@WMIex

; 592  :                                     {
; 593  :                                         WideCharToMultiByte(CP_ACP,0,(LPCWSTR)vbstr[i],-1,(LPSTR)szValue,sizeof(szValue),NULL,NULL);

  01bab	6a 00		 push	 0
  01bad	6a 00		 push	 0
  01baf	68 10 27 00 00	 push	 10000			; 00002710H
  01bb4	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  01bba	51		 push	 ecx
  01bbb	6a ff		 push	 -1
  01bbd	8b 14 b8	 mov	 edx, DWORD PTR [eax+edi*4]
  01bc0	52		 push	 edx
  01bc1	6a 00		 push	 0
  01bc3	6a 00		 push	 0
  01bc5	ff d3		 call	 ebx

; 595  :                                         {
; 596  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  01bc7	47		 inc	 edi

; 594  :                                         if(xml)

  01bc8	85 f6		 test	 esi, esi
  01bca	0f 84 80 00 00
	00		 je	 $LN12@WMIex

; 595  :                                         {
; 596  :                                             _snprintf(idx,sizeof(idx),"%.3u",i+1);

  01bd0	57		 push	 edi
  01bd1	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u?$AA@
  01bd6	68 04 01 00 00	 push	 260			; 00000104H
  01bdb	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _idx$137109[ebp]
  01be1	50		 push	 eax
  01be2	e8 00 00 00 00	 call	 __snprintf
  01be7	83 c4 10	 add	 esp, 16			; 00000010H

; 597  : 
; 598  :                                             id.assign(idx);

  01bea	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _idx$137109[ebp]
  01bf0	51		 push	 ecx
  01bf1	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  01bf7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 599  :                                             value.assign(szValue);

  01bfc	8d 95 b4 d4 ff
	ff		 lea	 edx, DWORD PTR _szValue$137002[ebp]
  01c02	52		 push	 edx
  01c03	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  01c09	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 600  :                                             xml->CreateChild(idx,value);

  01c0e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01c11	8b cc		 mov	 ecx, esp
  01c13	89 a5 50 86 ff
	ff		 mov	 DWORD PTR $T216243[ebp], esp
  01c19	8d 85 78 86 ff
	ff		 lea	 eax, DWORD PTR _value$137009[ebp]
  01c1f	50		 push	 eax
  01c20	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c25	c6 45 fc 37	 mov	 BYTE PTR __$EHRec$[ebp+12], 55 ; 00000037H
  01c29	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01c2c	8b cc		 mov	 ecx, esp
  01c2e	89 a5 58 86 ff
	ff		 mov	 DWORD PTR $T216244[ebp], esp
  01c34	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _idx$137109[ebp]
  01c3a	52		 push	 edx
  01c3b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c40	c6 45 fc 38	 mov	 BYTE PTR __$EHRec$[ebp+12], 56 ; 00000038H
  01c44	56		 push	 esi
  01c45	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+12], 54 ; 00000036H
  01c49	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild

; 601  :                                         }
; 602  :                                         else

  01c4e	eb 1c		 jmp	 SHORT $LN11@WMIex
$LN12@WMIex:

; 603  :                                         {
; 604  :                                             Log(LOG_MESSAGE,__LINE__,"\t> %.3d %s",i+1,szValue);

  01c50	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  01c56	50		 push	 eax
  01c57	57		 push	 edi
  01c58	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs?$AA@
  01c5d	68 5c 02 00 00	 push	 604			; 0000025cH
  01c62	6a 01		 push	 1
  01c64	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01c69	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@WMIex:

; 605  :                                         }
; 606  :                                         memset(szValue,0x00,sizeof(szValue));

  01c6c	68 10 27 00 00	 push	 10000			; 00002710H
  01c71	6a 00		 push	 0
  01c73	8d 8d b4 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$137002[ebp]
  01c79	51		 push	 ecx
  01c7a	e8 00 00 00 00	 call	 _memset
  01c7f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 591  :                                     for(unsigned int i=0;i<vbstr.size();i++)

  01c82	89 bd 50 85 ff
	ff		 mov	 DWORD PTR _i$139544[ebp], edi
  01c88	e9 03 ff ff ff	 jmp	 $LL15@WMIex
$LN13@WMIex:

; 607  :                                     }
; 608  :                                     vbstr.clear();

  01c8d	8b d9		 mov	 ebx, ecx
  01c8f	c7 85 14 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T218303[ebp], 0
  01c99	3b c1		 cmp	 eax, ecx
  01c9b	76 11		 jbe	 SHORT $LN673@WMIex
  01c9d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01ca2	8b 8d 48 85 ff
	ff		 mov	 ecx, DWORD PTR _vbstr$139533[ebp+16]
  01ca8	8b 85 44 85 ff
	ff		 mov	 eax, DWORD PTR _vbstr$139533[ebp+12]
$LN673@WMIex:
  01cae	8b b5 38 85 ff
	ff		 mov	 esi, DWORD PTR _vbstr$139533[ebp]
  01cb4	89 b5 14 85 ff
	ff		 mov	 DWORD PTR $T218303[ebp], esi
  01cba	8b f8		 mov	 edi, eax
  01cbc	c7 85 04 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T218260[ebp], 0
  01cc6	3b c1		 cmp	 eax, ecx
  01cc8	76 05		 jbe	 SHORT $LN692@WMIex
  01cca	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN692@WMIex:
  01ccf	8b 85 38 85 ff
	ff		 mov	 eax, DWORD PTR _vbstr$139533[ebp]
  01cd5	89 85 04 85 ff
	ff		 mov	 DWORD PTR $T218260[ebp], eax
  01cdb	53		 push	 ebx
  01cdc	56		 push	 esi
  01cdd	57		 push	 edi
  01cde	50		 push	 eax
  01cdf	8d 9d 1c 85 ff
	ff		 lea	 ebx, DWORD PTR $T218261[ebp]
  01ce5	8d b5 38 85 ff
	ff		 lea	 esi, DWORD PTR _vbstr$139533[ebp]
  01ceb	e8 00 00 00 00	 call	 ?erase@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE?AV?$_Vector_iterator@PA_WV?$allocator@PA_W@std@@@2@V?$_Vector_const_iterator@PA_WV?$allocator@PA_W@std@@@2@0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::erase

; 609  :                                 }

  01cf0	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  01cf4	8b d6		 mov	 edx, esi
  01cf6	52		 push	 edx
  01cf7	e8 00 00 00 00	 call	 ??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
$LN795@WMIex:
  01cfc	8b b5 30 86 ff
	ff		 mov	 esi, DWORD PTR _xml$GSCopy$[ebp]
  01d02	b3 07		 mov	 bl, 7
$LN53@WMIex:

; 610  :                                 break;
; 611  :                             }
; 612  :                             if(xml)

  01d04	85 f6		 test	 esi, esi
  01d06	74 09		 je	 SHORT $LN10@WMIex

; 613  :                             {
; 614  :                                 xml->CloseLasttag();

  01d08	8b c6		 mov	 eax, esi
  01d0a	e8 00 00 00 00	 call	 ?CloseLasttag@xmlwriter@@QAEXXZ ; xmlwriter::CloseLasttag

; 615  :                             }
; 616  :                             else

  01d0f	eb 43		 jmp	 SHORT $LN8@WMIex
$LN10@WMIex:

; 617  :                             {
; 618  :                                 if(strlen(szValue)>0)

  01d11	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  01d17	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01d1a	8d 9b 00 00 00
	00		 npad	 6
$LL784@WMIex:
  01d20	8a 08		 mov	 cl, BYTE PTR [eax]
  01d22	40		 inc	 eax
  01d23	84 c9		 test	 cl, cl
  01d25	75 f9		 jne	 SHORT $LL784@WMIex
  01d27	2b c2		 sub	 eax, edx
  01d29	74 29		 je	 SHORT $LN8@WMIex

; 619  :                                 {
; 620  :                                     Log(LOG_MESSAGE,__LINE__,"%s = %d",wmiClasses[x].pProperty,szValue);

  01d2b	8d 85 b4 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$137002[ebp]
  01d31	50		 push	 eax
  01d32	8b 8d 2c 86 ff
	ff		 mov	 ecx, DWORD PTR _x$136995[ebp]
  01d38	8b 14 cd 04 00
	00 00		 mov	 edx, DWORD PTR _wmiClasses[ecx*8+4]
  01d3f	52		 push	 edx
  01d40	68 00 00 00 00	 push	 OFFSET ??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd?$AA@
  01d45	68 6c 02 00 00	 push	 620			; 0000026cH
  01d4a	6a 01		 push	 1
  01d4c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01d51	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@WMIex:

; 621  :                                 }
; 622  :                             }
; 623  :                         }   //END: if(vtProp.vt & VT_BYREF)

  01d54	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  01d57	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  01d5d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN56@WMIex:

; 624  :                         break;
; 625  :                     }   //END: switch(vtProp.vt)
; 626  : 
; 627  :                     VariantClear(&vtProp);

  01d62	8d 85 3c 86 ff
	ff		 lea	 eax, DWORD PTR _vtProp$137000[ebp]
  01d68	50		 push	 eax
  01d69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 628  :                 }   //END: try

  01d6f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  01d73	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  01d79	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 629  :                 catch(...)

  01d7e	9b		 fwait
  01d7f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 212  :             {
; 213  :                 break;
; 214  :             }
; 215  : 
; 216  :             //line.clear();
; 217  :             for(int x=0;wmiClasses[x].pClass!=NULL && _thGetInt(&gbTerminate)==FALSE;x++)

  01d86	ff 85 2c 86 ff
	ff		 inc	 DWORD PTR _x$136995[ebp]
  01d8c	8b bd 2c 86 ff
	ff		 mov	 edi, DWORD PTR _x$136995[ebp]
  01d92	e9 89 e7 ff ff	 jmp	 $LL105@WMIex
__catch$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$0:

; 630  :                 {
; 631  :                     Log(LOG_DEBUG_WMI,__LINE__,"-- WMI, Catch unhndld excpetion on %.5u %s (%i) %s",properties,wmiClasses[x].pClass,x+1,wmiClasses[x].pProperty);

  01d97	8b 85 2c 86 ff
	ff		 mov	 eax, DWORD PTR _x$136995[ebp]
  01d9d	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _wmiClasses[eax*8+4]
  01da4	51		 push	 ecx
  01da5	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  01da8	52		 push	 edx
  01da9	8b 04 c5 00 00
	00 00		 mov	 eax, DWORD PTR _wmiClasses[eax*8]
  01db0	50		 push	 eax
  01db1	8b 8d 20 86 ff
	ff		 mov	 ecx, DWORD PTR _properties$[ebp]
  01db7	51		 push	 ecx
  01db8	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion?5@
  01dbd	68 77 02 00 00	 push	 631			; 00000277H
  01dc2	6a 40		 push	 64			; 00000040H
  01dc4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01dc9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 632  :                 }

  01dcc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  01dd3	b8 00 00 00 00	 mov	 eax, $LN785@WMIex
  01dd8	c3		 ret	 0
$LN785@WMIex:
  01dd9	8b b5 30 86 ff
	ff		 mov	 esi, DWORD PTR _xml$GSCopy$[ebp]
$LN104@WMIex:

; 212  :             {
; 213  :                 break;
; 214  :             }
; 215  : 
; 216  :             //line.clear();
; 217  :             for(int x=0;wmiClasses[x].pClass!=NULL && _thGetInt(&gbTerminate)==FALSE;x++)

  01ddf	ff 85 2c 86 ff
	ff		 inc	 DWORD PTR _x$136995[ebp]
  01de5	8b bd 2c 86 ff
	ff		 mov	 edi, DWORD PTR _x$136995[ebp]
  01deb	e9 30 e7 ff ff	 jmp	 $LL105@WMIex
$LN103@WMIex:

; 633  :             }
; 634  :             pclsObj->Release();

  01df0	8b 85 28 86 ff
	ff		 mov	 eax, DWORD PTR _pclsObj$136989[ebp]
  01df6	8b 10		 mov	 edx, DWORD PTR [eax]
  01df8	50		 push	 eax
  01df9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01dfc	ff d0		 call	 eax

; 635  :         }   //END: while (pEnumerator)

  01dfe	e9 cd e6 ff ff	 jmp	 $LL108@WMIex
$LN6@WMIex:

; 649  :     {
; 650  :         _snprintf(processed,sizeof(processed),"%u properties processed",properties);

  01e03	57		 push	 edi
  01e04	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@GPOLMEPO@?$CFu?5properties?5processed?$AA@
  01e09	68 04 01 00 00	 push	 260			; 00000104H
  01e0e	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR _processed$[ebp]
  01e14	50		 push	 eax
  01e15	e8 00 00 00 00	 call	 __snprintf
  01e1a	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@WMIex:

; 651  :     }
; 652  :     if(xml)

  01e1d	85 f6		 test	 esi, esi
  01e1f	74 6e		 je	 SHORT $LN4@WMIex

; 653  :     {
; 654  :         string temp;

  01e21	c7 85 74 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _temp$139567[ebp+24], 15 ; 0000000fH
  01e2b	c7 85 70 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$139567[ebp+20], 0
  01e35	c6 85 60 86 ff
	ff 00		 mov	 BYTE PTR _temp$139567[ebp+4], 0
  01e3c	bb 3a 00 00 00	 mov	 ebx, 58			; 0000003aH
  01e41	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 655  :         temp.append(processed);

  01e44	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _temp$139567[ebp]
  01e4a	51		 push	 ecx
  01e4b	8d 95 cc fc ff
	ff		 lea	 edx, DWORD PTR _processed$[ebp]
  01e51	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 656  :         xml->AddComment(temp);

  01e56	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01e59	8b cc		 mov	 ecx, esp
  01e5b	89 a5 24 86 ff
	ff		 mov	 DWORD PTR $T216245[ebp], esp
  01e61	8d 95 5c 86 ff
	ff		 lea	 edx, DWORD PTR _temp$139567[ebp]
  01e67	52		 push	 edx
  01e68	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e6d	c6 45 fc 3b	 mov	 BYTE PTR __$EHRec$[ebp+12], 59 ; 0000003bH
  01e71	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  01e74	8b ce		 mov	 ecx, esi
  01e76	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 657  :     }

  01e7b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  01e82	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _temp$139567[ebp]
  01e88	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 658  :     else

  01e8d	eb 16		 jmp	 SHORT $LN3@WMIex
$LN4@WMIex:

; 659  :     {
; 660  :         Log(LOG_MESSAGE,__LINE__,processed);

  01e8f	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR _processed$[ebp]
  01e95	50		 push	 eax
  01e96	68 94 02 00 00	 push	 660			; 00000294H
  01e9b	6a 01		 push	 1
  01e9d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01ea2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@WMIex:

; 661  :     }
; 662  : 
; 663  :     // Cleanup
; 664  :     // ========
; 665  : 
; 666  :     pSvc->Release();

  01ea5	8b 85 18 86 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  01eab	8b 08		 mov	 ecx, DWORD PTR [eax]
  01ead	50		 push	 eax
  01eae	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01eb1	ff d2		 call	 edx

; 667  :     pLoc->Release();     

  01eb3	8b 85 1c 86 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  01eb9	8b 08		 mov	 ecx, DWORD PTR [eax]
  01ebb	50		 push	 eax
  01ebc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  01ebf	ff d2		 call	 edx

; 668  :     CoUninitialize();

  01ec1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 669  :     if(xml)

  01ec7	85 f6		 test	 esi, esi
  01ec9	0f 84 26 01 00
	00		 je	 $LN2@WMIex

; 670  :     {
; 671  :         string temp;

  01ecf	c7 85 74 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _temp$139571[ebp+24], 15 ; 0000000fH
  01ed9	c7 85 70 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$139571[ebp+20], 0
  01ee3	c6 85 60 86 ff
	ff 00		 mov	 BYTE PTR _temp$139571[ebp+4], 0
  01eea	bb 3c 00 00 00	 mov	 ebx, 60			; 0000003cH
  01eef	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx

; 672  :         char elapsedTime[_MAX_PATH] = {0};

  01ef2	c6 85 dc fe ff
	ff 00		 mov	 BYTE PTR _elapsedTime$139572[ebp], 0
  01ef9	68 03 01 00 00	 push	 259			; 00000103H
  01efe	6a 00		 push	 0
  01f00	8d 85 dd fe ff
	ff		 lea	 eax, DWORD PTR _elapsedTime$139572[ebp+1]
  01f06	50		 push	 eax
  01f07	e8 00 00 00 00	 call	 _memset
  01f0c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 673  :         unsigned __int64 tickEnd;
; 674  :         float timeElapsed;
; 675  :         unsigned long seconds;
; 676  :         CalcElapsedTime(tickStart,tickEnd,timeElapsed,seconds);

  01f0f	8d 8d 24 86 ff
	ff		 lea	 ecx, DWORD PTR _seconds$139575[ebp]
  01f15	51		 push	 ecx
  01f16	8d 95 50 86 ff
	ff		 lea	 edx, DWORD PTR _timeElapsed$139574[ebp]
  01f1c	52		 push	 edx
  01f1d	8b 85 00 86 ff
	ff		 mov	 eax, DWORD PTR _tickStart$[ebp+4]
  01f23	50		 push	 eax
  01f24	8b 8d fc 85 ff
	ff		 mov	 ecx, DWORD PTR _tickStart$[ebp]
  01f2a	51		 push	 ecx
  01f2b	8d b5 1c 85 ff
	ff		 lea	 esi, DWORD PTR _tickEnd$139573[ebp]
  01f31	e8 00 00 00 00	 call	 ?CalcElapsedTime@@YAX_KAA_KAAMAAK@Z ; CalcElapsedTime

; 677  : 
; 678  :         _snprintf(elapsedTime,sizeof(elapsedTime),"Elapsed Time: %02d:%02d:%02d, %f s",seconds/3600,(seconds % 3600)/60,seconds % 60,timeElapsed);

  01f36	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  01f3b	8b 8d 24 86 ff
	ff		 mov	 ecx, DWORD PTR _seconds$139575[ebp]
  01f41	f7 e1		 mul	 ecx
  01f43	8b f2		 mov	 esi, edx
  01f45	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  01f48	d9 85 50 86 ff
	ff		 fld	 DWORD PTR _timeElapsed$139574[ebp]
  01f4e	83 c4 08	 add	 esp, 8
  01f51	dd 1c 24	 fstp	 QWORD PTR [esp]
  01f54	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  01f59	f7 e1		 mul	 ecx
  01f5b	c1 ea 05	 shr	 edx, 5
  01f5e	8b c2		 mov	 eax, edx
  01f60	c1 e0 04	 shl	 eax, 4
  01f63	2b c2		 sub	 eax, edx
  01f65	03 c0		 add	 eax, eax
  01f67	03 c0		 add	 eax, eax
  01f69	8b d1		 mov	 edx, ecx
  01f6b	2b d0		 sub	 edx, eax
  01f6d	52		 push	 edx
  01f6e	8b c6		 mov	 eax, esi
  01f70	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  01f76	2b c8		 sub	 ecx, eax
  01f78	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  01f7d	f7 e1		 mul	 ecx
  01f7f	c1 ea 05	 shr	 edx, 5
  01f82	52		 push	 edx
  01f83	56		 push	 esi
  01f84	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BNKPFHB@Elapsed?5Time?3?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@
  01f89	68 04 01 00 00	 push	 260			; 00000104H
  01f8e	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _elapsedTime$139572[ebp]
  01f94	51		 push	 ecx
  01f95	e8 00 00 00 00	 call	 __snprintf
  01f9a	83 c4 20	 add	 esp, 32			; 00000020H

; 679  :         temp.assign(elapsedTime);

  01f9d	8d 95 dc fe ff
	ff		 lea	 edx, DWORD PTR _elapsedTime$139572[ebp]
  01fa3	52		 push	 edx
  01fa4	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _temp$139571[ebp]
  01faa	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 680  : 
; 681  :         xml->AddComment(temp);

  01faf	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01fb2	8b cc		 mov	 ecx, esp
  01fb4	89 a5 24 86 ff
	ff		 mov	 DWORD PTR $T216246[ebp], esp
  01fba	8d 85 5c 86 ff
	ff		 lea	 eax, DWORD PTR _temp$139571[ebp]
  01fc0	50		 push	 eax
  01fc1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01fc6	c6 45 fc 3d	 mov	 BYTE PTR __$EHRec$[ebp+12], 61 ; 0000003dH
  01fca	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  01fcd	8b b5 30 86 ff
	ff		 mov	 esi, DWORD PTR _xml$GSCopy$[ebp]
  01fd3	8b ce		 mov	 ecx, esi
  01fd5	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 682  :         xml->CloseLasttag();

  01fda	8b c6		 mov	 eax, esi
  01fdc	e8 00 00 00 00	 call	 ?CloseLasttag@xmlwriter@@QAEXXZ ; xmlwriter::CloseLasttag

; 683  :     }

  01fe1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  01fe8	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _temp$139571[ebp]
  01fee	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 684  :     else

  01ff3	eb 1d		 jmp	 SHORT $LN1@WMIex
$LN2@WMIex:

; 685  :     {
; 686  :         LogElapsedTime(__LINE__,tickStart);

  01ff5	8b 8d 00 86 ff
	ff		 mov	 ecx, DWORD PTR _tickStart$[ebp+4]
  01ffb	51		 push	 ecx
  01ffc	8b 95 fc 85 ff
	ff		 mov	 edx, DWORD PTR _tickStart$[ebp]
  02002	52		 push	 edx
  02003	33 db		 xor	 ebx, ebx
  02005	bf ae 02 00 00	 mov	 edi, 686		; 000002aeH
  0200a	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPAD@Z ; LogElapsedTime
  0200f	83 c4 08	 add	 esp, 8
$LN1@WMIex:

; 687  :     }
; 688  :     ReleaseMutex(hWmiMutex);

  02012	8b b5 08 86 ff
	ff		 mov	 esi, DWORD PTR _hWmiMutex$[ebp]
  02018	56		 push	 esi
  02019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 689  :     CloseHandle(hWmiMutex);

  0201f	56		 push	 esi
  02020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 690  : 
; 691  :     Log(LOG_DEBUG_WMI,__LINE__,"<< WMI, ret True");

  02026	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True?$AA@
  0202b	68 b3 02 00 00	 push	 691			; 000002b3H
  02030	6a 40		 push	 64			; 00000040H
$LN793@WMIex:
  02032	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  02037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN792@WMIex:

; 692  :     return true;

  0203a	b0 01		 mov	 al, 1
$LN121@WMIex:

; 693  : }

  0203c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0203f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  02046	59		 pop	 ecx
  02047	5f		 pop	 edi
  02048	5e		 pop	 esi
  02049	5b		 pop	 ebx
  0204a	8b 4d e8	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0204d	33 cd		 xor	 ecx, ebp
  0204f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  02054	8b e5		 mov	 esp, ebp
  02056	5d		 pop	 ebp
  02057	c3		 ret	 0
$LN803@WMIex:
  02058	00 00 00 00	 DD	 $LN91@WMIex
  0205c	00 00 00 00	 DD	 $LN85@WMIex
  02060	00 00 00 00	 DD	 $LN73@WMIex
  02064	00 00 00 00	 DD	 $LN70@WMIex
  02068	00 00 00 00	 DD	 $LN57@WMIex
  0206c	00 00 00 00	 DD	 $LN60@WMIex
  02070	00 00 00 00	 DD	 $LN64@WMIex
  02074	00 00 00 00	 DD	 $LN57@WMIex
  02078	00 00 00 00	 DD	 $LN57@WMIex
  0207c	00 00 00 00	 DD	 $LN67@WMIex
  02080	00 00 00 00	 DD	 $LN57@WMIex
  02084	00 00 00 00	 DD	 $LN57@WMIex
  02088	00 00 00 00	 DD	 $LN57@WMIex
  0208c	00 00 00 00	 DD	 $LN57@WMIex
  02090	00 00 00 00	 DD	 $LN97@WMIex
  02094	00 00 00 00	 DD	 $LN94@WMIex
  02098	00 00 00 00	 DD	 $LN88@WMIex
  0209c	00 00 00 00	 DD	 $LN82@WMIex
  020a0	00 00 00 00	 DD	 $LN79@WMIex
  020a4	00 00 00 00	 DD	 $LN76@WMIex
$LN804@WMIex:
  020a8	00 00 00 00	 DD	 $LN46@WMIex
  020ac	00 00 00 00	 DD	 $LN40@WMIex
  020b0	00 00 00 00	 DD	 $LN28@WMIex
  020b4	00 00 00 00	 DD	 $LN22@WMIex
  020b8	00 00 00 00	 DD	 $LN16@WMIex
  020bc	00 00 00 00	 DD	 $LN52@WMIex
  020c0	00 00 00 00	 DD	 $LN34@WMIex
  020c4	00 00 00 00	 DD	 $LN53@WMIex
$LN783@WMIex:
  020c8	00		 DB	 0
  020c9	01		 DB	 1
  020ca	02		 DB	 2
  020cb	03		 DB	 3
  020cc	07		 DB	 7
  020cd	03		 DB	 3
  020ce	04		 DB	 4
  020cf	07		 DB	 7
  020d0	07		 DB	 7
  020d1	07		 DB	 7
  020d2	07		 DB	 7
  020d3	07		 DB	 7
  020d4	07		 DB	 7
  020d5	07		 DB	 7
  020d6	05		 DB	 5
  020d7	05		 DB	 5
  020d8	00		 DB	 0
  020d9	01		 DB	 1
  020da	06		 DB	 6
  020db	06		 DB	 6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$2:
  00000	8d bd 28 86 ff
	ff		 lea	 edi, DWORD PTR $T216195[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$3:
  0000b	8d bd 14 86 ff
	ff		 lea	 edi, DWORD PTR $T216196[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$4:
  00016	8d bd 28 86 ff
	ff		 lea	 edi, DWORD PTR $T216197[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$5:
  00021	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _tag$136981[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$6:
  0002c	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216198[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$7:
  00037	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216199[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$8:
  00042	8d 8d 78 86 ff
	ff		 lea	 ecx, DWORD PTR _value$137009[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$9:
  0004d	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216200[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$10:
  00058	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216201[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$11:
  00063	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216202[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$12:
  0006e	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216203[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$13:
  00079	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216204[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$14:
  00084	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216205[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$15:
  0008f	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216206[ebp]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$16:
  0009a	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216207[ebp]
  000a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$17:
  000a5	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216208[ebp]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$18:
  000b0	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216209[ebp]
  000b6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$19:
  000bb	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216210[ebp]
  000c1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$20:
  000c6	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216211[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$21:
  000d1	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216212[ebp]
  000d7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$22:
  000dc	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216213[ebp]
  000e2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$23:
  000e7	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216214[ebp]
  000ed	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$24:
  000f2	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216215[ebp]
  000f8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$25:
  000fd	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216216[ebp]
  00103	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$26:
  00108	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216217[ebp]
  0010e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$27:
  00113	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216218[ebp]
  00119	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$28:
  0011e	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216219[ebp]
  00124	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$29:
  00129	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216222[ebp]
  0012f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$30:
  00134	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216223[ebp]
  0013a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$31:
  0013f	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216226[ebp]
  00145	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$32:
  0014a	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216227[ebp]
  00150	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$33:
  00155	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216228[ebp]
  0015b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$34:
  00160	8b 8d 38 86 ff
	ff		 mov	 ecx, DWORD PTR $T216229[ebp]
  00166	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$35:
  0016b	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216230[ebp]
  00171	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$36:
  00176	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _id$137110[ebp]
  0017c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$37:
  00181	8d 85 cc 85 ff
	ff		 lea	 eax, DWORD PTR _vui1$137444[ebp]
  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  0018d	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$38:
  0018e	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216231[ebp]
  00194	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$39:
  00199	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216232[ebp]
  0019f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$40:
  001a4	8d 85 6c 85 ff
	ff		 lea	 eax, DWORD PTR _vui2$137793[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
  001b0	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$41:
  001b1	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216233[ebp]
  001b7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$42:
  001bc	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216234[ebp]
  001c2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$43:
  001c7	8d 85 b4 85 ff
	ff		 lea	 eax, DWORD PTR _vui4$138141[ebp]
  001cd	50		 push	 eax
  001ce	e8 00 00 00 00	 call	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
  001d3	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$44:
  001d4	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216235[ebp]
  001da	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$45:
  001df	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216236[ebp]
  001e5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$46:
  001ea	8d 85 84 85 ff
	ff		 lea	 eax, DWORD PTR _vui8$138489[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >
  001f6	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$47:
  001f7	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216237[ebp]
  001fd	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$48:
  00202	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216238[ebp]
  00208	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$49:
  0020d	8d 85 e4 85 ff
	ff		 lea	 eax, DWORD PTR _vr4$138837[ebp]
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
  00219	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$50:
  0021a	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216239[ebp]
  00220	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$51:
  00225	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216240[ebp]
  0022b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$52:
  00230	8d 85 9c 85 ff
	ff		 lea	 eax, DWORD PTR _vr8$139185[ebp]
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
  0023c	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$53:
  0023d	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216241[ebp]
  00243	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$54:
  00248	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216242[ebp]
  0024e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$55:
  00253	8d 85 38 85 ff
	ff		 lea	 eax, DWORD PTR _vbstr$139533[ebp]
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 ??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
  0025f	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$56:
  00260	8b 8d 50 86 ff
	ff		 mov	 ecx, DWORD PTR $T216243[ebp]
  00266	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$57:
  0026b	8b 8d 58 86 ff
	ff		 mov	 ecx, DWORD PTR $T216244[ebp]
  00271	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$58:
  00276	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _temp$139567[ebp]
  0027c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$59:
  00281	8b 8d 24 86 ff
	ff		 mov	 ecx, DWORD PTR $T216245[ebp]
  00287	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$60:
  0028c	8d 8d 5c 86 ff
	ff		 lea	 ecx, DWORD PTR _temp$139571[ebp]
  00292	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z$61:
  00297	8b 8d 24 86 ff
	ff		 mov	 ecx, DWORD PTR $T216246[ebp]
  0029d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z:
  002a2	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  002a6	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  002a9	8b 8a a0 84 ff
	ff		 mov	 ecx, DWORD PTR [edx-31584]
  002af	33 c8		 xor	 ecx, eax
  002b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b6	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  002b9	33 c8		 xor	 ecx, eax
  002bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z
  002c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ENDP			; WMIex
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
__tryblocktable$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
__ehfuncinfo$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Construct_n, COMDAT
; __Count$ = ecx

; 545  : 		{	// construct from _Count * _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00029	8b f1		 mov	 esi, ecx
  0002b	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 546  : 		if (_Buy(_Count))

  0002e	33 c0		 xor	 eax, eax
  00030	89 43 0c	 mov	 DWORD PTR [ebx+12], eax
  00033	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00036	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  00039	3b f0		 cmp	 esi, eax
  0003b	74 27		 je	 SHORT $LN7@Construct_
  0003d	8b fb		 mov	 edi, ebx
  0003f	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
  00044	84 c0		 test	 al, al
  00046	74 1c		 je	 SHORT $LN7@Construct_

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

  0004f	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00052	8b 7b 0c	 mov	 edi, DWORD PTR [ebx+12]
  00055	e8 00 00 00 00	 call	 ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
  0005a	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  0005d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@Construct_:

; 553  : 			_CATCH_END
; 554  : 			}
; 555  : 		}

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
__catch$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

  00078	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 552  : 			_RERAISE;

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@Construct_:
$LN21@Construct_:
  00089	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Construct_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z$1
__ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z
_TEXT	SEGMENT
$T222016 = -44						; size = 4
$T222022 = -44						; size = 4
$T222003 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 482  : 		{	// construct from _Count * _Ty()

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0000d	50		 push	 eax
  0000e	83 ec 24	 sub	 esp, 36			; 00000024H
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c4		 xor	 eax, esp
  0001a	50		 push	 eax
  0001b	8d 44 24 30	 lea	 eax, DWORD PTR __$EHRec$[esp+60]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b 74 24 40	 mov	 esi, DWORD PTR _this$[esp+56]
  00029	51		 push	 ecx
  0002a	89 64 24 14	 mov	 DWORD PTR $T222022[esp+64], esp
  0002e	89 64 24 14	 mov	 DWORD PTR $T222016[esp+64], esp
  00032	e8 00 00 00 00	 call	 ??0?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Container_base_aux_alloc_real<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00037	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+68], 1

; 483  : 		_Construct_n(_Count, _Ty());

  0003f	33 db		 xor	 ebx, ebx
  00041	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T222003[esp+84], 15 ; 0000000fH
  00049	89 5c 24 28	 mov	 DWORD PTR $T222003[esp+80], ebx
  0004d	88 5c 24 18	 mov	 BYTE PTR $T222003[esp+64], bl
  00051	c6 44 24 38 02	 mov	 BYTE PTR __$EHRec$[esp+68], 2
  00056	8b 4c 24 44	 mov	 ecx, DWORD PTR __Count$[esp+56]
  0005a	8d 44 24 14	 lea	 eax, DWORD PTR $T222003[esp+60]
  0005e	50		 push	 eax
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?_Construct_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Construct_n
  00065	c6 44 24 38 01	 mov	 BYTE PTR __$EHRec$[esp+68], 1
  0006a	83 7c 24 2c 10	 cmp	 DWORD PTR $T222003[esp+84], 16 ; 00000010H
  0006f	72 0d		 jb	 SHORT $LN62@vector@10
  00071	8b 4c 24 18	 mov	 ecx, DWORD PTR $T222003[esp+64]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007b	83 c4 04	 add	 esp, 4
$LN62@vector@10:
  0007e	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR $T222003[esp+84], 15 ; 0000000fH
  00086	89 5c 24 28	 mov	 DWORD PTR $T222003[esp+80], ebx
  0008a	88 5c 24 18	 mov	 BYTE PTR $T222003[esp+64], bl

; 484  : 		}

  0008e	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+68], -1
  00096	8b c6		 mov	 eax, esi
  00098	8b 4c 24 30	 mov	 ecx, DWORD PTR __$EHRec$[esp+60]
  0009c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a3	59		 pop	 ecx
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	83 c4 30	 add	 esp, 48			; 00000030H
  000a9	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z$2:
  00000	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Container_base_aux_alloc_real<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z$0:
  00008	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
  00011	c3		 ret	 0
__unwindfunclet$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z$1:
  00012	8d 4d d8	 lea	 ecx, DWORD PTR $T222003[ebp]
  00015	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z:
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 d4	 lea	 eax, DWORD PTR [edx-44]
  00021	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	__$ArrayPad$
PUBLIC	?ThreadWMIClass@@YGIPAX@Z			; ThreadWMIClass
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?ThreadWMIClass@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$4
__ehfuncinfo$?ThreadWMIClass@@YGIPAX@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ThreadWMIClass@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ?ThreadWMIClass@@YGIPAX@Z
_TEXT	SEGMENT
tv929 = -920						; size = 8
tv926 = -920						; size = 8
tv914 = -920						; size = 4
tv912 = -920						; size = 8
$T222286 = -920						; size = 4
$T222285 = -920						; size = 4
$T222280 = -920						; size = 4
tv917 = -906						; size = 2
_timeElapsed$ = -904					; size = 4
_tickStart$ = -904					; size = 8
$T222281 = -904						; size = 4
_fileName$ = -892					; size = 28
_oldFile$ = -864					; size = 260
_temp$139605 = -600					; size = 260
_newFile$ = -336					; size = 260
__$ArrayPad$ = -68					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?ThreadWMIClass@@YGIPAX@Z PROC				; ThreadWMIClass, COMDAT

; 703  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?ThreadWMIClass@@YGIPAX@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec a8 03 00
	00		 sub	 esp, 936		; 000003a8H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c4		 xor	 eax, esp
  00021	89 84 24 70 03
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+948], eax
  00028	53		 push	 ebx
  00029	56		 push	 esi
  0002a	57		 push	 edi
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c4		 xor	 eax, esp
  00032	50		 push	 eax
  00033	8d 84 24 b8 03
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+964]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	8b 75 08	 mov	 esi, DWORD PTR _lpData$[ebp]

; 704  :     vector<string> * plist = (vector<string>*)lpData;
; 705  : 
; 706  : 	Log(LOG_DEBUG_WMI,__LINE__,">> ThrdWMICls, %X",lpData);

  00043	56		 push	 esi
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BBPNDDPO@?$DO?$DO?5ThrdWMICls?0?5?$CFX?$AA@
  00049	68 c2 02 00 00	 push	 706			; 000002c2H
  0004e	6a 40		 push	 64			; 00000040H
  00050	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 707  : 
; 708  :     if(NULL==lpData)

  00058	85 f6		 test	 esi, esi
  0005a	75 24		 jne	 SHORT $LN15@ThreadWMIC

; 709  :     {
; 710  :         Log(LOG_DEBUG_WMI,__LINE__,"<< ThrdWMICls, Input null",lpData);

  0005c	56		 push	 esi
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null?$AA@
  00062	68 c6 02 00 00	 push	 710			; 000002c6H
  00067	6a 40		 push	 64			; 00000040H
  00069	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 711  :         _endthreadex(ERROR_INVALID_DATA);

  0006e	6a 0d		 push	 13			; 0000000dH
  00070	e8 00 00 00 00	 call	 __endthreadex
  00075	83 c4 14	 add	 esp, 20			; 00000014H

; 712  :         return ERROR_INVALID_DATA;

  00078	8d 46 0d	 lea	 eax, DWORD PTR [esi+13]
  0007b	e9 af 05 00 00	 jmp	 $LN16@ThreadWMIC
$LN15@ThreadWMIC:

; 713  :     }
; 714  : 
; 715  :     //find the last file
; 716  :     HANDLE hXmlFile = NULL;
; 717  :     int x;
; 718  :     for(x=9;x>=0;x--)

  00080	bf 09 00 00 00	 mov	 edi, 9
$LN14@ThreadWMIC:

; 719  :     {
; 720  :         char temp[_MAX_PATH] = {0};

  00085	68 03 01 00 00	 push	 259			; 00000103H
  0008a	8d 84 24 71 01
	00 00		 lea	 eax, DWORD PTR _temp$139605[esp+969]
  00091	6a 00		 push	 0
  00093	50		 push	 eax
  00094	c6 84 24 78 01
	00 00 00	 mov	 BYTE PTR _temp$139605[esp+976], 0
  0009c	e8 00 00 00 00	 call	 _memset
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 721  :         _snprintf(temp,sizeof(temp),"SysStatus_%s_%.1d.xml",plist->at(0).c_str(),x);

  000a4	6a 00		 push	 0
  000a6	8b c6		 mov	 eax, esi
  000a8	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  000ad	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  000b1	72 05		 jb	 SHORT $LN31@ThreadWMIC
  000b3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b6	eb 03		 jmp	 SHORT $LN32@ThreadWMIC
$LN31@ThreadWMIC:
  000b8	83 c0 04	 add	 eax, 4
$LN32@ThreadWMIC:
  000bb	57		 push	 edi
  000bc	50		 push	 eax
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PNOFHJNO@SysStatus_?$CFs_?$CF?41d?4xml?$AA@
  000c2	8d 8c 24 78 01
	00 00		 lea	 ecx, DWORD PTR _temp$139605[esp+976]
  000c9	68 04 01 00 00	 push	 260			; 00000104H
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 __snprintf
  000d4	83 c4 14	 add	 esp, 20			; 00000014H

; 722  :         Log(LOG_DEBUG_WMI,__LINE__,"ThrdWMICls, Trying opng %s",temp);

  000d7	8d 94 24 6c 01
	00 00		 lea	 edx, DWORD PTR _temp$139605[esp+964]
  000de	52		 push	 edx
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NMIGBPMF@ThrdWMICls?0?5Trying?5opng?5?$CFs?$AA@
  000e4	68 d2 02 00 00	 push	 722			; 000002d2H
  000e9	6a 40		 push	 64			; 00000040H
  000eb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 723  :         hXmlFile = CreateFile(temp,GENERIC_READ|GENERIC_WRITE,
; 724  :                                       FILE_SHARE_READ|FILE_SHARE_WRITE,
; 725  :                                       NULL,
; 726  :                                       OPEN_EXISTING,
; 727  :                                       FILE_ATTRIBUTE_NORMAL,
; 728  :                                       NULL);

  000f3	6a 00		 push	 0
  000f5	68 80 00 00 00	 push	 128			; 00000080H
  000fa	6a 03		 push	 3
  000fc	6a 00		 push	 0
  000fe	6a 03		 push	 3
  00100	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00105	8d 84 24 84 01
	00 00		 lea	 eax, DWORD PTR _temp$139605[esp+988]
  0010c	50		 push	 eax
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00113	8b d8		 mov	 ebx, eax

; 729  :         if(hXmlFile!=INVALID_HANDLE_VALUE)

  00115	83 fb ff	 cmp	 ebx, -1
  00118	75 0b		 jne	 SHORT $LN246@ThreadWMIC

; 713  :     }
; 714  : 
; 715  :     //find the last file
; 716  :     HANDLE hXmlFile = NULL;
; 717  :     int x;
; 718  :     for(x=9;x>=0;x--)

  0011a	83 ef 01	 sub	 edi, 1
  0011d	0f 89 62 ff ff
	ff		 jns	 $LN14@ThreadWMIC

; 729  :         if(hXmlFile!=INVALID_HANDLE_VALUE)

  00123	eb 51		 jmp	 SHORT $LN10@ThreadWMIC
$LN246@ThreadWMIC:

; 730  :         {
; 731  :             Log(LOG_DEBUG_WMI,__LINE__,"-- ThrdWMICls, Last file fnd: %s",temp);

  00125	8d 8c 24 6c 01
	00 00		 lea	 ecx, DWORD PTR _temp$139605[esp+964]
  0012c	51		 push	 ecx
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CFs@
  00132	68 db 02 00 00	 push	 731			; 000002dbH
  00137	6a 40		 push	 64			; 00000040H
  00139	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0013e	83 c4 10	 add	 esp, 16			; 00000010H

; 732  :             CloseHandle(hXmlFile);

  00141	53		 push	 ebx
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 733  :             hXmlFile = NULL;
; 734  : 
; 735  :             //all file were filled, removed the last one
; 736  :             if(x==9) {

  00148	83 ff 09	 cmp	 edi, 9
  0014b	75 29		 jne	 SHORT $LN10@ThreadWMIC

; 737  :                 Log(LOG_DEBUG_WMI,__LINE__,"-- ThrdWMICls, Removing %s - oldest file",temp);

  0014d	8d 94 24 6c 01
	00 00		 lea	 edx, DWORD PTR _temp$139605[esp+964]
  00154	52		 push	 edx
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5old@
  0015a	68 e1 02 00 00	 push	 737			; 000002e1H
  0015f	6a 40		 push	 64			; 00000040H
  00161	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 738  :                 remove((char*)temp);

  00166	8d 84 24 7c 01
	00 00		 lea	 eax, DWORD PTR _temp$139605[esp+980]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 _remove
  00173	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@ThreadWMIC:

; 739  :             }
; 740  : 
; 741  :             break;      //last one was found
; 742  :         }
; 743  :     }
; 744  : 
; 745  :     //rename the last one to the previous
; 746  :     char newFile[_MAX_PATH] = {0};

  00176	68 03 01 00 00	 push	 259			; 00000103H
  0017b	8d 8c 24 79 02
	00 00		 lea	 ecx, DWORD PTR _newFile$[esp+969]
  00182	6a 00		 push	 0
  00184	51		 push	 ecx
  00185	c6 84 24 80 02
	00 00 00	 mov	 BYTE PTR _newFile$[esp+976], 0
  0018d	e8 00 00 00 00	 call	 _memset
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH

; 747  :     char oldFile[_MAX_PATH] = {0};

  00195	68 03 01 00 00	 push	 259			; 00000103H
  0019a	8d 54 24 69	 lea	 edx, DWORD PTR _oldFile$[esp+969]
  0019e	6a 00		 push	 0
  001a0	52		 push	 edx
  001a1	c6 44 24 70 00	 mov	 BYTE PTR _oldFile$[esp+976], 0
  001a6	e8 00 00 00 00	 call	 _memset
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 748  :     for(;x>=0;x--)

  001ae	85 ff		 test	 edi, edi
  001b0	0f 8c aa 00 00
	00		 jl	 $LN253@ThreadWMIC
$LN9@ThreadWMIC:

; 749  :     {
; 750  :         _snprintf(newFile,sizeof(newFile),"SysStatus_%s_%.1d.xml",plist->at(0).c_str(),x+1);

  001b6	6a 00		 push	 0
  001b8	8b c6		 mov	 eax, esi
  001ba	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  001bf	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  001c4	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  001c7	72 05		 jb	 SHORT $LN37@ThreadWMIC
  001c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001cc	eb 03		 jmp	 SHORT $LN38@ThreadWMIC
$LN37@ThreadWMIC:
  001ce	83 c0 04	 add	 eax, 4
$LN38@ThreadWMIC:
  001d1	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001d4	51		 push	 ecx
  001d5	50		 push	 eax
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PNOFHJNO@SysStatus_?$CFs_?$CF?41d?4xml?$AA@
  001db	8d 94 24 80 02
	00 00		 lea	 edx, DWORD PTR _newFile$[esp+976]
  001e2	68 04 01 00 00	 push	 260			; 00000104H
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 __snprintf
  001ed	83 c4 14	 add	 esp, 20			; 00000014H

; 751  :         _snprintf(oldFile,sizeof(oldFile),"SysStatus_%s_%.1d.xml",plist->at(0).c_str(),x);

  001f0	6a 00		 push	 0
  001f2	8b c6		 mov	 eax, esi
  001f4	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  001f9	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  001fc	72 05		 jb	 SHORT $LN43@ThreadWMIC
  001fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00201	eb 03		 jmp	 SHORT $LN44@ThreadWMIC
$LN43@ThreadWMIC:
  00203	83 c0 04	 add	 eax, 4
$LN44@ThreadWMIC:
  00206	57		 push	 edi
  00207	50		 push	 eax
  00208	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PNOFHJNO@SysStatus_?$CFs_?$CF?41d?4xml?$AA@
  0020d	8d 44 24 70	 lea	 eax, DWORD PTR _oldFile$[esp+976]
  00211	68 04 01 00 00	 push	 260			; 00000104H
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 __snprintf
  0021c	83 c4 14	 add	 esp, 20			; 00000014H

; 752  : 
; 753  :         Log(LOG_DEBUG_WMI,__LINE__,"-- ThrdWMICls, Renaming %s -> %s",oldFile,newFile);

  0021f	8d 8c 24 74 02
	00 00		 lea	 ecx, DWORD PTR _newFile$[esp+964]
  00226	51		 push	 ecx
  00227	8d 54 24 68	 lea	 edx, DWORD PTR _oldFile$[esp+968]
  0022b	52		 push	 edx
  0022c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CFs@
  00231	68 f1 02 00 00	 push	 753			; 000002f1H
  00236	6a 40		 push	 64			; 00000040H
  00238	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0023d	83 c4 14	 add	 esp, 20			; 00000014H

; 754  :         rename((const char*)oldFile,(const char*)newFile);

  00240	8d 84 24 74 02
	00 00		 lea	 eax, DWORD PTR _newFile$[esp+964]
  00247	50		 push	 eax
  00248	8d 4c 24 68	 lea	 ecx, DWORD PTR _oldFile$[esp+968]
  0024c	51		 push	 ecx
  0024d	e8 00 00 00 00	 call	 _rename
  00252	83 c4 08	 add	 esp, 8
  00255	83 ef 01	 sub	 edi, 1
  00258	0f 89 58 ff ff
	ff		 jns	 $LN9@ThreadWMIC

; 748  :     for(;x>=0;x--)

  0025e	eb 05		 jmp	 SHORT $LN7@ThreadWMIC
$LN253@ThreadWMIC:
  00260	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
$LN7@ThreadWMIC:

; 755  :     }
; 756  :     //rename the log to 000
; 757  :     _snprintf(newFile,sizeof(newFile),"SysStatus_%s_0.xml",plist->at(0).c_str());

  00265	6a 00		 push	 0
  00267	8b c6		 mov	 eax, esi
  00269	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  0026e	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  00271	72 05		 jb	 SHORT $LN49@ThreadWMIC
  00273	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00276	eb 03		 jmp	 SHORT $LN50@ThreadWMIC
$LN49@ThreadWMIC:
  00278	83 c0 04	 add	 eax, 4
$LN50@ThreadWMIC:
  0027b	50		 push	 eax
  0027c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CJNFHACM@SysStatus_?$CFs_0?4xml?$AA@
  00281	8d 94 24 7c 02
	00 00		 lea	 edx, DWORD PTR _newFile$[esp+972]
  00288	68 04 01 00 00	 push	 260			; 00000104H
  0028d	52		 push	 edx
  0028e	e8 00 00 00 00	 call	 __snprintf
  00293	83 c4 10	 add	 esp, 16			; 00000010H

; 758  :     _snprintf(oldFile,sizeof(oldFile),"SysStatus_%s.xml",plist->at(0).c_str());

  00296	6a 00		 push	 0
  00298	8b c6		 mov	 eax, esi
  0029a	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  0029f	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  002a2	72 05		 jb	 SHORT $LN55@ThreadWMIC
  002a4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002a7	eb 03		 jmp	 SHORT $LN56@ThreadWMIC
$LN55@ThreadWMIC:
  002a9	83 c0 04	 add	 eax, 4
$LN56@ThreadWMIC:
  002ac	50		 push	 eax
  002ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PKMMABCD@SysStatus_?$CFs?4xml?$AA@
  002b2	8d 44 24 6c	 lea	 eax, DWORD PTR _oldFile$[esp+972]
  002b6	68 04 01 00 00	 push	 260			; 00000104H
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 __snprintf

; 759  :     Log(LOG_DEBUG_WMI,__LINE__,"-- ThrdWMICls, Remaning %s -> %s",oldFile,newFile);

  002c1	8d 8c 24 84 02
	00 00		 lea	 ecx, DWORD PTR _newFile$[esp+980]
  002c8	51		 push	 ecx
  002c9	8d 54 24 78	 lea	 edx, DWORD PTR _oldFile$[esp+984]
  002cd	52		 push	 edx
  002ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FDOJEIA@?9?9?5ThrdWMICls?0?5Remaning?5?$CFs?5?9?$DO?5?$CFs@
  002d3	68 f7 02 00 00	 push	 759			; 000002f7H
  002d8	6a 40		 push	 64			; 00000040H
  002da	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002df	83 c4 24	 add	 esp, 36			; 00000024H

; 760  :     rename((const char*)oldFile,(const char*)newFile);

  002e2	8d 84 24 74 02
	00 00		 lea	 eax, DWORD PTR _newFile$[esp+964]
  002e9	50		 push	 eax
  002ea	8d 4c 24 68	 lea	 ecx, DWORD PTR _oldFile$[esp+968]
  002ee	51		 push	 ecx
  002ef	e8 00 00 00 00	 call	 _rename
  002f4	83 c4 08	 add	 esp, 8

; 761  : 
; 762  :     string fileName;

  002f7	33 c0		 xor	 eax, eax
  002f9	bb 0f 00 00 00	 mov	 ebx, 15			; 0000000fH
  002fe	89 5c 24 60	 mov	 DWORD PTR _fileName$[esp+988], ebx
  00302	89 44 24 5c	 mov	 DWORD PTR _fileName$[esp+984], eax
  00306	88 44 24 4c	 mov	 BYTE PTR _fileName$[esp+968], al
  0030a	89 84 24 c0 03
	00 00		 mov	 DWORD PTR __$EHRec$[esp+972], eax

; 763  :     fileName.assign(oldFile);

  00311	8d 44 24 64	 lea	 eax, DWORD PTR _oldFile$[esp+964]
  00315	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$LL250@ThreadWMIC:
  00318	8a 08		 mov	 cl, BYTE PTR [eax]
  0031a	40		 inc	 eax
  0031b	84 c9		 test	 cl, cl
  0031d	75 f9		 jne	 SHORT $LL250@ThreadWMIC
  0031f	2b c2		 sub	 eax, edx
  00321	50		 push	 eax
  00322	8d 54 24 68	 lea	 edx, DWORD PTR _oldFile$[esp+968]
  00326	52		 push	 edx
  00327	8d 4c 24 50	 lea	 ecx, DWORD PTR _fileName$[esp+972]
  0032b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 764  :     xmlwriter *xml = new xmlwriter(fileName,DebugStringToFile);

  00330	6a 60		 push	 96			; 00000060H
  00332	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00337	8b f8		 mov	 edi, eax
  00339	83 c4 04	 add	 esp, 4
  0033c	89 7c 24 2c	 mov	 DWORD PTR $T222280[esp+964], edi
  00340	c6 84 24 c0 03
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+972], 1
  00348	85 ff		 test	 edi, edi
  0034a	74 45		 je	 SHORT $LN18@ThreadWMIC
  0034c	68 00 00 00 00	 push	 OFFSET ?DebugStringToFile@@YAXPADH@Z ; DebugStringToFile
  00351	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00354	8b cc		 mov	 ecx, esp
  00356	89 64 24 5c	 mov	 DWORD PTR $T222281[esp+996], esp
  0035a	6a ff		 push	 -1
  0035c	6a 00		 push	 0
  0035e	8d 44 24 70	 lea	 eax, DWORD PTR _fileName$[esp+1004]
  00362	89 59 18	 mov	 DWORD PTR [ecx+24], ebx
  00365	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0036c	50		 push	 eax
  0036d	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00371	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00376	c6 84 24 e0 03
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1004], 2
  0037e	c6 84 24 e0 03
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1004], 1
  00386	8b cf		 mov	 ecx, edi
  00388	e8 00 00 00 00	 call	 ??0xmlwriter@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6AXPADH@Z@Z ; xmlwriter::xmlwriter
  0038d	8b f8		 mov	 edi, eax
  0038f	eb 02		 jmp	 SHORT $LN19@ThreadWMIC
$LN18@ThreadWMIC:
  00391	33 ff		 xor	 edi, edi
$LN19@ThreadWMIC:
  00393	c6 84 24 c0 03
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+972], 0

; 765  :     if(!xml)

  0039b	85 ff		 test	 edi, edi
  0039d	75 4d		 jne	 SHORT $LN6@ThreadWMIC

; 766  :     {
; 767  :         Log(LOG_DEBUG_WMI,__LINE__,"<< ThrdWMICls, New XmlWriter(%s) class null",oldFile);

  0039f	8d 4c 24 64	 lea	 ecx, DWORD PTR _oldFile$[esp+964]
  003a3	51		 push	 ecx
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@DGGGCCBN@?$DM?$DM?5ThrdWMICls?0?5New?5XmlWriter?$CI?$CFs?$CJ@
  003a9	68 ff 02 00 00	 push	 767			; 000002ffH
  003ae	6a 40		 push	 64			; 00000040H
  003b0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 768  :         _endthreadex(ERROR_OUTOFMEMORY);

  003b5	6a 0e		 push	 14			; 0000000eH
  003b7	e8 00 00 00 00	 call	 __endthreadex
  003bc	83 c4 14	 add	 esp, 20			; 00000014H

; 769  :         return ERROR_OUTOFMEMORY;

  003bf	c7 84 24 c0 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+972], -1
  003ca	83 7c 24 60 10	 cmp	 DWORD PTR _fileName$[esp+988], 16 ; 00000010H
  003cf	72 0d		 jb	 SHORT $LN135@ThreadWMIC
  003d1	8b 54 24 4c	 mov	 edx, DWORD PTR _fileName$[esp+968]
  003d5	52		 push	 edx
  003d6	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  003db	83 c4 04	 add	 esp, 4
$LN135@ThreadWMIC:
  003de	89 5c 24 60	 mov	 DWORD PTR _fileName$[esp+988], ebx
  003e2	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  003e7	e9 36 02 00 00	 jmp	 $LN256@ThreadWMIC
$LN6@ThreadWMIC:

; 770  :     }
; 771  : 
; 772  :     unsigned __int64 tickStart = SysTick;

  003ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003f2	89 44 24 3c	 mov	 DWORD PTR _tickStart$[esp+964], eax

; 773  : 
; 774  :     xml->Createtag(plist->at(0));

  003f6	6a 00		 push	 0
  003f8	8b c6		 mov	 eax, esi
  003fa	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  003ff	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00402	8b cc		 mov	 ecx, esp
  00404	89 64 24 48	 mov	 DWORD PTR $T222285[esp+992], esp
  00408	6a ff		 push	 -1
  0040a	6a 00		 push	 0
  0040c	89 59 18	 mov	 DWORD PTR [ecx+24], ebx
  0040f	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00416	50		 push	 eax
  00417	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  0041b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00420	c6 84 24 dc 03
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1000], 3
  00428	c6 84 24 dc 03
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1000], 0
  00430	8b cf		 mov	 ecx, edi
  00432	e8 00 00 00 00	 call	 ?Createtag@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::Createtag

; 775  :     xml->AddComment(plist->at(1));

  00437	6a 01		 push	 1
  00439	8b c6		 mov	 eax, esi
  0043b	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  00440	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00443	8b cc		 mov	 ecx, esp
  00445	89 64 24 48	 mov	 DWORD PTR $T222286[esp+992], esp
  00449	6a ff		 push	 -1
  0044b	6a 00		 push	 0
  0044d	89 59 18	 mov	 DWORD PTR [ecx+24], ebx
  00450	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00457	50		 push	 eax
  00458	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  0045c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00461	c6 84 24 dc 03
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+1000], 4
  00469	c6 84 24 dc 03
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1000], 0
  00471	8b cf		 mov	 ecx, edi
  00473	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 776  : 
; 777  :     for(unsigned long x=2;x<plist->size() && _thGetInt(&gbTerminate)==FALSE;x++)

  00478	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0047b	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  0047e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00483	f7 e9		 imul	 ecx
  00485	03 d1		 add	 edx, ecx
  00487	c1 fa 04	 sar	 edx, 4
  0048a	8b c2		 mov	 eax, edx
  0048c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0048f	bb 02 00 00 00	 mov	 ebx, 2
  00494	03 c2		 add	 eax, edx
  00496	3b c3		 cmp	 eax, ebx
  00498	76 5c		 jbe	 SHORT $LN3@ThreadWMIC
  0049a	8d 9b 00 00 00
	00		 npad	 6
$LL5@ThreadWMIC:
  004a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gbTerminate@@3HA ; gbTerminate
  004a5	e8 00 00 00 00	 call	 ?_thGetInt@@YAHPAH@Z	; _thGetInt
  004aa	85 c0		 test	 eax, eax
  004ac	75 48		 jne	 SHORT $LN3@ThreadWMIC
  004ae	8b ff		 npad	 2
$LL2@ThreadWMIC:

; 778  :     {
; 779  :         while(WMIex((char*)plist->at(x).c_str(),xml)==false);

  004b0	53		 push	 ebx
  004b1	8b c6		 mov	 eax, esi
  004b3	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  004b8	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  004bc	72 05		 jb	 SHORT $LN203@ThreadWMIC
  004be	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004c1	eb 03		 jmp	 SHORT $LN204@ThreadWMIC
$LN203@ThreadWMIC:
  004c3	83 c0 04	 add	 eax, 4
$LN204@ThreadWMIC:
  004c6	6a 00		 push	 0
  004c8	8b d7		 mov	 edx, edi
  004ca	8b c8		 mov	 ecx, eax
  004cc	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  004d1	83 c4 04	 add	 esp, 4
  004d4	84 c0		 test	 al, al
  004d6	74 d8		 je	 SHORT $LL2@ThreadWMIC
  004d8	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  004db	2b 4e 0c	 sub	 ecx, DWORD PTR [esi+12]
  004de	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  004e3	f7 e9		 imul	 ecx
  004e5	03 d1		 add	 edx, ecx
  004e7	c1 fa 04	 sar	 edx, 4
  004ea	8b ca		 mov	 ecx, edx
  004ec	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004ef	43		 inc	 ebx
  004f0	03 ca		 add	 ecx, edx
  004f2	3b d9		 cmp	 ebx, ecx
  004f4	72 aa		 jb	 SHORT $LL5@ThreadWMIC
$LN3@ThreadWMIC:

; 780  :     }
; 781  :     xml->CloseAlltags();

  004f6	8b c7		 mov	 eax, edi
  004f8	e8 00 00 00 00	 call	 ?CloseAlltags@xmlwriter@@QAEXXZ ; xmlwriter::CloseAlltags

; 782  : 
; 783  :     delete xml;

  004fd	57		 push	 edi
  004fe	e8 00 00 00 00	 call	 ??1xmlwriter@@QAE@XZ	; xmlwriter::~xmlwriter
  00503	57		 push	 edi
  00504	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00509	83 c4 04	 add	 esp, 4

; 784  :     xml = NULL;
; 785  : 
; 786  :     unsigned __int64 tickEnd;
; 787  :     float timeElapsed;
; 788  :     unsigned long seconds;
; 789  :     CalcElapsedTime(tickStart,tickEnd,timeElapsed,seconds);

  0050c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00512	d9 7c 24 3a	 fnstcw	 WORD PTR tv917[esp+964]
  00516	33 c9		 xor	 ecx, ecx
  00518	2b 44 24 3c	 sub	 eax, DWORD PTR _tickStart$[esp+964]
  0051c	8b d1		 mov	 edx, ecx
  0051e	89 44 24 2c	 mov	 DWORD PTR tv929[esp+964], eax
  00522	1b ca		 sbb	 ecx, edx
  00524	8b c1		 mov	 eax, ecx
  00526	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0052b	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00531	89 4c 24 30	 mov	 DWORD PTR tv929[esp+968], ecx
  00535	df 6c 24 2c	 fild	 QWORD PTR tv929[esp+964]
  00539	89 44 24 30	 mov	 DWORD PTR tv926[esp+968], eax
  0053d	89 54 24 2c	 mov	 DWORD PTR tv926[esp+964], edx
  00541	df 6c 24 2c	 fild	 QWORD PTR tv926[esp+964]
  00545	0f b7 44 24 3a	 movzx	 eax, WORD PTR tv917[esp+964]
  0054a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0054f	d9 e0		 fchs
  00551	89 44 24 2c	 mov	 DWORD PTR tv914[esp+964], eax
  00555	de c1		 faddp	 ST(1), ST(0)

; 790  : 
; 791  :     Log(LOG_DEBUG_WMI,__LINE__,"<< ThrdWMICls, %s, %02d:%02d:%02d, %f s",plist->at(0).c_str(),seconds/3600,(seconds % 3600)/60,seconds % 60,timeElapsed);

  00557	52		 push	 edx
  00558	8b c6		 mov	 eax, esi
  0055a	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@408f400000000000
  00560	d9 5c 24 40	 fstp	 DWORD PTR _timeElapsed$[esp+968]
  00564	d9 44 24 40	 fld	 DWORD PTR _timeElapsed$[esp+968]
  00568	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  0056e	d9 6c 24 30	 fldcw	 WORD PTR tv914[esp+968]
  00572	df 7c 24 30	 fistp	 QWORD PTR tv912[esp+968]
  00576	8b 7c 24 30	 mov	 edi, DWORD PTR tv912[esp+968]
  0057a	d9 6c 24 3e	 fldcw	 WORD PTR tv917[esp+968]
  0057e	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  00583	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
  00588	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  0058b	72 05		 jb	 SHORT $LN214@ThreadWMIC
  0058d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00590	eb 03		 jmp	 SHORT $LN215@ThreadWMIC
$LN214@ThreadWMIC:
  00592	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
$LN215@ThreadWMIC:
  00595	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  0059a	d9 44 24 3c	 fld	 DWORD PTR _timeElapsed$[esp+964]
  0059e	f7 e7		 mul	 edi
  005a0	8b ca		 mov	 ecx, edx
  005a2	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  005a7	f7 e7		 mul	 edi
  005a9	c1 ea 05	 shr	 edx, 5
  005ac	8b c2		 mov	 eax, edx
  005ae	c1 e0 04	 shl	 eax, 4
  005b1	2b c2		 sub	 eax, edx
  005b3	03 c0		 add	 eax, eax
  005b5	03 c0		 add	 eax, eax
  005b7	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  005ba	8b d7		 mov	 edx, edi
  005bc	2b d0		 sub	 edx, eax
  005be	8b c1		 mov	 eax, ecx
  005c0	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  005c6	83 ec 08	 sub	 esp, 8
  005c9	2b f8		 sub	 edi, eax
  005cb	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  005d0	dd 1c 24	 fstp	 QWORD PTR [esp]
  005d3	52		 push	 edx
  005d4	f7 e7		 mul	 edi
  005d6	c1 ea 05	 shr	 edx, 5
  005d9	52		 push	 edx
  005da	51		 push	 ecx
  005db	56		 push	 esi
  005dc	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IKNGLCAL@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02d?3?$CF02d?3?$CF02@
  005e1	68 17 03 00 00	 push	 791			; 00000317H
  005e6	6a 40		 push	 64			; 00000040H
  005e8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  005ed	83 c4 24	 add	 esp, 36			; 00000024H

; 792  : 	_endthreadex(0);

  005f0	6a 00		 push	 0
  005f2	e8 00 00 00 00	 call	 __endthreadex
  005f7	83 c4 04	 add	 esp, 4

; 793  : 	return 0;

  005fa	c7 84 24 c0 03
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+972], -1
  00605	39 5c 24 60	 cmp	 DWORD PTR _fileName$[esp+988], ebx
  00609	72 0d		 jb	 SHORT $LN232@ThreadWMIC
  0060b	8b 4c 24 4c	 mov	 ecx, DWORD PTR _fileName$[esp+968]
  0060f	51		 push	 ecx
  00610	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00615	83 c4 04	 add	 esp, 4
$LN232@ThreadWMIC:
  00618	c7 44 24 60 0f
	00 00 00	 mov	 DWORD PTR _fileName$[esp+988], 15 ; 0000000fH
  00620	33 c0		 xor	 eax, eax
$LN256@ThreadWMIC:
  00622	c6 44 24 4c 00	 mov	 BYTE PTR _fileName$[esp+968], 0
  00627	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR _fileName$[esp+984], 0
$LN16@ThreadWMIC:

; 794  : }

  0062f	8b 8c 24 b8 03
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+964]
  00636	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0063d	59		 pop	 ecx
  0063e	5f		 pop	 edi
  0063f	5e		 pop	 esi
  00640	5b		 pop	 ebx
  00641	8b 8c 24 70 03
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+948]
  00648	33 cc		 xor	 ecx, esp
  0064a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0064f	8b e5		 mov	 esp, ebp
  00651	5d		 pop	 ebp
  00652	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$0:
  00000	8d 8d 84 fc ff
	ff		 lea	 ecx, DWORD PTR _fileName$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$1:
  0000b	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR $T222280[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	59		 pop	 ecx
  00018	c3		 ret	 0
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$2:
  00019	8b 8d 78 fc ff
	ff		 mov	 ecx, DWORD PTR $T222281[ebp]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$3:
  00024	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR $T222285[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$4:
  0002f	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR $T222286[ebp]
  00035	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ThreadWMIClass@@YGIPAX@Z:
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003e	8d 82 4c fc ff
	ff		 lea	 eax, DWORD PTR [edx-948]
  00044	8b 8a 48 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-952]
  0004a	33 c8		 xor	 ecx, eax
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	83 c0 0c	 add	 eax, 12			; 0000000cH
  00054	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThreadWMIClass@@YGIPAX@Z
  00063	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThreadWMIClass@@YGIPAX@Z ENDP				; ThreadWMIClass
PUBLIC	?WMI@@YAXPADPAK@Z				; WMI
; Function compile flags: /Ogtpy
;	COMDAT ?WMI@@YAXPADPAK@Z
_TEXT	SEGMENT
?WMI@@YAXPADPAK@Z PROC					; WMI, COMDAT
; _lpszOption$ = ecx
; _lpulProperties$ = eax

; 695  : {

  00000	51		 push	 ecx

; 696  :     WMIex(lpszOption,NULL,lpulProperties);

  00001	50		 push	 eax
  00002	33 d2		 xor	 edx, edx
  00004	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00009	83 c4 04	 add	 esp, 4
  0000c	59		 pop	 ecx

; 697  : }

  0000d	c3		 ret	 0
?WMI@@YAXPADPAK@Z ENDP					; WMI
PUBLIC	?WMIHardwareSensor@@YAXXZ			; WMIHardwareSensor
; Function compile flags: /Ogtpy
;	COMDAT ?WMIHardwareSensor@@YAXXZ
_TEXT	SEGMENT
?WMIHardwareSensor@@YAXXZ PROC				; WMIHardwareSensor, COMDAT

; 1130 : {

  00000	51		 push	 ecx

; 1131 :     static unsigned long CurrentProbe = (unsigned long)-1;
; 1132 :     static unsigned long PortableBattery = (unsigned long)-1;
; 1133 :     static unsigned long TemperatureProbe = (unsigned long)-1;
; 1134 :     static unsigned long VoltageProbe = (unsigned long)-1;
; 1135 : 
; 1136 :     Log(LOG_DEBUG_WMI,__LINE__,">> WMIHwSnsr");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr?$AA@
  00006	68 70 04 00 00	 push	 1136			; 00000470H
  0000b	6a 40		 push	 64			; 00000040H
  0000d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1137 : 
; 1138 :     if(CurrentProbe!=0)

  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  0001c	74 14		 je	 SHORT $LN7@WMIHardwar

; 1139 :     {
; 1140 :         WMI("Win32_CurrentProbe",&CurrentProbe);

  0001e	68 00 00 00 00	 push	 OFFSET ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  00023	33 d2		 xor	 edx, edx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@ENAKGAAL@Win32_CurrentProbe?$AA@
  0002a	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0002f	83 c4 04	 add	 esp, 4
$LN7@WMIHardwar:

; 1141 :     }
; 1142 : 
; 1143 :     if(PortableBattery!=0)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00039	74 14		 je	 SHORT $LN9@WMIHardwar

; 1144 :     {
; 1145 :         WMI("Win32_PortableBattery",&PortableBattery);

  0003b	68 00 00 00 00	 push	 OFFSET ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA
  00040	33 d2		 xor	 edx, edx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BG@GEFEDJOA@Win32_PortableBattery?$AA@
  00047	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0004c	83 c4 04	 add	 esp, 4
$LN9@WMIHardwar:

; 1146 :     }
; 1147 : 
; 1148 :     if(TemperatureProbe!=0)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00056	74 14		 je	 SHORT $LN11@WMIHardwar

; 1149 :     {
; 1150 :         WMI("Win32_TemperatureProbe",&TemperatureProbe);

  00058	68 00 00 00 00	 push	 OFFSET ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  0005d	33 d2		 xor	 edx, edx
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe?$AA@
  00064	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00069	83 c4 04	 add	 esp, 4
$LN11@WMIHardwar:

; 1151 :     }
; 1152 : 
; 1153 :     if(VoltageProbe!=0)

  0006c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00073	74 14		 je	 SHORT $LN13@WMIHardwar

; 1154 :     {
; 1155 :         WMI("Win32_VoltageProbe",&VoltageProbe);

  00075	68 00 00 00 00	 push	 OFFSET ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  0007a	33 d2		 xor	 edx, edx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@HAJJDCII@Win32_VoltageProbe?$AA@
  00081	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00086	83 c4 04	 add	 esp, 4
$LN13@WMIHardwar:

; 1156 :     }
; 1157 : 
; 1158 :     Log(LOG_DEBUG_WMI,__LINE__,"<< WMIHwSnsr");

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr?$AA@
  0008e	68 86 04 00 00	 push	 1158			; 00000486H
  00093	6a 40		 push	 64			; 00000040H
  00095	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	59		 pop	 ecx

; 1159 : }

  0009e	c3		 ret	 0
?WMIHardwareSensor@@YAXXZ ENDP				; WMIHardwareSensor
_TEXT	ENDS
PUBLIC	?WMISystemPerformance@@YAXXZ			; WMISystemPerformance
; Function compile flags: /Ogtpy
;	COMDAT ?WMISystemPerformance@@YAXXZ
_TEXT	SEGMENT
?WMISystemPerformance@@YAXXZ PROC			; WMISystemPerformance, COMDAT

; 1071 : {

  00000	51		 push	 ecx

; 1072 :     static unsigned long PerfRawData_PerfDisk_PhysicalDisk = (unsigned long)-1;
; 1073 :     static unsigned long PerfRawData_PerfNet_Redirector = (unsigned long)-1;
; 1074 :     static unsigned long PerfRawData_PerfOS_Cache = (unsigned long)-1;
; 1075 :     static unsigned long PerfRawData_PerfOS_Memory = (unsigned long)-1;
; 1076 :     static unsigned long PerfRawData_PerfOS_Objects = (unsigned long)-1;
; 1077 :     static unsigned long PerfRawData_PerfOS_PagingFile = (unsigned long)-1;
; 1078 :     static unsigned long PerfRawData_PerfOS_Processor = (unsigned long)-1;
; 1079 :     static unsigned long PerfRawData_PerfOS_System = (unsigned long)-1;
; 1080 : 
; 1081 :     Log(LOG_DEBUG_WMI,__LINE__,">> WMISysPerf");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf?$AA@
  00006	68 39 04 00 00	 push	 1081			; 00000439H
  0000b	6a 40		 push	 64			; 00000040H
  0000d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1082 : 
; 1083 :     if(PerfRawData_PerfDisk_PhysicalDisk!=0)

  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  0001c	74 14		 je	 SHORT $LN11@WMISystemP

; 1084 :     {
; 1085 :         WMI("Win32_PerfRawData_PerfDisk_PhysicalDisk",&PerfRawData_PerfDisk_PhysicalDisk);

  0001e	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA
  00023	33 d2		 xor	 edx, edx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Physi@
  0002a	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0002f	83 c4 04	 add	 esp, 4
$LN11@WMISystemP:

; 1086 :     }
; 1087 : 
; 1088 :     if(PerfRawData_PerfNet_Redirector!=0)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00039	74 14		 je	 SHORT $LN13@WMISystemP

; 1089 :     {
; 1090 :         WMI("Win32_PerfRawData_PerfNet_Redirector",&PerfRawData_PerfNet_Redirector);

  0003b	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA
  00040	33 d2		 xor	 edx, edx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redire@
  00047	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0004c	83 c4 04	 add	 esp, 4
$LN13@WMISystemP:

; 1091 :     }
; 1092 : 
; 1093 :     if(PerfRawData_PerfOS_Cache!=0)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00056	74 14		 je	 SHORT $LN15@WMISystemP

; 1094 :     {
; 1095 :         WMI("Win32_PerfRawData_PerfOS_Cache",&PerfRawData_PerfOS_Cache);

  00058	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA
  0005d	33 d2		 xor	 edx, edx
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache?$AA@
  00064	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00069	83 c4 04	 add	 esp, 4
$LN15@WMISystemP:

; 1096 :     }
; 1097 : 
; 1098 :     if(PerfRawData_PerfOS_Memory!=0)

  0006c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00073	74 14		 je	 SHORT $LN17@WMISystemP

; 1099 :     {
; 1100 :         WMI("Win32_PerfRawData_PerfOS_Memory",&PerfRawData_PerfOS_Memory);

  00075	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA
  0007a	33 d2		 xor	 edx, edx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory?$AA@
  00081	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00086	83 c4 04	 add	 esp, 4
$LN17@WMISystemP:

; 1101 :     }
; 1102 : 
; 1103 :     if(PerfRawData_PerfOS_Objects!=0)

  00089	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00090	74 14		 je	 SHORT $LN19@WMISystemP

; 1104 :     {
; 1105 :         WMI("Win32_PerfRawData_PerfOS_Objects",&PerfRawData_PerfOS_Objects);

  00092	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA
  00097	33 d2		 xor	 edx, edx
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Objects@
  0009e	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000a3	83 c4 04	 add	 esp, 4
$LN19@WMISystemP:

; 1106 :     }
; 1107 : 
; 1108 :     if(PerfRawData_PerfOS_PagingFile!=0)

  000a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000ad	74 14		 je	 SHORT $LN21@WMISystemP

; 1109 :     {
; 1110 :         WMI("Win32_PerfRawData_PerfOS_PagingFile",&PerfRawData_PerfOS_PagingFile);

  000af	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA
  000b4	33 d2		 xor	 edx, edx
  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_PagingF@
  000bb	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000c0	83 c4 04	 add	 esp, 4
$LN21@WMISystemP:

; 1111 :     }
; 1112 : 
; 1113 :     if(PerfRawData_PerfOS_Processor!=0)

  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000ca	74 14		 je	 SHORT $LN23@WMISystemP

; 1114 :     {
; 1115 :         WMI("Win32_PerfRawData_PerfOS_Processor",&PerfRawData_PerfOS_Processor);

  000cc	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA
  000d1	33 d2		 xor	 edx, edx
  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Process@
  000d8	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000dd	83 c4 04	 add	 esp, 4
$LN23@WMISystemP:

; 1116 :     }
; 1117 : 
; 1118 :     if(PerfRawData_PerfOS_System!=0)

  000e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000e7	74 14		 je	 SHORT $LN25@WMISystemP

; 1119 :     {
; 1120 :         WMI("Win32_PerfRawData_PerfOS_System",&PerfRawData_PerfOS_System);

  000e9	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA
  000ee	33 d2		 xor	 edx, edx
  000f0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System?$AA@
  000f5	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000fa	83 c4 04	 add	 esp, 4
$LN25@WMISystemP:

; 1121 :     }
; 1122 : 
; 1123 :     Log(LOG_DEBUG_WMI,__LINE__,"<< WMISysPerf");

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf?$AA@
  00102	68 63 04 00 00	 push	 1123			; 00000463H
  00107	6a 40		 push	 64			; 00000040H
  00109	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	59		 pop	 ecx

; 1124 : }

  00112	c3		 ret	 0
?WMISystemPerformance@@YAXXZ ENDP			; WMISystemPerformance
_TEXT	ENDS
PUBLIC	?WMISystemVolumes@@YAXXZ			; WMISystemVolumes
; Function compile flags: /Ogtpy
;	COMDAT ?WMISystemVolumes@@YAXXZ
_TEXT	SEGMENT
?WMISystemVolumes@@YAXXZ PROC				; WMISystemVolumes, COMDAT

; 1030 : {

  00000	51		 push	 ecx

; 1031 :     static unsigned long Volume = (unsigned long)-1;
; 1032 : 
; 1033 :     Log(LOG_DEBUG_WMI,__LINE__,">> WMISysVols");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols?$AA@
  00006	68 09 04 00 00	 push	 1033			; 00000409H
  0000b	6a 40		 push	 64			; 00000040H
  0000d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1034 : 
; 1035 :     //always check both because there may be moments system cannot
; 1036 :     //detect a network connection and it always exist at least one 
; 1037 :     //logical disk
; 1038 : #ifdef _GET_WMI_LOGICALDISK
; 1039 :     WMI("Win32_LogicalDisk");
; 1040 : #endif
; 1041 : 
; 1042 :     WMI("Win32_NetworkConnection");

  00015	6a 00		 push	 0
  00017	33 d2		 xor	 edx, edx
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@NLCFKEJK@Win32_NetworkConnection?$AA@
  0001e	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00023	83 c4 04	 add	 esp, 4

; 1043 : 
; 1044 :     if(Volume!=0)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA, 0
  0002d	74 14		 je	 SHORT $LN6@WMISystemV

; 1045 :     {
; 1046 :         WMI("Win32_Volume",&Volume);

  0002f	68 00 00 00 00	 push	 OFFSET ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA
  00034	33 d2		 xor	 edx, edx
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0N@NNCPDPIH@Win32_Volume?$AA@
  0003b	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00040	83 c4 04	 add	 esp, 4
$LN6@WMISystemV:

; 1047 :     }
; 1048 : 
; 1049 :     Log(LOG_DEBUG_WMI,__LINE__,"<< WMISysVols");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols?$AA@
  00048	68 19 04 00 00	 push	 1049			; 00000419H
  0004d	6a 40		 push	 64			; 00000040H
  0004f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	59		 pop	 ecx

; 1050 : }

  00058	c3		 ret	 0
?WMISystemVolumes@@YAXXZ ENDP				; WMISystemVolumes
_TEXT	ENDS
PUBLIC	?ThreadWMI@@YGIPAX@Z				; ThreadWMI
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?ThreadWMI@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$13
	DD	0cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$15
__ehfuncinfo$?ThreadWMI@@YGIPAX@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?ThreadWMI@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
; File e:\tools\sysstatus\wmi.cpp
xdata$x	ENDS
;	COMDAT ?ThreadWMI@@YGIPAX@Z
_TEXT	SEGMENT
_hwInfo$ = -360						; size = 24
_util$ = -336						; size = 24
$T237182 = -312						; size = 8
$T236985 = -312						; size = 8
$T236788 = -312						; size = 8
$T236611 = -312						; size = 8
$T236395 = -312						; size = 8
$T236197 = -312						; size = 8
$T236000 = -312						; size = 8
$T235803 = -312						; size = 8
_timeElapsed$ = -312					; size = 4
$T232228 = -312						; size = 4
$T232227 = -312						; size = 4
$T232226 = -312						; size = 4
$T232225 = -312						; size = 4
$T232224 = -312						; size = 4
$T232223 = -312						; size = 4
$T232222 = -312						; size = 4
$T232221 = -312						; size = 4
_sysInfo$ = -304					; size = 24
_memory$ = -280						; size = 24
_net$ = -256						; size = 24
_data$ = -232						; size = 24
_dev$ = -208						; size = 24
_user$ = -184						; size = 24
_seconds$ = -160					; size = 4
_tickStart$ = -160					; size = 8
_ahThreads$ = -152					; size = 80
_tickEnd$ = -72						; size = 8
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?ThreadWMI@@YGIPAX@Z PROC				; ThreadWMI, COMDAT

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?ThreadWMI@@YGIPAX@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00013	50		 push	 eax
  00014	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  0001a	53		 push	 ebx
  0001b	55		 push	 ebp
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c4		 xor	 eax, esp
  00025	50		 push	 eax
  00026	8d 84 24 78 01
	00 00		 lea	 eax, DWORD PTR __$EHRec$[esp+388]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 801  :     DWORD threads = 0;

  00033	33 db		 xor	 ebx, ebx

; 802  :     unsigned int uiThreadId = 0;
; 803  :     HANDLE ahThreads[20] = {0};

  00035	6a 4c		 push	 76			; 0000004cH
  00037	8d 84 24 f4 00
	00 00		 lea	 eax, DWORD PTR _ahThreads$[esp+396]
  0003e	53		 push	 ebx
  0003f	50		 push	 eax
  00040	33 ed		 xor	 ebp, ebp
  00042	89 9c 24 f8 00
	00 00		 mov	 DWORD PTR _ahThreads$[esp+400], ebx
  00049	e8 00 00 00 00	 call	 _memset
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 804  : 
; 805  : 	Log(LOG_DEBUG_WMI,__LINE__,">> ThrdWMI, In");

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IOMMKEOB@?$DO?$DO?5ThrdWMI?0?5In?$AA@
  00056	68 25 03 00 00	 push	 805			; 00000325H
  0005b	6a 40		 push	 64			; 00000040H
  0005d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 806  : 
; 807  :     unsigned __int64 tickStart = SysTick;

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 808  : 
; 809  :     //HW ************
; 810  :     vector<string> hwInfo(32);

  0006b	6a 20		 push	 32			; 00000020H
  0006d	8d 4c 24 20	 lea	 ecx, DWORD PTR _hwInfo$[esp+392]
  00071	51		 push	 ecx
  00072	89 84 24 ec 00
	00 00		 mov	 DWORD PTR _tickStart$[esp+396], eax
  00079	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0007e	89 9c 24 80 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+396], ebx

; 811  : 
; 812  :     hwInfo[0] = "HardwareInfo";

  00085	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00089	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0008d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00092	f7 e9		 imul	 ecx
  00094	03 d1		 add	 edx, ecx
  00096	c1 fa 04	 sar	 edx, 4
  00099	8b c2		 mov	 eax, edx
  0009b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009e	03 c2		 add	 eax, edx
  000a0	75 05		 jne	 SHORT $LN32@ThreadWMI
  000a2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN32@ThreadWMI:
  000a7	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  000ab	6a 0c		 push	 12			; 0000000cH
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FBNILPME@HardwareInfo?$AA@
  000b2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 813  :     hwInfo[1] = "Hardware Information";

  000b7	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  000bb	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  000bf	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000c4	f7 e9		 imul	 ecx
  000c6	03 d1		 add	 edx, ecx
  000c8	c1 fa 04	 sar	 edx, 4
  000cb	8b ca		 mov	 ecx, edx
  000cd	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d0	03 ca		 add	 ecx, edx
  000d2	83 f9 01	 cmp	 ecx, 1
  000d5	77 05		 ja	 SHORT $LN46@ThreadWMI
  000d7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN46@ThreadWMI:
  000dc	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  000e0	6a 14		 push	 20			; 00000014H
  000e2	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MGDJDLAD@Hardware?5Information?$AA@
  000ea	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 814  : 
; 815  :     hwInfo[2] = "Win32_1394Controller";

  000ef	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  000f3	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  000f7	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  000fc	f7 e9		 imul	 ecx
  000fe	03 d1		 add	 edx, ecx
  00100	c1 fa 04	 sar	 edx, 4
  00103	8b c2		 mov	 eax, edx
  00105	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00108	03 c2		 add	 eax, edx
  0010a	83 f8 02	 cmp	 eax, 2
  0010d	77 05		 ja	 SHORT $LN60@ThreadWMI
  0010f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN60@ThreadWMI:
  00114	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00118	6a 14		 push	 20			; 00000014H
  0011a	83 c1 38	 add	 ecx, 56			; 00000038H
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GIOJHHEG@Win32_1394Controller?$AA@
  00122	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 816  :     hwInfo[3] = "Win32_BaseBoard";

  00127	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0012b	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0012f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00134	f7 e9		 imul	 ecx
  00136	03 d1		 add	 edx, ecx
  00138	c1 fa 04	 sar	 edx, 4
  0013b	8b ca		 mov	 ecx, edx
  0013d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00140	03 ca		 add	 ecx, edx
  00142	83 f9 03	 cmp	 ecx, 3
  00145	77 05		 ja	 SHORT $LN74@ThreadWMI
  00147	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN74@ThreadWMI:
  0014c	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00150	6a 0f		 push	 15			; 0000000fH
  00152	83 c1 54	 add	 ecx, 84			; 00000054H
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FKIDHCEN@Win32_BaseBoard?$AA@
  0015a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 817  :     hwInfo[4] = "Win32_Battery";

  0015f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00163	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00167	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0016c	f7 e9		 imul	 ecx
  0016e	03 d1		 add	 edx, ecx
  00170	c1 fa 04	 sar	 edx, 4
  00173	8b c2		 mov	 eax, edx
  00175	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00178	03 c2		 add	 eax, edx
  0017a	83 f8 04	 cmp	 eax, 4
  0017d	77 05		 ja	 SHORT $LN88@ThreadWMI
  0017f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN88@ThreadWMI:
  00184	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00188	6a 0d		 push	 13			; 0000000dH
  0018a	83 c1 70	 add	 ecx, 112		; 00000070H
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CLAKILND@Win32_Battery?$AA@
  00192	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 818  :     hwInfo[5] = "Win32_BIOS";

  00197	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0019b	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0019f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001a4	f7 e9		 imul	 ecx
  001a6	03 d1		 add	 edx, ecx
  001a8	c1 fa 04	 sar	 edx, 4
  001ab	8b ca		 mov	 ecx, edx
  001ad	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  001b0	03 ca		 add	 ecx, edx
  001b2	83 f9 05	 cmp	 ecx, 5
  001b5	77 05		 ja	 SHORT $LN102@ThreadWMI
  001b7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN102@ThreadWMI:
  001bc	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  001c0	6a 0a		 push	 10			; 0000000aH
  001c2	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JLLHHBAL@Win32_BIOS?$AA@
  001cd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 819  :     hwInfo[6] = "Win32_Bus";

  001d2	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  001d6	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  001da	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  001df	f7 e9		 imul	 ecx
  001e1	03 d1		 add	 edx, ecx
  001e3	c1 fa 04	 sar	 edx, 4
  001e6	8b c2		 mov	 eax, edx
  001e8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001eb	03 c2		 add	 eax, edx
  001ed	83 f8 06	 cmp	 eax, 6
  001f0	77 05		 ja	 SHORT $LN116@ThreadWMI
  001f2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN116@ThreadWMI:
  001f7	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  001fb	6a 09		 push	 9
  001fd	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00203	68 00 00 00 00	 push	 OFFSET ??_C@_09HPFDNOIF@Win32_Bus?$AA@
  00208	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 820  :     hwInfo[7] = "Win32_CDROMDrive";

  0020d	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00211	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00215	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0021a	f7 e9		 imul	 ecx
  0021c	03 d1		 add	 edx, ecx
  0021e	c1 fa 04	 sar	 edx, 4
  00221	8b ca		 mov	 ecx, edx
  00223	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00226	03 ca		 add	 ecx, edx
  00228	83 f9 07	 cmp	 ecx, 7
  0022b	77 05		 ja	 SHORT $LN130@ThreadWMI
  0022d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN130@ThreadWMI:
  00232	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00236	6a 10		 push	 16			; 00000010H
  00238	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  0023e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive?$AA@
  00243	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 821  :     hwInfo[8] = "Win32_DMAChannel";

  00248	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0024c	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00250	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00255	f7 e9		 imul	 ecx
  00257	03 d1		 add	 edx, ecx
  00259	c1 fa 04	 sar	 edx, 4
  0025c	8b c2		 mov	 eax, edx
  0025e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00261	03 c2		 add	 eax, edx
  00263	83 f8 08	 cmp	 eax, 8
  00266	77 05		 ja	 SHORT $LN144@ThreadWMI
  00268	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN144@ThreadWMI:
  0026d	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00271	6a 10		 push	 16			; 00000010H
  00273	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ILOPCCAP@Win32_DMAChannel?$AA@
  0027e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 822  :     hwInfo[9] = "Win32_DriverVXD";

  00283	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00287	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0028b	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00290	f7 e9		 imul	 ecx
  00292	03 d1		 add	 edx, ecx
  00294	c1 fa 04	 sar	 edx, 4
  00297	8b ca		 mov	 ecx, edx
  00299	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0029c	03 ca		 add	 ecx, edx
  0029e	83 f9 09	 cmp	 ecx, 9
  002a1	77 05		 ja	 SHORT $LN158@ThreadWMI
  002a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN158@ThreadWMI:
  002a8	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  002ac	6a 0f		 push	 15			; 0000000fH
  002ae	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DGOGJGDP@Win32_DriverVXD?$AA@
  002b9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 823  :     hwInfo[10] = "Win32_FloppyController";

  002be	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  002c2	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  002c6	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  002cb	f7 e9		 imul	 ecx
  002cd	03 d1		 add	 edx, ecx
  002cf	c1 fa 04	 sar	 edx, 4
  002d2	8b c2		 mov	 eax, edx
  002d4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002d7	03 c2		 add	 eax, edx
  002d9	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  002dc	77 05		 ja	 SHORT $LN172@ThreadWMI
  002de	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN172@ThreadWMI:
  002e3	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  002e7	6a 16		 push	 22			; 00000016H
  002e9	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  002ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GBOCBJMM@Win32_FloppyController?$AA@
  002f4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 824  :     hwInfo[11] = "Win32_FloppyDrive";

  002f9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  002fd	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00301	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00306	f7 e9		 imul	 ecx
  00308	03 d1		 add	 edx, ecx
  0030a	c1 fa 04	 sar	 edx, 4
  0030d	8b ca		 mov	 ecx, edx
  0030f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00312	03 ca		 add	 ecx, edx
  00314	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00317	77 05		 ja	 SHORT $LN186@ThreadWMI
  00319	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN186@ThreadWMI:
  0031e	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00322	6a 11		 push	 17			; 00000011H
  00324	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  0032a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MGJAFBFH@Win32_FloppyDrive?$AA@
  0032f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  :     hwInfo[12] = "Win32_HeatPipe";

  00334	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00338	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0033c	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00341	f7 e9		 imul	 ecx
  00343	03 d1		 add	 edx, ecx
  00345	c1 fa 04	 sar	 edx, 4
  00348	8b c2		 mov	 eax, edx
  0034a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0034d	03 c2		 add	 eax, edx
  0034f	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00352	77 05		 ja	 SHORT $LN200@ThreadWMI
  00354	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN200@ThreadWMI:
  00359	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  0035d	6a 0e		 push	 14			; 0000000eH
  0035f	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  00365	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MCPBPNON@Win32_HeatPipe?$AA@
  0036a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 826  :     hwInfo[13] = "Win32_Keyboard";

  0036f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00373	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00377	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0037c	f7 e9		 imul	 ecx
  0037e	03 d1		 add	 edx, ecx
  00380	c1 fa 04	 sar	 edx, 4
  00383	8b ca		 mov	 ecx, edx
  00385	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00388	03 ca		 add	 ecx, edx
  0038a	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0038d	77 05		 ja	 SHORT $LN214@ThreadWMI
  0038f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN214@ThreadWMI:
  00394	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00398	6a 0e		 push	 14			; 0000000eH
  0039a	81 c1 6c 01 00
	00		 add	 ecx, 364		; 0000016cH
  003a0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IGJIBAJA@Win32_Keyboard?$AA@
  003a5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 827  :     hwInfo[14] = "Win32_MotherboardDevice";

  003aa	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  003ae	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  003b2	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  003b7	f7 e9		 imul	 ecx
  003b9	03 d1		 add	 edx, ecx
  003bb	c1 fa 04	 sar	 edx, 4
  003be	8b c2		 mov	 eax, edx
  003c0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  003c3	03 c2		 add	 eax, edx
  003c5	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  003c8	77 05		 ja	 SHORT $LN228@ThreadWMI
  003ca	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN228@ThreadWMI:
  003cf	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  003d3	6a 17		 push	 23			; 00000017H
  003d5	81 c1 88 01 00
	00		 add	 ecx, 392		; 00000188H
  003db	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice?$AA@
  003e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 828  :     hwInfo[15] = "Win32_OnBoardDevice";

  003e5	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  003e9	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  003ed	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  003f2	f7 e9		 imul	 ecx
  003f4	03 d1		 add	 edx, ecx
  003f6	c1 fa 04	 sar	 edx, 4
  003f9	8b ca		 mov	 ecx, edx
  003fb	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  003fe	03 ca		 add	 ecx, edx
  00400	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00403	77 05		 ja	 SHORT $LN242@ThreadWMI
  00405	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN242@ThreadWMI:
  0040a	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  0040e	6a 13		 push	 19			; 00000013H
  00410	81 c1 a4 01 00
	00		 add	 ecx, 420		; 000001a4H
  00416	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice?$AA@
  0041b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 829  :     hwInfo[16] = "Win32_IDEController";

  00420	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00424	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00428	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0042d	f7 e9		 imul	 ecx
  0042f	03 d1		 add	 edx, ecx
  00431	c1 fa 04	 sar	 edx, 4
  00434	8b c2		 mov	 eax, edx
  00436	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00439	03 c2		 add	 eax, edx
  0043b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0043e	77 05		 ja	 SHORT $LN256@ThreadWMI
  00440	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN256@ThreadWMI:
  00445	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00449	6a 13		 push	 19			; 00000013H
  0044b	81 c1 c0 01 00
	00		 add	 ecx, 448		; 000001c0H
  00451	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FMCMMJCA@Win32_IDEController?$AA@
  00456	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 830  :     hwInfo[17] = "Win32_InfraredDevice";

  0045b	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0045f	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00463	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00468	f7 e9		 imul	 ecx
  0046a	03 d1		 add	 edx, ecx
  0046c	c1 fa 04	 sar	 edx, 4
  0046f	8b ca		 mov	 ecx, edx
  00471	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00474	03 ca		 add	 ecx, edx
  00476	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00479	77 05		 ja	 SHORT $LN270@ThreadWMI
  0047b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN270@ThreadWMI:
  00480	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00484	6a 14		 push	 20			; 00000014H
  00486	81 c1 dc 01 00
	00		 add	 ecx, 476		; 000001dcH
  0048c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EEIPINHM@Win32_InfraredDevice?$AA@
  00491	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 831  :     hwInfo[18] = "Win32_IRQResource";

  00496	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0049a	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0049e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  004a3	f7 e9		 imul	 ecx
  004a5	03 d1		 add	 edx, ecx
  004a7	c1 fa 04	 sar	 edx, 4
  004aa	8b c2		 mov	 eax, edx
  004ac	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004af	03 c2		 add	 eax, edx
  004b1	83 f8 12	 cmp	 eax, 18			; 00000012H
  004b4	77 05		 ja	 SHORT $LN284@ThreadWMI
  004b6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN284@ThreadWMI:
  004bb	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  004bf	6a 11		 push	 17			; 00000011H
  004c1	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  004c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MGLAEOHD@Win32_IRQResource?$AA@
  004cc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 832  :     hwInfo[19] = "Win32_PCMCIAController";

  004d1	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  004d5	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  004d9	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  004de	f7 e9		 imul	 ecx
  004e0	03 d1		 add	 edx, ecx
  004e2	c1 fa 04	 sar	 edx, 4
  004e5	8b ca		 mov	 ecx, edx
  004e7	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  004ea	03 ca		 add	 ecx, edx
  004ec	83 f9 13	 cmp	 ecx, 19			; 00000013H
  004ef	77 05		 ja	 SHORT $LN298@ThreadWMI
  004f1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN298@ThreadWMI:
  004f6	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  004fa	6a 16		 push	 22			; 00000016H
  004fc	81 c1 14 02 00
	00		 add	 ecx, 532		; 00000214H
  00502	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CNGPGCKD@Win32_PCMCIAController?$AA@
  00507	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 833  :     hwInfo[20] = "Win32_PointingDevice";

  0050c	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00510	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00514	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00519	f7 e9		 imul	 ecx
  0051b	03 d1		 add	 edx, ecx
  0051d	c1 fa 04	 sar	 edx, 4
  00520	8b c2		 mov	 eax, edx
  00522	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00525	03 c2		 add	 eax, edx
  00527	83 f8 14	 cmp	 eax, 20			; 00000014H
  0052a	77 05		 ja	 SHORT $LN312@ThreadWMI
  0052c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN312@ThreadWMI:
  00531	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00535	6a 14		 push	 20			; 00000014H
  00537	81 c1 30 02 00
	00		 add	 ecx, 560		; 00000230H
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MJMHBKMK@Win32_PointingDevice?$AA@
  00542	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 834  :     hwInfo[21] = "Win32_PortConnector";

  00547	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0054b	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0054f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00554	f7 e9		 imul	 ecx
  00556	03 d1		 add	 edx, ecx
  00558	c1 fa 04	 sar	 edx, 4
  0055b	8b ca		 mov	 ecx, edx
  0055d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00560	03 ca		 add	 ecx, edx
  00562	83 f9 15	 cmp	 ecx, 21			; 00000015H
  00565	77 05		 ja	 SHORT $LN326@ThreadWMI
  00567	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN326@ThreadWMI:
  0056c	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00570	6a 13		 push	 19			; 00000013H
  00572	81 c1 4c 02 00
	00		 add	 ecx, 588		; 0000024cH
  00578	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BFHBBNBL@Win32_PortConnector?$AA@
  0057d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 835  :     hwInfo[22] = "Win32_PortResource";

  00582	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00586	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0058a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0058f	f7 e9		 imul	 ecx
  00591	03 d1		 add	 edx, ecx
  00593	c1 fa 04	 sar	 edx, 4
  00596	8b c2		 mov	 eax, edx
  00598	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0059b	03 c2		 add	 eax, edx
  0059d	83 f8 16	 cmp	 eax, 22			; 00000016H
  005a0	77 05		 ja	 SHORT $LN340@ThreadWMI
  005a2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN340@ThreadWMI:
  005a7	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  005ab	6a 12		 push	 18			; 00000012H
  005ad	81 c1 68 02 00
	00		 add	 ecx, 616		; 00000268H
  005b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JJNGNMBL@Win32_PortResource?$AA@
  005b8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 836  :     hwInfo[23] = "Win32_PnPEntity";

  005bd	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  005c1	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  005c5	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  005ca	f7 e9		 imul	 ecx
  005cc	03 d1		 add	 edx, ecx
  005ce	c1 fa 04	 sar	 edx, 4
  005d1	8b ca		 mov	 ecx, edx
  005d3	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  005d6	03 ca		 add	 ecx, edx
  005d8	83 f9 17	 cmp	 ecx, 23			; 00000017H
  005db	77 05		 ja	 SHORT $LN354@ThreadWMI
  005dd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN354@ThreadWMI:
  005e2	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  005e6	6a 0f		 push	 15			; 0000000fH
  005e8	81 c1 84 02 00
	00		 add	 ecx, 644		; 00000284H
  005ee	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EHCOOLPP@Win32_PnPEntity?$AA@
  005f3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : #ifdef _GET_WMI_PRINTER
; 838  :     hwInfo[] = "Win32_Printer";
; 839  : #endif
; 840  :     hwInfo[24] = "Win32_PrinterDriver";

  005f8	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  005fc	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00600	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00605	f7 e9		 imul	 ecx
  00607	03 d1		 add	 edx, ecx
  00609	c1 fa 04	 sar	 edx, 4
  0060c	8b c2		 mov	 eax, edx
  0060e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00611	03 c2		 add	 eax, edx
  00613	83 f8 18	 cmp	 eax, 24			; 00000018H
  00616	77 05		 ja	 SHORT $LN368@ThreadWMI
  00618	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN368@ThreadWMI:
  0061d	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00621	6a 13		 push	 19			; 00000013H
  00623	81 c1 a0 02 00
	00		 add	 ecx, 672		; 000002a0H
  00629	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HLKMDILE@Win32_PrinterDriver?$AA@
  0062e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 841  :     hwInfo[25] = "Win32_Processor";

  00633	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00637	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0063b	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00640	f7 e9		 imul	 ecx
  00642	03 d1		 add	 edx, ecx
  00644	c1 fa 04	 sar	 edx, 4
  00647	8b ca		 mov	 ecx, edx
  00649	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0064c	03 ca		 add	 ecx, edx
  0064e	83 f9 19	 cmp	 ecx, 25			; 00000019H
  00651	77 05		 ja	 SHORT $LN382@ThreadWMI
  00653	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN382@ThreadWMI:
  00658	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  0065c	6a 0f		 push	 15			; 0000000fH
  0065e	81 c1 bc 02 00
	00		 add	 ecx, 700		; 000002bcH
  00664	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OJJOBJJP@Win32_Processor?$AA@
  00669	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 842  :     hwInfo[26] = "Win32_SCSIController";

  0066e	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00672	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00676	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0067b	f7 e9		 imul	 ecx
  0067d	03 d1		 add	 edx, ecx
  0067f	c1 fa 04	 sar	 edx, 4
  00682	8b c2		 mov	 eax, edx
  00684	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00687	03 c2		 add	 eax, edx
  00689	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  0068c	77 05		 ja	 SHORT $LN396@ThreadWMI
  0068e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN396@ThreadWMI:
  00693	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00697	6a 14		 push	 20			; 00000014H
  00699	81 c1 d8 02 00
	00		 add	 ecx, 728		; 000002d8H
  0069f	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OGHHAMBD@Win32_SCSIController?$AA@
  006a4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 843  :     hwInfo[27] = "Win32_SerialPort";

  006a9	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  006ad	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  006b1	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  006b6	f7 e9		 imul	 ecx
  006b8	03 d1		 add	 edx, ecx
  006ba	c1 fa 04	 sar	 edx, 4
  006bd	8b ca		 mov	 ecx, edx
  006bf	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  006c2	03 ca		 add	 ecx, edx
  006c4	83 f9 1b	 cmp	 ecx, 27			; 0000001bH
  006c7	77 05		 ja	 SHORT $LN410@ThreadWMI
  006c9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN410@ThreadWMI:
  006ce	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  006d2	6a 10		 push	 16			; 00000010H
  006d4	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  006da	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DLHLCIMJ@Win32_SerialPort?$AA@
  006df	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 844  :     hwInfo[28] = "Win32_SerialPortConfiguration";

  006e4	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  006e8	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  006ec	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  006f1	f7 e9		 imul	 ecx
  006f3	03 d1		 add	 edx, ecx
  006f5	c1 fa 04	 sar	 edx, 4
  006f8	8b c2		 mov	 eax, edx
  006fa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  006fd	03 c2		 add	 eax, edx
  006ff	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  00702	77 05		 ja	 SHORT $LN424@ThreadWMI
  00704	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN424@ThreadWMI:
  00709	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  0070d	6a 1d		 push	 29			; 0000001dH
  0070f	81 c1 10 03 00
	00		 add	 ecx, 784		; 00000310H
  00715	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration?$AA@
  0071a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 845  :     hwInfo[29] = "Win32_SoundDevice";

  0071f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00723	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00727	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0072c	f7 e9		 imul	 ecx
  0072e	03 d1		 add	 edx, ecx
  00730	c1 fa 04	 sar	 edx, 4
  00733	8b ca		 mov	 ecx, edx
  00735	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00738	03 ca		 add	 ecx, edx
  0073a	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  0073d	77 05		 ja	 SHORT $LN438@ThreadWMI
  0073f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN438@ThreadWMI:
  00744	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00748	6a 11		 push	 17			; 00000011H
  0074a	81 c1 2c 03 00
	00		 add	 ecx, 812		; 0000032cH
  00750	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@INJPMPPD@Win32_SoundDevice?$AA@
  00755	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 846  :     hwInfo[30] = "Win32_USBController";

  0075a	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  0075e	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  00762	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00767	f7 e9		 imul	 ecx
  00769	03 d1		 add	 edx, ecx
  0076b	c1 fa 04	 sar	 edx, 4
  0076e	8b c2		 mov	 eax, edx
  00770	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00773	03 c2		 add	 eax, edx
  00775	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00778	77 05		 ja	 SHORT $LN452@ThreadWMI
  0077a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN452@ThreadWMI:
  0077f	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  00783	6a 13		 push	 19			; 00000013H
  00785	81 c1 48 03 00
	00		 add	 ecx, 840		; 00000348H
  0078b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KNIHCNGM@Win32_USBController?$AA@
  00790	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 847  :     hwInfo[31] = "Win32_VideoController";

  00795	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  00799	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  0079d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  007a2	f7 e9		 imul	 ecx
  007a4	03 d1		 add	 edx, ecx
  007a6	c1 fa 04	 sar	 edx, 4
  007a9	8b ca		 mov	 ecx, edx
  007ab	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  007ae	03 ca		 add	 ecx, edx
  007b0	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  007b3	77 05		 ja	 SHORT $LN466@ThreadWMI
  007b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN466@ThreadWMI:
  007ba	8b 4c 24 28	 mov	 ecx, DWORD PTR _hwInfo$[esp+400]
  007be	6a 15		 push	 21			; 00000015H
  007c0	81 c1 64 03 00
	00		 add	 ecx, 868		; 00000364H
  007c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IOBPPLKC@Win32_VideoController?$AA@
  007cb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 848  : 
; 849  :     if(StartThread(hwInfo[0],ThreadWMIClass,(LPVOID)&hwInfo,0,&ahThreads[threads]))

  007d0	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  007d4	2b 4c 24 28	 sub	 ecx, DWORD PTR _hwInfo$[esp+400]
  007d8	8d 54 24 1c	 lea	 edx, DWORD PTR _hwInfo$[esp+388]
  007dc	53		 push	 ebx
  007dd	52		 push	 edx
  007de	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  007e3	f7 e9		 imul	 ecx
  007e5	03 d1		 add	 edx, ecx
  007e7	c1 fa 04	 sar	 edx, 4
  007ea	8b c2		 mov	 eax, edx
  007ec	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007ef	03 c2		 add	 eax, edx
  007f1	8d b4 24 f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+396]
  007f8	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  007fd	75 05		 jne	 SHORT $LN480@ThreadWMI
  007ff	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN480@ThreadWMI:
  00804	8b 44 24 30	 mov	 eax, DWORD PTR _hwInfo$[esp+408]
  00808	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0080b	8b cc		 mov	 ecx, esp
  0080d	89 64 24 70	 mov	 DWORD PTR $T232221[esp+424], esp
  00811	6a ff		 push	 -1
  00813	53		 push	 ebx
  00814	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0081b	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  0081e	50		 push	 eax
  0081f	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00822	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00827	c6 84 24 a4 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+432], 1
  0082f	88 9c 24 a4 01
	00 00		 mov	 BYTE PTR __$EHRec$[esp+432], bl
  00836	8b d6		 mov	 edx, esi
  00838	8b cf		 mov	 ecx, edi
  0083a	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  0083f	83 c4 24	 add	 esp, 36			; 00000024H
  00842	3a c3		 cmp	 al, bl
  00844	74 05		 je	 SHORT $LN11@ThreadWMI

; 850  :     {
; 851  :         threads++;

  00846	bd 01 00 00 00	 mov	 ebp, 1
$LN11@ThreadWMI:

; 852  :     }
; 853  : 
; 854  :     //HW ************
; 855  : 
; 856  :     //DATA **********
; 857  :     vector<string> data(6);

  0084b	6a 06		 push	 6
  0084d	8d 8c 24 a0 00
	00 00		 lea	 ecx, DWORD PTR _data$[esp+392]
  00854	51		 push	 ecx
  00855	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0085a	c6 84 24 80 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+396], 2

; 858  : 
; 859  :     data[0] = "DataStorage";

  00862	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  00869	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  00870	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00875	f7 e9		 imul	 ecx
  00877	03 d1		 add	 edx, ecx
  00879	c1 fa 04	 sar	 edx, 4
  0087c	8b c2		 mov	 eax, edx
  0087e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00881	03 c2		 add	 eax, edx
  00883	75 05		 jne	 SHORT $LN514@ThreadWMI
  00885	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN514@ThreadWMI:
  0088a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  00891	6a 0b		 push	 11			; 0000000bH
  00893	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PNBJJAPO@DataStorage?$AA@
  00898	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 860  :     data[1] = "Disk and Partitions Information";

  0089d	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  008a4	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  008ab	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  008b0	f7 e9		 imul	 ecx
  008b2	03 d1		 add	 edx, ecx
  008b4	c1 fa 04	 sar	 edx, 4
  008b7	8b ca		 mov	 ecx, edx
  008b9	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  008bc	03 ca		 add	 ecx, edx
  008be	83 f9 01	 cmp	 ecx, 1
  008c1	77 05		 ja	 SHORT $LN528@ThreadWMI
  008c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN528@ThreadWMI:
  008c8	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  008cf	6a 1f		 push	 31			; 0000001fH
  008d1	83 c1 1c	 add	 ecx, 28			; 0000001cH
  008d4	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information?$AA@
  008d9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 861  : 
; 862  :     data[2] = "Win32_DiskDrive";

  008de	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  008e5	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  008ec	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  008f1	f7 e9		 imul	 ecx
  008f3	03 d1		 add	 edx, ecx
  008f5	c1 fa 04	 sar	 edx, 4
  008f8	8b c2		 mov	 eax, edx
  008fa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  008fd	03 c2		 add	 eax, edx
  008ff	83 f8 02	 cmp	 eax, 2
  00902	77 05		 ja	 SHORT $LN542@ThreadWMI
  00904	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN542@ThreadWMI:
  00909	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  00910	6a 0f		 push	 15			; 0000000fH
  00912	83 c1 38	 add	 ecx, 56			; 00000038H
  00915	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CJPFNKBD@Win32_DiskDrive?$AA@
  0091a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 863  :     data[3] = "Win32_DiskPartition";

  0091f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  00926	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  0092d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00932	f7 e9		 imul	 ecx
  00934	03 d1		 add	 edx, ecx
  00936	c1 fa 04	 sar	 edx, 4
  00939	8b ca		 mov	 ecx, edx
  0093b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0093e	03 ca		 add	 ecx, edx
  00940	83 f9 03	 cmp	 ecx, 3
  00943	77 05		 ja	 SHORT $LN556@ThreadWMI
  00945	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN556@ThreadWMI:
  0094a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  00951	6a 13		 push	 19			; 00000013H
  00953	83 c1 54	 add	 ecx, 84			; 00000054H
  00956	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GBMGFCLI@Win32_DiskPartition?$AA@
  0095b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 864  :     data[4] = "Win32_PhysicalMedia";

  00960	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  00967	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  0096e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00973	f7 e9		 imul	 ecx
  00975	03 d1		 add	 edx, ecx
  00977	c1 fa 04	 sar	 edx, 4
  0097a	8b c2		 mov	 eax, edx
  0097c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0097f	03 c2		 add	 eax, edx
  00981	83 f8 04	 cmp	 eax, 4
  00984	77 05		 ja	 SHORT $LN570@ThreadWMI
  00986	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN570@ThreadWMI:
  0098b	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  00992	6a 13		 push	 19			; 00000013H
  00994	83 c1 70	 add	 ecx, 112		; 00000070H
  00997	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia?$AA@
  0099c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 865  :     data[5] = "Win32_TapeDrive";

  009a1	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  009a8	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  009af	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  009b4	f7 e9		 imul	 ecx
  009b6	03 d1		 add	 edx, ecx
  009b8	c1 fa 04	 sar	 edx, 4
  009bb	8b ca		 mov	 ecx, edx
  009bd	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  009c0	03 ca		 add	 ecx, edx
  009c2	83 f9 05	 cmp	 ecx, 5
  009c5	77 05		 ja	 SHORT $LN584@ThreadWMI
  009c7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN584@ThreadWMI:
  009cc	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  009d3	6a 0f		 push	 15			; 0000000fH
  009d5	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  009db	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GLDDIFFN@Win32_TapeDrive?$AA@
  009e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 866  : 
; 867  :     if(StartThread(data[0],ThreadWMIClass,(LPVOID)&data,0,&ahThreads[threads]))

  009e5	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+404]
  009ec	2b 8c 24 a8 00
	00 00		 sub	 ecx, DWORD PTR _data$[esp+400]
  009f3	8d 94 24 9c 00
	00 00		 lea	 edx, DWORD PTR _data$[esp+388]
  009fa	53		 push	 ebx
  009fb	52		 push	 edx
  009fc	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00a01	f7 e9		 imul	 ecx
  00a03	03 d1		 add	 edx, ecx
  00a05	c1 fa 04	 sar	 edx, 4
  00a08	8b c2		 mov	 eax, edx
  00a0a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00a0d	03 c2		 add	 eax, edx
  00a0f	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  00a16	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  00a1b	75 05		 jne	 SHORT $LN598@ThreadWMI
  00a1d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN598@ThreadWMI:
  00a22	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR _data$[esp+408]
  00a29	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00a2c	8b cc		 mov	 ecx, esp
  00a2e	89 64 24 70	 mov	 DWORD PTR $T232222[esp+424], esp
  00a32	6a ff		 push	 -1
  00a34	53		 push	 ebx
  00a35	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00a3c	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00a3f	50		 push	 eax
  00a40	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00a43	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00a48	c6 84 24 a4 01
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+432], 3
  00a50	c6 84 24 a4 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+432], 2
  00a58	8b d6		 mov	 edx, esi
  00a5a	8b cf		 mov	 ecx, edi
  00a5c	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  00a61	83 c4 24	 add	 esp, 36			; 00000024H
  00a64	3a c3		 cmp	 al, bl
  00a66	74 01		 je	 SHORT $LN10@ThreadWMI

; 868  :     {
; 869  :         threads++;

  00a68	45		 inc	 ebp
$LN10@ThreadWMI:

; 870  :     }
; 871  :     //DATA **********
; 872  : 
; 873  :     //MEM ***********
; 874  :     vector<string> memory(10);

  00a69	6a 0a		 push	 10			; 0000000aH
  00a6b	8d 4c 24 70	 lea	 ecx, DWORD PTR _memory$[esp+392]
  00a6f	51		 push	 ecx
  00a70	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00a75	c6 84 24 80 01
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+396], 4

; 875  : 
; 876  :     memory[0] = "Memory";

  00a7d	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00a81	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00a85	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00a8a	f7 e9		 imul	 ecx
  00a8c	03 d1		 add	 edx, ecx
  00a8e	c1 fa 04	 sar	 edx, 4
  00a91	8b c2		 mov	 eax, edx
  00a93	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00a96	03 c2		 add	 eax, edx
  00a98	75 05		 jne	 SHORT $LN632@ThreadWMI
  00a9a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN632@ThreadWMI:
  00a9f	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00aa3	6a 06		 push	 6
  00aa5	68 00 00 00 00	 push	 OFFSET ??_C@_06LEBJIAPJ@Memory?$AA@
  00aaa	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 877  :     memory[1] = "Memory Information";

  00aaf	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00ab3	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00ab7	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00abc	f7 e9		 imul	 ecx
  00abe	03 d1		 add	 edx, ecx
  00ac0	c1 fa 04	 sar	 edx, 4
  00ac3	8b ca		 mov	 ecx, edx
  00ac5	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00ac8	03 ca		 add	 ecx, edx
  00aca	83 f9 01	 cmp	 ecx, 1
  00acd	77 05		 ja	 SHORT $LN646@ThreadWMI
  00acf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN646@ThreadWMI:
  00ad4	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00ad8	6a 12		 push	 18			; 00000012H
  00ada	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00add	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BGPGMIME@Memory?5Information?$AA@
  00ae2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 878  : 
; 879  :     memory[2] = "Win32_CacheMemory";

  00ae7	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00aeb	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00aef	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00af4	f7 e9		 imul	 ecx
  00af6	03 d1		 add	 edx, ecx
  00af8	c1 fa 04	 sar	 edx, 4
  00afb	8b c2		 mov	 eax, edx
  00afd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b00	03 c2		 add	 eax, edx
  00b02	83 f8 02	 cmp	 eax, 2
  00b05	77 05		 ja	 SHORT $LN660@ThreadWMI
  00b07	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN660@ThreadWMI:
  00b0c	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00b10	6a 11		 push	 17			; 00000011H
  00b12	83 c1 38	 add	 ecx, 56			; 00000038H
  00b15	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BKKBKJDE@Win32_CacheMemory?$AA@
  00b1a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 880  :     memory[3] = "Win32_DeviceMemoryAddress";

  00b1f	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00b23	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00b27	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00b2c	f7 e9		 imul	 ecx
  00b2e	03 d1		 add	 edx, ecx
  00b30	c1 fa 04	 sar	 edx, 4
  00b33	8b ca		 mov	 ecx, edx
  00b35	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00b38	03 ca		 add	 ecx, edx
  00b3a	83 f9 03	 cmp	 ecx, 3
  00b3d	77 05		 ja	 SHORT $LN674@ThreadWMI
  00b3f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN674@ThreadWMI:
  00b44	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00b48	6a 19		 push	 25			; 00000019H
  00b4a	83 c1 54	 add	 ecx, 84			; 00000054H
  00b4d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress?$AA@
  00b52	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 881  :     memory[4] = "Win32_MemoryArray";

  00b57	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00b5b	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00b5f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00b64	f7 e9		 imul	 ecx
  00b66	03 d1		 add	 edx, ecx
  00b68	c1 fa 04	 sar	 edx, 4
  00b6b	8b c2		 mov	 eax, edx
  00b6d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00b70	03 c2		 add	 eax, edx
  00b72	83 f8 04	 cmp	 eax, 4
  00b75	77 05		 ja	 SHORT $LN688@ThreadWMI
  00b77	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN688@ThreadWMI:
  00b7c	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00b80	6a 11		 push	 17			; 00000011H
  00b82	83 c1 70	 add	 ecx, 112		; 00000070H
  00b85	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NBCNDILJ@Win32_MemoryArray?$AA@
  00b8a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 882  :     memory[5] = "Win32_MemoryDevice";

  00b8f	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00b93	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00b97	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00b9c	f7 e9		 imul	 ecx
  00b9e	03 d1		 add	 edx, ecx
  00ba0	c1 fa 04	 sar	 edx, 4
  00ba3	8b ca		 mov	 ecx, edx
  00ba5	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00ba8	03 ca		 add	 ecx, edx
  00baa	83 f9 05	 cmp	 ecx, 5
  00bad	77 05		 ja	 SHORT $LN702@ThreadWMI
  00baf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN702@ThreadWMI:
  00bb4	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00bb8	6a 12		 push	 18			; 00000012H
  00bba	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00bc0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MHIIAMPP@Win32_MemoryDevice?$AA@
  00bc5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 883  :     memory[6] = "Win32_PhysicalMemory";

  00bca	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00bce	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00bd2	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00bd7	f7 e9		 imul	 ecx
  00bd9	03 d1		 add	 edx, ecx
  00bdb	c1 fa 04	 sar	 edx, 4
  00bde	8b c2		 mov	 eax, edx
  00be0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00be3	03 c2		 add	 eax, edx
  00be5	83 f8 06	 cmp	 eax, 6
  00be8	77 05		 ja	 SHORT $LN716@ThreadWMI
  00bea	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN716@ThreadWMI:
  00bef	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00bf3	6a 14		 push	 20			; 00000014H
  00bf5	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00bfb	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory?$AA@
  00c00	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 884  :     memory[7] = "Win32_PhysicalMemoryArray";

  00c05	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00c09	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00c0d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00c12	f7 e9		 imul	 ecx
  00c14	03 d1		 add	 edx, ecx
  00c16	c1 fa 04	 sar	 edx, 4
  00c19	8b ca		 mov	 ecx, edx
  00c1b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00c1e	03 ca		 add	 ecx, edx
  00c20	83 f9 07	 cmp	 ecx, 7
  00c23	77 05		 ja	 SHORT $LN730@ThreadWMI
  00c25	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN730@ThreadWMI:
  00c2a	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00c2e	6a 19		 push	 25			; 00000019H
  00c30	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00c36	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray?$AA@
  00c3b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 885  :     memory[8] = "Win32_SMBIOSMemory";

  00c40	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00c44	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00c48	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00c4d	f7 e9		 imul	 ecx
  00c4f	03 d1		 add	 edx, ecx
  00c51	c1 fa 04	 sar	 edx, 4
  00c54	8b c2		 mov	 eax, edx
  00c56	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00c59	03 c2		 add	 eax, edx
  00c5b	83 f8 08	 cmp	 eax, 8
  00c5e	77 05		 ja	 SHORT $LN744@ThreadWMI
  00c60	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN744@ThreadWMI:
  00c65	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00c69	6a 12		 push	 18			; 00000012H
  00c6b	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  00c71	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory?$AA@
  00c76	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 886  :     memory[9] = "Win32_SystemMemoryResource";

  00c7b	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00c7f	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00c83	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00c88	f7 e9		 imul	 ecx
  00c8a	03 d1		 add	 edx, ecx
  00c8c	c1 fa 04	 sar	 edx, 4
  00c8f	8b ca		 mov	 ecx, edx
  00c91	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00c94	03 ca		 add	 ecx, edx
  00c96	83 f9 09	 cmp	 ecx, 9
  00c99	77 05		 ja	 SHORT $LN758@ThreadWMI
  00c9b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN758@ThreadWMI:
  00ca0	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  00ca4	6a 1a		 push	 26			; 0000001aH
  00ca6	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00cac	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource?$AA@
  00cb1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 887  : 
; 888  :     if(StartThread(memory[0],ThreadWMIClass,(LPVOID)&memory,0,&ahThreads[threads]))

  00cb6	8b 4c 24 7c	 mov	 ecx, DWORD PTR _memory$[esp+404]
  00cba	2b 4c 24 78	 sub	 ecx, DWORD PTR _memory$[esp+400]
  00cbe	8d 54 24 6c	 lea	 edx, DWORD PTR _memory$[esp+388]
  00cc2	53		 push	 ebx
  00cc3	52		 push	 edx
  00cc4	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00cc9	f7 e9		 imul	 ecx
  00ccb	03 d1		 add	 edx, ecx
  00ccd	c1 fa 04	 sar	 edx, 4
  00cd0	8b c2		 mov	 eax, edx
  00cd2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00cd5	03 c2		 add	 eax, edx
  00cd7	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  00cde	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  00ce3	75 05		 jne	 SHORT $LN772@ThreadWMI
  00ce5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN772@ThreadWMI:
  00cea	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR _memory$[esp+408]
  00cf1	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00cf4	8b cc		 mov	 ecx, esp
  00cf6	89 64 24 70	 mov	 DWORD PTR $T232223[esp+424], esp
  00cfa	6a ff		 push	 -1
  00cfc	53		 push	 ebx
  00cfd	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  00d04	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00d07	50		 push	 eax
  00d08	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  00d0b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00d10	c6 84 24 a4 01
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+432], 5
  00d18	c6 84 24 a4 01
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+432], 4
  00d20	8b d6		 mov	 edx, esi
  00d22	8b cf		 mov	 ecx, edi
  00d24	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  00d29	83 c4 24	 add	 esp, 36			; 00000024H
  00d2c	3a c3		 cmp	 al, bl
  00d2e	74 01		 je	 SHORT $LN9@ThreadWMI

; 889  :     {
; 890  :         threads++;

  00d30	45		 inc	 ebp
$LN9@ThreadWMI:

; 891  :     }
; 892  :     //MEM ***********
; 893  : 
; 894  :     //SYS ***********
; 895  :     vector<string> sysInfo(12);

  00d31	6a 0c		 push	 12			; 0000000cH
  00d33	8d 4c 24 58	 lea	 ecx, DWORD PTR _sysInfo$[esp+392]
  00d37	51		 push	 ecx
  00d38	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00d3d	c6 84 24 80 01
	00 00 06	 mov	 BYTE PTR __$EHRec$[esp+396], 6

; 896  : 
; 897  :     sysInfo[0] = "SystemInfo";

  00d45	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00d49	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00d4d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00d52	f7 e9		 imul	 ecx
  00d54	03 d1		 add	 edx, ecx
  00d56	c1 fa 04	 sar	 edx, 4
  00d59	8b c2		 mov	 eax, edx
  00d5b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00d5e	03 c2		 add	 eax, edx
  00d60	75 05		 jne	 SHORT $LN806@ThreadWMI
  00d62	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN806@ThreadWMI:
  00d67	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00d6b	6a 0a		 push	 10			; 0000000aH
  00d6d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NDINDOCK@SystemInfo?$AA@
  00d72	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 898  :     sysInfo[1] = "System Information";

  00d77	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00d7b	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00d7f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00d84	f7 e9		 imul	 ecx
  00d86	03 d1		 add	 edx, ecx
  00d88	c1 fa 04	 sar	 edx, 4
  00d8b	8b ca		 mov	 ecx, edx
  00d8d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00d90	03 ca		 add	 ecx, edx
  00d92	83 f9 01	 cmp	 ecx, 1
  00d95	77 05		 ja	 SHORT $LN820@ThreadWMI
  00d97	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN820@ThreadWMI:
  00d9c	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00da0	6a 12		 push	 18			; 00000012H
  00da2	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00da5	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OJGHJHKA@System?5Information?$AA@
  00daa	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 899  : 
; 900  :     //sysInfo[] = "Win32_ApplicationService";
; 901  :     sysInfo[2] = "Win32_ComputerSystem";

  00daf	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00db3	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00db7	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00dbc	f7 e9		 imul	 ecx
  00dbe	03 d1		 add	 edx, ecx
  00dc0	c1 fa 04	 sar	 edx, 4
  00dc3	8b c2		 mov	 eax, edx
  00dc5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00dc8	03 c2		 add	 eax, edx
  00dca	83 f8 02	 cmp	 eax, 2
  00dcd	77 05		 ja	 SHORT $LN834@ThreadWMI
  00dcf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN834@ThreadWMI:
  00dd4	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00dd8	6a 14		 push	 20			; 00000014H
  00dda	83 c1 38	 add	 ecx, 56			; 00000038H
  00ddd	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GMDCFJKK@Win32_ComputerSystem?$AA@
  00de2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 902  :     sysInfo[3] = "Win32_ComputerSystemProduct";

  00de7	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00deb	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00def	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00df4	f7 e9		 imul	 ecx
  00df6	03 d1		 add	 edx, ecx
  00df8	c1 fa 04	 sar	 edx, 4
  00dfb	8b ca		 mov	 ecx, edx
  00dfd	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00e00	03 ca		 add	 ecx, edx
  00e02	83 f9 03	 cmp	 ecx, 3
  00e05	77 05		 ja	 SHORT $LN848@ThreadWMI
  00e07	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN848@ThreadWMI:
  00e0c	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00e10	6a 1b		 push	 27			; 0000001bH
  00e12	83 c1 54	 add	 ecx, 84			; 00000054H
  00e15	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct?$AA@
  00e1a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 903  :     sysInfo[4] = "Win32_Product";

  00e1f	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00e23	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00e27	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00e2c	f7 e9		 imul	 ecx
  00e2e	03 d1		 add	 edx, ecx
  00e30	c1 fa 04	 sar	 edx, 4
  00e33	8b c2		 mov	 eax, edx
  00e35	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00e38	03 c2		 add	 eax, edx
  00e3a	83 f8 04	 cmp	 eax, 4
  00e3d	77 05		 ja	 SHORT $LN862@ThreadWMI
  00e3f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN862@ThreadWMI:
  00e44	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00e48	6a 0d		 push	 13			; 0000000dH
  00e4a	83 c1 70	 add	 ecx, 112		; 00000070H
  00e4d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LCAALOJJ@Win32_Product?$AA@
  00e52	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 904  :     //sysInfo[] = "Win32_ProgIDSpecification";
; 905  :     sysInfo[5] = "Win32_QuickFixEngineering";

  00e57	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00e5b	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00e5f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00e64	f7 e9		 imul	 ecx
  00e66	03 d1		 add	 edx, ecx
  00e68	c1 fa 04	 sar	 edx, 4
  00e6b	8b ca		 mov	 ecx, edx
  00e6d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00e70	03 ca		 add	 ecx, edx
  00e72	83 f9 05	 cmp	 ecx, 5
  00e75	77 05		 ja	 SHORT $LN876@ThreadWMI
  00e77	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN876@ThreadWMI:
  00e7c	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00e80	6a 19		 push	 25			; 00000019H
  00e82	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00e88	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering?$AA@
  00e8d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 906  :     sysInfo[6] = "Win32_Refrigeration";

  00e92	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00e96	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00e9a	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00e9f	f7 e9		 imul	 ecx
  00ea1	03 d1		 add	 edx, ecx
  00ea3	c1 fa 04	 sar	 edx, 4
  00ea6	8b c2		 mov	 eax, edx
  00ea8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00eab	03 c2		 add	 eax, edx
  00ead	83 f8 06	 cmp	 eax, 6
  00eb0	77 05		 ja	 SHORT $LN890@ThreadWMI
  00eb2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN890@ThreadWMI:
  00eb7	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00ebb	6a 13		 push	 19			; 00000013H
  00ebd	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00ec3	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DKANKDCG@Win32_Refrigeration?$AA@
  00ec8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 907  :     sysInfo[7] = "Win32_Registry";

  00ecd	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00ed1	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00ed5	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00eda	f7 e9		 imul	 ecx
  00edc	03 d1		 add	 edx, ecx
  00ede	c1 fa 04	 sar	 edx, 4
  00ee1	8b ca		 mov	 ecx, edx
  00ee3	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00ee6	03 ca		 add	 ecx, edx
  00ee8	83 f9 07	 cmp	 ecx, 7
  00eeb	77 05		 ja	 SHORT $LN904@ThreadWMI
  00eed	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN904@ThreadWMI:
  00ef2	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00ef6	6a 0e		 push	 14			; 0000000eH
  00ef8	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00efe	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OGGGECNI@Win32_Registry?$AA@
  00f03	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 908  :     sysInfo[8] = "Win32_SystemAccount";

  00f08	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00f0c	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00f10	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00f15	f7 e9		 imul	 ecx
  00f17	03 d1		 add	 edx, ecx
  00f19	c1 fa 04	 sar	 edx, 4
  00f1c	8b c2		 mov	 eax, edx
  00f1e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00f21	03 c2		 add	 eax, edx
  00f23	83 f8 08	 cmp	 eax, 8
  00f26	77 05		 ja	 SHORT $LN918@ThreadWMI
  00f28	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN918@ThreadWMI:
  00f2d	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00f31	6a 13		 push	 19			; 00000013H
  00f33	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  00f39	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DHOOODEL@Win32_SystemAccount?$AA@
  00f3e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 909  :     sysInfo[9] = "Win32_SystemDriver";

  00f43	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00f47	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00f4b	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00f50	f7 e9		 imul	 ecx
  00f52	03 d1		 add	 edx, ecx
  00f54	c1 fa 04	 sar	 edx, 4
  00f57	8b ca		 mov	 ecx, edx
  00f59	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00f5c	03 ca		 add	 ecx, edx
  00f5e	83 f9 09	 cmp	 ecx, 9
  00f61	77 05		 ja	 SHORT $LN932@ThreadWMI
  00f63	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN932@ThreadWMI:
  00f68	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00f6c	6a 12		 push	 18			; 00000012H
  00f6e	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00f74	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GGPCAOMO@Win32_SystemDriver?$AA@
  00f79	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 910  :     sysInfo[10] = "Win32_SystemEnclosure";

  00f7e	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00f82	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00f86	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00f8b	f7 e9		 imul	 ecx
  00f8d	03 d1		 add	 edx, ecx
  00f8f	c1 fa 04	 sar	 edx, 4
  00f92	8b c2		 mov	 eax, edx
  00f94	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00f97	03 c2		 add	 eax, edx
  00f99	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00f9c	77 05		 ja	 SHORT $LN946@ThreadWMI
  00f9e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN946@ThreadWMI:
  00fa3	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00fa7	6a 15		 push	 21			; 00000015H
  00fa9	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  00faf	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@COLMHJCF@Win32_SystemEnclosure?$AA@
  00fb4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 911  :     sysInfo[11] = "Win32_SystemSlot";

  00fb9	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00fbd	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00fc1	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00fc6	f7 e9		 imul	 ecx
  00fc8	03 d1		 add	 edx, ecx
  00fca	c1 fa 04	 sar	 edx, 4
  00fcd	8b ca		 mov	 ecx, edx
  00fcf	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00fd2	03 ca		 add	 ecx, edx
  00fd4	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00fd7	77 05		 ja	 SHORT $LN960@ThreadWMI
  00fd9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN960@ThreadWMI:
  00fde	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  00fe2	6a 10		 push	 16			; 00000010H
  00fe4	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  00fea	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IINEGLLN@Win32_SystemSlot?$AA@
  00fef	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 912  : 
; 913  :     if(StartThread(sysInfo[0],ThreadWMIClass,(LPVOID)&sysInfo,0,&ahThreads[threads]))

  00ff4	8b 4c 24 64	 mov	 ecx, DWORD PTR _sysInfo$[esp+404]
  00ff8	2b 4c 24 60	 sub	 ecx, DWORD PTR _sysInfo$[esp+400]
  00ffc	8d 54 24 54	 lea	 edx, DWORD PTR _sysInfo$[esp+388]
  01000	53		 push	 ebx
  01001	52		 push	 edx
  01002	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01007	f7 e9		 imul	 ecx
  01009	03 d1		 add	 edx, ecx
  0100b	c1 fa 04	 sar	 edx, 4
  0100e	8b c2		 mov	 eax, edx
  01010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01013	03 c2		 add	 eax, edx
  01015	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  0101c	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  01021	75 05		 jne	 SHORT $LN974@ThreadWMI
  01023	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN974@ThreadWMI:
  01028	8b 44 24 68	 mov	 eax, DWORD PTR _sysInfo$[esp+408]
  0102c	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0102f	8b cc		 mov	 ecx, esp
  01031	89 64 24 70	 mov	 DWORD PTR $T232224[esp+424], esp
  01035	6a ff		 push	 -1
  01037	53		 push	 ebx
  01038	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0103f	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  01042	50		 push	 eax
  01043	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  01046	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0104b	c6 84 24 a4 01
	00 00 07	 mov	 BYTE PTR __$EHRec$[esp+432], 7
  01053	c6 84 24 a4 01
	00 00 06	 mov	 BYTE PTR __$EHRec$[esp+432], 6
  0105b	8b d6		 mov	 edx, esi
  0105d	8b cf		 mov	 ecx, edi
  0105f	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  01064	83 c4 24	 add	 esp, 36			; 00000024H
  01067	3a c3		 cmp	 al, bl
  01069	74 01		 je	 SHORT $LN8@ThreadWMI

; 914  :     {
; 915  :         threads++;

  0106b	45		 inc	 ebp
$LN8@ThreadWMI:

; 916  :     }
; 917  :     //SYS ***********
; 918  : 
; 919  :     //NET ***********
; 920  :     vector<string> net(6);

  0106c	6a 06		 push	 6
  0106e	8d 8c 24 88 00
	00 00		 lea	 ecx, DWORD PTR _net$[esp+392]
  01075	51		 push	 ecx
  01076	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0107b	c6 84 24 80 01
	00 00 08	 mov	 BYTE PTR __$EHRec$[esp+396], 8

; 921  : 
; 922  :     net[0] = "Network";

  01083	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  0108a	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  01091	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01096	f7 e9		 imul	 ecx
  01098	03 d1		 add	 edx, ecx
  0109a	c1 fa 04	 sar	 edx, 4
  0109d	8b c2		 mov	 eax, edx
  0109f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  010a2	03 c2		 add	 eax, edx
  010a4	75 05		 jne	 SHORT $LN1008@ThreadWMI
  010a6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1008@ThreadWMI:
  010ab	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  010b2	6a 07		 push	 7
  010b4	68 00 00 00 00	 push	 OFFSET ??_C@_07BGDMAJAE@Network?$AA@
  010b9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 923  :     net[1] = "Network Information";

  010be	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  010c5	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  010cc	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  010d1	f7 e9		 imul	 ecx
  010d3	03 d1		 add	 edx, ecx
  010d5	c1 fa 04	 sar	 edx, 4
  010d8	8b ca		 mov	 ecx, edx
  010da	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  010dd	03 ca		 add	 ecx, edx
  010df	83 f9 01	 cmp	 ecx, 1
  010e2	77 05		 ja	 SHORT $LN1022@ThreadWMI
  010e4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1022@ThreadWMI:
  010e9	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  010f0	6a 13		 push	 19			; 00000013H
  010f2	83 c1 1c	 add	 ecx, 28			; 0000001cH
  010f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KDFOEONK@Network?5Information?$AA@
  010fa	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 924  : 
; 925  :     net[2] = "Win32_NetworkAdapter";

  010ff	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  01106	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  0110d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01112	f7 e9		 imul	 ecx
  01114	03 d1		 add	 edx, ecx
  01116	c1 fa 04	 sar	 edx, 4
  01119	8b c2		 mov	 eax, edx
  0111b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0111e	03 c2		 add	 eax, edx
  01120	83 f8 02	 cmp	 eax, 2
  01123	77 05		 ja	 SHORT $LN1036@ThreadWMI
  01125	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1036@ThreadWMI:
  0112a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  01131	6a 14		 push	 20			; 00000014H
  01133	83 c1 38	 add	 ecx, 56			; 00000038H
  01136	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter?$AA@
  0113b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 926  :     net[3] = "Win32_NetworkAdapterConfiguration";

  01140	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  01147	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  0114e	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01153	f7 e9		 imul	 ecx
  01155	03 d1		 add	 edx, ecx
  01157	c1 fa 04	 sar	 edx, 4
  0115a	8b ca		 mov	 ecx, edx
  0115c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0115f	03 ca		 add	 ecx, edx
  01161	83 f9 03	 cmp	 ecx, 3
  01164	77 05		 ja	 SHORT $LN1050@ThreadWMI
  01166	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1050@ThreadWMI:
  0116b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  01172	6a 21		 push	 33			; 00000021H
  01174	83 c1 54	 add	 ecx, 84			; 00000054H
  01177	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfiguratio@
  0117c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 927  :     net[4] = "Win32_NetworkLoginProfile";

  01181	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  01188	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  0118f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01194	f7 e9		 imul	 ecx
  01196	03 d1		 add	 edx, ecx
  01198	c1 fa 04	 sar	 edx, 4
  0119b	8b c2		 mov	 eax, edx
  0119d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  011a0	03 c2		 add	 eax, edx
  011a2	83 f8 04	 cmp	 eax, 4
  011a5	77 05		 ja	 SHORT $LN1064@ThreadWMI
  011a7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1064@ThreadWMI:
  011ac	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  011b3	6a 19		 push	 25			; 00000019H
  011b5	83 c1 70	 add	 ecx, 112		; 00000070H
  011b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile?$AA@
  011bd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 928  :     net[5] = "Win32_NetworkProtocol";

  011c2	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  011c9	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  011d0	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  011d5	f7 e9		 imul	 ecx
  011d7	03 d1		 add	 edx, ecx
  011d9	c1 fa 04	 sar	 edx, 4
  011dc	8b ca		 mov	 ecx, edx
  011de	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  011e1	03 ca		 add	 ecx, edx
  011e3	83 f9 05	 cmp	 ecx, 5
  011e6	77 05		 ja	 SHORT $LN1078@ThreadWMI
  011e8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1078@ThreadWMI:
  011ed	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  011f4	6a 15		 push	 21			; 00000015H
  011f6	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  011fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol?$AA@
  01201	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 929  : 
; 930  :     if(StartThread(net[0],ThreadWMIClass,(LPVOID)&net,0,&ahThreads[threads]))

  01206	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+404]
  0120d	2b 8c 24 90 00
	00 00		 sub	 ecx, DWORD PTR _net$[esp+400]
  01214	8d 94 24 84 00
	00 00		 lea	 edx, DWORD PTR _net$[esp+388]
  0121b	53		 push	 ebx
  0121c	52		 push	 edx
  0121d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01222	f7 e9		 imul	 ecx
  01224	03 d1		 add	 edx, ecx
  01226	c1 fa 04	 sar	 edx, 4
  01229	8b c2		 mov	 eax, edx
  0122b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0122e	03 c2		 add	 eax, edx
  01230	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  01237	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  0123c	75 05		 jne	 SHORT $LN1092@ThreadWMI
  0123e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1092@ThreadWMI:
  01243	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR _net$[esp+408]
  0124a	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0124d	8b cc		 mov	 ecx, esp
  0124f	89 64 24 70	 mov	 DWORD PTR $T232225[esp+424], esp
  01253	6a ff		 push	 -1
  01255	53		 push	 ebx
  01256	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0125d	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  01260	50		 push	 eax
  01261	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  01264	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  01269	c6 84 24 a4 01
	00 00 09	 mov	 BYTE PTR __$EHRec$[esp+432], 9
  01271	c6 84 24 a4 01
	00 00 08	 mov	 BYTE PTR __$EHRec$[esp+432], 8
  01279	8b d6		 mov	 edx, esi
  0127b	8b cf		 mov	 ecx, edi
  0127d	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  01282	83 c4 24	 add	 esp, 36			; 00000024H
  01285	3a c3		 cmp	 al, bl
  01287	74 01		 je	 SHORT $LN7@ThreadWMI

; 931  :     {
; 932  :         threads++;

  01289	45		 inc	 ebp
$LN7@ThreadWMI:

; 933  :     }
; 934  :     //NET ***********
; 935  : 
; 936  :     //USER **********
; 937  :     vector<string> user(2);

  0128a	6a 02		 push	 2
  0128c	8d 8c 24 d0 00
	00 00		 lea	 ecx, DWORD PTR _user$[esp+392]
  01293	51		 push	 ecx
  01294	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01299	c6 84 24 80 01
	00 00 0a	 mov	 BYTE PTR __$EHRec$[esp+396], 10 ; 0000000aH

; 938  : 
; 939  :     user[0] = "UserAccountAndSecurity";

  012a1	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+404]
  012a8	2b 8c 24 d8 00
	00 00		 sub	 ecx, DWORD PTR _user$[esp+400]
  012af	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  012b4	f7 e9		 imul	 ecx
  012b6	03 d1		 add	 edx, ecx
  012b8	c1 fa 04	 sar	 edx, 4
  012bb	8b c2		 mov	 eax, edx
  012bd	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  012c0	03 c2		 add	 eax, edx
  012c2	75 05		 jne	 SHORT $LN1126@ThreadWMI
  012c4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1126@ThreadWMI:
  012c9	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+400]
  012d0	6a 16		 push	 22			; 00000016H
  012d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IAHFOAM@UserAccountAndSecurity?$AA@
  012d7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 940  :     user[1] = "User Account and Security Information";

  012dc	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+404]
  012e3	2b 8c 24 d8 00
	00 00		 sub	 ecx, DWORD PTR _user$[esp+400]
  012ea	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  012ef	f7 e9		 imul	 ecx
  012f1	03 d1		 add	 edx, ecx
  012f3	c1 fa 04	 sar	 edx, 4
  012f6	8b ca		 mov	 ecx, edx
  012f8	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  012fb	03 ca		 add	 ecx, edx
  012fd	83 f9 01	 cmp	 ecx, 1
  01300	77 05		 ja	 SHORT $LN1140@ThreadWMI
  01302	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1140@ThreadWMI:
  01307	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+400]
  0130e	6a 25		 push	 37			; 00000025H
  01310	83 c1 1c	 add	 ecx, 28			; 0000001cH
  01313	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@BJFGJGFN@User?5Account?5and?5Security?5Inform@
  01318	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 941  : 
; 942  : #ifdef _GET_WMI_ACCOUNTS    //user and groups which includes the full domain
; 943  :     user[] = "Win32_Account";
; 944  : #endif
; 945  : 
; 946  :     if(StartThread(user[0],ThreadWMIClass,(LPVOID)&user,0,&ahThreads[threads]))

  0131d	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+404]
  01324	2b 8c 24 d8 00
	00 00		 sub	 ecx, DWORD PTR _user$[esp+400]
  0132b	8d 94 24 cc 00
	00 00		 lea	 edx, DWORD PTR _user$[esp+388]
  01332	53		 push	 ebx
  01333	52		 push	 edx
  01334	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01339	f7 e9		 imul	 ecx
  0133b	03 d1		 add	 edx, ecx
  0133d	c1 fa 04	 sar	 edx, 4
  01340	8b c2		 mov	 eax, edx
  01342	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01345	03 c2		 add	 eax, edx
  01347	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  0134e	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  01353	75 05		 jne	 SHORT $LN1154@ThreadWMI
  01355	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1154@ThreadWMI:
  0135a	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR _user$[esp+408]
  01361	83 ec 1c	 sub	 esp, 28			; 0000001cH
  01364	8b cc		 mov	 ecx, esp
  01366	89 64 24 70	 mov	 DWORD PTR $T232226[esp+424], esp
  0136a	6a ff		 push	 -1
  0136c	53		 push	 ebx
  0136d	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  01374	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  01377	50		 push	 eax
  01378	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  0137b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  01380	c6 84 24 a4 01
	00 00 0b	 mov	 BYTE PTR __$EHRec$[esp+432], 11 ; 0000000bH
  01388	c6 84 24 a4 01
	00 00 0a	 mov	 BYTE PTR __$EHRec$[esp+432], 10 ; 0000000aH
  01390	8b d6		 mov	 edx, esi
  01392	8b cf		 mov	 ecx, edi
  01394	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  01399	83 c4 24	 add	 esp, 36			; 00000024H
  0139c	3a c3		 cmp	 al, bl
  0139e	74 01		 je	 SHORT $LN6@ThreadWMI

; 947  :     {
; 948  :         threads++;

  013a0	45		 inc	 ebp
$LN6@ThreadWMI:

; 949  :     }
; 950  :     //USER **********
; 951  : 
; 952  :     //DEV ***********
; 953  :     vector<string> dev(4);

  013a1	6a 04		 push	 4
  013a3	8d 8c 24 b8 00
	00 00		 lea	 ecx, DWORD PTR _dev$[esp+392]
  013aa	51		 push	 ecx
  013ab	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  013b0	c6 84 24 80 01
	00 00 0c	 mov	 BYTE PTR __$EHRec$[esp+396], 12 ; 0000000cH

; 954  : 
; 955  :     dev[0] = "Developer";

  013b8	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+404]
  013bf	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR _dev$[esp+400]
  013c6	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  013cb	f7 e9		 imul	 ecx
  013cd	03 d1		 add	 edx, ecx
  013cf	c1 fa 04	 sar	 edx, 4
  013d2	8b c2		 mov	 eax, edx
  013d4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  013d7	03 c2		 add	 eax, edx
  013d9	75 05		 jne	 SHORT $LN1188@ThreadWMI
  013db	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1188@ThreadWMI:
  013e0	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+400]
  013e7	6a 09		 push	 9
  013e9	68 00 00 00 00	 push	 OFFSET ??_C@_09HCBPJCHD@Developer?$AA@
  013ee	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 956  :     dev[1] = "Developer Information";

  013f3	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+404]
  013fa	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR _dev$[esp+400]
  01401	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01406	f7 e9		 imul	 ecx
  01408	03 d1		 add	 edx, ecx
  0140a	c1 fa 04	 sar	 edx, 4
  0140d	8b ca		 mov	 ecx, edx
  0140f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01412	03 ca		 add	 ecx, edx
  01414	83 f9 01	 cmp	 ecx, 1
  01417	77 05		 ja	 SHORT $LN1202@ThreadWMI
  01419	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1202@ThreadWMI:
  0141e	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+400]
  01425	6a 15		 push	 21			; 00000015H
  01427	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0142a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KMFPDIMK@Developer?5Information?$AA@
  0142f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 957  : 
; 958  :     dev[2] = "Win32_CodecFile";

  01434	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+404]
  0143b	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR _dev$[esp+400]
  01442	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01447	f7 e9		 imul	 ecx
  01449	03 d1		 add	 edx, ecx
  0144b	c1 fa 04	 sar	 edx, 4
  0144e	8b c2		 mov	 eax, edx
  01450	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01453	03 c2		 add	 eax, edx
  01455	83 f8 02	 cmp	 eax, 2
  01458	77 05		 ja	 SHORT $LN1216@ThreadWMI
  0145a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1216@ThreadWMI:
  0145f	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+400]
  01466	6a 0f		 push	 15			; 0000000fH
  01468	83 c1 38	 add	 ecx, 56			; 00000038H
  0146b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MBMLPGOB@Win32_CodecFile?$AA@
  01470	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 959  : #ifdef _GET_WMI_COMCLASS    //get all COM class - which can be thousands
; 960  :     dev[] = "Win32_COMClass";
; 961  : #endif
; 962  : #ifdef _GET_WMI_SOFTWARE_DETAILS    //get all software element, part of a software feature
; 963  :                                     //(a distinct subset of a product which may contain one 
; 964  :                                     //or more elements) - which can be thousands
; 965  :     dev[] = "Win32_SoftwareElement";
; 966  : #endif
; 967  :     dev[3] = "Win32_SoftwareFeature";

  01475	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+404]
  0147c	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR _dev$[esp+400]
  01483	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01488	f7 e9		 imul	 ecx
  0148a	03 d1		 add	 edx, ecx
  0148c	c1 fa 04	 sar	 edx, 4
  0148f	8b ca		 mov	 ecx, edx
  01491	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01494	03 ca		 add	 ecx, edx
  01496	83 f9 03	 cmp	 ecx, 3
  01499	77 05		 ja	 SHORT $LN1230@ThreadWMI
  0149b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1230@ThreadWMI:
  014a0	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+400]
  014a7	6a 15		 push	 21			; 00000015H
  014a9	83 c1 54	 add	 ecx, 84			; 00000054H
  014ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature?$AA@
  014b1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 968  : 
; 969  :     if(StartThread(dev[0],ThreadWMIClass,(LPVOID)&dev,0,&ahThreads[threads]))

  014b6	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+404]
  014bd	2b 8c 24 c0 00
	00 00		 sub	 ecx, DWORD PTR _dev$[esp+400]
  014c4	8d 94 24 b4 00
	00 00		 lea	 edx, DWORD PTR _dev$[esp+388]
  014cb	53		 push	 ebx
  014cc	52		 push	 edx
  014cd	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  014d2	f7 e9		 imul	 ecx
  014d4	03 d1		 add	 edx, ecx
  014d6	c1 fa 04	 sar	 edx, 4
  014d9	8b c2		 mov	 eax, edx
  014db	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  014de	03 c2		 add	 eax, edx
  014e0	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  014e7	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  014ec	75 05		 jne	 SHORT $LN1244@ThreadWMI
  014ee	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1244@ThreadWMI:
  014f3	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR _dev$[esp+408]
  014fa	83 ec 1c	 sub	 esp, 28			; 0000001cH
  014fd	8b cc		 mov	 ecx, esp
  014ff	89 64 24 70	 mov	 DWORD PTR $T232227[esp+424], esp
  01503	6a ff		 push	 -1
  01505	53		 push	 ebx
  01506	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  0150d	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  01510	50		 push	 eax
  01511	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  01514	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  01519	c6 84 24 a4 01
	00 00 0d	 mov	 BYTE PTR __$EHRec$[esp+432], 13 ; 0000000dH
  01521	c6 84 24 a4 01
	00 00 0c	 mov	 BYTE PTR __$EHRec$[esp+432], 12 ; 0000000cH
  01529	8b d6		 mov	 edx, esi
  0152b	8b cf		 mov	 ecx, edi
  0152d	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  01532	83 c4 24	 add	 esp, 36			; 00000024H
  01535	3a c3		 cmp	 al, bl
  01537	74 01		 je	 SHORT $LN5@ThreadWMI

; 970  :     {
; 971  :         threads++;

  01539	45		 inc	 ebp
$LN5@ThreadWMI:

; 972  :     }
; 973  :     //DEV ***********
; 974  : 
; 975  :     //UTIL **********
; 976  :     vector<string> util(14);

  0153a	6a 0e		 push	 14			; 0000000eH
  0153c	8d 4c 24 38	 lea	 ecx, DWORD PTR _util$[esp+392]
  01540	51		 push	 ecx
  01541	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01546	c6 84 24 80 01
	00 00 0e	 mov	 BYTE PTR __$EHRec$[esp+396], 14 ; 0000000eH

; 977  : 
; 978  :     util[0] = "Utility";

  0154e	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01552	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01556	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0155b	f7 e9		 imul	 ecx
  0155d	03 d1		 add	 edx, ecx
  0155f	c1 fa 04	 sar	 edx, 4
  01562	8b c2		 mov	 eax, edx
  01564	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01567	03 c2		 add	 eax, edx
  01569	75 05		 jne	 SHORT $LN1278@ThreadWMI
  0156b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1278@ThreadWMI:
  01570	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01574	6a 07		 push	 7
  01576	68 00 00 00 00	 push	 OFFSET ??_C@_07HCOFHGI@Utility?$AA@
  0157b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 979  :     util[1] = "Utility Information";

  01580	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01584	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01588	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0158d	f7 e9		 imul	 ecx
  0158f	03 d1		 add	 edx, ecx
  01591	c1 fa 04	 sar	 edx, 4
  01594	8b ca		 mov	 ecx, edx
  01596	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01599	03 ca		 add	 ecx, edx
  0159b	83 f9 01	 cmp	 ecx, 1
  0159e	77 05		 ja	 SHORT $LN1292@ThreadWMI
  015a0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1292@ThreadWMI:
  015a5	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  015a9	6a 13		 push	 19			; 00000013H
  015ab	83 c1 1c	 add	 ecx, 28			; 0000001cH
  015ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DMCOJOJG@Utility?5Information?$AA@
  015b3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 980  : 
; 981  :     util[2] = "Win32_BaseService";

  015b8	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  015bc	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  015c0	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  015c5	f7 e9		 imul	 ecx
  015c7	03 d1		 add	 edx, ecx
  015c9	c1 fa 04	 sar	 edx, 4
  015cc	8b c2		 mov	 eax, edx
  015ce	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  015d1	03 c2		 add	 eax, edx
  015d3	83 f8 02	 cmp	 eax, 2
  015d6	77 05		 ja	 SHORT $LN1306@ThreadWMI
  015d8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1306@ThreadWMI:
  015dd	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  015e1	6a 11		 push	 17			; 00000011H
  015e3	83 c1 38	 add	 ecx, 56			; 00000038H
  015e6	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DPAOPBJD@Win32_BaseService?$AA@
  015eb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 982  :     util[3] = "Win32_BootConfiguration";

  015f0	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  015f4	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  015f8	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  015fd	f7 e9		 imul	 ecx
  015ff	03 d1		 add	 edx, ecx
  01601	c1 fa 04	 sar	 edx, 4
  01604	8b ca		 mov	 ecx, edx
  01606	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01609	03 ca		 add	 ecx, edx
  0160b	83 f9 03	 cmp	 ecx, 3
  0160e	77 05		 ja	 SHORT $LN1320@ThreadWMI
  01610	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1320@ThreadWMI:
  01615	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01619	6a 17		 push	 23			; 00000017H
  0161b	83 c1 54	 add	 ecx, 84			; 00000054H
  0161e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EMHOOOGN@Win32_BootConfiguration?$AA@
  01623	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 983  :     util[4] = "Win32_Desktop";

  01628	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  0162c	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01630	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01635	f7 e9		 imul	 ecx
  01637	03 d1		 add	 edx, ecx
  01639	c1 fa 04	 sar	 edx, 4
  0163c	8b c2		 mov	 eax, edx
  0163e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01641	03 c2		 add	 eax, edx
  01643	83 f8 04	 cmp	 eax, 4
  01646	77 05		 ja	 SHORT $LN1334@ThreadWMI
  01648	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1334@ThreadWMI:
  0164d	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01651	6a 0d		 push	 13			; 0000000dH
  01653	83 c1 70	 add	 ecx, 112		; 00000070H
  01656	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MLAGCNDM@Win32_Desktop?$AA@
  0165b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 984  :     util[5] = "Win32_DesktopMonitor";

  01660	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01664	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01668	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0166d	f7 e9		 imul	 ecx
  0166f	03 d1		 add	 edx, ecx
  01671	c1 fa 04	 sar	 edx, 4
  01674	8b ca		 mov	 ecx, edx
  01676	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01679	03 ca		 add	 ecx, edx
  0167b	83 f9 05	 cmp	 ecx, 5
  0167e	77 05		 ja	 SHORT $LN1348@ThreadWMI
  01680	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1348@ThreadWMI:
  01685	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01689	6a 14		 push	 20			; 00000014H
  0168b	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  01691	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CJJIHFON@Win32_DesktopMonitor?$AA@
  01696	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 985  :     util[6] = "Win32_Fan";

  0169b	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  0169f	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  016a3	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  016a8	f7 e9		 imul	 ecx
  016aa	03 d1		 add	 edx, ecx
  016ac	c1 fa 04	 sar	 edx, 4
  016af	8b c2		 mov	 eax, edx
  016b1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  016b4	03 c2		 add	 eax, edx
  016b6	83 f8 06	 cmp	 eax, 6
  016b9	77 05		 ja	 SHORT $LN1362@ThreadWMI
  016bb	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1362@ThreadWMI:
  016c0	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  016c4	6a 09		 push	 9
  016c6	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  016cc	68 00 00 00 00	 push	 OFFSET ??_C@_09BEHCCOGC@Win32_Fan?$AA@
  016d1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 986  :     util[7] = "Win32_OperatingSystem";

  016d6	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  016da	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  016de	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  016e3	f7 e9		 imul	 ecx
  016e5	03 d1		 add	 edx, ecx
  016e7	c1 fa 04	 sar	 edx, 4
  016ea	8b ca		 mov	 ecx, edx
  016ec	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  016ef	03 ca		 add	 ecx, edx
  016f1	83 f9 07	 cmp	 ecx, 7
  016f4	77 05		 ja	 SHORT $LN1376@ThreadWMI
  016f6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1376@ThreadWMI:
  016fb	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  016ff	6a 15		 push	 21			; 00000015H
  01701	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  01707	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MCGAGLCL@Win32_OperatingSystem?$AA@
  0170c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 987  :     util[8] = "Win32_PageFile";

  01711	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01715	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01719	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0171e	f7 e9		 imul	 ecx
  01720	03 d1		 add	 edx, ecx
  01722	c1 fa 04	 sar	 edx, 4
  01725	8b c2		 mov	 eax, edx
  01727	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0172a	03 c2		 add	 eax, edx
  0172c	83 f8 08	 cmp	 eax, 8
  0172f	77 05		 ja	 SHORT $LN1390@ThreadWMI
  01731	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1390@ThreadWMI:
  01736	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  0173a	6a 0e		 push	 14			; 0000000eH
  0173c	81 c1 e0 00 00
	00		 add	 ecx, 224		; 000000e0H
  01742	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GFMPEM@Win32_PageFile?$AA@
  01747	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 988  :     util[9] = "Win32_ParallelPort";

  0174c	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01750	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01754	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01759	f7 e9		 imul	 ecx
  0175b	03 d1		 add	 edx, ecx
  0175d	c1 fa 04	 sar	 edx, 4
  01760	8b ca		 mov	 ecx, edx
  01762	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01765	03 ca		 add	 ecx, edx
  01767	83 f9 09	 cmp	 ecx, 9
  0176a	77 05		 ja	 SHORT $LN1404@ThreadWMI
  0176c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1404@ThreadWMI:
  01771	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01775	6a 12		 push	 18			; 00000012H
  01777	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  0177d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CPCJFLPJ@Win32_ParallelPort?$AA@
  01782	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 989  :     util[10] = "Win32_Proxy";

  01787	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  0178b	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  0178f	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01794	f7 e9		 imul	 ecx
  01796	03 d1		 add	 edx, ecx
  01798	c1 fa 04	 sar	 edx, 4
  0179b	8b c2		 mov	 eax, edx
  0179d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  017a0	03 c2		 add	 eax, edx
  017a2	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  017a5	77 05		 ja	 SHORT $LN1418@ThreadWMI
  017a7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1418@ThreadWMI:
  017ac	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  017b0	6a 0b		 push	 11			; 0000000bH
  017b2	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  017b8	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GFHBIAHO@Win32_Proxy?$AA@
  017bd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 990  :     util[11] = "Win32_Share";

  017c2	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  017c6	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  017ca	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  017cf	f7 e9		 imul	 ecx
  017d1	03 d1		 add	 edx, ecx
  017d3	c1 fa 04	 sar	 edx, 4
  017d6	8b ca		 mov	 ecx, edx
  017d8	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  017db	03 ca		 add	 ecx, edx
  017dd	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  017e0	77 05		 ja	 SHORT $LN1432@ThreadWMI
  017e2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1432@ThreadWMI:
  017e7	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  017eb	6a 0b		 push	 11			; 0000000bH
  017ed	81 c1 34 01 00
	00		 add	 ecx, 308		; 00000134H
  017f3	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MCIKNCEL@Win32_Share?$AA@
  017f8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 991  :     util[12] = "Win32_WindowsProductActivation";

  017fd	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01801	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01805	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0180a	f7 e9		 imul	 ecx
  0180c	03 d1		 add	 edx, ecx
  0180e	c1 fa 04	 sar	 edx, 4
  01811	8b c2		 mov	 eax, edx
  01813	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01816	03 c2		 add	 eax, edx
  01818	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0181b	77 05		 ja	 SHORT $LN1446@ThreadWMI
  0181d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1446@ThreadWMI:
  01822	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01826	6a 1e		 push	 30			; 0000001eH
  01828	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0182e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation?$AA@
  01833	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 992  :     util[13] = "Win32_WMISetting";

  01838	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  0183c	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  01840	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01845	f7 e9		 imul	 ecx
  01847	03 d1		 add	 edx, ecx
  01849	c1 fa 04	 sar	 edx, 4
  0184c	8b ca		 mov	 ecx, edx
  0184e	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  01851	03 ca		 add	 ecx, edx
  01853	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  01856	77 05		 ja	 SHORT $LN1460@ThreadWMI
  01858	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1460@ThreadWMI:
  0185d	8b 4c 24 40	 mov	 ecx, DWORD PTR _util$[esp+400]
  01861	6a 10		 push	 16			; 00000010H
  01863	81 c1 6c 01 00
	00		 add	 ecx, 364		; 0000016cH
  01869	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BBHCGAKO@Win32_WMISetting?$AA@
  0186e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 993  : 
; 994  :     if(StartThread(util[0],ThreadWMIClass,(LPVOID)&util,0,&ahThreads[threads]))

  01873	8b 4c 24 44	 mov	 ecx, DWORD PTR _util$[esp+404]
  01877	2b 4c 24 40	 sub	 ecx, DWORD PTR _util$[esp+400]
  0187b	8d 54 24 34	 lea	 edx, DWORD PTR _util$[esp+388]
  0187f	53		 push	 ebx
  01880	52		 push	 edx
  01881	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  01886	f7 e9		 imul	 ecx
  01888	03 d1		 add	 edx, ecx
  0188a	c1 fa 04	 sar	 edx, 4
  0188d	8b c2		 mov	 eax, edx
  0188f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  01892	03 c2		 add	 eax, edx
  01894	8d b4 ac f4 00
	00 00		 lea	 esi, DWORD PTR _ahThreads$[esp+ebp*4+396]
  0189b	bf 00 00 00 00	 mov	 edi, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  018a0	75 05		 jne	 SHORT $LN1474@ThreadWMI
  018a2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1474@ThreadWMI:
  018a7	8b 44 24 48	 mov	 eax, DWORD PTR _util$[esp+408]
  018ab	83 ec 1c	 sub	 esp, 28			; 0000001cH
  018ae	8b cc		 mov	 ecx, esp
  018b0	89 64 24 70	 mov	 DWORD PTR $T232228[esp+424], esp
  018b4	6a ff		 push	 -1
  018b6	53		 push	 ebx
  018b7	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
  018be	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  018c1	50		 push	 eax
  018c2	88 59 04	 mov	 BYTE PTR [ecx+4], bl
  018c5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  018ca	c6 84 24 a4 01
	00 00 0f	 mov	 BYTE PTR __$EHRec$[esp+432], 15 ; 0000000fH
  018d2	c6 84 24 a4 01
	00 00 0e	 mov	 BYTE PTR __$EHRec$[esp+432], 14 ; 0000000eH
  018da	8b d6		 mov	 edx, esi
  018dc	8b cf		 mov	 ecx, edi
  018de	e8 00 00 00 00	 call	 ?StartThread@@YA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  018e3	83 c4 24	 add	 esp, 36			; 00000024H
  018e6	3a c3		 cmp	 al, bl
  018e8	74 01		 je	 SHORT $LN4@ThreadWMI

; 995  :     {
; 996  :         threads++;

  018ea	45		 inc	 ebp
$LN4@ThreadWMI:

; 997  :     }
; 998  :     //UTIL **********
; 999  : 
; 1000 :     Log(LOG_DEBUG_WMI,__LINE__,"ThrdWMI, Waitg %u thrs",threads);

  018eb	55		 push	 ebp
  018ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@PEBHJHOI@ThrdWMI?0?5Waitg?5?$CFu?5thrs?$AA@
  018f1	68 e8 03 00 00	 push	 1000			; 000003e8H
  018f6	6a 40		 push	 64			; 00000040H
  018f8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  018fd	83 c4 10	 add	 esp, 16			; 00000010H

; 1001 :     WaitForMultipleObjects(threads,ahThreads,TRUE,INFINITE);

  01900	6a ff		 push	 -1
  01902	6a 01		 push	 1
  01904	8d 8c 24 f4 00
	00 00		 lea	 ecx, DWORD PTR _ahThreads$[esp+396]
  0190b	51		 push	 ecx
  0190c	55		 push	 ebp
  0190d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16

; 1002 :     for(DWORD x=0;x<threads;x++)

  01913	33 f6		 xor	 esi, esi
  01915	3b eb		 cmp	 ebp, ebx
  01917	76 16		 jbe	 SHORT $LN1@ThreadWMI
  01919	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  0191f	90		 npad	 1
$LL3@ThreadWMI:

; 1003 :     {
; 1004 :         CloseHandle(ahThreads[x]);

  01920	8b 94 b4 ec 00
	00 00		 mov	 edx, DWORD PTR _ahThreads$[esp+esi*4+388]
  01927	52		 push	 edx
  01928	ff d7		 call	 edi
  0192a	46		 inc	 esi
  0192b	3b f5		 cmp	 esi, ebp
  0192d	72 f1		 jb	 SHORT $LL3@ThreadWMI
$LN1@ThreadWMI:

; 1005 :     }
; 1006 :     hwInfo.clear();

  0192f	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  01933	8b 44 24 28	 mov	 eax, DWORD PTR _hwInfo$[esp+400]
  01937	8b d9		 mov	 ebx, ecx
  01939	3b c1		 cmp	 eax, ecx
  0193b	76 0d		 jbe	 SHORT $LN1514@ThreadWMI
  0193d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01942	8b 4c 24 2c	 mov	 ecx, DWORD PTR _hwInfo$[esp+404]
  01946	8b 44 24 28	 mov	 eax, DWORD PTR _hwInfo$[esp+400]
$LN1514@ThreadWMI:
  0194a	8b 74 24 1c	 mov	 esi, DWORD PTR _hwInfo$[esp+388]
  0194e	8b f8		 mov	 edi, eax
  01950	3b c1		 cmp	 eax, ecx
  01952	76 05		 jbe	 SHORT $LN1533@ThreadWMI
  01954	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1533@ThreadWMI:
  01959	8b 44 24 1c	 mov	 eax, DWORD PTR _hwInfo$[esp+388]
  0195d	53		 push	 ebx
  0195e	56		 push	 esi
  0195f	57		 push	 edi
  01960	50		 push	 eax
  01961	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T235803[esp+404]
  01965	8d 74 24 2c	 lea	 esi, DWORD PTR _hwInfo$[esp+404]
  01969	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1007 :     data.clear();

  0196e	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR _data$[esp+404]
  01975	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
  0197c	8b d8		 mov	 ebx, eax
  0197e	3b c8		 cmp	 ecx, eax
  01980	76 13		 jbe	 SHORT $LN1554@ThreadWMI
  01982	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01987	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR _data$[esp+404]
  0198e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+400]
$LN1554@ThreadWMI:
  01995	8b b4 24 9c 00
	00 00		 mov	 esi, DWORD PTR _data$[esp+388]
  0199c	8b f9		 mov	 edi, ecx
  0199e	3b c8		 cmp	 ecx, eax
  019a0	76 05		 jbe	 SHORT $LN1573@ThreadWMI
  019a2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1573@ThreadWMI:
  019a7	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR _data$[esp+388]
  019ae	53		 push	 ebx
  019af	56		 push	 esi
  019b0	57		 push	 edi
  019b1	51		 push	 ecx
  019b2	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T236000[esp+404]
  019b6	8d b4 24 ac 00
	00 00		 lea	 esi, DWORD PTR _data$[esp+404]
  019bd	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1008 :     memory.clear();

  019c2	8b 44 24 7c	 mov	 eax, DWORD PTR _memory$[esp+404]
  019c6	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
  019ca	8b d8		 mov	 ebx, eax
  019cc	3b c8		 cmp	 ecx, eax
  019ce	76 0d		 jbe	 SHORT $LN1594@ThreadWMI
  019d0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  019d5	8b 44 24 7c	 mov	 eax, DWORD PTR _memory$[esp+404]
  019d9	8b 4c 24 78	 mov	 ecx, DWORD PTR _memory$[esp+400]
$LN1594@ThreadWMI:
  019dd	8b 74 24 6c	 mov	 esi, DWORD PTR _memory$[esp+388]
  019e1	8b f9		 mov	 edi, ecx
  019e3	3b c8		 cmp	 ecx, eax
  019e5	76 05		 jbe	 SHORT $LN1613@ThreadWMI
  019e7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1613@ThreadWMI:
  019ec	8b 54 24 6c	 mov	 edx, DWORD PTR _memory$[esp+388]
  019f0	53		 push	 ebx
  019f1	56		 push	 esi
  019f2	57		 push	 edi
  019f3	52		 push	 edx
  019f4	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T236197[esp+404]
  019f8	8d 74 24 7c	 lea	 esi, DWORD PTR _memory$[esp+404]
  019fc	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1009 :     sysInfo.clear();

  01a01	8b 44 24 64	 mov	 eax, DWORD PTR _sysInfo$[esp+404]
  01a05	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
  01a09	8b d8		 mov	 ebx, eax
  01a0b	3b c8		 cmp	 ecx, eax
  01a0d	76 0d		 jbe	 SHORT $LN1634@ThreadWMI
  01a0f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01a14	8b 44 24 64	 mov	 eax, DWORD PTR _sysInfo$[esp+404]
  01a18	8b 4c 24 60	 mov	 ecx, DWORD PTR _sysInfo$[esp+400]
$LN1634@ThreadWMI:
  01a1c	8b 74 24 54	 mov	 esi, DWORD PTR _sysInfo$[esp+388]
  01a20	8b f9		 mov	 edi, ecx
  01a22	3b c8		 cmp	 ecx, eax
  01a24	76 05		 jbe	 SHORT $LN1653@ThreadWMI
  01a26	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1653@ThreadWMI:
  01a2b	8b 44 24 54	 mov	 eax, DWORD PTR _sysInfo$[esp+388]
  01a2f	53		 push	 ebx
  01a30	56		 push	 esi
  01a31	57		 push	 edi
  01a32	50		 push	 eax
  01a33	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T236395[esp+404]
  01a37	8d 74 24 64	 lea	 esi, DWORD PTR _sysInfo$[esp+404]
  01a3b	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1010 :     net.clear();

  01a40	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _net$[esp+404]
  01a47	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
  01a4e	8b d8		 mov	 ebx, eax
  01a50	3b c8		 cmp	 ecx, eax
  01a52	76 13		 jbe	 SHORT $LN1674@ThreadWMI
  01a54	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01a59	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR _net$[esp+404]
  01a60	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+400]
$LN1674@ThreadWMI:
  01a67	8b b4 24 84 00
	00 00		 mov	 esi, DWORD PTR _net$[esp+388]
  01a6e	8b f9		 mov	 edi, ecx
  01a70	3b c8		 cmp	 ecx, eax
  01a72	76 05		 jbe	 SHORT $LN1693@ThreadWMI
  01a74	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1693@ThreadWMI:
  01a79	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR _net$[esp+388]
  01a80	53		 push	 ebx
  01a81	56		 push	 esi
  01a82	57		 push	 edi
  01a83	51		 push	 ecx
  01a84	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T236611[esp+404]
  01a88	8d b4 24 94 00
	00 00		 lea	 esi, DWORD PTR _net$[esp+404]
  01a8f	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1011 :     user.clear();

  01a94	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR _user$[esp+404]
  01a9b	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+400]
  01aa2	8b d8		 mov	 ebx, eax
  01aa4	3b c8		 cmp	 ecx, eax
  01aa6	76 13		 jbe	 SHORT $LN1714@ThreadWMI
  01aa8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01aad	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR _user$[esp+404]
  01ab4	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR _user$[esp+400]
$LN1714@ThreadWMI:
  01abb	8b b4 24 cc 00
	00 00		 mov	 esi, DWORD PTR _user$[esp+388]
  01ac2	8b f9		 mov	 edi, ecx
  01ac4	3b c8		 cmp	 ecx, eax
  01ac6	76 05		 jbe	 SHORT $LN1733@ThreadWMI
  01ac8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1733@ThreadWMI:
  01acd	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR _user$[esp+388]
  01ad4	53		 push	 ebx
  01ad5	56		 push	 esi
  01ad6	57		 push	 edi
  01ad7	52		 push	 edx
  01ad8	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T236788[esp+404]
  01adc	8d b4 24 dc 00
	00 00		 lea	 esi, DWORD PTR _user$[esp+404]
  01ae3	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1012 :     dev.clear();

  01ae8	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR _dev$[esp+404]
  01aef	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+400]
  01af6	8b d8		 mov	 ebx, eax
  01af8	3b c8		 cmp	 ecx, eax
  01afa	76 13		 jbe	 SHORT $LN1754@ThreadWMI
  01afc	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01b01	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR _dev$[esp+404]
  01b08	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR _dev$[esp+400]
$LN1754@ThreadWMI:
  01b0f	8b b4 24 b4 00
	00 00		 mov	 esi, DWORD PTR _dev$[esp+388]
  01b16	8b f9		 mov	 edi, ecx
  01b18	3b c8		 cmp	 ecx, eax
  01b1a	76 05		 jbe	 SHORT $LN1773@ThreadWMI
  01b1c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1773@ThreadWMI:
  01b21	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR _dev$[esp+388]
  01b28	53		 push	 ebx
  01b29	56		 push	 esi
  01b2a	57		 push	 edi
  01b2b	50		 push	 eax
  01b2c	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T236985[esp+404]
  01b30	8d b4 24 c4 00
	00 00		 lea	 esi, DWORD PTR _dev$[esp+404]
  01b37	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1013 :     util.clear();

  01b3c	8b 44 24 44	 mov	 eax, DWORD PTR _util$[esp+404]
  01b40	8b 7c 24 40	 mov	 edi, DWORD PTR _util$[esp+400]
  01b44	8b d8		 mov	 ebx, eax
  01b46	3b f8		 cmp	 edi, eax
  01b48	76 0d		 jbe	 SHORT $LN1794@ThreadWMI
  01b4a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  01b4f	8b 44 24 44	 mov	 eax, DWORD PTR _util$[esp+404]
  01b53	8b 7c 24 40	 mov	 edi, DWORD PTR _util$[esp+400]
$LN1794@ThreadWMI:
  01b57	8b 74 24 34	 mov	 esi, DWORD PTR _util$[esp+388]
  01b5b	3b f8		 cmp	 edi, eax
  01b5d	76 05		 jbe	 SHORT $LN1813@ThreadWMI
  01b5f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
$LN1813@ThreadWMI:
  01b64	8b 4c 24 34	 mov	 ecx, DWORD PTR _util$[esp+388]
  01b68	53		 push	 ebx
  01b69	56		 push	 esi
  01b6a	57		 push	 edi
  01b6b	51		 push	 ecx
  01b6c	8d 5c 24 5c	 lea	 ebx, DWORD PTR $T237182[esp+404]
  01b70	8d 74 24 44	 lea	 esi, DWORD PTR _util$[esp+404]
  01b74	e8 00 00 00 00	 call	 ?erase@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::erase

; 1014 : 
; 1015 :     unsigned __int64 tickEnd;
; 1016 :     float timeElapsed;
; 1017 :     unsigned long seconds;
; 1018 :     CalcElapsedTime(tickStart,tickEnd,timeElapsed,seconds);

  01b79	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR _tickStart$[esp+388]
  01b80	8d 94 24 e4 00
	00 00		 lea	 edx, DWORD PTR _seconds$[esp+388]
  01b87	52		 push	 edx
  01b88	8d 44 24 50	 lea	 eax, DWORD PTR _timeElapsed$[esp+392]
  01b8c	50		 push	 eax
  01b8d	33 c0		 xor	 eax, eax
  01b8f	50		 push	 eax
  01b90	51		 push	 ecx
  01b91	8d b4 24 4c 01
	00 00		 lea	 esi, DWORD PTR _tickEnd$[esp+404]
  01b98	e8 00 00 00 00	 call	 ?CalcElapsedTime@@YAX_KAA_KAAMAAK@Z ; CalcElapsedTime

; 1019 : 
; 1020 :     Log(LOG_DEBUG_WMI,__LINE__,"ThrdWMI, Out, %02d:%02d:%02d, %f s",seconds/3600,(seconds % 3600)/60,seconds % 60,timeElapsed);

  01b9d	d9 44 24 5c	 fld	 DWORD PTR _timeElapsed$[esp+404]
  01ba1	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR _seconds$[esp+404]
  01ba8	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  01bac	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  01bb1	f7 e1		 mul	 ecx
  01bb3	8b f2		 mov	 esi, edx
  01bb5	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  01bba	f7 e1		 mul	 ecx
  01bbc	c1 ea 05	 shr	 edx, 5
  01bbf	8b c2		 mov	 eax, edx
  01bc1	c1 e0 04	 shl	 eax, 4
  01bc4	2b c2		 sub	 eax, edx
  01bc6	03 c0		 add	 eax, eax
  01bc8	03 c0		 add	 eax, eax
  01bca	8b d1		 mov	 edx, ecx
  01bcc	2b d0		 sub	 edx, eax
  01bce	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  01bd1	8b c6		 mov	 eax, esi
  01bd3	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  01bd9	83 c4 08	 add	 esp, 8
  01bdc	52		 push	 edx
  01bdd	2b c8		 sub	 ecx, eax
  01bdf	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  01be4	f7 e1		 mul	 ecx
  01be6	c1 ea 05	 shr	 edx, 5
  01be9	52		 push	 edx
  01bea	56		 push	 esi
  01beb	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KILGIJLE@ThrdWMI?0?5Out?0?5?$CF02d?3?$CF02d?3?$CF02d?0?5?$CFf@
  01bf0	68 fc 03 00 00	 push	 1020			; 000003fcH
  01bf5	6a 40		 push	 64			; 00000040H
  01bf7	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1021 : 	_endthreadex(0);

  01bfc	6a 00		 push	 0
  01bfe	e8 00 00 00 00	 call	 __endthreadex
  01c03	83 c4 24	 add	 esp, 36			; 00000024H

; 1022 : 	return 0;

  01c06	c6 84 24 80 01
	00 00 0c	 mov	 BYTE PTR __$EHRec$[esp+396], 12 ; 0000000cH
  01c0e	8d 4c 24 34	 lea	 ecx, DWORD PTR _util$[esp+388]
  01c12	51		 push	 ecx
  01c13	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c18	c6 84 24 80 01
	00 00 0a	 mov	 BYTE PTR __$EHRec$[esp+396], 10 ; 0000000aH
  01c20	8d 94 24 b4 00
	00 00		 lea	 edx, DWORD PTR _dev$[esp+388]
  01c27	52		 push	 edx
  01c28	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c2d	c6 84 24 80 01
	00 00 08	 mov	 BYTE PTR __$EHRec$[esp+396], 8
  01c35	8d 84 24 cc 00
	00 00		 lea	 eax, DWORD PTR _user$[esp+388]
  01c3c	50		 push	 eax
  01c3d	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c42	c6 84 24 80 01
	00 00 06	 mov	 BYTE PTR __$EHRec$[esp+396], 6
  01c4a	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR _net$[esp+388]
  01c51	51		 push	 ecx
  01c52	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c57	c6 84 24 80 01
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+396], 4
  01c5f	8d 54 24 54	 lea	 edx, DWORD PTR _sysInfo$[esp+388]
  01c63	52		 push	 edx
  01c64	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c69	c6 84 24 80 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+396], 2
  01c71	8d 44 24 6c	 lea	 eax, DWORD PTR _memory$[esp+388]
  01c75	50		 push	 eax
  01c76	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c7b	c6 84 24 80 01
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+396], 0
  01c83	8d 8c 24 9c 00
	00 00		 lea	 ecx, DWORD PTR _data$[esp+388]
  01c8a	51		 push	 ecx
  01c8b	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01c90	c7 84 24 80 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+396], -1
  01c9b	8d 54 24 1c	 lea	 edx, DWORD PTR _hwInfo$[esp+388]
  01c9f	52		 push	 edx
  01ca0	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  01ca5	33 c0		 xor	 eax, eax

; 1023 : }

  01ca7	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+388]
  01cae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01cb5	59		 pop	 ecx
  01cb6	5f		 pop	 edi
  01cb7	5e		 pop	 esi
  01cb8	5d		 pop	 ebp
  01cb9	5b		 pop	 ebx
  01cba	8b e5		 mov	 esp, ebp
  01cbc	5d		 pop	 ebp
  01cbd	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$0:
  00000	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR _hwInfo$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0000c	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$1:
  0000d	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232221[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$2:
  00018	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _data$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00024	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$3:
  00025	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232222[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$4:
  00030	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _memory$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0003c	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$5:
  0003d	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232223[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$6:
  00048	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _sysInfo$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00054	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$7:
  00055	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232224[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$8:
  00060	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR _net$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006c	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$9:
  0006d	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232225[ebp]
  00073	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$10:
  00078	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _user$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00084	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$11:
  00085	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232226[ebp]
  0008b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$12:
  00090	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _dev$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0009c	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$13:
  0009d	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232227[ebp]
  000a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$14:
  000a8	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR _util$[ebp]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  000b4	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$15:
  000b5	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR $T232228[ebp]
  000bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ThreadWMI@@YGIPAX@Z:
  000c0	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000c4	8d 82 8c fe ff
	ff		 lea	 eax, DWORD PTR [edx-372]
  000ca	8b 8a 88 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-376]
  000d0	33 c8		 xor	 ecx, eax
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThreadWMI@@YGIPAX@Z
  000dc	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThreadWMI@@YGIPAX@Z ENDP				; ThreadWMI
END
