; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27031.1 

	TITLE	c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_03LJNDFDHG@WQL@				; `string'
PUBLIC	??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x@ ; `string'
PUBLIC	??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ@ ; `string'
PUBLIC	??_C@_06DBMAJEKE@0x?$CF?42X@			; `string'
PUBLIC	??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X@	; `string'
PUBLIC	??_C@_06DFENOIBG@0x?$CF?44X@			; `string'
PUBLIC	??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X@	; `string'
PUBLIC	??_C@_06DMFHBBHC@0x?$CF?48X@			; `string'
PUBLIC	??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X@	; `string'
PUBLIC	??_C@_06GGPPAHKI@0x?$CFllX@			; `string'
PUBLIC	??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X@	; `string'
PUBLIC	??_C@_09LCPBGOAC@0x?$CF?416llX@			; `string'
PUBLIC	??_C@_0P@BEIAOANA@?$CFs?5?$DN?50x?$CF?416llX@	; `string'
PUBLIC	??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf@		; `string'
PUBLIC	??_C@_02CGLCDNAE@?$CFe@				; `string'
PUBLIC	??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe@		; `string'
PUBLIC	??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs@		; `string'
PUBLIC	??_C@_03FKNCMABI@?$CFlu@			; `string'
PUBLIC	??_C@_08MBLOFINO@?$CFs?5?$DN?5?$CFlu@		; `string'
PUBLIC	??_C@_04EHEKGOB@?$CF?43u@			; `string'
PUBLIC	??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X@		; `string'
PUBLIC	??_C@_09MHANBIPO@?$CFs?40x?$CF?44X@		; `string'
PUBLIC	??_C@_07OPDHNNBB@0x?$CF?48lX@			; `string'
PUBLIC	??_C@_0L@EBBEPHKL@?$CFs?40x?$CF?48lX@		; `string'
PUBLIC	??_C@_0N@HHGAEPMF@?$CFs?40x?$CF?416llX@		; `string'
PUBLIC	??_C@_05OKOCMAOB@?$CFs?4?$CFf@			; `string'
PUBLIC	??_C@_05MBMPJDCC@?$CFs?4?$CFe@			; `string'
PUBLIC	??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3@		; `string'
PUBLIC	??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs@	; `string'
PUBLIC	??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd@		; `string'
PUBLIC	??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion@ ; `string'
PUBLIC	??_C@_0BJ@LOAJDHFE@?$CFlu?5properties?5processed@ ; `string'
PUBLIC	??_C@_0CL@NIHPHPOO@Elapsed?5Time?3?5?$CF02llu?3?$CF02llu?3?$CF02@ ; `string'
PUBLIC	??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True@	; `string'
PUBLIC	??_C@_0BE@CMGEPGOJ@?$DO?$DO?5ThrdWMICls?0?50x?$CFp@ ; `string'
PUBLIC	??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null@ ; `string'
PUBLIC	??_C@_0P@GEABHMOE@?$CFs_?$CFs_?$CF?41d?4xml@	; `string'
PUBLIC	??_C@_0BO@KIFPLLFC@?9?9?5ThrdWMICls?0?5Trying?5opng?5?$CFs@ ; `string'
PUBLIC	??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5ol@ ; `string'
PUBLIC	??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CF@ ; `string'
PUBLIC	??_C@_0M@EJAENGON@?$CFs_?$CFs_0?4xml@		; `string'
PUBLIC	??_C@_09LJCHENPN@?$CFs_?$CFs?4xml@		; `string'
PUBLIC	??_C@_0CC@FAKIJPEF@?9?9?5ThrdWMICls?0?5Remaining?5?$CFs?5?9?$DO?5@ ; `string'
PUBLIC	??_C@_0DA@NFLHPILJ@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02llu?3?$CF02ll@ ; `string'
PUBLIC	??_C@_0BE@JLEOHDJI@?$DO?$DO?5ThrdWMI?0?5In?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_03MFKIFBDE@hwi@				; `string'
PUBLIC	??_C@_0N@FBNILPME@HardwareInfo@			; `string'
PUBLIC	??_C@_0BF@MGDJDLAD@Hardware?5Information@	; `string'
PUBLIC	??_C@_02ELHCGPCE@ds@				; `string'
PUBLIC	??_C@_0M@PNBJJAPO@DataStorage@			; `string'
PUBLIC	??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information@ ; `string'
PUBLIC	??_C@_03IJLIBDBM@mem@				; `string'
PUBLIC	??_C@_06LEBJIAPJ@Memory@			; `string'
PUBLIC	??_C@_0BD@BGPGMIME@Memory?5Information@		; `string'
PUBLIC	??_C@_04HDBAHLAM@sysi@				; `string'
PUBLIC	??_C@_0L@NDINDOCK@SystemInfo@			; `string'
PUBLIC	??_C@_0BD@OJGHJHKA@System?5Information@		; `string'
PUBLIC	??_C@_03NBFOK@net@				; `string'
PUBLIC	??_C@_07BGDMAJAE@Network@			; `string'
PUBLIC	??_C@_0BE@KDFOEONK@Network?5Information@	; `string'
PUBLIC	??_C@_03FNIGJHAM@dev@				; `string'
PUBLIC	??_C@_09HCBPJCHD@Developer@			; `string'
PUBLIC	??_C@_0BG@KMFPDIMK@Developer?5Information@	; `string'
PUBLIC	??_C@_04GCPMIEJC@util@				; `string'
PUBLIC	??_C@_07HCOFHGI@Utility@			; `string'
PUBLIC	??_C@_0BE@DMCOJOJG@Utility?5Information@	; `string'
PUBLIC	??_C@_0BK@COLFJDO@?9?9?5ThrdWMI?0?5Waitg?5?$CFu?5thrs@ ; `string'
PUBLIC	??_C@_0CO@MMEAEDPF@?$DM?$DM?5ThrdWMI?0?5Out?0?5?$CF02llu?3?$CF02llu?3@ ; `string'
PUBLIC	??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols@		; `string'
PUBLIC	??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols@		; `string'
PUBLIC	??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf@		; `string'
PUBLIC	??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf@		; `string'
PUBLIC	??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr@		; `string'
PUBLIC	??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr@		; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	_IID_IRegistrar
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	_LIBID_ATLLib
PUBLIC	_IID_IInternalConnection
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	___pobjMapEntryLast
PUBLIC	___pobjMapEntryFirst
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	_CLSID_Registrar
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	??_C@_02NJPGOMH@?$CFf@				; `string'
PUBLIC	??_C@_0BA@MKMIKKJB@atlTraceGeneral@		; `string'
PUBLIC	??_C@_0M@DGPFJEBB@atlTraceCOM@			; `string'
PUBLIC	??_C@_0L@LHELAKBP@atlTraceQI@			; `string'
PUBLIC	??_C@_0BC@MALHFBAO@atlTraceRegistrar@		; `string'
PUBLIC	??_C@_0BB@ILPPDKFL@atlTraceRefcount@		; `string'
PUBLIC	??_C@_0BC@DGHHNKDC@atlTraceWindowing@		; `string'
PUBLIC	??_C@_0BB@GHKJKKIE@atlTraceControls@		; `string'
PUBLIC	??_C@_0BA@DKOAAGGM@atlTraceHosting@		; `string'
PUBLIC	??_C@_0BB@BEBMGMDO@atlTraceDBClient@		; `string'
PUBLIC	??_C@_0BD@KOADKDIA@atlTraceDBProvider@		; `string'
PUBLIC	??_C@_0P@LNEGBOLO@atlTraceSnapin@		; `string'
PUBLIC	??_C@_0BA@MCBFIDIC@atlTraceNotImpl@		; `string'
PUBLIC	??_C@_0BD@PJPCCAKP@atlTraceAllocation@		; `string'
PUBLIC	??_C@_0BC@PGMFNIFA@atlTraceException@		; `string'
PUBLIC	??_C@_0N@BNNILHBE@atlTraceTime@			; `string'
PUBLIC	??_C@_0O@MEOJAOKK@atlTraceCache@		; `string'
PUBLIC	??_C@_0BA@IDBKCKK@atlTraceStencil@		; `string'
PUBLIC	??_C@_0P@MBNHGHMI@atlTraceString@		; `string'
PUBLIC	??_C@_0M@IOBBMAHG@atlTraceMap@			; `string'
PUBLIC	??_C@_0N@FEAAACHD@atlTraceUtil@			; `string'
PUBLIC	??_C@_0BB@DNJDADMG@atlTraceSecurity@		; `string'
PUBLIC	??_C@_0N@KLPNCFEE@atlTraceSync@			; `string'
PUBLIC	??_C@_0O@KHOBHOBJ@atlTraceISAPI@		; `string'
PUBLIC	??_C@_01CPLAODJH@S@				; `string'
PUBLIC	??_C@_01PLPBNMEI@M@				; `string'
PUBLIC	??_C@_01CKDDGHAB@D@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B@				; `string'
PUBLIC	??_C@_03LAIAPFCB@Val@				; `string'
PUBLIC	??_C@_0M@DBGDLGLL@ForceRemove@			; `string'
PUBLIC	??_C@_08KAAPDIAN@NoRemove@			; `string'
PUBLIC	??_C@_06JBKGCNBB@Delete@			; `string'
PUBLIC	??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs@	; `string'
PUBLIC	??_C@_0BI@BJBFJFDH@?$DM?$DM?5WMI?0?5Null?5class?5name@ ; `string'
PUBLIC	??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex@		; `string'
PUBLIC	??_C@_0BO@LNIDFIJJ@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?50x?$CFp?5timeout@ ; `string'
PUBLIC	??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5CO@ ; `string'
PUBLIC	??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5se@ ; `string'
PUBLIC	??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemL@ ; `string'
PUBLIC	??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@ ; `string'
PUBLIC	??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?4@ ; `string'
PUBLIC	??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2@ ; `string'
PUBLIC	??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5bla@ ; `string'
PUBLIC	??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs@	; `string'
PUBLIC	??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for@ ; `string'
EXTRN	__imp__SetSecurityDescriptorDacl@16:PROC
EXTRN	_CLSID_WbemLocator:BYTE
EXTRN	__imp__SafeArrayDestroy@4:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__SafeArrayGetUBound@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__SafeArrayUnlock@4:PROC
EXTRN	__imp__SafeArrayGetLBound@12:PROC
EXTRN	___ImageBase:BYTE
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__SafeArrayGetVartype@8:PROC
EXTRN	_IID_IWbemLocator:BYTE
EXTRN	__imp__CoInitializeSecurity@36:PROC
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z:PROC ; _com_util::ConvertStringToBSTR
EXTRN	__imp__CoSetProxyBlanket@32:PROC
EXTRN	__imp__SafeArrayLock@4:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	__imp__InitializeSecurityDescriptor@8:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	?_com_issue_error@@YGXJ@Z:PROC			; _com_issue_error
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__VariantClear@4:PROC
;	COMDAT ?secInitialized@?1??WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z@4_NA
_BSS	SEGMENT
?secInitialized@?1??WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z@4_NA DB 01H DUP (?) ; `WMIex'::`2'::secInitialized
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for@
CONST	SEGMENT
??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for@ DB '-- WMI, Qu'
	DB	'erying properties for %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs@
CONST	SEGMENT
??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs@ DB 'SELECT * FROM %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5bla@
CONST	SEGMENT
??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5bla@ DB '<< W'
	DB	'MI, Could not set proxy blanket, 0x%.8x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2@
CONST	SEGMENT
??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2@ DB '-- WMI, C'
	DB	'onnected to ROOT\CIMV2 WMI namespace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?4@
CONST	SEGMENT
??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?4@ DB '<'
	DB	'< WMI, Could not connect, 0x%.8x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@
CONST	SEGMENT
??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@ DB 'R'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, '\', 00H, 'C', 00H, 'I', 00H
	DB	'M', 00H, 'V', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemL@
CONST	SEGMENT
??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemL@ DB '<< WM'
	DB	'I, Failed to create IWbemLocator object,0x%.8x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5se@
CONST	SEGMENT
??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5se@ DB '<< WM'
	DB	'I, Failed to initialize security, 0x%.8x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5CO@
CONST	SEGMENT
??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5CO@ DB '<< WMI'
	DB	', Failed to initialize COM library, 0x%.8X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LNIDFIJJ@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?50x?$CFp?5timeout@
CONST	SEGMENT
??_C@_0BO@LNIDFIJJ@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?50x?$CFp?5timeout@ DB '<'
	DB	'< WMI, %s Mutex 0x%p timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex@
CONST	SEGMENT
??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex@ DB 'SysStatus_WMI_Mutex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BJBFJFDH@?$DM?$DM?5WMI?0?5Null?5class?5name@
CONST	SEGMENT
??_C@_0BI@BJBFJFDH@?$DM?$DM?5WMI?0?5Null?5class?5name@ DB '<< WMI, Null c'
	DB	'lass name', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs@
CONST	SEGMENT
??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs@ DB '>> WMI, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete@ DB 'Delete', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KAAPDIAN@NoRemove@
CONST	SEGMENT
??_C@_08KAAPDIAN@NoRemove@ DB 'NoRemove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DBGDLGLL@ForceRemove@
CONST	SEGMENT
??_C@_0M@DBGDLGLL@ForceRemove@ DB 'ForceRemove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LAIAPFCB@Val@
CONST	SEGMENT
??_C@_03LAIAPFCB@Val@ DB 'Val', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B@
CONST	SEGMENT
??_C@_01HMGJMAIH@B@ DB 'B', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D@
CONST	SEGMENT
??_C@_01CKDDGHAB@D@ DB 'D', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLPBNMEI@M@
CONST	SEGMENT
??_C@_01PLPBNMEI@M@ DB 'M', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S@
CONST	SEGMENT
??_C@_01CPLAODJH@S@ DB 'S', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KHOBHOBJ@atlTraceISAPI@
CONST	SEGMENT
??_C@_0O@KHOBHOBJ@atlTraceISAPI@ DB 'atlTraceISAPI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLPNCFEE@atlTraceSync@
CONST	SEGMENT
??_C@_0N@KLPNCFEE@atlTraceSync@ DB 'atlTraceSync', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNJDADMG@atlTraceSecurity@
CONST	SEGMENT
??_C@_0BB@DNJDADMG@atlTraceSecurity@ DB 'atlTraceSecurity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEAAACHD@atlTraceUtil@
CONST	SEGMENT
??_C@_0N@FEAAACHD@atlTraceUtil@ DB 'atlTraceUtil', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOBBMAHG@atlTraceMap@
CONST	SEGMENT
??_C@_0M@IOBBMAHG@atlTraceMap@ DB 'atlTraceMap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MBNHGHMI@atlTraceString@
CONST	SEGMENT
??_C@_0P@MBNHGHMI@atlTraceString@ DB 'atlTraceString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDBKCKK@atlTraceStencil@
CONST	SEGMENT
??_C@_0BA@IDBKCKK@atlTraceStencil@ DB 'atlTraceStencil', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEOJAOKK@atlTraceCache@
CONST	SEGMENT
??_C@_0O@MEOJAOKK@atlTraceCache@ DB 'atlTraceCache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNNILHBE@atlTraceTime@
CONST	SEGMENT
??_C@_0N@BNNILHBE@atlTraceTime@ DB 'atlTraceTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGMFNIFA@atlTraceException@
CONST	SEGMENT
??_C@_0BC@PGMFNIFA@atlTraceException@ DB 'atlTraceException', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJPCCAKP@atlTraceAllocation@
CONST	SEGMENT
??_C@_0BD@PJPCCAKP@atlTraceAllocation@ DB 'atlTraceAllocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MCBFIDIC@atlTraceNotImpl@
CONST	SEGMENT
??_C@_0BA@MCBFIDIC@atlTraceNotImpl@ DB 'atlTraceNotImpl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNEGBOLO@atlTraceSnapin@
CONST	SEGMENT
??_C@_0P@LNEGBOLO@atlTraceSnapin@ DB 'atlTraceSnapin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOADKDIA@atlTraceDBProvider@
CONST	SEGMENT
??_C@_0BD@KOADKDIA@atlTraceDBProvider@ DB 'atlTraceDBProvider', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BEBMGMDO@atlTraceDBClient@
CONST	SEGMENT
??_C@_0BB@BEBMGMDO@atlTraceDBClient@ DB 'atlTraceDBClient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKOAAGGM@atlTraceHosting@
CONST	SEGMENT
??_C@_0BA@DKOAAGGM@atlTraceHosting@ DB 'atlTraceHosting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHKJKKIE@atlTraceControls@
CONST	SEGMENT
??_C@_0BB@GHKJKKIE@atlTraceControls@ DB 'atlTraceControls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DGHHNKDC@atlTraceWindowing@
CONST	SEGMENT
??_C@_0BC@DGHHNKDC@atlTraceWindowing@ DB 'atlTraceWindowing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILPPDKFL@atlTraceRefcount@
CONST	SEGMENT
??_C@_0BB@ILPPDKFL@atlTraceRefcount@ DB 'atlTraceRefcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MALHFBAO@atlTraceRegistrar@
CONST	SEGMENT
??_C@_0BC@MALHFBAO@atlTraceRegistrar@ DB 'atlTraceRegistrar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LHELAKBP@atlTraceQI@
CONST	SEGMENT
??_C@_0L@LHELAKBP@atlTraceQI@ DB 'atlTraceQI', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGPFJEBB@atlTraceCOM@
CONST	SEGMENT
??_C@_0M@DGPFJEBB@atlTraceCOM@ DB 'atlTraceCOM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKMIKKJB@atlTraceGeneral@
CONST	SEGMENT
??_C@_0BA@MKMIKKJB@atlTraceGeneral@ DB 'atlTraceGeneral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Memory
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Processor
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_System
_DATA	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::VoltageProbe
_DATA	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::TemperatureProbe
_DATA	ENDS
;	COMDAT ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_PagingFile
_DATA	ENDS
;	COMDAT ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA
_DATA	SEGMENT
?Volume@?1??WMISystemVolumes@@YAXXZ@4KA DD 0ffffffffH	; `WMISystemVolumes'::`2'::Volume
_DATA	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfNet_Redirector
_DATA	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Cache
_DATA	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
data$r	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
data$r	ENDS
;	COMDAT ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfDisk_PhysicalDisk
_DATA	ENDS
;	COMDAT ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::CurrentProbe
_DATA	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA
_DATA	SEGMENT
?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA DD 0ffffffffH ; `WMIHardwareSensor'::`2'::PortableBattery
_DATA	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA
_DATA	SEGMENT
?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA DD 0ffffffffH ; `WMISystemPerformance'::`2'::PerfRawData_PerfOS_Objects
_DATA	ENDS
;	COMDAT ??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr@
CONST	SEGMENT
??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr@ DB '<< WMIHwSnsr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr@
CONST	SEGMENT
??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr@ DB '>> WMIHwSnsr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf@
CONST	SEGMENT
??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf@ DB '<< WMISysPerf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf@
CONST	SEGMENT
??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf@ DB '>> WMISysPerf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols@
CONST	SEGMENT
??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols@ DB '<< WMISysVols', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols@
CONST	SEGMENT
??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols@ DB '>> WMISysVols', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MMEAEDPF@?$DM?$DM?5ThrdWMI?0?5Out?0?5?$CF02llu?3?$CF02llu?3@
CONST	SEGMENT
??_C@_0CO@MMEAEDPF@?$DM?$DM?5ThrdWMI?0?5Out?0?5?$CF02llu?3?$CF02llu?3@ DB '<'
	DB	'< ThrdWMI, Out, %02llu:%02llu:%02llu, %.3f s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@COLFJDO@?9?9?5ThrdWMI?0?5Waitg?5?$CFu?5thrs@
CONST	SEGMENT
??_C@_0BK@COLFJDO@?9?9?5ThrdWMI?0?5Waitg?5?$CFu?5thrs@ DB '-- ThrdWMI, Wa'
	DB	'itg %u thrs', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DMCOJOJG@Utility?5Information@
CONST	SEGMENT
??_C@_0BE@DMCOJOJG@Utility?5Information@ DB 'Utility Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HCOFHGI@Utility@
CONST	SEGMENT
??_C@_07HCOFHGI@Utility@ DB 'Utility', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GCPMIEJC@util@
CONST	SEGMENT
??_C@_04GCPMIEJC@util@ DB 'util', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KMFPDIMK@Developer?5Information@
CONST	SEGMENT
??_C@_0BG@KMFPDIMK@Developer?5Information@ DB 'Developer Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCBPJCHD@Developer@
CONST	SEGMENT
??_C@_09HCBPJCHD@Developer@ DB 'Developer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FNIGJHAM@dev@
CONST	SEGMENT
??_C@_03FNIGJHAM@dev@ DB 'dev', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDFOEONK@Network?5Information@
CONST	SEGMENT
??_C@_0BE@KDFOEONK@Network?5Information@ DB 'Network Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGDMAJAE@Network@
CONST	SEGMENT
??_C@_07BGDMAJAE@Network@ DB 'Network', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NBFOK@net@
CONST	SEGMENT
??_C@_03NBFOK@net@ DB 'net', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OJGHJHKA@System?5Information@
CONST	SEGMENT
??_C@_0BD@OJGHJHKA@System?5Information@ DB 'System Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDINDOCK@SystemInfo@
CONST	SEGMENT
??_C@_0L@NDINDOCK@SystemInfo@ DB 'SystemInfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDBAHLAM@sysi@
CONST	SEGMENT
??_C@_04HDBAHLAM@sysi@ DB 'sysi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGPGMIME@Memory?5Information@
CONST	SEGMENT
??_C@_0BD@BGPGMIME@Memory?5Information@ DB 'Memory Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEBJIAPJ@Memory@
CONST	SEGMENT
??_C@_06LEBJIAPJ@Memory@ DB 'Memory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IJLIBDBM@mem@
CONST	SEGMENT
??_C@_03IJLIBDBM@mem@ DB 'mem', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information@
CONST	SEGMENT
??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information@ DB 'Disk and Parti'
	DB	'tions Information', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PNBJJAPO@DataStorage@
CONST	SEGMENT
??_C@_0M@PNBJJAPO@DataStorage@ DB 'DataStorage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02ELHCGPCE@ds@
CONST	SEGMENT
??_C@_02ELHCGPCE@ds@ DB 'ds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGDJDLAD@Hardware?5Information@
CONST	SEGMENT
??_C@_0BF@MGDJDLAD@Hardware?5Information@ DB 'Hardware Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBNILPME@HardwareInfo@
CONST	SEGMENT
??_C@_0N@FBNILPME@HardwareInfo@ DB 'HardwareInfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MFKIFBDE@hwi@
CONST	SEGMENT
??_C@_03MFKIFBDE@hwi@ DB 'hwi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JLEOHDJI@?$DO?$DO?5ThrdWMI?0?5In?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BE@JLEOHDJI@?$DO?$DO?5ThrdWMI?0?5In?5?$CI?$CFp?$CJ@ DB '>> ThrdWMI'
	DB	', In (%p)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NFLHPILJ@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02llu?3?$CF02ll@
CONST	SEGMENT
??_C@_0DA@NFLHPILJ@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02llu?3?$CF02ll@ DB '<'
	DB	'< ThrdWMICls, %s, %02llu:%02llu:%02llu, %.3f s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FAKIJPEF@?9?9?5ThrdWMICls?0?5Remaining?5?$CFs?5?9?$DO?5@
CONST	SEGMENT
??_C@_0CC@FAKIJPEF@?9?9?5ThrdWMICls?0?5Remaining?5?$CFs?5?9?$DO?5@ DB '--'
	DB	' ThrdWMICls, Remaining %s -> %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJCHENPN@?$CFs_?$CFs?4xml@
CONST	SEGMENT
??_C@_09LJCHENPN@?$CFs_?$CFs?4xml@ DB '%s_%s.xml', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EJAENGON@?$CFs_?$CFs_0?4xml@
CONST	SEGMENT
??_C@_0M@EJAENGON@?$CFs_?$CFs_0?4xml@ DB '%s_%s_0.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CF@
CONST	SEGMENT
??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CF@ DB '-'
	DB	'- ThrdWMICls, Renaming %s -> %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5ol@
CONST	SEGMENT
??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5ol@ DB '-- Thr'
	DB	'dWMICls, Removing %s - oldest file', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CF@
CONST	SEGMENT
??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CF@ DB '-- Th'
	DB	'rdWMICls, Last file fnd: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KIFPLLFC@?9?9?5ThrdWMICls?0?5Trying?5opng?5?$CFs@
CONST	SEGMENT
??_C@_0BO@KIFPLLFC@?9?9?5ThrdWMICls?0?5Trying?5opng?5?$CFs@ DB '-- ThrdWM'
	DB	'ICls, Trying opng %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GEABHMOE@?$CFs_?$CFs_?$CF?41d?4xml@
CONST	SEGMENT
??_C@_0P@GEABHMOE@?$CFs_?$CFs_?$CF?41d?4xml@ DB '%s_%s_%.1d.xml', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null@
CONST	SEGMENT
??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null@ DB '<< ThrdWMICls'
	DB	', Input null', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CMGEPGOJ@?$DO?$DO?5ThrdWMICls?0?50x?$CFp@
CONST	SEGMENT
??_C@_0BE@CMGEPGOJ@?$DO?$DO?5ThrdWMICls?0?50x?$CFp@ DB '>> ThrdWMICls, 0x'
	DB	'%p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True@
CONST	SEGMENT
??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True@ DB '<< WMI, ret True', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NIHPHPOO@Elapsed?5Time?3?5?$CF02llu?3?$CF02llu?3?$CF02@
CONST	SEGMENT
??_C@_0CL@NIHPHPOO@Elapsed?5Time?3?5?$CF02llu?3?$CF02llu?3?$CF02@ DB 'Ela'
	DB	'psed Time: %02llu:%02llu:%02llu, %.3f s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LOAJDHFE@?$CFlu?5properties?5processed@
CONST	SEGMENT
??_C@_0BJ@LOAJDHFE@?$CFlu?5properties?5processed@ DB '%lu properties proc'
	DB	'essed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion@
CONST	SEGMENT
??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion@ DB '-- WMI, Ca'
	DB	'tch unhndld excpetion on %.5u %s (%i) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd@
CONST	SEGMENT
??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd@ DB '%s = %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs@
CONST	SEGMENT
??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs@ DB 09H, '> %.3d %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3@
CONST	SEGMENT
??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3@ DB '%s, %d:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBMPJDCC@?$CFs?4?$CFe@
CONST	SEGMENT
??_C@_05MBMPJDCC@?$CFs?4?$CFe@ DB '%s.%e', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OKOCMAOB@?$CFs?4?$CFf@
CONST	SEGMENT
??_C@_05OKOCMAOB@?$CFs?4?$CFf@ DB '%s.%f', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HHGAEPMF@?$CFs?40x?$CF?416llX@
CONST	SEGMENT
??_C@_0N@HHGAEPMF@?$CFs?40x?$CF?416llX@ DB '%s.0x%.16llX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EBBEPHKL@?$CFs?40x?$CF?48lX@
CONST	SEGMENT
??_C@_0L@EBBEPHKL@?$CFs?40x?$CF?48lX@ DB '%s.0x%.8lX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OPDHNNBB@0x?$CF?48lX@
CONST	SEGMENT
??_C@_07OPDHNNBB@0x?$CF?48lX@ DB '0x%.8lX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MHANBIPO@?$CFs?40x?$CF?44X@
CONST	SEGMENT
??_C@_09MHANBIPO@?$CFs?40x?$CF?44X@ DB '%s.0x%.4X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X@
CONST	SEGMENT
??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X@ DB '%s.0x%.2X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHEKGOB@?$CF?43u@
CONST	SEGMENT
??_C@_04EHEKGOB@?$CF?43u@ DB '%.3u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MBLOFINO@?$CFs?5?$DN?5?$CFlu@
CONST	SEGMENT
??_C@_08MBLOFINO@?$CFs?5?$DN?5?$CFlu@ DB '%s = %lu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKNCMABI@?$CFlu@
CONST	SEGMENT
??_C@_03FKNCMABI@?$CFlu@ DB '%lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs@
CONST	SEGMENT
??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs@ DB '%s = %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe@
CONST	SEGMENT
??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe@ DB '%s = %e', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CGLCDNAE@?$CFe@
CONST	SEGMENT
??_C@_02CGLCDNAE@?$CFe@ DB '%e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf@
CONST	SEGMENT
??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf@ DB '%s = %f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BEIAOANA@?$CFs?5?$DN?50x?$CF?416llX@
CONST	SEGMENT
??_C@_0P@BEIAOANA@?$CFs?5?$DN?50x?$CF?416llX@ DB '%s = 0x%.16llX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LCPBGOAC@0x?$CF?416llX@
CONST	SEGMENT
??_C@_09LCPBGOAC@0x?$CF?416llX@ DB '0x%.16llX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X@
CONST	SEGMENT
??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X@ DB '%s = 0x%.16X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGPPAHKI@0x?$CFllX@
CONST	SEGMENT
??_C@_06GGPPAHKI@0x?$CFllX@ DB '0x%llX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X@
CONST	SEGMENT
??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X@ DB '%s = 0x%.8X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMFHBBHC@0x?$CF?48X@
CONST	SEGMENT
??_C@_06DMFHBBHC@0x?$CF?48X@ DB '0x%.8X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X@
CONST	SEGMENT
??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X@ DB '%s = 0x%.4X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DFENOIBG@0x?$CF?44X@
CONST	SEGMENT
??_C@_06DFENOIBG@0x?$CF?44X@ DB '0x%.4X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X@
CONST	SEGMENT
??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X@ DB '%s = 0x%.2X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBMAJEKE@0x?$CF?42X@
CONST	SEGMENT
??_C@_06DBMAJEKE@0x?$CF?42X@ DB '0x%.2X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ@
CONST	SEGMENT
??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ@ DB '-'
	DB	'- WMI, Processing %.5u %s (%i) %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x@
CONST	SEGMENT
??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x@ DB '-- W'
	DB	'MI, Query for %s failed, 0x%.8x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJNDFDHG@WQL@
CONST	SEGMENT
??_C@_03LJNDFDHG@WQL@ DB 'WQL', 00H			; `string'
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z	; std::_Copy_memmove<unsigned short *,unsigned short *>
PUBLIC	??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z	; std::_Copy_memmove<unsigned long *,unsigned long *>
PUBLIC	??$_Copy_memmove@PA_KPA_K@std@@YAPA_KPA_K00@Z	; std::_Copy_memmove<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Copy_memmove@PAMPAM@std@@YAPAMPAM00@Z	; std::_Copy_memmove<float *,float *>
PUBLIC	??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z	; std::_Copy_memmove<double *,double *>
PUBLIC	??$_Copy_memmove@PAPA_WPAPA_W@std@@YAPAPA_WPAPA_W00@Z ; std::_Copy_memmove<wchar_t * *,wchar_t * *>
PUBLIC	??$_Emplace_back@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??$_Seek_wrapped@E@std@@YAXAAPAEQAE@Z		; std::_Seek_wrapped<unsigned char>
PUBLIC	??$_Uninitialized_move_al_unchecked@EEV?$allocator@E@std@@@std@@YAPAEQAE00AAV?$allocator@E@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned char,unsigned char,std::allocator<unsigned char> >
PUBLIC	??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ; std::_Ptr_move_cat<unsigned char,unsigned char>
PUBLIC	??$_Get_unwrapped_n@EH$0A@@std@@YAPAEQAEH@Z	; std::_Get_unwrapped_n<unsigned char,int,0>
PUBLIC	??$_Get_unwrapped@E@std@@YAPAEQAE@Z		; std::_Get_unwrapped<unsigned char>
PUBLIC	??$_Seek_wrapped@G@std@@YAXAAPAGQAG@Z		; std::_Seek_wrapped<unsigned short>
PUBLIC	??$_Uninitialized_move_al_unchecked@GGV?$allocator@G@std@@@std@@YAPAGQAG00AAV?$allocator@G@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned short,unsigned short,std::allocator<unsigned short> >
PUBLIC	??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ; std::_Ptr_move_cat<unsigned short,unsigned short>
PUBLIC	??$_Get_unwrapped_n@GH$0A@@std@@YAPAGQAGH@Z	; std::_Get_unwrapped_n<unsigned short,int,0>
PUBLIC	??$_Get_unwrapped@G@std@@YAPAGQAG@Z		; std::_Get_unwrapped<unsigned short>
PUBLIC	??$_Seek_wrapped@K@std@@YAXAAPAKQAK@Z		; std::_Seek_wrapped<unsigned long>
PUBLIC	??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKQAK00AAV?$allocator@K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned long,unsigned long,std::allocator<unsigned long> >
PUBLIC	??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ; std::_Ptr_move_cat<unsigned long,unsigned long>
PUBLIC	??$_Get_unwrapped_n@KH$0A@@std@@YAPAKQAKH@Z	; std::_Get_unwrapped_n<unsigned long,int,0>
PUBLIC	??$_Get_unwrapped@K@std@@YAPAKQAK@Z		; std::_Get_unwrapped<unsigned long>
PUBLIC	??$_Seek_wrapped@_K@std@@YAXAAPA_KQA_K@Z	; std::_Seek_wrapped<unsigned __int64>
PUBLIC	??$_Uninitialized_move_al_unchecked@_K_KV?$allocator@_K@std@@@std@@YAPA_KQA_K00AAV?$allocator@_K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<unsigned __int64,unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>
PUBLIC	??$_Get_unwrapped_n@_KH$0A@@std@@YAPA_KQA_KH@Z	; std::_Get_unwrapped_n<unsigned __int64,int,0>
PUBLIC	??$_Get_unwrapped@_K@std@@YAPA_KQA_K@Z		; std::_Get_unwrapped<unsigned __int64>
PUBLIC	??$_Seek_wrapped@M@std@@YAXAAPAMQAM@Z		; std::_Seek_wrapped<float>
PUBLIC	??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPAMQAM00AAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<float,float,std::allocator<float> >
PUBLIC	??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z ; std::_Ptr_move_cat<float,float>
PUBLIC	??$_Get_unwrapped_n@MH$0A@@std@@YAPAMQAMH@Z	; std::_Get_unwrapped_n<float,int,0>
PUBLIC	??$_Get_unwrapped@M@std@@YAPAMQAM@Z		; std::_Get_unwrapped<float>
PUBLIC	??$_Seek_wrapped@N@std@@YAXAAPANQAN@Z		; std::_Seek_wrapped<double>
PUBLIC	??$_Uninitialized_move_al_unchecked@NNV?$allocator@N@std@@@std@@YAPANQAN00AAV?$allocator@N@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<double,double,std::allocator<double> >
PUBLIC	??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z ; std::_Ptr_move_cat<double,double>
PUBLIC	??$_Get_unwrapped_n@NH$0A@@std@@YAPANQANH@Z	; std::_Get_unwrapped_n<double,int,0>
PUBLIC	??$_Get_unwrapped@N@std@@YAPANQAN@Z		; std::_Get_unwrapped<double>
PUBLIC	??$_Seek_wrapped@PA_W@std@@YAXAAPAPA_WQAPA_W@Z	; std::_Seek_wrapped<wchar_t *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PA_WPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W00AAV?$allocator@PA_W@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<wchar_t *,wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z ; std::_Ptr_move_cat<wchar_t *,wchar_t *>
PUBLIC	??$_Get_unwrapped_n@PA_WH$0A@@std@@YAPAPA_WQAPA_WH@Z ; std::_Get_unwrapped_n<wchar_t *,int,0>
PUBLIC	??$_Get_unwrapped@PA_W@std@@YAPAPA_WQAPA_W@Z	; std::_Get_unwrapped<wchar_t *>
PUBLIC	??$_Zero_range@PAG@std@@YAPAGQAG0@Z		; std::_Zero_range<unsigned short *>
PUBLIC	??$_Zero_range@PAK@std@@YAPAKQAK0@Z		; std::_Zero_range<unsigned long *>
PUBLIC	??$_Zero_range@PA_K@std@@YAPA_KQA_K0@Z		; std::_Zero_range<unsigned __int64 *>
PUBLIC	??$_Zero_range@PAM@std@@YAPAMQAM0@Z		; std::_Zero_range<float *>
PUBLIC	??$_Zero_range@PAN@std@@YAPANQAN0@Z		; std::_Zero_range<double *>
PUBLIC	??$_Zero_range@PAPA_W@std@@YAPAPA_WQAPA_W0@Z	; std::_Zero_range<wchar_t * *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z ; std::_Uninitialized_copy_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Ptr_copy_cat@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV20@@Z ; std::_Ptr_copy_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Get_unwrapped@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@@Z ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Idl_distance@PAEPAE@std@@YA@ABQAE0@Z	; std::_Idl_distance<unsigned char *,unsigned char *>
PUBLIC	??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Idl_distance@PAGPAG@std@@YA@ABQAG0@Z	; std::_Idl_distance<unsigned short *,unsigned short *>
PUBLIC	??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGQAG0PAGAAV?$allocator@G@0@@Z ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
PUBLIC	??$_Idl_distance@PAKPAK@std@@YA@ABQAK0@Z	; std::_Idl_distance<unsigned long *,unsigned long *>
PUBLIC	??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
PUBLIC	??$_Idl_distance@PA_KPA_K@std@@YA@ABQA_K0@Z	; std::_Idl_distance<unsigned __int64 *,unsigned __int64 *>
PUBLIC	??$_Uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KQA_K0PA_KAAV?$allocator@_K@0@@Z ; std::_Uninitialized_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
PUBLIC	??$_Idl_distance@PAMPAM@std@@YA@ABQAM0@Z	; std::_Idl_distance<float *,float *>
PUBLIC	??$_Uninitialized_move@PAMPAMV?$allocator@M@std@@@std@@YAPAMQAM0PAMAAV?$allocator@M@0@@Z ; std::_Uninitialized_move<float *,float *,std::allocator<float> >
PUBLIC	??$_Idl_distance@PANPAN@std@@YA@ABQAN0@Z	; std::_Idl_distance<double *,double *>
PUBLIC	??$_Uninitialized_move@PANPANV?$allocator@N@std@@@std@@YAPANQAN0PANAAV?$allocator@N@0@@Z ; std::_Uninitialized_move<double *,double *,std::allocator<double> >
PUBLIC	??$_Idl_distance@PAPA_WPAPA_W@std@@YA@ABQAPA_W0@Z ; std::_Idl_distance<wchar_t * *,wchar_t * *>
PUBLIC	??$_Uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W0PAPA_WAAV?$allocator@PA_W@0@@Z ; std::_Uninitialized_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Uninitialized_value_construct_n1@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<unsigned short *,unsigned int,std::allocator<unsigned short> >
PUBLIC	??$_Uninitialized_value_construct_n1@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<unsigned long *,unsigned int,std::allocator<unsigned long> >
PUBLIC	??$_Uninitialized_value_construct_n1@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<unsigned __int64 *,unsigned int,std::allocator<unsigned __int64> >
PUBLIC	??$_Uninitialized_value_construct_n1@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<float *,unsigned int,std::allocator<float> >
PUBLIC	??$_Uninitialized_value_construct_n1@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<double *,unsigned int,std::allocator<double> >
PUBLIC	??$_Uninitialized_value_construct_n1@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<wchar_t * *,unsigned int,std::allocator<wchar_t *> >
PUBLIC	??$_Idl_distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV12@@std@@YA@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Idl_distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
PUBLIC	??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Distance1@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$allocator@G@2@XZ ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$allocator@K@2@XZ ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$allocator@_K@2@XZ ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$allocator@M@2@XZ ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$allocator@N@2@XZ ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$allocator@PA_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_first
PUBLIC	?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept1@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$allocator@G@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned short> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$allocator@K@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned long> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00U?$integral_constant@_N$00@2@@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$allocator@_K@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_K@std@@@std@@SAIABV?$allocator@_K@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned __int64> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00U?$integral_constant@_N$00@2@@Z ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$allocator@M@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z ; std::_Default_allocator_traits<std::allocator<float> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00U?$integral_constant@_N$00@2@@Z ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$allocator@N@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAIABV?$allocator@N@2@@Z ; std::_Default_allocator_traits<std::allocator<double> >::max_size
PUBLIC	?_Umove_if_noexcept1@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00U?$integral_constant@_N$00@2@@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$allocator@PA_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PA_W@std@@@std@@SAIABV?$allocator@PA_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	?allocate@?$allocator@G@std@@QAEPAGI@Z		; std::allocator<unsigned short>::allocate
PUBLIC	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@GV?$allocator@G@std@@@std@@ABEII@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@GV?$allocator@G@std@@@std@@AAEXQAGII@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Change_array
PUBLIC	?_Xlength@?$vector@GV?$allocator@G@std@@@std@@CAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@ABEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Orphan_range
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
PUBLIC	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array
PUBLIC	?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
PUBLIC	?allocate@?$allocator@_K@std@@QAEPA_KI@Z	; std::allocator<unsigned __int64>::allocate
PUBLIC	?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@_KV?$allocator@_K@std@@@std@@ABEII@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@_KV?$allocator@_K@std@@@std@@AAEXQA_KII@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Change_array
PUBLIC	?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@_KV?$allocator@_K@std@@@std@@ABEXPA_K0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Orphan_range
PUBLIC	?allocate@?$allocator@M@std@@QAEPAMI@Z		; std::allocator<float>::allocate
PUBLIC	?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00@Z ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@ABEII@Z ; std::vector<float,std::allocator<float> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AAEXQAMII@Z ; std::vector<float,std::allocator<float> >::_Change_array
PUBLIC	?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@ABEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Orphan_range
PUBLIC	?allocate@?$allocator@N@std@@QAEPANI@Z		; std::allocator<double>::allocate
PUBLIC	?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00@Z ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@ABEII@Z ; std::vector<double,std::allocator<double> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AAEXQANII@Z ; std::vector<double,std::allocator<double> >::_Change_array
PUBLIC	?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ; std::vector<double,std::allocator<double> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@ABEXPAN0@Z ; std::vector<double,std::allocator<double> >::_Orphan_range
PUBLIC	?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z	; std::allocator<wchar_t *>::allocate
PUBLIC	?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::max_size
PUBLIC	?_Umove_if_noexcept@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEII@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXQAPA_WII@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PA_WV?$allocator@PA_W@std@@@std@@CAXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEXPAPA_W0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Orphan_range
PUBLIC	??$_Uninitialized_value_construct_n@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@@Z ; std::_Uninitialized_value_construct_n<unsigned short *,unsigned int,std::allocator<unsigned short> >
PUBLIC	??$_Uninitialized_value_construct_n@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@@Z ; std::_Uninitialized_value_construct_n<unsigned long *,unsigned int,std::allocator<unsigned long> >
PUBLIC	??$_Uninitialized_value_construct_n@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@@Z ; std::_Uninitialized_value_construct_n<unsigned __int64 *,unsigned int,std::allocator<unsigned __int64> >
PUBLIC	??$_Uninitialized_value_construct_n@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@@Z ; std::_Uninitialized_value_construct_n<float *,unsigned int,std::allocator<float> >
PUBLIC	??$_Uninitialized_value_construct_n@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@@Z ; std::_Uninitialized_value_construct_n<double *,unsigned int,std::allocator<double> >
PUBLIC	??$_Uninitialized_value_construct_n@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@@Z ; std::_Uninitialized_value_construct_n<wchar_t * *,unsigned int,std::allocator<wchar_t *> >
PUBLIC	??$_Get_size_of_n@$01@std@@YAII@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<<lambda_1c24340e0c23a1361b49dbc3231bff51> >
PUBLIC	??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3> >
PUBLIC	??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Resize<<lambda_41cf2654fb7f54282f884164b4804166> >
PUBLIC	??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Resize<<lambda_37d2edcfa81498688f5009d219c6f7fd> >
PUBLIC	??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z ; std::vector<float,std::allocator<float> >::_Resize<<lambda_d7a4910ec896527b17c46ceb55731b6b> >
PUBLIC	??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z ; std::vector<double,std::allocator<double> >::_Resize<<lambda_72b2ca492da4f1408aac84fdabcda767> >
PUBLIC	??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Resize<<lambda_9015b627a392ed02a76b60582322ef4a> >
PUBLIC	??$_Destroy_range1@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned short> >
PUBLIC	??$_Destroy_range1@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned long> >
PUBLIC	??$_Destroy_range1@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned __int64> >
PUBLIC	??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<float> >
PUBLIC	??$_Destroy_range1@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<double> >
PUBLIC	??$_Destroy_range1@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<wchar_t *> >
PUBLIC	??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
PUBLIC	??$distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
PUBLIC	??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
PUBLIC	??$forward@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
PUBLIC	?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ	; ATL::CComSafeArray<wchar_t *,8>::Unlock
PUBLIC	?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned char,17>::Unlock
PUBLIC	?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned short,18>::Unlock
PUBLIC	?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned long,19>::Unlock
PUBLIC	?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned __int64,21>::Unlock
PUBLIC	?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ	; ATL::CComSafeArray<float,4>::Unlock
PUBLIC	?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ	; ATL::CComSafeArray<double,5>::Unlock
PUBLIC	?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ	; ATL::CComSafeArray<wchar_t *,8>::GetType
PUBLIC	?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ	; ATL::CComSafeArray<wchar_t *,8>::Destroy
PUBLIC	?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ	; ATL::CComSafeArray<wchar_t *,8>::Lock
PUBLIC	?_Udefault@?$vector@GV?$allocator@G@std@@@std@@AAEPAGPAGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Udefault
PUBLIC	?_Udefault@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Udefault
PUBLIC	?_Udefault@?$vector@_KV?$allocator@_K@std@@@std@@AAEPA_KPA_KI@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Udefault
PUBLIC	?_Udefault@?$vector@MV?$allocator@M@std@@@std@@AAEPAMPAMI@Z ; std::vector<float,std::allocator<float> >::_Udefault
PUBLIC	?_Udefault@?$vector@NV?$allocator@N@std@@@std@@AAEPANPANI@Z ; std::vector<double,std::allocator<double> >::_Udefault
PUBLIC	?_Udefault@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEPAPA_WPAPA_WI@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Udefault
PUBLIC	?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned char,17>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned char,17>::GetUpperBound
PUBLIC	?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned char,17>::GetType
PUBLIC	?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned char,17>::Destroy
PUBLIC	?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned char,17>::Lock
PUBLIC	?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned short,18>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned short,18>::GetUpperBound
PUBLIC	?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned short,18>::GetType
PUBLIC	?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned short,18>::Destroy
PUBLIC	?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned short,18>::Lock
PUBLIC	?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned long,19>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned long,19>::GetUpperBound
PUBLIC	?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned long,19>::GetType
PUBLIC	?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned long,19>::Destroy
PUBLIC	?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned long,19>::Lock
PUBLIC	?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned __int64,21>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ; ATL::CComSafeArray<unsigned __int64,21>::GetUpperBound
PUBLIC	?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ	; ATL::CComSafeArray<unsigned __int64,21>::GetType
PUBLIC	?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ	; ATL::CComSafeArray<unsigned __int64,21>::Destroy
PUBLIC	?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ	; ATL::CComSafeArray<unsigned __int64,21>::Lock
PUBLIC	?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ; ATL::CComSafeArray<float,4>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ; ATL::CComSafeArray<float,4>::GetUpperBound
PUBLIC	?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ	; ATL::CComSafeArray<float,4>::GetType
PUBLIC	?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ	; ATL::CComSafeArray<float,4>::Destroy
PUBLIC	?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ		; ATL::CComSafeArray<float,4>::Lock
PUBLIC	?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ; ATL::CComSafeArray<double,5>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ; ATL::CComSafeArray<double,5>::GetUpperBound
PUBLIC	?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ	; ATL::CComSafeArray<double,5>::GetType
PUBLIC	?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ	; ATL::CComSafeArray<double,5>::Destroy
PUBLIC	?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ		; ATL::CComSafeArray<double,5>::Lock
PUBLIC	??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ		; ATL::CComSafeArray<wchar_t *,8>::CComSafeArray<wchar_t *,8>
PUBLIC	??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ		; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>
PUBLIC	?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<wchar_t *,8>::Attach
PUBLIC	?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z	; ATL::CComSafeArray<wchar_t *,8>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z ; ATL::CComSafeArray<wchar_t *,8>::GetAt
PUBLIC	??0<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QAE@QAV?$vector@EV?$allocator@E@std@@@std@@@Z ; <lambda_1c24340e0c23a1361b49dbc3231bff51>::<lambda_1c24340e0c23a1361b49dbc3231bff51>
PUBLIC	??R<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QBE@PAEI@Z ; <lambda_1c24340e0c23a1361b49dbc3231bff51>::operator()
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	??0?$allocator@G@std@@QAE@XZ			; std::allocator<unsigned short>::allocator<unsigned short>
PUBLIC	??0<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QAE@QAV?$vector@GV?$allocator@G@std@@@std@@@Z ; <lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>::<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>
PUBLIC	??R<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QBE@PAGI@Z ; <lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>::operator()
PUBLIC	?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
PUBLIC	??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
PUBLIC	??0<lambda_41cf2654fb7f54282f884164b4804166>@@QAE@QAV?$vector@KV?$allocator@K@std@@@std@@@Z ; <lambda_41cf2654fb7f54282f884164b4804166>::<lambda_41cf2654fb7f54282f884164b4804166>
PUBLIC	??R<lambda_41cf2654fb7f54282f884164b4804166>@@QBE@PAKI@Z ; <lambda_41cf2654fb7f54282f884164b4804166>::operator()
PUBLIC	?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
PUBLIC	??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
PUBLIC	??0?$allocator@_K@std@@QAE@XZ			; std::allocator<unsigned __int64>::allocator<unsigned __int64>
PUBLIC	??0<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QAE@QAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ; <lambda_37d2edcfa81498688f5009d219c6f7fd>::<lambda_37d2edcfa81498688f5009d219c6f7fd>
PUBLIC	??R<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QBE@PA_KI@Z ; <lambda_37d2edcfa81498688f5009d219c6f7fd>::operator()
PUBLIC	?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
PUBLIC	??0?$_Vector_val@U?$_Simple_types@_K@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned __int64> >::_Vector_val<std::_Simple_types<unsigned __int64> >
PUBLIC	??0?$allocator@M@std@@QAE@XZ			; std::allocator<float>::allocator<float>
PUBLIC	??0<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QAE@QAV?$vector@MV?$allocator@M@std@@@std@@@Z ; <lambda_d7a4910ec896527b17c46ceb55731b6b>::<lambda_d7a4910ec896527b17c46ceb55731b6b>
PUBLIC	??R<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QBE@PAMI@Z ; <lambda_d7a4910ec896527b17c46ceb55731b6b>::operator()
PUBLIC	?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z ; std::vector<float,std::allocator<float> >::resize
PUBLIC	??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
PUBLIC	??0?$allocator@N@std@@QAE@XZ			; std::allocator<double>::allocator<double>
PUBLIC	??0<lambda_72b2ca492da4f1408aac84fdabcda767>@@QAE@QAV?$vector@NV?$allocator@N@std@@@std@@@Z ; <lambda_72b2ca492da4f1408aac84fdabcda767>::<lambda_72b2ca492da4f1408aac84fdabcda767>
PUBLIC	??R<lambda_72b2ca492da4f1408aac84fdabcda767>@@QBE@PANI@Z ; <lambda_72b2ca492da4f1408aac84fdabcda767>::operator()
PUBLIC	?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z ; std::vector<double,std::allocator<double> >::resize
PUBLIC	??0?$_Vector_val@U?$_Simple_types@N@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<double> >::_Vector_val<std::_Simple_types<double> >
PUBLIC	??0?$allocator@PA_W@std@@QAE@XZ			; std::allocator<wchar_t *>::allocator<wchar_t *>
PUBLIC	??0<lambda_9015b627a392ed02a76b60582322ef4a>@@QAE@QAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ; <lambda_9015b627a392ed02a76b60582322ef4a>::<lambda_9015b627a392ed02a76b60582322ef4a>
PUBLIC	??R<lambda_9015b627a392ed02a76b60582322ef4a>@@QBE@PAPA_WI@Z ; <lambda_9015b627a392ed02a76b60582322ef4a>::operator()
PUBLIC	?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PA_W@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<wchar_t *> >::_Vector_val<std::_Simple_types<wchar_t *> >
PUBLIC	??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned char,17>::CComSafeArray<unsigned char,17>
PUBLIC	??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>
PUBLIC	?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned char,17>::Attach
PUBLIC	?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned char,17>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z	; ATL::CComSafeArray<unsigned char,17>::GetAt
PUBLIC	??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned short,18>::CComSafeArray<unsigned short,18>
PUBLIC	??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>
PUBLIC	?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned short,18>::Attach
PUBLIC	?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned short,18>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z	; ATL::CComSafeArray<unsigned short,18>::GetAt
PUBLIC	??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned long,19>::CComSafeArray<unsigned long,19>
PUBLIC	??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>
PUBLIC	?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned long,19>::Attach
PUBLIC	?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned long,19>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z	; ATL::CComSafeArray<unsigned long,19>::GetAt
PUBLIC	??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned __int64,21>::CComSafeArray<unsigned __int64,21>
PUBLIC	??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ		; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>
PUBLIC	?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<unsigned __int64,21>::Attach
PUBLIC	?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z	; ATL::CComSafeArray<unsigned __int64,21>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z	; ATL::CComSafeArray<unsigned __int64,21>::GetAt
PUBLIC	??0?$CComSafeArray@M$03@ATL@@QAE@XZ		; ATL::CComSafeArray<float,4>::CComSafeArray<float,4>
PUBLIC	??1?$CComSafeArray@M$03@ATL@@QAE@XZ		; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>
PUBLIC	?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<float,4>::Attach
PUBLIC	?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z	; ATL::CComSafeArray<float,4>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z	; ATL::CComSafeArray<float,4>::GetAt
PUBLIC	??0?$CComSafeArray@N$04@ATL@@QAE@XZ		; ATL::CComSafeArray<double,5>::CComSafeArray<double,5>
PUBLIC	??1?$CComSafeArray@N$04@ATL@@QAE@XZ		; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>
PUBLIC	?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z ; ATL::CComSafeArray<double,5>::Attach
PUBLIC	?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z	; ATL::CComSafeArray<double,5>::GetCount
PUBLIC	?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z	; ATL::CComSafeArray<double,5>::GetAt
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z ; std::_Destroy_range<std::allocator<unsigned __int64> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ; std::_Destroy_range<std::allocator<float> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ; std::_Destroy_range<std::allocator<double> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1><>
PUBLIC	??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
PUBLIC	??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,void>
PUBLIC	??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ; FromVariant<wchar_t *>
PUBLIC	??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z ; FromVariant<double>
PUBLIC	??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z ; FromVariant<float>
PUBLIC	??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ; FromVariant<unsigned __int64>
PUBLIC	??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z ; FromVariant<unsigned long>
PUBLIC	??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z ; FromVariant<unsigned short>
PUBLIC	??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ; FromVariant<unsigned char>
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$allocator@G@2@XZ ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$allocator@K@2@XZ ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$allocator@_K@2@XZ ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_second
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$allocator@M@2@XZ ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$allocator@N@2@XZ ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$allocator@PA_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_second
PUBLIC	?deallocate@?$allocator@G@std@@QAEXQAGI@Z	; std::allocator<unsigned short>::deallocate
PUBLIC	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$allocator@G@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
PUBLIC	?deallocate@?$allocator@K@std@@QAEXQAKI@Z	; std::allocator<unsigned long>::deallocate
PUBLIC	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$allocator@K@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
PUBLIC	?deallocate@?$allocator@_K@std@@QAEXQA_KI@Z	; std::allocator<unsigned __int64>::deallocate
PUBLIC	?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$allocator@_K@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myend
PUBLIC	?deallocate@?$allocator@M@std@@QAEXQAMI@Z	; std::allocator<float>::deallocate
PUBLIC	?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$allocator@M@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
PUBLIC	?deallocate@?$allocator@N@std@@QAEXQANI@Z	; std::allocator<double>::deallocate
PUBLIC	?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$allocator@N@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myend
PUBLIC	?deallocate@?$allocator@PA_W@std@@QAEXQAPA_WI@Z	; std::allocator<wchar_t *>::deallocate
PUBLIC	?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::capacity
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$allocator@PA_W@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myend
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA?AV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::select_on_container_copy_construction
PUBLIC	?begin@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::begin
PUBLIC	?end@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::end
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
PUBLIC	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
PUBLIC	?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Orphan_all
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
PUBLIC	?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K0@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Destroy
PUBLIC	?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Orphan_all
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Mylast
PUBLIC	?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM0@Z ; std::vector<float,std::allocator<float> >::_Destroy
PUBLIC	?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AAEXXZ ; std::vector<float,std::allocator<float> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
PUBLIC	?_Destroy@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN0@Z ; std::vector<double,std::allocator<double> >::_Destroy
PUBLIC	?_Tidy@?$vector@NV?$allocator@N@std@@@std@@AAEXXZ ; std::vector<double,std::allocator<double> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Orphan_all
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Mylast
PUBLIC	?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W0@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Destroy
PUBLIC	?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Tidy
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Orphan_all
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Mylast
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	??0?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ; ATL::CComSafeArray<wchar_t *,8>::GetLowerBound
PUBLIC	?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ; ATL::CComSafeArray<wchar_t *,8>::GetUpperBound
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
PUBLIC	??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
PUBLIC	??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
PUBLIC	?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::clear
PUBLIC	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
PUBLIC	??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::clear
PUBLIC	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
PUBLIC	??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
PUBLIC	??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >
PUBLIC	?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::clear
PUBLIC	?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::size
PUBLIC	??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator[]
PUBLIC	??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
PUBLIC	??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
PUBLIC	?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ; std::vector<float,std::allocator<float> >::clear
PUBLIC	?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ; std::vector<float,std::allocator<float> >::size
PUBLIC	??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ; std::vector<float,std::allocator<float> >::operator[]
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
PUBLIC	?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ ; std::vector<double,std::allocator<double> >::clear
PUBLIC	?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ; std::vector<double,std::allocator<double> >::size
PUBLIC	??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ; std::vector<double,std::allocator<double> >::operator[]
PUBLIC	??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
PUBLIC	?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::clear
PUBLIC	?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::size
PUBLIC	??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::operator[]
PUBLIC	?ThreadWMIClass@@YGIPAX@Z			; ThreadWMIClass
PUBLIC	?WMI@@YAXPBDPAK@Z				; WMI
PUBLIC	?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z		; WMIex
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??BCComBSTR@ATL@@QBEPA_WXZ			; ATL::CComBSTR::operator wchar_t *
PUBLIC	?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z ; ATL::AtlSafeArrayGetActualVartype
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_Free@Data_t@_bstr_t@@AAEXXZ			; _bstr_t::Data_t::_Free
PUBLIC	??1Data_t@_bstr_t@@AAE@XZ			; _bstr_t::Data_t::~Data_t
PUBLIC	??2Data_t@_bstr_t@@SAPAXI@Z			; _bstr_t::Data_t::operator new
PUBLIC	?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ		; _bstr_t::Data_t::GetWString
PUBLIC	??_GData_t@_bstr_t@@AAEPAXI@Z			; _bstr_t::Data_t::`scalar deleting destructor'
PUBLIC	?Release@Data_t@_bstr_t@@QAEKXZ			; _bstr_t::Data_t::Release
PUBLIC	??0Data_t@_bstr_t@@QAE@PB_W@Z			; _bstr_t::Data_t::Data_t
PUBLIC	??0Data_t@_bstr_t@@QAE@PBD@Z			; _bstr_t::Data_t::Data_t
PUBLIC	?_Free@_bstr_t@@AAEXXZ				; _bstr_t::_Free
PUBLIC	??B_bstr_t@@QBEPA_WXZ				; _bstr_t::operator wchar_t *
PUBLIC	??1_bstr_t@@QAE@XZ				; _bstr_t::~_bstr_t
PUBLIC	??0_bstr_t@@QAE@PB_W@Z				; _bstr_t::_bstr_t
PUBLIC	??0_bstr_t@@QAE@PBD@Z				; _bstr_t::_bstr_t
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	?ThreadWMI@@YGIPAX@Z				; ThreadWMI
PUBLIC	?WMISystemVolumes@@YAXXZ			; WMISystemVolumes
PUBLIC	?WMIHardwareSensor@@YAXXZ			; WMIHardwareSensor
PUBLIC	?WMISystemPerformance@@YAXXZ			; WMISystemPerformance
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
?wmiClasses@@3PAU_wmi_classes_@@A DD FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@ ; wmiClasses
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BF@GIOJHHEG@Win32_1394Controller@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_07HMDPOHHF@Product@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0O@GLLHAKAI@ConfigOptions@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_05BOMFGPKE@Depth@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_06HCAKHJJK@Height@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_06ODJMJFLN@Weight@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_05IBAMDCFI@Width@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0N@CCJNCHMP@HostingBoard@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_09DADBKOHO@Removable@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0BI@NLNEBFOD@RequirementsDescription@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0BG@KNNEFNEE@RequiresDaughterBoard@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0L@NLNCHAIH@SlotLayout@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_0BE@DAJBDDHL@SpecialRequirements@
	DD	FLAT:??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0O@PKGMNGNM@BatteryStatus@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0O@IKADLBCG@TimeOnBattery@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BB@HMDCOCCC@TimeToFullCharge@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BE@HNKJKBND@BatteryRechargeTime@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_09CAHFAGKL@Chemistry@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0P@IFPGNGPN@DesignCapacity@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0O@PBABLEFL@DesignVoltage@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BB@NPKJIND@EstimatedRunTime@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BE@NEEKJBPN@ExpectedBatteryLife@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0N@DDGBNILM@ExpectedLife@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BD@HADPLBCE@FullChargeCapacity@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BA@KENPOHHF@MaxRechargeTime@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0BE@IIEJDIAD@SmartBatteryVersion@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0O@CLAKILND@Win32_Battery@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BE@DHLHFABD@BiosCharacteristics@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0M@JNJNMLGA@BIOSVersion@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0M@PIEABBJI@BuildNumber@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_07FOHBHJJA@CodeSet@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BA@LAFEEKJE@CurrentLanguage@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BD@IAKLNJOL@IdentificationCode@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BF@JGHHIKJK@InstallableLanguages@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BA@OPCNKLIC@ListOfLanguages@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0O@LMGDODCH@OtherTargetOS@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0M@PLCFCEDN@PrimaryBIOS@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0M@FEKFCCJH@ReleaseDate@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BC@GDJFCIN@SMBIOSBIOSVersion@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BD@GHLLPFOK@SMBIOSMajorVersion@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BD@NBGOPAJG@SMBIOSMinorVersion@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0O@BHMENNOL@SMBIOSPresent@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BC@MBHIKAHO@SoftwareElementID@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_0BF@GFDCFGAP@SoftwareElementState@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0L@JLLHHBAL@Win32_BIOS@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_06KNDINCOD@BusNum@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_07FFFMBEEK@BusType@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_09HPFDNOIF@Win32_Bus@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_05FHDOJGAA@Drive@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0L@PEPMOJNO@VolumeName@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BD@KNELKJMD@VolumeSerialNumber@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0P@HKGKOHLF@DriveIntegrity@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BA@KMBBNBII@FileSystemFlags@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BC@JDDJOAMF@FileSystemFlagsEx@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BH@GKGMNPDK@MaximumComponentLength@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0M@BKHKLNGH@MediaLoaded@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BJ@FCFAAAMD@MfrAssignedRevisionLevel@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0O@MEKHAACN@RevisionLevel@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_07IMFLOLAO@SCSIBus@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0BA@FGFDLPLK@SCSILogicalUnit@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_08IICBNDDA@SCSIPort@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@BGGJIJCI@SCSITargetId@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_04EBKMHHBE@Size@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
	DD	FLAT:??_C@_0N@GFEIEMMN@TransferRate@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_04HOKNCALA@Port@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0L@PGAIMACF@DMAChannel@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0M@HJPEAMBM@AddressSize@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_09LDKFCLB@BurstMode@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_08IOOBKHAJ@ByteMode@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0O@BPLPAGKN@ChannelTiming@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0BA@HBAKOKJE@MaxTransferSize@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0P@HFMGHLOP@TransferWidths@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_0M@MOIPDDOB@TypeCTiming@
	DD	FLAT:??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
	DD	FLAT:??_C@_08HKOOHOAE@WordMode@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0M@PIEABBJI@BuildNumber@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_07FOHBHJJA@CodeSet@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_07DFGIDBBA@Control@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BG@IOIHNNJK@DeviceDescriptorBlock@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BD@IAKLNJOL@IdentificationCode@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BA@JOJBKDJN@LanguageEdition@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0O@LMGDODCH@OtherTargetOS@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_06CGGMGNDK@PM_API@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BB@CCKMONLJ@ServiceTableSize@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BC@MBHIKAHO@SoftwareElementID@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BF@GFDCFGAP@SoftwareElementState@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_0BG@LEBBIDOP@TargetOperatingSystem@
	DD	FLAT:??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
	DD	FLAT:??_C@_07JENHGIOM@V86_API@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BH@GBOCBJMM@Win32_FloppyController@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0O@PBOKHICP@ActiveCooling@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0P@MCPBPNON@Win32_HeatPipe@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BE@FMCMMJCA@Win32_IDEController@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_08PPIOJEA@Hardware@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_09PKFILKGD@Shareable@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_0N@NCNNCPPP@TriggerLevel@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_0M@NKHMGHID@TriggerType@
	DD	FLAT:??_C@_0BC@MGLAEOHD@Win32_IRQResource@
	DD	FLAT:??_C@_06BOOCMPNK@Vector@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_06KMHOJANB@Layout@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0BF@DODFNOHG@NumberOfFunctionKeys@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_08EOCJLAAL@IsLocked@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_08FJIAHGMM@Password@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0P@IGJIBAJA@Win32_Keyboard@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0P@GCEIIPJN@PrimaryBusType@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0P@EJGNFGBG@RevisionNumber@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0BB@MKKJDBAN@SecondaryBusType@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0L@PMICFDLL@DeviceType@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_07DOAOMMKG@Enabled@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_09DADBKOHO@Removable@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_07LMLHFMEG@Service@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_09GPHNMGJN@ClassGuid@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0N@EEHHOFBP@CompatibleID@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0L@MCPBCGGP@HardwareID@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0N@HMDMLBLH@PointingType@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BA@EHILAMBM@NumberOfButtons@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BA@PLLFIHNG@DeviceInterface@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0N@OGCCLEJJ@HardwareType@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0L@DEGCDBKP@Handedness@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BF@FLDPHBAC@DoubleSpeedThreshold@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0M@LNGELFEC@InfFileName@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0L@KHOEHLLF@InfSection@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_08EOCJLAAL@IsLocked@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0BD@MJAHKLJJ@QuadSpeedThreshold@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0L@NEGJIGMA@SampleRate@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
	DD	FLAT:??_C@_05MKJLCFN@Synch@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0BM@OAEDMMAI@ExternalReferenceDesignator@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0BM@JBGCGAG@InternalReferenceDesignator@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_08BOPEOHEK@PortType@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0O@CPCPFFAH@ConnectorType@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0BA@KNNOFNF@ConnectorPinout@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BE@BFHBBNBL@Win32_PortConnector@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource@
	DD	FLAT:??_C@_05NNNCCOHC@Alias@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@JJNGNMBL@Win32_PortResource@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0BA@PFCCEOEE@DefaultDataType@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0L@EAJLGPDF@DriverPath@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_08CKKAOMLK@FilePath@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0L@LKBOBDBI@ConfigFile@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_08JFJMIJHO@DataFile@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0M@PJPGFADP@MonitorName@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0BC@MLDLGMGB@SupportedPlatform@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_07JFPHJDHA@InfName@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_08GLFJHHAH@HelpFile@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0P@NBBGILI@DependentFiles@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_06ENMIEFDD@OEMUrl@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_07LCDJNPHI@Started@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_09IAGOJBFI@StartMode@
	DD	FLAT:??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@MDJPNJNL@Architecture@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0O@FFCOPHIP@NumberOfCores@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0O@MJOHKFKO@MaxClockSpeed@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_06BOFMEHLD@Family@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@DJKFFMLN@L2CacheSize@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@NBPCHGPE@L2CacheSpeed@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@PICLIDHN@L3CacheSize@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@EKFHDKJL@L3CacheSpeed@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@IPOPOCBB@AddressWidth@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_09OJECCCEO@CpuStatus@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BC@JFANJPME@CurrentClockSpeed@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0P@IHAGOHLC@CurrentVoltage@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_09KNGBBIL@DataWidth@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_08JALCBBMK@ExtClock@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_05KOHFLOFG@Level@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0P@HLLBIGKP@LoadPercentage@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BH@LLAHKBOJ@OtherFamilyDescription@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@DHKOOBFD@ProcessorId@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0O@DAODMABE@ProcessorType@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_08DNLDHPFP@Revision@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_04EBAMNOLK@Role@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0BC@GCIFEBIL@SocketDesignation@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_08HPJGCEAH@Stepping@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_08HJBCPKNB@UniqueId@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0O@KHACBBMN@UpgradeMethod@
	DD	FLAT:??_C@_0BA@OJJOBJJP@Win32_Processor@
	DD	FLAT:??_C@_0M@DEJHGOJI@VoltageCaps@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0L@DJBCKAGE@DriverName@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BA@BJODOJJC@HardwareVersion@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BD@LPBNFPJD@ControllerTimeouts@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_09DJCHLIFB@DeviceMap@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_05FNNGFGLF@Index@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0N@OLJPFNHL@MaxDataWidth@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BA@IDEAMGMB@MaxTransferRate@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BF@OGNJDJGP@ProtectionManagement@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BF@OGHHAMBD@Win32_SCSIController@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0M@BFAJGJNN@MaxBaudRate@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0N@KFNBCBNP@ProviderType@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_06JCOMDNII@Binary@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BH@PKAPBGLB@MaximumInputBufferSize@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BI@EAKFLPF@MaximumOutputBufferSize@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BB@NCMHEECO@OSAutoDiscovered@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BB@CCEBCKAP@SettableBaudRate@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BB@BOCNMDDI@SettableDataBits@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BE@FMKJPGFK@SettableFlowControl@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0P@MOHECAJ@SettableParity@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BE@NMPLPPIE@SettableParityCheck@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0N@OBGEBGNG@SettableRLSD@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BB@EPIEMKMF@SettableStopBits@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BC@EEEMKCBH@Supports16BitMode@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0P@GODDIGIP@SupportsDTRDSR@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BI@LJLLOLPH@SupportsElapsedTimeouts@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BE@JOEIKOLI@SupportsIntTimeouts@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BE@JCPAAGPO@SupportsParityCheck@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0N@GBIJPBEE@SupportsRLSD@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0P@NGNOBJLG@SupportsRTSCTS@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BK@GGENNCGN@SupportsSpecialCharacters@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BA@OPAGJFHI@SupportsXOnXOff@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BD@GDEAPHBI@SupportsXOnXOffSet@
	DD	FLAT:??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_08FCNNIBJG@BaudRate@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0M@PAFDOFKP@BitsPerByte@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_06OKNHBMNM@Parity@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_08DPBIGBFM@StopBits@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_06OICOCAHF@IsBusy@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BG@DFLLPBBO@AbortReadWriteOnError@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BC@OGEDEEBA@BinaryModeEnabled@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BD@MCBMPIAJ@ContinueXMitOnXOff@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BC@BMKJGEMK@CTSOutflowControl@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BB@LNMOOKGE@DiscardNULLBytes@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BC@HDHNIDHE@DSROutflowControl@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0P@FDLAEJMA@DSRSensitivity@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BD@HKACMHPL@DTRFlowControlType@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0N@HDNBGKMG@EOFCharacter@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BG@HECEEKCN@ErrorReplaceCharacter@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BI@MDNCEDD@ErrorReplacementEnabled@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0P@ELDMBJ@EventCharacter@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BD@KACACAPH@ParityCheckEnabled@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BD@HDDKDMKB@RTSFlowControlType@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0O@IABHIILA@XOffCharacter@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BC@PIOKAKHD@XOffXMitThreshold@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0N@LMKFMCPA@XOnCharacter@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BB@OHGPOKOF@XOnXMitThreshold@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BF@FMELJHC@XOnXOffInFlowControl@
	DD	FLAT:??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
	DD	FLAT:??_C@_0BG@LCMFOHKE@XOnXOffOutFlowControl@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0M@MNPNDAHP@ProductName@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0O@GILLNKKD@MPU401Address@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0O@GHJKPLAG@DMABufferSize@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@INJPMPPD@Win32_SoundDevice@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BE@KNIHCNGM@Win32_USBController@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BE@FEOPMOOE@CurrentBitsPerPixel@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BM@OFHJCNEB@CurrentHorizontalResolution@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BK@LFIAOAGD@CurrentVerticalResolution@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BG@NCBMILGB@CurrentNumberOfColors@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BD@JKLPINND@CurrentRefreshRate@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BA@CDIHNLEF@CurrentScanMode@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BH@IKBJPLJ@CurrentNumberOfColumns@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BE@BKBIMFEG@CurrentNumberOfRows@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BC@GFHBBCIN@VideoArchitecture@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BA@COFLHODM@VideoMemoryType@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_09LIEAKBEG@VideoMode@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BF@MAGAOPPB@VideoModeDescription@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0P@OMEGAAG@VideoProcessor@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BC@PEHKLIOA@ColorTableEntries@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BF@JCFFEIIM@NumberOfColorPlanes?$DL@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BD@DECAKEGH@NumberOfVideoPages@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BF@FKKNOPFN@SystemPaletteEntries@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BI@DFJMJFBI@AcceleratorCapabilities@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BF@LPCADEJI@AdapterCompatibility@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0P@MPKKGADB@AdapterDACType@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0L@CKHNOAKJ@AdapterRAM@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0M@HMKFJKEG@InfFilename@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0L@KHOEHLLF@InfSection@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0O@KKIKAADI@DriverVersion@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BD@HBMCPLLH@DeviceSpecificPens@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0L@HJOBJMDE@DitherType@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0L@GAFFCADK@DriverDate@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_09MBIABGHL@ICMIntent@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_09OGGCGCBA@ICMMethod@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BI@NCJGCGIA@InstalledDisplayDrivers@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BD@KFJBBNPN@MaxMemorySupported@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0P@DHIEOPKP@MaxRefreshRate@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0P@BADPIIJO@MinRefreshRate@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0L@NCAJOFAD@Monochrome@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BN@FJFLBOEO@ReservedSystemPaletteEntries@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BF@HGGDLIIF@SpecificationVersion@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BG@IOBPPLKC@Win32_VideoController@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0L@BLANPANH@Partitions@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_04EBKMHHBE@Size@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_09GDNFOKKF@Signature@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0P@MMMIFHLL@BytesPerSector@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BB@HMBACBBL@FirmwareRevision@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_05FNNGFGLF@Index@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0O@IHENGMAG@InterfaceType@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0M@BKHKLNGH@MediaLoaded@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_07IMFLOLAO@SCSIBus@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BA@FGFDLPLK@SCSILogicalUnit@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_08IICBNDDA@SCSIPort@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@BGGJIJCI@SCSITargetId@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BA@CCMKCJPC@SectorsPerTrack@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0P@NEMACPGO@TotalCylinders@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0L@PLGEACLG@TotalHeads@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0N@BJMAPGKO@TotalSectors@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0M@BHKEFGGG@TotalTracks@
	DD	FLAT:??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
	DD	FLAT:??_C@_0BC@KOKBEBBE@TracksPerCylinder@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_04EBKMHHBE@Size@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_04KOACHJEN@Type@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_08GBCOMNMP@Bootable@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0O@GKABHDFN@BootPartition@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BB@GMPNKCND@PrimaryPartition@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_06IOEANFCI@Access@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0O@NMDEFEE@HiddenSectors@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0BB@CLPKNLNO@RewritePartition@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0P@HEMAHOJD@StartingOffset@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0BB@GANKFIKA@MediaDescription@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0BC@FNAKMFAB@CreationClassName@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_09DADBKOHO@Removable@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_08PINBMPEF@Capacity@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0P@CNPPDDMA@WriteProtectOn@
	DD	FLAT:??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
	DD	FLAT:??_C@_0N@NINPCONM@CleanerMedia@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_02HOGEDOAB@Id@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0M@COKFBABJ@Compression@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BB@GHOHONOE@DefaultBlockSize@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_03NLPJKHLD@ECC@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BD@IDPNAMKG@EOTWarningZoneSize@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@PNICBLFI@FeaturesHigh@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0M@GCKGDCME@FeaturesLow@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@HEPDBKFE@MaxBlockSize@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@HBNKJHPM@MaxMediaSize@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BC@NKLHGLCM@MaxPartitionCount@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0N@DELMGCCC@MinBlockSize@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0O@IIJMNCFJ@NeedsCleaning@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BH@COPKOGMD@NumberOfMediaSupported@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_07DDDGKLAD@Padding@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0P@OCFCAPCK@ReportSetMarks@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_06IOEANFCI@Access@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0O@BJAAJMNJ@Associativity@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0L@GKCEABFB@CacheSpeed@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_09LDLPEFB@CacheType@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0N@FNMLGPI@MaxCacheSize@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0M@JJECGOOK@CurrentSRAM@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BB@OEAEPHLK@ErrorCorrectType@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0L@NIIIAJJG@FlushTimer@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0O@BJDNNDOA@InstalledSize@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_05KOHFLOFG@Level@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_08BFDFHGHF@LineSize@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_08KDOEBHGA@Location@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0L@OICKBPFP@ReadPolicy@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BC@CACAEAGO@ReplacementPolicy@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0O@LOONNFKJ@SupportedSRAM@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress@
	DD	FLAT:??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
	DD	FLAT:??_C@_0M@GMGLDKG@WritePolicy@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@
	DD	FLAT:??_C@_0L@NKIIONIP@MemoryType@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_06IOEANFCI@Access@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BB@CCADGENH@ErrorGranularity@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_06IOEANFCI@Access@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BB@CCADGENH@ErrorGranularity@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_09ELEBPJGH@BankLabel@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_08PINBMPEF@Capacity@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_09KNGBBIL@DataWidth@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0O@DKGGAIKL@DeviceLocator@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0L@JPOMKNPI@FormFactor@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0BE@GAJMAAIE@InterleaveDataDepth@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0BD@OOBFBMPB@InterleavePosition@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0L@NKIIONIP@MemoryType@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0O@MJAFBIEI@PositionInRow@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_09DADBKOHO@Removable@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_05HOIAGEJD@Speed@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0L@EONKMHCB@TotalWidth@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_0L@NHBAOOAD@TypeDetail@
	DD	FLAT:??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0O@EOCLGIEK@MemoryDevices@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_05BOMFGPKE@Depth@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_06HCAKHJJK@Height@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_05IBAMDCFI@Width@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_06ODJMJFLN@Weight@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_08KDOEBHGA@Location@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0M@LPAFCHAO@MaxCapacity@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0BG@BDKPEMKD@MemoryErrorCorrection@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_09DADBKOHO@Removable@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
	DD	FLAT:??_C@_03GMFFJGJI@Use@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BA@JKJCLFJA@StartingAddress@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0O@DMEOEBEF@EndingAddress@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_06IOEANFCI@Access@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BE@FGEPBFNL@AdditionalErrorData@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BB@HJBOPHEK@CorrectableError@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0M@PJGEGKNG@ErrorAccess@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0N@BEELHEFJ@ErrorAddress@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_09GOCFECJA@ErrorData@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0P@LPKOAMHJ@ErrorDataOrder@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_09EPPHMMOH@ErrorInfo@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BA@DBMDPLBE@ErrorResolution@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_09LMOKKAAG@ErrorTime@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BC@FEODMBII@ErrorTransferSize@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BG@GMMANAIM@OtherErrorDescription@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
	DD	FLAT:??_C@_0BD@EHELDMNK@SystemLevelAddress@
	DD	FLAT:??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@GEHHDFHH@SystemType@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BD@KEFEPCEP@NumberOfProcessors@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_08KAFEAHEM@UserName@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BE@BPKIAGEB@AdminPasswordStatus@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BJ@GMKDMOMC@AutomaticManagedPagefile@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BJ@CCCKPNOE@AutomaticResetBootOption@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BJ@HFJMLPDD@AutomaticResetCapability@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BC@LOIFGJNH@BootOptionOnLimit@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BF@NHNHHNLM@BootOptionOnWatchDog@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BB@KCAGDBFG@BootROMSupported@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0M@FAIFADKE@BootupState@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BD@NPOFELCJ@ChassisBootupState@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BA@KEBGPOLH@CurrentTimeZone@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BB@PNOOHJBN@DaylightInEffect@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0M@HMDMJNAL@DNSHostName@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_06HFDFFJHI@Domain@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@DHGJAMBB@DomainRole@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BK@DMLHGPE@EnableDaylightSavingsTime@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BG@OFHEPCGG@FrontPanelResetStatus@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BC@MOGIEFCC@InfraredSupported@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BA@FHFMLOBH@InitialLoadInfo@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BH@NPMFKEOG@KeyboardPasswordStatus@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0N@FDMFJCLB@LastLoadInfo@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@INCFKHMA@NameFormat@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BJ@OJMPPEPI@NetworkServerModeEnabled@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0O@KFCLFAME@OEMLogoBitmap@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0P@DEDOEGFN@OEMStringArray@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0N@BDBDHMKI@PartOfDomain@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BA@BAAGJACJ@PauseAfterReset@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0N@EOPDJAGI@PCSystemType@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BG@MGBDJIM@PowerOnPasswordStatus@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@PFLEPOFF@PowerState@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BB@PGEJAGBJ@PowerSupplyState@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BE@GNDJOKHP@PrimaryOwnerContact@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BB@CIHLIHGG@PrimaryOwnerName@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BA@JGMMLHGF@ResetCapability@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@NDDNCBN@ResetCount@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@ODMHPMJN@ResetLimit@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_05CPOHHMHJ@Roles@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BK@GHHBNFKI@SupportContactDescription@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BD@MJBJDOPG@SystemStartupDelay@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BF@HNHDCNN@SystemStartupOptions@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BF@IKJAHOGK@SystemStartupSetting@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0N@HHACICKK@ThermalState@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0BE@LPDNMOEG@TotalPhysicalMemory@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_0L@FAPFOCCC@WakeUpType@
	DD	FLAT:??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
	DD	FLAT:??_C@_09CLAAHCGK@Workgroup@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
	DD	FLAT:??_C@_06LGGLFMPE@Vendor@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
	DD	FLAT:??_C@_04NOKDILIH@UUID@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
	DD	FLAT:??_C@_0BC@IBEJLMDM@IdentifyingNumber@
	DD	FLAT:??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
	DD	FLAT:??_C@_09ODBEMGCH@SKUNumber@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_09IHHILKBJ@ProductID@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_06LGGLFMPE@Vendor@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0P@CAOEPKFE@AssignmentType@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0BC@IBEJLMDM@IdentifyingNumber@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0BA@DLLPKNMD@InstallLocation@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0N@FNHIHJOE@InstallState@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_08LMOOJGEG@HelpLink@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0O@PPCFOOHH@HelpTelephone@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0O@GCCHCBIO@InstallSource@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_08BENDAOKD@Language@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0N@ONDNCIN@LocalPackage@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0N@LIDMIFHK@PackageCache@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0M@OMMGPPBL@PackageCode@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0M@PLFIHHBG@PackageName@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_08KOFIEIPM@RegOwner@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0L@BDBMLIBF@RegCompany@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_09ODBEMGCH@SKUNumber@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0L@LNLOEOEC@Transforms@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0N@CIJCJNDA@URLInfoAbout@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_0O@FDAGMPND@URLUpdateInfo@
	DD	FLAT:??_C@_0O@LCAALOJJ@Win32_Product@
	DD	FLAT:??_C@_09JCLOCIPO@WordCount@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_08GFKGEEBB@HotFixID@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_0M@NMGHOPGA@InstalledBy@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_0M@NBDMPIKF@InstalledOn@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_0M@PIGNGIJB@FixComments@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_0BE@FBEKBLIJ@ServicePackInEffect@
	DD	FLAT:??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0O@PBOKHICP@ActiveCooling@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@DKANKDCG@Win32_Refrigeration@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry@
	DD	FLAT:??_C@_0M@MLALLFJB@CurrentSize@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry@
	DD	FLAT:??_C@_0M@JHEHBNHB@MaximumSize@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry@
	DD	FLAT:??_C@_0N@JHIKPPPP@ProposedSize@
	DD	FLAT:??_C@_0P@OGGGECNI@Win32_Registry@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_03OMFNLMOB@SID@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_06HFDFFJHI@Domain@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_0N@FPKOIMIG@LocalAccount@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_07JDPBNNMM@SIDType@
	DD	FLAT:??_C@_0BE@DHOOODEL@Win32_SystemAccount@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0M@MLHPPPJP@DisplayName@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_08LHLJMCNC@PathName@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0M@MEIJGDEJ@AcceptPause@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0L@MPAKMMDG@AcceptStop@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0BA@DKLNMHH@DesktopInteract@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0N@GPBKMKLE@ErrorControl@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_08FHJJFIAP@ExitCode@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_0M@CFFFGGEC@ServiceType@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_07LCDJNPHI@Started@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_09IAGOJBFI@StartMode@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_09CIMAKHDE@StartName@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_05JNKNAC@State@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
	DD	FLAT:??_C@_05KFFLJNBG@TagId@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0N@MLFAOMIG@ChassisTypes@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_05BOMFGPKE@Depth@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_06HCAKHJJK@Height@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_05IBAMDCFI@Width@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_06ODJMJFLN@Weight@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0N@FBKDMIBE@AudibleAlarm@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BC@OICCILBJ@BreachDescription@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BI@OIOFCGCN@CableManagementStrategy@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BK@DMAHAAAM@CurrentRequiredOrProduced@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0P@FPMIANAI@HeatGeneration@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0N@FCOIALPI@HotSwappable@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0M@FLPBGKMO@LockPresent@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BD@BOLIJOBH@NumberOfPowerCords@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_09DADBKOHO@Removable@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0M@KLOLJEDG@Replaceable@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0P@IFAJDLJO@SecurityBreach@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0P@LBCDFKMM@SecurityStatus@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BE@CDEDGENH@ServiceDescriptions@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BC@MJACHPAA@ServicePhilosophy@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0P@GDBINLPP@SMBIOSAssetTag@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0BB@EPPDMJMG@TypeDescriptions@
	DD	FLAT:??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
	DD	FLAT:??_C@_0N@BGAIBJKD@VisibleAlarm@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_03PJHNOEGB@Tag@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BA@JKMEMADA@SlotDesignation@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0O@CPCPFFAH@ConnectorType@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_05NFIJOKEG@Model@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BA@KNNOFNF@ConnectorPinout@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0N@OHNMFPEL@CurrentUsage@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0O@JIADPBNP@HeightAllowed@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0O@ICFBEHEI@LengthAllowed@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0N@OLJPFNHL@MaxDataWidth@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0L@MIOPIENN@PartNumber@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_09KGLBDKHB@PMESignal@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_09HKGEBMAI@PoweredOn@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BD@MJCDBDLK@PurposeDescription@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_06LOOAMPBO@Shared@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_03LMAAELJP@SKU@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0P@MHGKENBB@SpecialPurpose@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BA@HLMBNLEL@SupportsHotPlug@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0O@OPICFFNJ@ThermalRating@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BH@BMAHGALK@VccMixedVoltageSupport@
	DD	FLAT:??_C@_0BB@IINEGLLN@Win32_SystemSlot@
	DD	FLAT:??_C@_0BH@LMHCBHLE@VppMixedVoltageSupport@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0M@MNPNDAHP@ProductName@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0L@MLCHOGMM@MACAddress@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BA@PKOOKBHK@PhysicalAdapter@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0M@IOFGKGDC@ServiceName@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BA@FMEGGBNH@NetConnectionID@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BE@OHJLPIPO@NetConnectionStatus@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_05HOIAGEJD@Speed@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_08MFFAALKH@MaxSpeed@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_04MEIDEPGF@GUID@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BB@HCIBJPII@NetworkAddresses@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BB@CPOCLJND@PermanentAddress@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0M@CBMGKKGD@AdapterType@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0O@JDINGPBK@AdapterTypeID@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_09MMNBJFFE@AutoSense@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_09HBJECKPO@Installed@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0P@LMPBIBLI@InterfaceIndex@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0L@COBEMNCH@NetEnabled@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0L@MLCHOGMM@MACAddress@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_09NIGMFFPO@IPAddress@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0L@BJOKJMLN@DHCPServer@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BB@HACNIBBH@DefaultIPGateway@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_09FBHLGFBK@DNSDomain@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0M@HMDMJNAL@DNSHostName@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_08EKHHNDLH@IPSubnet@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0M@IOFGKGDC@ServiceName@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BF@NNMMFFI@ArpAlwaysSourceRoute@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BA@DHDIOMKI@ArpUseEtherSNAP@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0N@OAKOAPMO@DatabasePath@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@GOBIIDKA@DeadGWDetectEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0L@JFBEJJHM@DefaultTOS@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0L@EIDNNLHD@DefaultTTL@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0M@HIMIFMFA@DHCPEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BB@BOGKHOEE@DHCPLeaseExpires@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BC@MIONLOAH@DHCPLeaseObtained@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BL@NEHFNDKH@DNSDomainSuffixSearchOrder@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BM@LEBEBEIJ@DNSEnabledForWINSResolution@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BF@CIMMNJEP@DNSServerSearchOrder@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BN@OACMHJBD@DomainDNSRegistrationEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@GGFBGHJP@ForwardBufferMemory@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BL@EIIPDLGE@FullDNSRegistrationEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BC@JPOLFPNM@GatewayCostMetric@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_09LFCMALKM@IGMPLevel@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0P@LMPBIBLI@InterfaceIndex@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BD@KDBLHBOO@IPConnectionMetric@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_09KIFLBGKF@IPEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BI@LBDHONDJ@IPFilterSecurityEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BG@IJANIIKC@IPPortSecurityEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BH@HHIPIHMF@IPSecPermitIPProtocols@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@JOIOPHFJ@IPSecPermitTCPPorts@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@IDDAOKAD@IPSecPermitUDPPorts@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BD@EFBIPBIB@IPUseZeroBroadcast@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0L@JNAHKDDE@IPXAddress@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0L@ONDAOAGP@IPXEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0N@EAKCLKKB@IPXFrameType@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0N@FHNNAGIP@IPXMediaType@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BB@HFHJDNKD@IPXNetworkNumber@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@KIGHGIHN@IPXVirtualNetNumber@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BC@HLLJNCGL@KeepAliveInterval@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0O@HNPIKCNH@KeepAliveTime@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_03BLLMIPHO@MTU@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BC@CHJCENM@NumForwardPackets@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BF@DPKIODPI@PMTUBHDetectEnabled?$DL@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BF@KBFAFCNG@PMTUDiscoveryEnabled@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@MJKNHDFN@TcpipNetbiosOptions@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BN@NBAJINBE@TcpMaxConnectRetransmissions@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BK@ICGANMDC@TcpMaxDataRetransmissions@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BC@CEGEJAFC@TcpNumConnections@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BL@JOFENPLC@TcpUseRFC1122UrgentPointer@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0O@CIEPJIDD@TcpWindowSize@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BI@MIGGLKDO@WINSEnableLMHostsLookup@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BD@POPKKJKC@WINSHostLookupFile@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BC@BECMMLFM@WINSPrimaryServer@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0M@CMEBCDLL@WINSScopeID@
	DD	FLAT:??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
	DD	FLAT:??_C@_0BE@CHHDIDN@WINSSecondaryServer@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_08FPDCFGEH@FullName@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0O@PKMMPAKN@HomeDirectory@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0BD@GBDEODMP@HomeDirectoryDrive@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0M@NDLIHBHJ@LogonServer@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_06HAPGBBDI@UserId@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_08LFHMHDM@UserType@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0M@KEGPAPIK@UserComment@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0P@FLJOKOM@AccountExpires@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0BD@JGGENGAP@AuthorizationFlags@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0BB@OBONNEPA@BadPasswordCount@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_08BHOPBADB@Caption?$DL@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_08DOHJINHB@CodePage@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_07JABLCLAF@Comment@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0M@NALIBBDH@CountryCode@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_05BOOEKJH@Flags@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0L@NKJIFPDG@LastLogoff@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_09JEOPKIAO@LastLogon@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0L@HFGJFNDM@LogonHours@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0P@BDLNENEK@MaximumStorage@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0P@FMELCCCP@NumberOfLogons@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0L@PBGCNDPG@Parameters@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0M@HKNCEPDC@PasswordAge@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0BA@HLOHOKEI@PasswordExpires@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0P@CIBDNLPH@PrimaryGroupId@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0L@FILALLBE@Privileges@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_07EELFDIBP@Profile@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0L@GHILPLPE@ScriptPath@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0N@LMMEGDEF@UnitsPerWeek@
	DD	FLAT:??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
	DD	FLAT:??_C@_0N@LMIHDJBC@Workstations@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BG@IODJFDPJ@ConnectionlessService@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BD@ECGOALCK@GuaranteesDelivery@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BF@FAHCIDLD@GuaranteesSequencing@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BD@FFCOFDOJ@MaximumAddressSize@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BD@IBPHBINL@MaximumMessageSize@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BA@NLEIFDG@MessageOriented@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BD@PCBKNDJA@MinimumAddressSize@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BF@DJOBDJFP@PseudoStreamOriented@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BF@ONDNBOBK@SupportsBroadcasting@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BE@OAOGNDFG@SupportsConnectData@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BH@KMFDMCNH@SupportsDisconnectData@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BD@BJHEFNDH@SupportsEncryption@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BG@MJFBKLBP@SupportsExpeditedData@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BH@PFGLDBHN@SupportsFragmentation?$DL@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BI@FGBPBAKA@SupportsGracefulClosing@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BM@MDHHIPIM@SupportsGuaranteedBandwidth@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BF@BHPPOJFK@SupportsMulticasting@
	DD	FLAT:??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
	DD	FLAT:??_C@_0BJ@MNHPDIFA@SupportsQualityofService@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_08BHIEONMC@FileSize@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_08PICKODJL@FileType@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0L@OHPKPJND@AccessMask@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_07CNOHFBBG@Archive@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0L@FBPJPEIN@Compressed@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0N@GPGLEEKJ@CreationDate@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_09KLPLELGE@Encrypted@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0BB@CPNPJAMG@EncryptionMethod@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_06PDIOKLEE@FSName@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_05MBDCODDP@Group@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_06FHBILLDG@Hidden@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0L@PCJCDOJK@InUseCount@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0N@BLGOKNC@LastAccessed@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0N@JFOMFNHF@LastModified@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_08PMHOKLA@Readable@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_06JIODDOFH@System@
	DD	FLAT:??_C@_0BA@MBMLPGOB@Win32_CodecFile@
	DD	FLAT:??_C@_09HKGIPMHJ@Writeable@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_0M@MNPNDAHP@ProductName@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_06LGGLFMPE@Vendor@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_0BC@IBEJLMDM@IdentifyingNumber@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_08OBOKCFEP@Accesses@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_0L@PLFFHFAH@Attributes@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_0N@FNHIHJOE@InstallState@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_07PKCEDPHO@LastUse@
	DD	FLAT:??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0M@MLHPPPJP@DisplayName@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_08LHLJMCNC@PathName@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0M@CFFFGGEC@ServiceType@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_09IAGOJBFI@StartMode@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_05JNKNAC@State@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0N@GPBKMKLE@ErrorControl@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_07LCDJNPHI@Started@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0M@MEIJGDEJ@AcceptPause@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0L@MPAKMMDG@AcceptStop@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0BA@DKLNMHH@DesktopInteract@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_08FHJJFIAP@ExitCode@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_09CIMAKHDE@StartName@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BC@DPAOPBJD@Win32_BaseService@
	DD	FLAT:??_C@_05KFFLJNBG@TagId@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_0O@KLLIKPKC@BootDirectory@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_0BC@BJLIMIEA@ConfigurationPath@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_09PABAEPFH@LastDrive@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_0BB@FHBPINGK@ScratchDirectory@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
	DD	FLAT:??_C@_0O@FDHFFDED@TempDirectory@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0M@EEKAPENF@BorderWidth@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0L@GMHAONPD@CoolSwitch@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BA@NKDGIFD@CursorBlinkRate@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BA@CNEMFCKH@DragFullWindows@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BA@MJNOPNAD@GridGranularity@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0M@FALLBHKM@IconSpacing@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BC@HAAMKFAI@IconTitleFaceName@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0O@COINDPHH@IconTitleSize@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0O@HLNDODKM@IconTitleWrap@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_07NOCIGAPP@Pattern@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BC@KENIIHPI@ScreenSaverActive@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BG@OPEGFPLM@ScreenSaverExecutable@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BC@ENMGOCGL@ScreenSaverSecure@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BD@LIKEHLGN@ScreenSaverTimeout@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_09FAKNONCF@Wallpaper@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0BD@MNOICNPG@WallpaperStretched@
	DD	FLAT:??_C@_0O@MLAGCNDM@Win32_Desktop@
	DD	FLAT:??_C@_0P@HLGPBKPI@WallpaperTiled@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0N@EJILFHEF@ScreenHeight@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0M@GOACCFHI@ScreenWidth@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BG@JHIHGKIO@PixelsPerXLogicalInch@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BG@EKBBLDAL@PixelsPerYLogicalInch@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BE@EAJFLPNK@MonitorManufacturer@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0M@FCPFJAEP@MonitorType@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_09LPCHGGLO@Bandwidth@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0M@GAHMDPOP@DisplayType@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_08EOCJLAAL@IsLocked@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0O@PBOKHICP@ActiveCooling@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0N@HOGGFFKF@DesiredSpeed@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_09BEHCCOGC@Win32_Fan@
	DD	FLAT:??_C@_0O@ODMHJIAL@VariableSpeed@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0P@NOCBMKBI@OSArchitecture@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0M@PIEABBJI@BuildNumber@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_09LLAGGHGM@BuildType@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0L@EGALIDNG@CSDVersion@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BI@MCMKKPJH@ServicePackMajorVersion@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BI@HEBPKKOL@ServicePackMinorVersion@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0P@HNONGDKL@OSProductSuite@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_06MNBFCOOH@OSType@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0N@MHPBIIPD@Organization@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0P@DAFCPCAO@RegisteredUser@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0M@GGPOPAAP@ProductType@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0L@BLKKOICB@BootDevice@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0N@LCIKLBMI@SystemDevice@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0M@JBPIDKPO@SystemDrive@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BA@FNJMICPB@SystemDirectory@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BB@IEJHMEDK@WindowsDirectory@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_07FOHBHJJA@CodeSet@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0M@NALIBBDH@CountryCode@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0L@IOMOHLID@OSLanguage@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BA@KEBGPOLH@CurrentTimeZone@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0CC@LDMHMPMB@DataExecutionPrevention_Availab@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0CK@PHHDEHCB@DataExecutionPrevention_32BitAp@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0CA@KCIFHCEN@DataExecutionPrevention_Drivers@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0CG@FOLHLACL@DataExecutionPrevention_Support@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_05GCIPIGEI@Debug@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0M@DGCHPHG@Distributed@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BA@LIJDDPMD@EncryptionLevel@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BL@LKLGBOHP@ForegroundApplicationBoost@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BD@KJPLACJD@FreePhysicalMemory@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BH@GDCHGEBO@FreeSpaceInPagingFiles@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BC@HEKPKJCK@FreeVirtualMemory@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BB@GLODIIPC@LargeSystemCache@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0P@DKHNBJBB@LastBootUpTime@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0O@GFNPHCJN@LocalDateTime@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_06BMNFLCFO@Locale@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BF@BJJFAIPL@MaxNumberOfProcesses@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BF@OEEDDGBK@MaxProcessMemorySize@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0N@FEFLNODO@MUILanguages@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BG@MGHJNMGE@NumberOfLicensedUsers@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BC@FILGLGHH@NumberOfProcesses@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0O@PBBGLGFJ@NumberOfUsers@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BD@GLJCNHGP@OperatingSystemSKU@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BF@KAMHDIPP@OtherTypeDescription@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0L@KNGIFFNB@PAEEnabled@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0O@NNCCMBIG@PlusProductID@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BC@LMIHOAGL@PlusVersionNumber@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_07NAEHBBNL@Primary@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BI@BKJHEEOL@SizeStoredInPagingFiles@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_09IIJPJFOC@SuiteMask@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BD@PBNAJGBH@TotalSwapSpaceSize@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BH@IBKKELEK@TotalVirtualMemorySize@
	DD	FLAT:??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
	DD	FLAT:??_C@_0BH@EOFEPLNL@TotalVisibleMemorySize@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_08BHIEONMC@FileSize@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_09LCEICGML@FreeSpace@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_08PICKODJL@FileType@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_06PDIOKLEE@FSName@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0L@OHPKPJND@AccessMask@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_07CNOHFBBG@Archive@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0L@FBPJPEIN@Compressed@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0BC@MBGAHHAB@CompressionMethod@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0N@GPGLEEKJ@CreationDate@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_09KLPLELGE@Encrypted@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0BB@CPNPJAMG@EncryptionMethod@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_06FHBILLDG@Hidden@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0M@EONNPILK@InitialSize@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0L@PCJCDOJK@InUseCount@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0N@BLGOKNC@LastAccessed@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0N@JFOMFNHF@LastModified@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_0M@JHEHBNHB@MaximumSize@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_08PMHOKLA@Readable@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_06JIODDOFH@System@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_07NGFJPNPN@Version@
	DD	FLAT:??_C@_0P@GFMPEM@Win32_PageFile@
	DD	FLAT:??_C@_09HKGIPMHJ@Writeable@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0N@FNJCOOAL@Capabilities@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0L@LICOLOBE@DMASupport@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BE@JDLAPHJE@MaxNumberControlled@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BB@NCMHEECO@OSAutoDiscovered@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BC@JHPOAJCM@ProtocolSupported@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
	DD	FLAT:??_C@_0BA@HADKHLAI@TimeOfLastReset@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy@
	DD	FLAT:??_C@_0BA@LEMEMCNN@ProxyPortNumber@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy@
	DD	FLAT:??_C@_0M@BCMAAPLG@ProxyServer@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy@
	DD	FLAT:??_C@_0L@FFDIDHBB@ServerName@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0M@GFHBIAHO@Win32_Proxy@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_04HMIIHGGM@Path@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_0P@IBLGFEE@MaximumAllowed@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_0N@PEAHLPLG@AllowMaximum@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0M@MCIKNCEL@Win32_Share@
	DD	FLAT:??_C@_04KOACHJEN@Type@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_09IHHILKBJ@ProductID@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_0BD@HINAAJAB@ActivationRequired@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_0BB@FFPKNIIL@IsNotificationOn@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_0BK@MHMKFBPN@RemainingEvaluationPeriod@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_0BF@GDCPFLAD@RemainingGracePeriod@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_0L@FFDIDHBB@ServerName@
	DD	FLAT:??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BK@HACJICBD@ASPScriptDefaultNamespace@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BB@HHJGCMCA@ASPScriptEnabled@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BA@FCAEOBFB@AutorecoverMofs@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0P@LBFHKJDL@AutoStartWin9X@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0P@HCBDPJED@BackupInterval@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0P@HCKKJOFA@BackupLastTime@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0N@DMPKCKPJ@BuildVersion@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BC@PJAEIMII@DatabaseDirectory@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BA@GMIIIOHB@DatabaseMaxSize@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BL@FLALGEND@EnableAnonWin9xConnections@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0N@OBNHEDLP@EnableEvents@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BP@DHLDKHJI@EnableStartupHeapPreallocation@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BN@FBHHPGGC@HighThresholdOnClientObjects@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BG@LKICGCBK@HighThresholdOnEvents@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BG@MDEOBFAH@InstallationDirectory@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BN@GKEEMEKI@LastStartupHeapPreallocation@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BB@FALFKNPE@LoggingDirectory@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0N@FMFGOJPB@LoggingLevel@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BM@NGNJMOHJ@LowThresholdOnClientObjects@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BF@PHEPMKDN@LowThresholdOnEvents@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0P@CEPALFMK@MaxLogFileSize@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BH@PBKELOKA@MaxWaitOnClientObjects@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BA@NHHFPHIJ@MaxWaitOnEvents@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_0BI@NOBDNJPM@MofSelfInstallDirectory@
	DD	FLAT:??_C@_0BB@BBHCGAKO@Win32_WMISetting@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09CMMJGBDB@SettingID@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0L@MJJCDBO@BitsPerPel@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_07KLCNEDPB@Collate@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_05PDOBBJNA@Color@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_06BLCAIJFC@Copies@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0L@FHIBJDML@DeviceName@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0N@DJPIPGBF@DisplayFlags@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0BB@FJLGFJEJ@DisplayFrequency@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0L@HJOBJMDE@DitherType@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0O@KKIKAADI@DriverVersion@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_06KIOALPNI@Duplex@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_08EOPEEPJC@FormName@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0BF@FOMIFJDP@HorizontalResolution@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09MBIABGHL@ICMIntent@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09OGGCGCBA@ICMMethod@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09ENKMJEBL@LogPixels@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09HPDNNFFF@MediaType@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0M@LHPCLPIO@Orientation@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0M@ICHOFLKL@PaperLength@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09KFDMKFMI@PaperSize@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0L@OINDMHF@PaperWidth@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0L@FDBJOBNL@PelsHeight@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_09CGGAMGGM@PelsWidth@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0N@CLBFGPBN@PrintQuality@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_05MAGIBEFI@Scale@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0BF@HGGDLIIF@SpecificationVersion@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_08KMMMDKPE@TTOption@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0BD@FGMLFAJH@VerticalResolution@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0M@IMNEHNOF@XResolution@
	DD	FLAT:??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
	DD	FLAT:??_C@_0M@BHHBDBIK@YResolution@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0BA@FLFAPDFG@ConnectionState@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0P@LNPCDAPC@ConnectionType@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0M@GAHMDPOP@DisplayType@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0L@CCMICFHJ@RemotePath@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_08KAFEAHEM@UserName@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0L@OHPKPJND@AccessMask@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_07JABLCLAF@Comment@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_09CLGGKACF@LocalName@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0L@FLEBOKCI@RemoteName@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0L@LNKKEMJM@Persistent@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0N@ONCOBKP@ProviderName@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_0N@EPHJOCBJ@ResourceType@
	DD	FLAT:??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_05IEIONIFO@Label@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0M@EHMJIHII@DriveLetter@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_08PINBMPEF@Capacity@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_09LCEICGML@FreeSpace@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_09NKILGKMH@DriveType@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0L@FPFLHALM@FileSystem@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0N@FPJJBBNM@SerialNumber@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_09JFLKFGKE@BlockSize@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0P@PGINBNEO@NumberOfBlocks@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_06IOEANFCI@Access@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_09HICOCIIF@Automount@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0L@FBPJPEIN@Compressed@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0M@FMPADJNN@DirtyBitSet@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BB@PNCBAHDK@ErrorMethodology@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BA@JDIBBDEO@IndexingEnabled@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BG@ELFKDNP@MaximumFileNameLength@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_07ODOLMOGH@Purpose@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0O@HEHOMNCC@QuotasEnabled@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BB@MPFPEDFA@QuotasIncomplete@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BB@JJBCJECG@QuotasRebuilding@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BD@BJDMHPHA@SupportsDiskQuotas@
	DD	FLAT:??_C@_0N@NNCPDPIH@Win32_Volume@
	DD	FLAT:??_C@_0BN@DMMADKEM@SupportsFileBasedCompression@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@CKOOLAI@AvgDiskQueueLength@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@LLDDCMMH@AvgDiskSecPerRead?$DL@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BH@CFGDHLM@CurrentDiskQueueLength@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BA@BBEHMIEJ@DiskBytesPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BE@IJJNINGL@DiskReadBytesPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BA@GPEPCNFG@DiskReadsPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BE@INHPJNPE@DiskTransfersPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BB@FFLCGPKG@DiskWritesPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BE@KMHMAHCP@PercentDiskReadTime@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BA@HPDMAPLN@PercentDiskTime@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BF@CHKOMNLI@PercentDiskTime_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BF@DOKCNDOL@PercentDiskWriteTime@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BA@LOOKHAGM@PercentIdleTime@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BF@PLICIEBG@PercentIdleTime_Base@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0O@JFLPIICD@SplitIOPerSec@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0O@EJBHEMAA@FreeMegabytes@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BD@CKOOLAI@AvgDiskQueueLength@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BC@IJGACNJB@AvgDiskSecPerRead@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BH@CFGDHLM@CurrentDiskQueueLength@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BA@BBEHMIEJ@DiskBytesPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BE@IJJNINGL@DiskReadBytesPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BA@GPEPCNFG@DiskReadsPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BE@INHPJNPE@DiskTransfersPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BB@FFLCGPKG@DiskWritesPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BE@KMHMAHCP@PercentDiskReadTime@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BA@HPDMAPLN@PercentDiskTime@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BF@CHKOMNLI@PercentDiskTime_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BF@DOKCNDOL@PercentDiskWriteTime@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BB@FDAACFPN@PercentFreeSpace@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BG@KEJCKNPB@PercentFreeSpace_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BA@LOOKHAGM@PercentIdleTime@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BF@PLICIEBG@PercentIdleTime_Base@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0O@JFLPIICD@SplitIOPerSec@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BE@IEAMAKJB@BytesReceivedPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BH@GKKKHEEC@BytesTransmittedPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BB@NADCFLBJ@BytesTotalPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0O@GPMHHPHG@PacketsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BG@PFNBEMLM@PacketsReceivedPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BJ@EHOOHGK@PacketsTransmittedPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0N@IJGODAGI@ConnectsCore@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BF@MNEGHJGM@ConnectsLanManager20@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BF@NEFNEICN@ConnectsLanManager21@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BC@EOFEMAHF@ConnectsWindowsNT@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BA@DJMJIEBG@CurrentCommands@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BE@OGCPPNJJ@NetworkErrorsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BF@LPDAMOL@ReadBytesCachePerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BH@IAHICFAL@ReadBytesNetworkPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BJ@ILOCGCLG@ReadBytesNonPagingPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BG@OLGMIDCE@ReadBytesPagingPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BL@CFIGOGID@ReadOperationsRandomPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BC@JALNAJBD@ReadPacketsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BH@JCFIFLJN@ReadPacketsSmallPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BC@MGHKCLNK@ReadsDeniedPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BB@FFKFENGC@ReadsLargePerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BC@GAMKMMKB@ServerDisconnects@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BB@LGLKKLGK@ServerReconnects@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0P@EPIIEJNA@ServerSessions@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BD@BALBBJPI@ServerSessionsHung@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BG@GCNKDHCE@WriteBytesCachePerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BI@HNBBGOIH@WriteBytesNetworkPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BK@PNNKNAIA@WriteBytesNonPagingPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BH@OANOHFDO@WriteBytesPagingPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BM@IJPFNDGO@WriteOperationsRandomPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BD@NEABLLFJ@WritePacketsPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BI@GPDBBABB@WritePacketsSmallPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BC@LMECNINB@WriteDeniedPerSec@
	DD	FLAT:??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
	DD	FLAT:??_C@_0BB@HAMOOOJ@WriteLargePerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BF@MGINILGA@AsyncCopyReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BE@CAOOLPND@AsyncDataMapsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BF@GKOKALKG@AsyncFastReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BE@OMOFBJFA@AsyncMDLReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BE@PNDFACCO@AsyncPinReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BE@FFJCEMDJ@CopyReadHitsPercent@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BJ@FGOEJAHL@CopyReadHitsPercent_Base@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BA@BIHGDHJL@CopyReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BC@MJKDEPG@DataFlushesPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BF@JDDABGEO@DataFlushPagesPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@KOAAJIJA@DataMapHitsPercent@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BI@ILDKBHLK@DataMapHitsPercent_Base@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BC@OOMEAEEA@DataMapPinsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BH@JDIGEHGG@DataMapPinsPerSec_Base@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0P@GAMMIBDO@DataMapsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BL@HBAEFMGM@FastReadNotPossiblesPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BN@JGPDPBED@FastReadResourceMissesPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BA@LEBBLHFN@FastReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BH@JCPDBLIF@LazyWriteFlushesPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BF@GOGJJNKE@LazyWritePagesPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@PNDPPHMH@MDLReadHitsPercent@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BI@NMONEPAO@MDLReadHitsPercent_Base@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0P@KMMHCHLN@MDLReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@INCEIJBE@PinReadHitsPercent@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BI@KGBEKIEP@PinReadHitsPercent_Base@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0P@LNBHDMMD@PinReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BB@NGKOLIIB@ReadAheadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BE@PJJLELAC@SyncCopyReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@IDCIAAHF@SyncDataMapsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BE@FFPMMLME@SyncFastReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@EPCDKGPG@SyncMDLReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@FOPDLNII@SyncPinReadsPerSec@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0P@HPKKNIPF@AvailableBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BA@DKABBPEK@AvailableKBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BA@FJNBCKHA@AvailableMBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0L@ECJIAGHC@CacheBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0P@BPAGOPIK@CacheBytesPeak@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BC@ONMHHFEO@CacheFaultsPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0M@HHOMCEFN@CommitLimit@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0P@FAEGOFEG@CommittedBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BH@BIADJNEE@DemandZeroFaultsPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BL@MIKHIOLC@FreeSystemPageTableEntries@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BB@HOEEGAIG@PageFaultsPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BA@BHCICMAP@PageReadsPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BB@NHNEKMAP@PagesInputPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BC@PGIEMCPC@PagesOutputPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0M@PJBDCOH@PagesPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BB@EHHNOBPH@PageWritesPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BL@EHMKCOHH@PercentCommittedBytesInUse@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0CA@DKFDEGAA@PercentCommittedBytesInUse_Base@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BD@GAOJBHDB@PoolNonpagedAllocs@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BC@GMPJEGLC@PoolNonpagedBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BA@LDKKFHCE@PoolPagedAllocs@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0P@PJENKINF@PoolPagedBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BH@OMBHLDMN@PoolPagedResidentBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BJ@NPNGHFJN@SystemCacheResidentBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BI@KPKNFENK@SystemCodeResidentBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BF@JBGABIBK@SystemCodeTotalBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BK@MNCINJBF@SystemDriverResidentBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BH@KPIDEMMH@SystemDriverTotalBytes@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BH@KEMPGDKK@TransitionFaultsPerSec@
	DD	FLAT:??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
	DD	FLAT:??_C@_0BC@KBPIOBBH@WriteCopiesPerSec@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_09BNGODGIH@Processes@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_07CMIGFCHA@Threads@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_07LDPBBEEB@Mutexes@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_06HEBKAGDH@Events@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0L@GLBCAKLN@Semaphores@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_08FBPDBPOE@Sections@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0N@CKGFJCHF@PercentUsage@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BB@JKLALBIF@PercentUsagePeak@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BF@EMKPKJGP@PercentProcessorTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BA@JCLIOML@PercentUserTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BA@LOOKHAGM@PercentIdleTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BE@DLJADCBG@C1TransitionsPerSec@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BE@JIMGLELP@C2TransitionsPerSec@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BE@EPCEDEOH@C3TransitionsPerSec@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_07BHCICOFH@DPCRate@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BB@KHEGFAIJ@DPCsQueuedPerSec@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BB@FCICDGPJ@InterruptsPerSec@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0O@PJFMGMCN@PercentC1Time@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0O@HPMIBOID@PercentC2Time@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0O@LEJEMNCG@PercentC3Time@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0P@LMLLFJEI@PercentDPCTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BF@GMGAHOLM@PercentInterruptTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BG@FPNGHOGK@PercentPrivilegedTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_09BNGODGIH@Processes@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_07CMIGFCHA@Threads@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BG@KHFHJKMP@AlignmentFixupsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BG@GIPKJDB@ContextSwitchesPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BK@DHKAACDP@ExceptionDispatchesPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BH@EMNLAEFK@FileControlBytesPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BM@PIKKJCOI@FileControlOperationsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BE@NKKLPLAB@FileReadBytesPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BF@LGMPDKBA@FileWriteBytesPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BJ@PHDBHNCO@FloatingEmulationsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BB@EEOEKLCO@Frequency_Object@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BD@IONDPFD@Frequency_PerfTime@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BK@NGGOKLMO@PercentRegistryQuotaInUse@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BF@NPGOAGED@ProcessorQueueLength@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BC@HMBPBBJB@SystemCallsPerSec@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0N@JBKHOEPE@SystemUpTime@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BB@JNCIMECH@Timestamp_Object@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
	DD	FLAT:??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
	DD	FLAT:??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0P@IDBBEDLI@CurrentReading@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_08NLCOAFEI@Accuracy@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_09BKMALBOE@Tolerance@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0P@OAFFNBPO@NominalReading@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_09EDCPMBJN@NormalMax@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_09FBKECFPC@NormalMin@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BH@NMAIJHFM@LowerThresholdCritical@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BE@NPMAGCMK@LowerThresholdFatal@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BH@FKDKGMLL@UpperThresholdCritical@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BE@HGEJIDLL@UpperThresholdFatal@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0M@EIBDACPL@MaxReadable@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0M@NIGABCBB@MinReadable@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_08JLKOPNJP@IsLinear@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0O@PKGMNGNM@BatteryStatus@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BB@NPKJIND@EstimatedRunTime@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0O@IKADLBCG@TimeOnBattery@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BB@HMDCOCCC@TimeToFullCharge@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0N@BBNLMPJO@Manufacturer@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BA@EMGHNHBI@ManufactureDate@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_09CAHFAGKL@Chemistry@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0P@IFPGNGPN@DesignCapacity@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BD@HADPLBCE@FullChargeCapacity@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BE@HNKJKBND@BatteryRechargeTime@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BD@EBMPMBCC@CapacityMultiplier@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0O@PBABLEFL@DesignVoltage@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BE@NEEKJBPN@ExpectedBatteryLife@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0N@DDGBNILM@ExpectedLife@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_08KDOEBHGA@Location@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BA@LLOCDJF@MaxBatteryError@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BA@KENPOHHF@MaxRechargeTime@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BE@IIEJDIAD@SmartBatteryVersion@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0BI@LFKNNEKA@SystemCreationClassName@
	DD	FLAT:??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
	DD	FLAT:??_C@_0L@MPHEPFAH@SystemName@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0P@IDBBEDLI@CurrentReading@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_08NLCOAFEI@Accuracy@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_09BKMALBOE@Tolerance@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0P@OAFFNBPO@NominalReading@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_09EDCPMBJN@NormalMax@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_09FBKECFPC@NormalMin@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BH@NMAIJHFM@LowerThresholdCritical@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BE@NPMAGCMK@LowerThresholdFatal@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BH@FKDKGMLL@UpperThresholdCritical@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BE@HGEJIDLL@UpperThresholdFatal@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0M@NIGABCBB@MinReadable@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0M@EIBDACPL@MaxReadable@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_08JLKOPNJP@IsLinear@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_04FABLJDN@Name@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0M@HHJKGII@PNPDeviceID@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_08JLPEJKOE@DeviceID@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0P@IDBBEDLI@CurrentReading@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_08NLCOAFEI@Accuracy@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0L@KGPBCGJE@Resolution@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_09BKMALBOE@Tolerance@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0P@OAFFNBPO@NominalReading@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_09EDCPMBJN@NormalMax@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_09FBKECFPC@NormalMin@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BH@NMAIJHFM@LowerThresholdCritical@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BE@NPMAGCMK@LowerThresholdFatal@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BH@FKDKGMLL@UpperThresholdCritical@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BE@HGEJIDLL@UpperThresholdFatal@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0M@NIGABCBB@MinReadable@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0M@EIBDACPL@MaxReadable@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0N@MFGCECDI@Availability@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_07OJKFJLLK@Caption@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0M@OHKMKKDH@Description@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0N@FJHLDHMG@ErrorCleared@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BB@KIDBLMK@ErrorDescription@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0M@NBIJNNJJ@InstallDate@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_08JLKOPNJP@IsLinear@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0O@NDKHIJAE@LastErrorCode@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_06PGDKHFME@Status@
	DD	FLAT:??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
	DD	FLAT:??_C@_0L@PKEHCAEI@StatusInfo@
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_bstr_t@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_bstr_t@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0_bstr_t@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_bstr_t@@QAE@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_bstr_t@@QAE@PB_W@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_bstr_t@@QAE@PB_W@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0_bstr_t@@QAE@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_bstr_t@@QAE@PB_W@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_bstr_t@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Free@_bstr_t@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Release@Data_t@_bstr_t@@QAEKXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GData_t@_bstr_t@@AAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1Data_t@_bstr_t@@AAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Free@Data_t@_bstr_t@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Init@CComCriticalSection@ATL@@QAEJXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Term@CComCriticalSection@ATL@@QAEJXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CAtlWinModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0CAtlWinModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CAtlWinModule@ATL@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CAtlWinModule@ATL@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??1CAtlWinModule@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__E_AtlWinModule@ATL@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??__E_AtlWinModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??__E_AtlWinModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__E_AtlWinModule@ATL@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__E_AtlWinModule@ATL@@YAXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__F_AtlWinModule@ATL@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??__F_AtlWinModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??__F_AtlWinModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__F_AtlWinModule@ATL@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__F_AtlWinModule@ATL@@YAXXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$2
__catchsym$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z$2
__catchsym$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@N$04@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@M$03@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z$2
__catchsym$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z$2
__catchsym$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z$2
__catchsym$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z$2
__catchsym$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z$2
__catchsym$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z$2
__catchsym$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z$2
__catchsym$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z$0
__ehfuncinfo$?ThreadWMIClass@@YGIPAX@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?ThreadWMIClass@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__ehfuncinfo$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z DD 019930522H
	DD	027H
	DD	FLAT:__unwindtable$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z
	DD	01H
	DD	FLAT:__tryblocktable$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?ThreadWMIClass@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$7
	DD	03H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$2
__unwindtable$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$38
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$5
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$10
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$11
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$12
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$13
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$14
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$15
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$16
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$17
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$18
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$19
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$20
	DD	06H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$21
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$22
	DD	016H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$23
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$24
	DD	018H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$25
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$26
	DD	01aH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$27
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$28
	DD	01cH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$29
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$30
	DD	01eH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$31
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$32
	DD	020H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$33
	DD	015H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$34
	DD	022H
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$35
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$36
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$37
__tryblocktable$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z DD 05H
	DD	023H
	DD	024H
	DD	01H
	DD	FLAT:__catchsym$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$39
__catchsym$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$39 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$0
__ehfuncinfo$?ThreadWMI@@YGIPAX@Z DD 019930522H
	DD	06aH
	DD	FLAT:__unwindtable$?ThreadWMI@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?ThreadWMI@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$18
	DD	012H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$20
	DD	014H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$21
	DD	015H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$22
	DD	016H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$23
	DD	017H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$24
	DD	018H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$25
	DD	019H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$26
	DD	01aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$27
	DD	01bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$28
	DD	01cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$29
	DD	01dH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$30
	DD	01eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$31
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$33
	DD	020H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$34
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$34
	DD	022H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$35
	DD	023H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$36
	DD	024H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$37
	DD	025H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$38
	DD	026H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$39
	DD	027H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$40
	DD	022H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$42
	DD	029H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$43
	DD	022H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$43
	DD	02bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$44
	DD	02cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$45
	DD	02dH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$46
	DD	02eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$47
	DD	02fH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$48
	DD	030H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$49
	DD	031H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$50
	DD	032H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$51
	DD	033H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$52
	DD	034H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$53
	DD	02bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$55
	DD	036H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$56
	DD	02bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$56
	DD	038H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$57
	DD	039H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$58
	DD	03aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$59
	DD	03bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$60
	DD	03cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$61
	DD	03dH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$62
	DD	03eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$63
	DD	03fH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$64
	DD	040H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$65
	DD	041H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$66
	DD	042H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$67
	DD	043H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$68
	DD	038H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$70
	DD	045H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$71
	DD	038H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$71
	DD	047H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$72
	DD	048H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$73
	DD	049H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$74
	DD	04aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$75
	DD	04bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$76
	DD	04cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$77
	DD	047H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$79
	DD	04eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$80
	DD	047H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$80
	DD	050H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$81
	DD	051H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$82
	DD	052H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$83
	DD	053H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$84
	DD	050H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$86
	DD	055H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$87
	DD	050H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$87
	DD	057H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$88
	DD	058H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$89
	DD	059H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$90
	DD	05aH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$91
	DD	05bH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$92
	DD	05cH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$93
	DD	05dH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$94
	DD	05eH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$95
	DD	05fH
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$96
	DD	060H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$97
	DD	061H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$98
	DD	062H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$99
	DD	063H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$100
	DD	064H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$101
	DD	065H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$102
	DD	057H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$104
	DD	067H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$105
	DD	057H
	DD	FLAT:__unwindfunclet$?ThreadWMI@@YGIPAX@Z$105
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
?WMISystemPerformance@@YAXXZ PROC			; WMISystemPerformance

; 1032 : {

  00000	51		 push	 ecx

; 1033 :     static unsigned long PerfRawData_PerfDisk_PhysicalDisk = (unsigned long)-1;
; 1034 :     static unsigned long PerfRawData_PerfNet_Redirector = (unsigned long)-1;
; 1035 :     static unsigned long PerfRawData_PerfOS_Cache = (unsigned long)-1;
; 1036 :     static unsigned long PerfRawData_PerfOS_Memory = (unsigned long)-1;
; 1037 :     static unsigned long PerfRawData_PerfOS_Objects = (unsigned long)-1;
; 1038 :     static unsigned long PerfRawData_PerfOS_PagingFile = (unsigned long)-1;
; 1039 :     static unsigned long PerfRawData_PerfOS_Processor = (unsigned long)-1;
; 1040 :     static unsigned long PerfRawData_PerfOS_System = (unsigned long)-1;
; 1041 : 
; 1042 :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMISysPerf");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf@
  00006	68 12 04 00 00	 push	 1042			; 00000412H
  0000b	6a 40		 push	 64			; 00000040H
  0000d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1043 : 
; 1044 :     if (PerfRawData_PerfDisk_PhysicalDisk != 0)

  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  0001c	74 14		 je	 SHORT $LN2@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  0001e	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA
  00023	33 d2		 xor	 edx, edx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
  0002a	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  0002f	83 c4 04	 add	 esp, 4
$LN2@WMISystemP:

; 1045 :     {
; 1046 :         WMI("Win32_PerfRawData_PerfDisk_PhysicalDisk", &PerfRawData_PerfDisk_PhysicalDisk);
; 1047 :     }
; 1048 : 
; 1049 :     if (PerfRawData_PerfNet_Redirector != 0)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00039	74 14		 je	 SHORT $LN3@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  0003b	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA
  00040	33 d2		 xor	 edx, edx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
  00047	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  0004c	83 c4 04	 add	 esp, 4
$LN3@WMISystemP:

; 1050 :     {
; 1051 :         WMI("Win32_PerfRawData_PerfNet_Redirector", &PerfRawData_PerfNet_Redirector);
; 1052 :     }
; 1053 : 
; 1054 :     if (PerfRawData_PerfOS_Cache != 0)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00056	74 14		 je	 SHORT $LN4@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00058	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA
  0005d	33 d2		 xor	 edx, edx
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
  00064	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00069	83 c4 04	 add	 esp, 4
$LN4@WMISystemP:

; 1055 :     {
; 1056 :         WMI("Win32_PerfRawData_PerfOS_Cache", &PerfRawData_PerfOS_Cache);
; 1057 :     }
; 1058 : 
; 1059 :     if (PerfRawData_PerfOS_Memory != 0)

  0006c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00073	74 14		 je	 SHORT $LN5@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00075	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA
  0007a	33 d2		 xor	 edx, edx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
  00081	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00086	83 c4 04	 add	 esp, 4
$LN5@WMISystemP:

; 1060 :     {
; 1061 :         WMI("Win32_PerfRawData_PerfOS_Memory", &PerfRawData_PerfOS_Memory);
; 1062 :     }
; 1063 : 
; 1064 :     if (PerfRawData_PerfOS_Objects != 0)

  00089	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00090	74 14		 je	 SHORT $LN6@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00092	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA
  00097	33 d2		 xor	 edx, edx
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
  0009e	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  000a3	83 c4 04	 add	 esp, 4
$LN6@WMISystemP:

; 1065 :     {
; 1066 :         WMI("Win32_PerfRawData_PerfOS_Objects", &PerfRawData_PerfOS_Objects);
; 1067 :     }
; 1068 : 
; 1069 :     if (PerfRawData_PerfOS_PagingFile != 0)

  000a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000ad	74 14		 je	 SHORT $LN7@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  000af	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA
  000b4	33 d2		 xor	 edx, edx
  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
  000bb	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  000c0	83 c4 04	 add	 esp, 4
$LN7@WMISystemP:

; 1070 :     {
; 1071 :         WMI("Win32_PerfRawData_PerfOS_PagingFile", &PerfRawData_PerfOS_PagingFile);
; 1072 :     }
; 1073 : 
; 1074 :     if (PerfRawData_PerfOS_Processor != 0)

  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000ca	74 14		 je	 SHORT $LN8@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  000cc	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA
  000d1	33 d2		 xor	 edx, edx
  000d3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
  000d8	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  000dd	83 c4 04	 add	 esp, 4
$LN8@WMISystemP:

; 1075 :     {
; 1076 :         WMI("Win32_PerfRawData_PerfOS_Processor", &PerfRawData_PerfOS_Processor);
; 1077 :     }
; 1078 : 
; 1079 :     if (PerfRawData_PerfOS_System != 0)

  000e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000e7	74 14		 je	 SHORT $LN9@WMISystemP

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  000e9	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA
  000ee	33 d2		 xor	 edx, edx
  000f0	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
  000f5	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  000fa	83 c4 04	 add	 esp, 4
$LN9@WMISystemP:

; 1080 :     {
; 1081 :         WMI("Win32_PerfRawData_PerfOS_System", &PerfRawData_PerfOS_System);
; 1082 :     }
; 1083 : 
; 1084 :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMISysPerf");

  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf@
  00102	68 3c 04 00 00	 push	 1084			; 0000043cH
  00107	6a 40		 push	 64			; 00000040H
  00109	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1085 : }

  00111	59		 pop	 ecx
  00112	c3		 ret	 0
?WMISystemPerformance@@YAXXZ ENDP			; WMISystemPerformance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
?WMIHardwareSensor@@YAXXZ PROC				; WMIHardwareSensor

; 1091 : {

  00000	51		 push	 ecx

; 1092 :     static unsigned long CurrentProbe = (unsigned long)-1;
; 1093 :     static unsigned long PortableBattery = (unsigned long)-1;
; 1094 :     static unsigned long TemperatureProbe = (unsigned long)-1;
; 1095 :     static unsigned long VoltageProbe = (unsigned long)-1;
; 1096 : 
; 1097 :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMIHwSnsr");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr@
  00006	68 49 04 00 00	 push	 1097			; 00000449H
  0000b	6a 40		 push	 64			; 00000040H
  0000d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1098 : 
; 1099 :     if (CurrentProbe != 0)

  00015	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  0001c	74 14		 je	 SHORT $LN2@WMIHardwar

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  0001e	68 00 00 00 00	 push	 OFFSET ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  00023	33 d2		 xor	 edx, edx
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
  0002a	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  0002f	83 c4 04	 add	 esp, 4
$LN2@WMIHardwar:

; 1100 :     {
; 1101 :         WMI("Win32_CurrentProbe", &CurrentProbe);
; 1102 :     }
; 1103 : 
; 1104 :     if (PortableBattery != 0)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00039	74 14		 je	 SHORT $LN3@WMIHardwar

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  0003b	68 00 00 00 00	 push	 OFFSET ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA
  00040	33 d2		 xor	 edx, edx
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
  00047	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  0004c	83 c4 04	 add	 esp, 4
$LN3@WMIHardwar:

; 1105 :     {
; 1106 :         WMI("Win32_PortableBattery", &PortableBattery);
; 1107 :     }
; 1108 : 
; 1109 :     if (TemperatureProbe != 0)

  0004f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00056	74 14		 je	 SHORT $LN4@WMIHardwar

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00058	68 00 00 00 00	 push	 OFFSET ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  0005d	33 d2		 xor	 edx, edx
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
  00064	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00069	83 c4 04	 add	 esp, 4
$LN4@WMIHardwar:

; 1110 :     {
; 1111 :         WMI("Win32_TemperatureProbe", &TemperatureProbe);
; 1112 :     }
; 1113 : 
; 1114 :     if (VoltageProbe != 0)

  0006c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00073	74 14		 je	 SHORT $LN5@WMIHardwar

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00075	68 00 00 00 00	 push	 OFFSET ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  0007a	33 d2		 xor	 edx, edx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
  00081	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00086	83 c4 04	 add	 esp, 4
$LN5@WMIHardwar:

; 1115 :     {
; 1116 :         WMI("Win32_VoltageProbe", &VoltageProbe);
; 1117 :     }
; 1118 : 
; 1119 :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMIHwSnsr");

  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr@
  0008e	68 5f 04 00 00	 push	 1119			; 0000045fH
  00093	6a 40		 push	 64			; 00000040H
  00095	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1120 : }

  0009d	59		 pop	 ecx
  0009e	c3		 ret	 0
?WMIHardwareSensor@@YAXXZ ENDP				; WMIHardwareSensor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
?WMISystemVolumes@@YAXXZ PROC				; WMISystemVolumes

; 991  : {

  00000	51		 push	 ecx

; 992  :     static unsigned long Volume = (unsigned long)-1;
; 993  : 
; 994  :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMISysVols");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols@
  00006	68 e2 03 00 00	 push	 994			; 000003e2H
  0000b	6a 40		 push	 64			; 00000040H
  0000d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00015	33 d2		 xor	 edx, edx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
  0001c	6a 00		 push	 0
  0001e	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00023	83 c4 04	 add	 esp, 4

; 995  : 
; 996  :     //always check both because there may be moments system cannot
; 997  :     //detect a network connection and it always exist at least one 
; 998  :     //logical disk
; 999  : #ifdef _GET_WMI_LOGICALDISK
; 1000 :     WMI("Win32_LogicalDisk");
; 1001 : #endif
; 1002 : 
; 1003 :     WMI("Win32_NetworkConnection");
; 1004 : 
; 1005 :     if (Volume != 0)

  00026	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA, 0
  0002d	74 14		 je	 SHORT $LN2@WMISystemV

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  0002f	68 00 00 00 00	 push	 OFFSET ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA
  00034	33 d2		 xor	 edx, edx
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0N@NNCPDPIH@Win32_Volume@
  0003b	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00040	83 c4 04	 add	 esp, 4
$LN2@WMISystemV:

; 1006 :     {
; 1007 :         WMI("Win32_Volume", &Volume);
; 1008 :     }
; 1009 : 
; 1010 :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMISysVols");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols@
  00048	68 f2 03 00 00	 push	 1010			; 000003f2H
  0004d	6a 40		 push	 64			; 00000040H
  0004f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1011 : }

  00057	59		 pop	 ecx
  00058	c3		 ret	 0
?WMISystemVolumes@@YAXXZ ENDP				; WMISystemVolumes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
_timeElapsed$1$ = -1380					; size = 8
tv7027 = -1372						; size = 4
_hwInfo$ = -1368					; size = 12
_data$ = -1356						; size = 12
_memory$ = -1344					; size = 12
_sysInfo$ = -1332					; size = 12
_net$ = -1320						; size = 12
_dev$ = -1308						; size = 12
_util$ = -1296						; size = 12
_seconds$2$ = -1284					; size = 4
_tickStart$2$ = -1284					; size = 4
_seconds$1$ = -1280					; size = 4
_tickStart$1$ = -1280					; size = 4
tv7028 = -1276						; size = 4
$T9 = -1276						; size = 1
$T10 = -1276						; size = 1
$T11 = -1276						; size = 1
$T12 = -1276						; size = 1
$T13 = -1276						; size = 1
$T14 = -1276						; size = 1
$T15 = -1276						; size = 1
$T16 = -1272						; size = 792
$T17 = -480						; size = 384
$T18 = -408						; size = 312
$T19 = -360						; size = 264
$T20 = -264						; size = 168
$T21 = -264						; size = 168
$T22 = -216						; size = 120
_ahThreads$ = -96					; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?ThreadWMI@@YGIPAX@Z PROC				; ThreadWMI

; 821  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ThreadWMI@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 58 05 00
	00		 sub	 esp, 1368		; 00000558H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 75 08	 mov	 esi, DWORD PTR _lpData$[ebp]

; 822  :     DWORD threads = 0;
; 823  :     HANDLE ahThreads[20] = { 0 };

  00030	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  00033	6a 50		 push	 80			; 00000050H
  00035	33 ff		 xor	 edi, edi
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _memset

; 824  : 
; 825  :     Log(LOG_DEBUG_WMI, __LINE__, ">> ThrdWMI, In (%p)", lpData);

  0003e	56		 push	 esi
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JLEOHDJI@?$DO?$DO?5ThrdWMI?0?5In?5?$CI?$CFp?$CJ@
  00044	68 39 03 00 00	 push	 825			; 00000339H
  00049	6a 40		 push	 64			; 00000040H
  0004b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00050	83 c4 1c	 add	 esp, 28			; 0000001cH

; 827  :     uint64_t tickStart = SysTick();

  00053	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00058	6a 03		 push	 3

; 1784 : 		_Mysize(0),

  0005a	89 bd 18 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+16], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00060	8d 8d 08 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]

; 1785 : 		_Myres(0)

  00066	89 bd 1c fb ff
	ff		 mov	 DWORD PTR $T16[ebp+20], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_03MFKIFBDE@hwi@
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 827  :     uint64_t tickStart = SysTick();

  00071	89 85 fc fa ff
	ff		 mov	 DWORD PTR _tickStart$2$[ebp], eax
  00077	89 95 00 fb ff
	ff		 mov	 DWORD PTR _tickStart$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

  0007d	89 bd 18 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+16], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00083	c7 85 1c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0008d	c6 85 08 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00094	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00099	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009c	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+24]
  000a2	6a 0c		 push	 12			; 0000000cH

; 1784 : 		_Mysize(0),

  000a4	89 bd 30 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+40], edi

; 1785 : 		_Myres(0)

  000aa	89 bd 34 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+44], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FBNILPME@HardwareInfo@

; 3976 : 		_My_data._Mysize = 0;

  000b5	89 bd 30 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+40], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000bb	c7 85 34 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000c5	c6 85 20 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000cc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  000d1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000d5	8d 8d 38 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+48]
  000db	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  000dd	89 bd 48 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+64], edi

; 1785 : 		_Myres(0)

  000e3	89 bd 4c fb ff
	ff		 mov	 DWORD PTR $T16[ebp+68], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MGDJDLAD@Hardware?5Information@

; 3976 : 		_My_data._Mysize = 0;

  000ee	89 bd 48 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+64], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000f4	c7 85 4c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000fe	c6 85 38 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00105	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0010a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0010e	8d 8d 50 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+72]
  00114	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  00116	89 bd 60 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+88], edi

; 1785 : 		_Myres(0)

  0011c	89 bd 64 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+92], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GIOJHHEG@Win32_1394Controller@

; 3976 : 		_My_data._Mysize = 0;

  00127	89 bd 60 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+88], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0012d	c7 85 64 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00137	c6 85 50 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0013e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00143	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00147	8d 8d 68 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+96]
  0014d	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  0014f	89 bd 78 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+112], edi

; 1785 : 		_Myres(0)

  00155	89 bd 7c fb ff
	ff		 mov	 DWORD PTR $T16[ebp+116], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FKIDHCEN@Win32_BaseBoard@

; 3976 : 		_My_data._Mysize = 0;

  00160	89 bd 78 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+112], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00166	c7 85 7c fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00170	c6 85 68 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00177	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0017c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00180	8d 8d 80 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+120]
  00186	6a 0d		 push	 13			; 0000000dH

; 1784 : 		_Mysize(0),

  00188	89 bd 90 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+136], edi

; 1785 : 		_Myres(0)

  0018e	89 bd 94 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+140], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CLAKILND@Win32_Battery@

; 3976 : 		_My_data._Mysize = 0;

  00199	89 bd 90 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+136], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0019f	c7 85 94 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+140], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001a9	c6 85 80 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+120], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001b0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  001b5	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001b9	8d 8d 98 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+144]
  001bf	6a 0a		 push	 10			; 0000000aH

; 1784 : 		_Mysize(0),

  001c1	89 bd a8 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+160], edi

; 1785 : 		_Myres(0)

  001c7	89 bd ac fb ff
	ff		 mov	 DWORD PTR $T16[ebp+164], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001cd	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JLLHHBAL@Win32_BIOS@

; 3976 : 		_My_data._Mysize = 0;

  001d2	89 bd a8 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+160], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001d8	c7 85 ac fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+164], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001e2	c6 85 98 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+144], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001e9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  001ee	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001f2	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+168]
  001f8	6a 09		 push	 9

; 1784 : 		_Mysize(0),

  001fa	89 bd c0 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+184], edi

; 1785 : 		_Myres(0)

  00200	89 bd c4 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+188], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00206	68 00 00 00 00	 push	 OFFSET ??_C@_09HPFDNOIF@Win32_Bus@

; 3976 : 		_My_data._Mysize = 0;

  0020b	89 bd c0 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+184], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00211	c7 85 c4 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+188], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0021b	c6 85 b0 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+168], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00222	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00227	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0022b	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+192]
  00231	6a 10		 push	 16			; 00000010H

; 1784 : 		_Mysize(0),

  00233	89 bd d8 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+208], edi

; 1785 : 		_Myres(0)

  00239	89 bd dc fb ff
	ff		 mov	 DWORD PTR $T16[ebp+212], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0023f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@

; 3976 : 		_My_data._Mysize = 0;

  00244	89 bd d8 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+208], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0024a	c7 85 dc fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+212], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00254	c6 85 c8 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+192], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0025b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00260	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00264	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+216]
  0026a	6a 10		 push	 16			; 00000010H

; 1784 : 		_Mysize(0),

  0026c	89 bd f0 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+232], edi

; 1785 : 		_Myres(0)

  00272	89 bd f4 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+236], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00278	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ILOPCCAP@Win32_DMAChannel@

; 3976 : 		_My_data._Mysize = 0;

  0027d	89 bd f0 fb ff
	ff		 mov	 DWORD PTR $T16[ebp+232], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00283	c7 85 f4 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+236], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0028d	c6 85 e0 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+216], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00294	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00299	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0029d	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+240]
  002a3	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  002a5	89 bd 08 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+256], edi

; 1785 : 		_Myres(0)

  002ab	89 bd 0c fc ff
	ff		 mov	 DWORD PTR $T16[ebp+260], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DGOGJGDP@Win32_DriverVXD@

; 3976 : 		_My_data._Mysize = 0;

  002b6	89 bd 08 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+256], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002bc	c7 85 0c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+260], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  002c6	c6 85 f8 fb ff
	ff 00		 mov	 BYTE PTR $T16[ebp+240], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002cd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  002d2	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002d6	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+264]
  002dc	6a 16		 push	 22			; 00000016H

; 1784 : 		_Mysize(0),

  002de	89 bd 20 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+280], edi

; 1785 : 		_Myres(0)

  002e4	89 bd 24 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+284], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GBOCBJMM@Win32_FloppyController@

; 3976 : 		_My_data._Mysize = 0;

  002ef	89 bd 20 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+280], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002f5	c7 85 24 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+284], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  002ff	c6 85 10 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+264], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00306	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0030b	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0030f	8d 8d 28 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+288]
  00315	6a 11		 push	 17			; 00000011H

; 1784 : 		_Mysize(0),

  00317	89 bd 38 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+304], edi

; 1785 : 		_Myres(0)

  0031d	89 bd 3c fc ff
	ff		 mov	 DWORD PTR $T16[ebp+308], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@

; 3976 : 		_My_data._Mysize = 0;

  00328	89 bd 38 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+304], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0032e	c7 85 3c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+308], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00338	c6 85 28 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+288], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0033f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00344	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00348	89 bd 50 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+328], edi

; 1785 : 		_Myres(0)

  0034e	89 bd 54 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+332], edi

; 3976 : 		_My_data._Mysize = 0;

  00354	89 bd 50 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+328], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0035a	6a 0e		 push	 14			; 0000000eH
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MCPBPNON@Win32_HeatPipe@
  00361	8d 8d 40 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+312]

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00367	c7 85 54 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+332], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00371	c6 85 40 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+312], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00378	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0037d	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00381	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+336]
  00387	6a 0e		 push	 14			; 0000000eH

; 1784 : 		_Mysize(0),

  00389	89 bd 68 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+352], edi

; 1785 : 		_Myres(0)

  0038f	89 bd 6c fc ff
	ff		 mov	 DWORD PTR $T16[ebp+356], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00395	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IGJIBAJA@Win32_Keyboard@

; 3976 : 		_My_data._Mysize = 0;

  0039a	89 bd 68 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+352], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003a0	c7 85 6c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+356], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  003aa	c6 85 58 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+336], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003b1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  003b6	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003ba	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+360]
  003c0	6a 17		 push	 23			; 00000017H

; 1784 : 		_Mysize(0),

  003c2	89 bd 80 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+376], edi

; 1785 : 		_Myres(0)

  003c8	89 bd 84 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+380], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@

; 3976 : 		_My_data._Mysize = 0;

  003d3	89 bd 80 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+376], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003d9	c7 85 84 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+380], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  003e3	c6 85 70 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+360], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003ea	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  003ef	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003f3	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+384]
  003f9	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  003fb	89 bd 98 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+400], edi

; 1785 : 		_Myres(0)

  00401	89 bd 9c fc ff
	ff		 mov	 DWORD PTR $T16[ebp+404], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00407	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@

; 3976 : 		_My_data._Mysize = 0;

  0040c	89 bd 98 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+400], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00412	c7 85 9c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+404], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0041c	c6 85 88 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+384], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00423	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00428	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0042c	8d 8d a0 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+408]
  00432	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  00434	89 bd b0 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+424], edi

; 1785 : 		_Myres(0)

  0043a	89 bd b4 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+428], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00440	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FMCMMJCA@Win32_IDEController@

; 3976 : 		_My_data._Mysize = 0;

  00445	89 bd b0 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+424], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0044b	c7 85 b4 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+428], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00455	c6 85 a0 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+408], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0045c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00461	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00465	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+432]
  0046b	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  0046d	89 bd c8 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+448], edi

; 1785 : 		_Myres(0)

  00473	89 bd cc fc ff
	ff		 mov	 DWORD PTR $T16[ebp+452], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00479	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EEIPINHM@Win32_InfraredDevice@

; 3976 : 		_My_data._Mysize = 0;

  0047e	89 bd c8 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+448], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00484	c7 85 cc fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+452], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0048e	c6 85 b8 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+432], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00495	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0049a	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0049e	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+456]
  004a4	6a 11		 push	 17			; 00000011H

; 1784 : 		_Mysize(0),

  004a6	89 bd e0 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+472], edi

; 1785 : 		_Myres(0)

  004ac	89 bd e4 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+476], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  004b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MGLAEOHD@Win32_IRQResource@

; 3976 : 		_My_data._Mysize = 0;

  004b7	89 bd e0 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+472], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  004bd	c7 85 e4 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+476], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  004c7	c6 85 d0 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+456], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  004ce	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  004d3	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  004d7	6a 16		 push	 22			; 00000016H

; 1784 : 		_Mysize(0),

  004d9	89 bd f8 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+496], edi

; 1785 : 		_Myres(0)

  004df	89 bd fc fc ff
	ff		 mov	 DWORD PTR $T16[ebp+500], edi

; 3976 : 		_My_data._Mysize = 0;

  004e5	89 bd f8 fc ff
	ff		 mov	 DWORD PTR $T16[ebp+496], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  004eb	c7 85 fc fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+500], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  004f5	c6 85 e8 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp+480], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  004fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
  00501	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+480]
  00507	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0050c	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00510	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+504]
  00516	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  00518	89 bd 10 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+520], edi

; 1785 : 		_Myres(0)

  0051e	89 bd 14 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+524], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00524	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MJMHBKMK@Win32_PointingDevice@

; 3976 : 		_My_data._Mysize = 0;

  00529	89 bd 10 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+520], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0052f	c7 85 14 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+524], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00539	c6 85 00 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+504], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00540	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00545	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00549	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+528]
  0054f	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  00551	89 bd 28 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+544], edi

; 1785 : 		_Myres(0)

  00557	89 bd 2c fd ff
	ff		 mov	 DWORD PTR $T16[ebp+548], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0055d	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BFHBBNBL@Win32_PortConnector@

; 3976 : 		_My_data._Mysize = 0;

  00562	89 bd 28 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+544], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00568	c7 85 2c fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+548], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00572	c6 85 18 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+528], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00579	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0057e	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00582	8d 8d 30 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+552]
  00588	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  0058a	89 bd 40 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+568], edi

; 1785 : 		_Myres(0)

  00590	89 bd 44 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+572], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00596	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JJNGNMBL@Win32_PortResource@

; 3976 : 		_My_data._Mysize = 0;

  0059b	89 bd 40 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+568], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  005a1	c7 85 44 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+572], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  005ab	c6 85 30 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+552], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005b2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  005b7	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005bb	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+576]
  005c1	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  005c3	89 bd 58 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+592], edi

; 1785 : 		_Myres(0)

  005c9	89 bd 5c fd ff
	ff		 mov	 DWORD PTR $T16[ebp+596], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EHCOOLPP@Win32_PnPEntity@

; 3976 : 		_My_data._Mysize = 0;

  005d4	89 bd 58 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+592], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  005da	c7 85 5c fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+596], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  005e4	c6 85 48 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+576], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005eb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  005f0	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005f4	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+600]
  005fa	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  005fc	89 bd 70 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+616], edi

; 1785 : 		_Myres(0)

  00602	89 bd 74 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+620], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00608	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@HLKMDILE@Win32_PrinterDriver@

; 3976 : 		_My_data._Mysize = 0;

  0060d	89 bd 70 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+616], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00613	c7 85 74 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+620], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0061d	c6 85 60 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+600], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00624	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00629	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0062d	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+624]
  00633	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  00635	89 bd 88 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+640], edi

; 1785 : 		_Myres(0)

  0063b	89 bd 8c fd ff
	ff		 mov	 DWORD PTR $T16[ebp+644], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00641	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OJJOBJJP@Win32_Processor@

; 3976 : 		_My_data._Mysize = 0;

  00646	89 bd 88 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+640], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0064c	c7 85 8c fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+644], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00656	c6 85 78 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+624], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0065d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00662	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00666	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+648]
  0066c	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  0066e	89 bd a0 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+664], edi

; 1785 : 		_Myres(0)

  00674	89 bd a4 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+668], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0067a	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@OGHHAMBD@Win32_SCSIController@

; 3976 : 		_My_data._Mysize = 0;

  0067f	89 bd a0 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+664], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00685	c7 85 a4 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+668], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0068f	c6 85 90 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+648], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00696	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0069b	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0069f	6a 10		 push	 16			; 00000010H

; 1784 : 		_Mysize(0),

  006a1	89 bd b8 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+688], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006a7	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+672]

; 1785 : 		_Myres(0)

  006ad	89 bd bc fd ff
	ff		 mov	 DWORD PTR $T16[ebp+692], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DLHLCIMJ@Win32_SerialPort@

; 3976 : 		_My_data._Mysize = 0;

  006b8	89 bd b8 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+688], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  006be	c7 85 bc fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+692], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  006c8	c6 85 a8 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+672], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006cf	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  006d4	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006d8	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+696]
  006de	6a 1d		 push	 29			; 0000001dH

; 1784 : 		_Mysize(0),

  006e0	89 bd d0 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+712], edi

; 1785 : 		_Myres(0)

  006e6	89 bd d4 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+716], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@

; 3976 : 		_My_data._Mysize = 0;

  006f1	89 bd d0 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+712], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  006f7	c7 85 d4 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+716], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00701	c6 85 c0 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+696], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00708	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0070d	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00711	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+720]
  00717	6a 11		 push	 17			; 00000011H

; 1784 : 		_Mysize(0),

  00719	89 bd e8 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+736], edi

; 1785 : 		_Myres(0)

  0071f	89 bd ec fd ff
	ff		 mov	 DWORD PTR $T16[ebp+740], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00725	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@INJPMPPD@Win32_SoundDevice@

; 3976 : 		_My_data._Mysize = 0;

  0072a	89 bd e8 fd ff
	ff		 mov	 DWORD PTR $T16[ebp+736], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00730	c7 85 ec fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+740], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0073a	c6 85 d8 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+720], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00741	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  00746	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0074a	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+744]
  00750	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  00752	89 bd 00 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+760], edi

; 1785 : 		_Myres(0)

  00758	89 bd 04 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+764], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0075e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KNIHCNGM@Win32_USBController@

; 3976 : 		_My_data._Mysize = 0;

  00763	89 bd 00 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+760], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00769	c7 85 04 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+764], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00773	c6 85 f0 fd ff
	ff 00		 mov	 BYTE PTR $T16[ebp+744], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0077a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  0077f	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00783	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+768]
  00789	6a 15		 push	 21			; 00000015H

; 1784 : 		_Mysize(0),

  0078b	89 bd 18 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+784], edi

; 1785 : 		_Myres(0)

  00791	89 bd 1c fe ff
	ff		 mov	 DWORD PTR $T16[ebp+788], edi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00797	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IOBPPLKC@Win32_VideoController@

; 3976 : 		_My_data._Mysize = 0;

  0079c	89 bd 18 fe ff
	ff		 mov	 DWORD PTR $T16[ebp+784], edi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  007a2	c7 85 1c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+788], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  007ac	c6 85 08 fe ff
	ff 00		 mov	 BYTE PTR $T16[ebp+768], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  007b3	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  007b8	c7 45 fc 20 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 32 ; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  007bf	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR $T16[ebp+792]
  007c5	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T15[ebp]
  007cb	8d 8d a8 fa ff
	ff		 lea	 ecx, DWORD PTR _hwInfo$[ebp]

; 389  : 		: _Myfirst(),

  007d1	89 bd a8 fa ff
	ff		 mov	 DWORD PTR _hwInfo$[ebp], edi

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  007d7	50		 push	 eax
  007d8	8d 85 08 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]

; 390  : 		_Mylast(),

  007de	89 bd ac fa ff
	ff		 mov	 DWORD PTR _hwInfo$[ebp+4], edi

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  007e4	50		 push	 eax

; 391  : 		_Myend()

  007e5	89 bd b0 fa ff
	ff		 mov	 DWORD PTR _hwInfo$[ebp+8], edi

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  007eb	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 830  :     std::vector<std::string> hwInfo{ "hwi",

  007f0	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
  007f4	8d 85 08 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  007fa	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  007ff	6a 21		 push	 33			; 00000021H
  00801	6a 18		 push	 24			; 00000018H
  00803	50		 push	 eax
  00804	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00809	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _hwInfo$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 852  :     if (StartThread(hwInfo[1], ThreadWMIClass, (LPVOID)&hwInfo, 0, &ahThreads[threads]))

  0080f	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  00812	50		 push	 eax
  00813	57		 push	 edi
  00814	8d 85 a8 fa ff
	ff		 lea	 eax, DWORD PTR _hwInfo$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  0081a	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 852  :     if (StartThread(hwInfo[1], ThreadWMIClass, (LPVOID)&hwInfo, 0, &ahThreads[threads]))

  0081d	50		 push	 eax
  0081e	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  00823	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  00828	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0082b	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+16], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 852  :     if (StartThread(hwInfo[1], ThreadWMIClass, (LPVOID)&hwInfo, 0, &ahThreads[threads]))

  00835	84 c0		 test	 al, al
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1785 : 		_Myres(0)

  00837	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+20], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 852  :     if (StartThread(hwInfo[1], ThreadWMIClass, (LPVOID)&hwInfo, 0, &ahThreads[threads]))

  00841	b9 01 00 00 00	 mov	 ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

  00846	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+16], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 852  :     if (StartThread(hwInfo[1], ThreadWMIClass, (LPVOID)&hwInfo, 0, &ahThreads[threads]))

  00850	0f 45 f9	 cmovne	 edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00853	c7 85 0c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T21[ebp+20], 15 ; 0000000fH

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0085d	6a 02		 push	 2
  0085f	68 00 00 00 00	 push	 OFFSET ??_C@_02ELHCGPCE@ds@
  00864	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0086a	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T21[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00871	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  00876	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+8], 35 ; 00000023H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0087a	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+24]
  00880	6a 0b		 push	 11			; 0000000bH

; 1784 : 		_Mysize(0),

  00882	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+40], 0

; 1785 : 		_Myres(0)

  0088c	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+44], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00896	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PNBJJAPO@DataStorage@

; 3976 : 		_My_data._Mysize = 0;

  0089b	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+40], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  008a5	c7 85 24 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T21[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  008af	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR $T21[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008b6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  008bb	c6 45 fc 24	 mov	 BYTE PTR __$EHRec$[ebp+8], 36 ; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008bf	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+48]
  008c5	6a 1f		 push	 31			; 0000001fH

; 1784 : 		_Mysize(0),

  008c7	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+64], 0

; 1785 : 		_Myres(0)

  008d1	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+68], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008db	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BNLNLMID@Disk?5and?5Partitions?5Information@

; 3976 : 		_My_data._Mysize = 0;

  008e0	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+64], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  008ea	c7 85 3c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T21[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  008f4	c6 85 28 ff ff
	ff 00		 mov	 BYTE PTR $T21[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008fb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  00900	c6 45 fc 25	 mov	 BYTE PTR __$EHRec$[ebp+8], 37 ; 00000025H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00904	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+72]
  0090a	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  0090c	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+88], 0

; 1785 : 		_Myres(0)

  00916	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+92], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00920	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CJPFNKBD@Win32_DiskDrive@

; 3976 : 		_My_data._Mysize = 0;

  00925	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+88], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0092f	c7 85 54 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T21[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00939	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR $T21[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00940	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  00945	c6 45 fc 26	 mov	 BYTE PTR __$EHRec$[ebp+8], 38 ; 00000026H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00949	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+96]
  0094f	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  00951	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+112], 0

; 1785 : 		_Myres(0)

  0095b	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+116], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00965	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GBMGFCLI@Win32_DiskPartition@

; 3976 : 		_My_data._Mysize = 0;

  0096a	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T21[ebp+112], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00974	c7 85 6c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T21[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0097e	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T21[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00985	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  0098a	c6 45 fc 27	 mov	 BYTE PTR __$EHRec$[ebp+8], 39 ; 00000027H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0098e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+120]
  00994	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  00996	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+136], 0

; 1785 : 		_Myres(0)

  0099d	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+140], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009a4	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@

; 3976 : 		_My_data._Mysize = 0;

  009a9	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+136], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  009b0	c7 45 84 0f 00
	00 00		 mov	 DWORD PTR $T21[ebp+140], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  009b7	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR $T21[ebp+120], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009be	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  009c3	c6 45 fc 28	 mov	 BYTE PTR __$EHRec$[ebp+8], 40 ; 00000028H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009c7	8d 4d 88	 lea	 ecx, DWORD PTR $T21[ebp+144]
  009ca	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  009cc	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+160], 0

; 1785 : 		_Myres(0)

  009d3	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+164], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009da	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GLDDIFFN@Win32_TapeDrive@

; 3976 : 		_My_data._Mysize = 0;

  009df	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T21[ebp+160], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  009e6	c7 45 9c 0f 00
	00 00		 mov	 DWORD PTR $T21[ebp+164], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  009ed	c6 45 88 00	 mov	 BYTE PTR $T21[ebp+144], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  009f6	c6 45 fc 29	 mov	 BYTE PTR __$EHRec$[ebp+8], 41 ; 00000029H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  009fa	8d 45 a0	 lea	 eax, DWORD PTR $T21[ebp+168]
  009fd	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T14[ebp]
  00a03	8d 8d b4 fa ff
	ff		 lea	 ecx, DWORD PTR _data$[ebp]

; 389  : 		: _Myfirst(),

  00a09	c7 85 b4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _data$[ebp], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00a13	50		 push	 eax
  00a14	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]

; 390  : 		_Mylast(),

  00a1a	c7 85 b8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _data$[ebp+4], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00a24	50		 push	 eax

; 391  : 		_Myend()

  00a25	c7 85 bc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _data$[ebp+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00a2f	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 860  :     std::vector<std::string> data{ "ds",

  00a34	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
  00a38	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  00a3e	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a43	6a 07		 push	 7
  00a45	6a 18		 push	 24			; 00000018H
  00a47	50		 push	 eax
  00a48	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00a4d	8b 8d b4 fa ff
	ff		 mov	 ecx, DWORD PTR _data$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 866  :     if (StartThread(data[1], ThreadWMIClass, (LPVOID)&data, 0, &ahThreads[threads]))

  00a53	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  00a56	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00a59	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  00a5e	50		 push	 eax
  00a5f	8d 85 b4 fa ff
	ff		 lea	 eax, DWORD PTR _data$[ebp]
  00a65	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00a67	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 866  :     if (StartThread(data[1], ThreadWMIClass, (LPVOID)&data, 0, &ahThreads[threads]))

  00a6a	50		 push	 eax
  00a6b	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  00a70	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a73	84 c0		 test	 al, al
  00a75	74 01		 je	 SHORT $LN6@ThreadWMI

; 867  :     {
; 868  :         ++threads;

  00a77	47		 inc	 edi
$LN6@ThreadWMI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a78	6a 03		 push	 3

; 1784 : 		_Mysize(0),

  00a7a	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a84	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]

; 1785 : 		_Myres(0)

  00a8a	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a94	68 00 00 00 00	 push	 OFFSET ??_C@_03IJLIBDBM@mem@

; 3976 : 		_My_data._Mysize = 0;

  00a99	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00aa3	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00aad	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T19[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ab4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00ab9	c6 45 fc 2c	 mov	 BYTE PTR __$EHRec$[ebp+8], 44 ; 0000002cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00abd	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+24]
  00ac3	6a 06		 push	 6

; 1784 : 		_Mysize(0),

  00ac5	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+40], 0

; 1785 : 		_Myres(0)

  00acf	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+44], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ad9	68 00 00 00 00	 push	 OFFSET ??_C@_06LEBJIAPJ@Memory@

; 3976 : 		_My_data._Mysize = 0;

  00ade	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+40], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ae8	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00af2	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T19[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00af9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00afe	c6 45 fc 2d	 mov	 BYTE PTR __$EHRec$[ebp+8], 45 ; 0000002dH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b02	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+48]
  00b08	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  00b0a	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+64], 0

; 1785 : 		_Myres(0)

  00b14	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+68], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b1e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BGPGMIME@Memory?5Information@

; 3976 : 		_My_data._Mysize = 0;

  00b23	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+64], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b2d	c7 85 dc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00b37	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR $T19[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b3e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00b43	c6 45 fc 2e	 mov	 BYTE PTR __$EHRec$[ebp+8], 46 ; 0000002eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b47	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+72]
  00b4d	6a 11		 push	 17			; 00000011H

; 1784 : 		_Mysize(0),

  00b4f	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+88], 0

; 1785 : 		_Myres(0)

  00b59	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+92], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b63	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BKKBKJDE@Win32_CacheMemory@

; 3976 : 		_My_data._Mysize = 0;

  00b68	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+88], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b72	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00b7c	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T19[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b83	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00b88	c6 45 fc 2f	 mov	 BYTE PTR __$EHRec$[ebp+8], 47 ; 0000002fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b8c	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+96]
  00b92	6a 19		 push	 25			; 00000019H

; 1784 : 		_Mysize(0),

  00b94	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+112], 0

; 1785 : 		_Myres(0)

  00b9e	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+116], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ba8	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@

; 3976 : 		_My_data._Mysize = 0;

  00bad	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+112], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00bb7	c7 85 0c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00bc1	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T19[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00bc8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00bcd	c6 45 fc 30	 mov	 BYTE PTR __$EHRec$[ebp+8], 48 ; 00000030H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00bd1	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+120]
  00bd7	6a 11		 push	 17			; 00000011H

; 1784 : 		_Mysize(0),

  00bd9	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+136], 0

; 1785 : 		_Myres(0)

  00be3	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+140], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00bed	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NBCNDILJ@Win32_MemoryArray@

; 3976 : 		_My_data._Mysize = 0;

  00bf2	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+136], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00bfc	c7 85 24 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+140], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00c06	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR $T19[ebp+120], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c0d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00c12	c6 45 fc 31	 mov	 BYTE PTR __$EHRec$[ebp+8], 49 ; 00000031H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c16	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+144]
  00c1c	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  00c1e	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+160], 0

; 1785 : 		_Myres(0)

  00c28	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+164], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c32	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@

; 3976 : 		_My_data._Mysize = 0;

  00c37	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+160], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00c41	c7 85 3c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+164], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00c4b	c6 85 28 ff ff
	ff 00		 mov	 BYTE PTR $T19[ebp+144], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c52	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00c57	c6 45 fc 32	 mov	 BYTE PTR __$EHRec$[ebp+8], 50 ; 00000032H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00c5b	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+184], 0

; 1785 : 		_Myres(0)

  00c65	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+188], 0

; 3976 : 		_My_data._Mysize = 0;

  00c6f	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+184], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00c79	c7 85 54 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+188], 15 ; 0000000fH

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c83	6a 14		 push	 20			; 00000014H
  00c85	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
  00c8a	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+168]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00c90	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR $T19[ebp+168], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c97	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00c9c	c6 45 fc 33	 mov	 BYTE PTR __$EHRec$[ebp+8], 51 ; 00000033H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ca0	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+192]
  00ca6	6a 19		 push	 25			; 00000019H

; 1784 : 		_Mysize(0),

  00ca8	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+208], 0

; 1785 : 		_Myres(0)

  00cb2	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+212], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00cbc	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@

; 3976 : 		_My_data._Mysize = 0;

  00cc1	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T19[ebp+208], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ccb	c7 85 6c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T19[ebp+212], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00cd5	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T19[ebp+192], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00cdc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00ce1	c6 45 fc 34	 mov	 BYTE PTR __$EHRec$[ebp+8], 52 ; 00000034H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ce5	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+216]
  00ceb	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  00ced	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+232], 0

; 1785 : 		_Myres(0)

  00cf4	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+236], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00cfb	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@

; 3976 : 		_My_data._Mysize = 0;

  00d00	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+232], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d07	c7 45 84 0f 00
	00 00		 mov	 DWORD PTR $T19[ebp+236], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00d0e	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR $T19[ebp+216], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d15	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00d1a	c6 45 fc 35	 mov	 BYTE PTR __$EHRec$[ebp+8], 53 ; 00000035H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d1e	8d 4d 88	 lea	 ecx, DWORD PTR $T19[ebp+240]
  00d21	6a 1a		 push	 26			; 0000001aH

; 1784 : 		_Mysize(0),

  00d23	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+256], 0

; 1785 : 		_Myres(0)

  00d2a	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+260], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d31	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@

; 3976 : 		_My_data._Mysize = 0;

  00d36	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T19[ebp+256], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d3d	c7 45 9c 0f 00
	00 00		 mov	 DWORD PTR $T19[ebp+260], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00d44	c6 45 88 00	 mov	 BYTE PTR $T19[ebp+240], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d48	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00d4d	c6 45 fc 36	 mov	 BYTE PTR __$EHRec$[ebp+8], 54 ; 00000036H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00d51	8d 45 a0	 lea	 eax, DWORD PTR $T19[ebp+264]
  00d54	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T13[ebp]
  00d5a	8d 8d c0 fa ff
	ff		 lea	 ecx, DWORD PTR _memory$[ebp]

; 389  : 		: _Myfirst(),

  00d60	c7 85 c0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _memory$[ebp], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00d6a	50		 push	 eax
  00d6b	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]

; 390  : 		_Mylast(),

  00d71	c7 85 c4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _memory$[ebp+4], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00d7b	50		 push	 eax

; 391  : 		_Myend()

  00d7c	c7 85 c8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _memory$[ebp+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00d86	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 873  :     std::vector<std::string> memory{ "mem",

  00d8b	c6 45 fc 38	 mov	 BYTE PTR __$EHRec$[ebp+8], 56 ; 00000038H
  00d8f	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00d95	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00d9a	6a 0b		 push	 11			; 0000000bH
  00d9c	6a 18		 push	 24			; 00000018H
  00d9e	50		 push	 eax
  00d9f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00da4	8b 8d c0 fa ff
	ff		 mov	 ecx, DWORD PTR _memory$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 881  :     if (StartThread(memory[1], ThreadWMIClass, (LPVOID)&memory, 0, &ahThreads[threads]))

  00daa	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  00dad	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  00db0	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  00db5	50		 push	 eax
  00db6	8d 85 c0 fa ff
	ff		 lea	 eax, DWORD PTR _memory$[ebp]
  00dbc	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00dbe	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 881  :     if (StartThread(memory[1], ThreadWMIClass, (LPVOID)&memory, 0, &ahThreads[threads]))

  00dc1	50		 push	 eax
  00dc2	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  00dc7	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dca	84 c0		 test	 al, al
  00dcc	74 01		 je	 SHORT $LN7@ThreadWMI

; 882  :     {
; 883  :         ++threads;

  00dce	47		 inc	 edi
$LN7@ThreadWMI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00dcf	6a 04		 push	 4

; 1784 : 		_Mysize(0),

  00dd1	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ddb	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]

; 1785 : 		_Myres(0)

  00de1	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00deb	68 00 00 00 00	 push	 OFFSET ??_C@_04HDBAHLAM@sysi@

; 3976 : 		_My_data._Mysize = 0;

  00df0	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00dfa	c7 85 7c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00e04	c6 85 68 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e0b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00e10	c6 45 fc 39	 mov	 BYTE PTR __$EHRec$[ebp+8], 57 ; 00000039H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e14	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+24]
  00e1a	6a 0a		 push	 10			; 0000000aH

; 1784 : 		_Mysize(0),

  00e1c	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+40], 0

; 1785 : 		_Myres(0)

  00e26	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+44], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e30	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NDINDOCK@SystemInfo@

; 3976 : 		_My_data._Mysize = 0;

  00e35	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+40], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e3f	c7 85 94 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00e49	c6 85 80 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e50	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00e55	c6 45 fc 3a	 mov	 BYTE PTR __$EHRec$[ebp+8], 58 ; 0000003aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e59	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+48]
  00e5f	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  00e61	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+64], 0

; 1785 : 		_Myres(0)

  00e6b	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+68], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e75	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OJGHJHKA@System?5Information@

; 3976 : 		_My_data._Mysize = 0;

  00e7a	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+64], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e84	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00e8e	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e95	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00e9a	c6 45 fc 3b	 mov	 BYTE PTR __$EHRec$[ebp+8], 59 ; 0000003bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e9e	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+72]
  00ea4	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  00ea6	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+88], 0

; 1785 : 		_Myres(0)

  00eb0	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+92], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00eba	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@

; 3976 : 		_My_data._Mysize = 0;

  00ebf	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+88], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ec9	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00ed3	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00eda	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00edf	c6 45 fc 3c	 mov	 BYTE PTR __$EHRec$[ebp+8], 60 ; 0000003cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ee3	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+96]
  00ee9	6a 1b		 push	 27			; 0000001bH

; 1784 : 		_Mysize(0),

  00eeb	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+112], 0

; 1785 : 		_Myres(0)

  00ef5	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+116], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00eff	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@

; 3976 : 		_My_data._Mysize = 0;

  00f04	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+112], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00f0e	c7 85 dc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00f18	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f1f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00f24	c6 45 fc 3d	 mov	 BYTE PTR __$EHRec$[ebp+8], 61 ; 0000003dH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f28	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+120]
  00f2e	6a 0d		 push	 13			; 0000000dH

; 1784 : 		_Mysize(0),

  00f30	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+136], 0

; 1785 : 		_Myres(0)

  00f3a	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+140], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f44	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LCAALOJJ@Win32_Product@

; 3976 : 		_My_data._Mysize = 0;

  00f49	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+136], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00f53	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+140], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00f5d	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp+120], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f64	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00f69	c6 45 fc 3e	 mov	 BYTE PTR __$EHRec$[ebp+8], 62 ; 0000003eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f6d	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+144]
  00f73	6a 19		 push	 25			; 00000019H

; 1784 : 		_Mysize(0),

  00f75	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+160], 0

; 1785 : 		_Myres(0)

  00f7f	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+164], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f89	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@

; 3976 : 		_My_data._Mysize = 0;

  00f8e	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+160], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00f98	c7 85 0c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+164], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00fa2	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T18[ebp+144], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00fa9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00fae	c6 45 fc 3f	 mov	 BYTE PTR __$EHRec$[ebp+8], 63 ; 0000003fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00fb2	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+184], 0

; 1785 : 		_Myres(0)

  00fbc	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+188], 0

; 3976 : 		_My_data._Mysize = 0;

  00fc6	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+184], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00fd0	c7 85 24 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+188], 15 ; 0000000fH

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00fda	6a 13		 push	 19			; 00000013H
  00fdc	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DKANKDCG@Win32_Refrigeration@
  00fe1	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+168]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00fe7	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp+168], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00fee	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  00ff3	c6 45 fc 40	 mov	 BYTE PTR __$EHRec$[ebp+8], 64 ; 00000040H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ff7	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+192]
  00ffd	6a 0e		 push	 14			; 0000000eH

; 1784 : 		_Mysize(0),

  00fff	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+208], 0

; 1785 : 		_Myres(0)

  01009	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+212], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01013	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OGGGECNI@Win32_Registry@

; 3976 : 		_My_data._Mysize = 0;

  01018	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+208], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01022	c7 85 3c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+212], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0102c	c6 85 28 ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp+192], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01033	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  01038	c6 45 fc 41	 mov	 BYTE PTR __$EHRec$[ebp+8], 65 ; 00000041H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0103c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+216]
  01042	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  01044	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+232], 0

; 1785 : 		_Myres(0)

  0104e	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+236], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01058	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DHOOODEL@Win32_SystemAccount@

; 3976 : 		_My_data._Mysize = 0;

  0105d	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+232], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01067	c7 85 54 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+236], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01071	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp+216], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01078	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  0107d	c6 45 fc 42	 mov	 BYTE PTR __$EHRec$[ebp+8], 66 ; 00000042H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01081	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+240]
  01087	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  01089	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+256], 0

; 1785 : 		_Myres(0)

  01093	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+260], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0109d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GGPCAOMO@Win32_SystemDriver@

; 3976 : 		_My_data._Mysize = 0;

  010a2	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T18[ebp+256], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  010ac	c7 85 6c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T18[ebp+260], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  010b6	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp+240], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010bd	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  010c2	c6 45 fc 43	 mov	 BYTE PTR __$EHRec$[ebp+8], 67 ; 00000043H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010c6	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+264]
  010cc	6a 15		 push	 21			; 00000015H

; 1784 : 		_Mysize(0),

  010ce	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+280], 0

; 1785 : 		_Myres(0)

  010d5	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+284], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@

; 3976 : 		_My_data._Mysize = 0;

  010e1	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+280], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  010e8	c7 45 84 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+284], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  010ef	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR $T18[ebp+264], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010f6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  010fb	c6 45 fc 44	 mov	 BYTE PTR __$EHRec$[ebp+8], 68 ; 00000044H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010ff	8d 4d 88	 lea	 ecx, DWORD PTR $T18[ebp+288]
  01102	6a 10		 push	 16			; 00000010H

; 1784 : 		_Mysize(0),

  01104	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+304], 0

; 1785 : 		_Myres(0)

  0110b	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+308], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01112	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IINEGLLN@Win32_SystemSlot@

; 3976 : 		_My_data._Mysize = 0;

  01117	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T18[ebp+304], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0111e	c7 45 9c 0f 00
	00 00		 mov	 DWORD PTR $T18[ebp+308], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01125	c6 45 88 00	 mov	 BYTE PTR $T18[ebp+288], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01129	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  0112e	c6 45 fc 45	 mov	 BYTE PTR __$EHRec$[ebp+8], 69 ; 00000045H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01132	8d 45 a0	 lea	 eax, DWORD PTR $T18[ebp+312]
  01135	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T12[ebp]
  0113b	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR _sysInfo$[ebp]

; 389  : 		: _Myfirst(),

  01141	c7 85 cc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _sysInfo$[ebp], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0114b	50		 push	 eax
  0114c	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]

; 390  : 		_Mylast(),

  01152	c7 85 d0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _sysInfo$[ebp+4], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0115c	50		 push	 eax

; 391  : 		_Myend()

  0115d	c7 85 d4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _sysInfo$[ebp+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01167	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 888  :     std::vector<std::string> sysInfo{ "sysi",

  0116c	c6 45 fc 47	 mov	 BYTE PTR __$EHRec$[ebp+8], 71 ; 00000047H
  01170	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  01176	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0117b	6a 0d		 push	 13			; 0000000dH
  0117d	6a 18		 push	 24			; 00000018H
  0117f	50		 push	 eax
  01180	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  01185	8b 8d cc fa ff
	ff		 mov	 ecx, DWORD PTR _sysInfo$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 899  :     if (StartThread(sysInfo[1], ThreadWMIClass, (LPVOID)&sysInfo, 0, &ahThreads[threads]))

  0118b	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  0118e	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  01191	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  01196	50		 push	 eax
  01197	8d 85 cc fa ff
	ff		 lea	 eax, DWORD PTR _sysInfo$[ebp]
  0119d	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  0119f	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 899  :     if (StartThread(sysInfo[1], ThreadWMIClass, (LPVOID)&sysInfo, 0, &ahThreads[threads]))

  011a2	50		 push	 eax
  011a3	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  011a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  011ab	84 c0		 test	 al, al
  011ad	74 01		 je	 SHORT $LN8@ThreadWMI

; 900  :     {
; 901  :         ++threads;

  011af	47		 inc	 edi
$LN8@ThreadWMI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  011b0	6a 03		 push	 3

; 1784 : 		_Mysize(0),

  011b2	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  011bc	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]

; 1785 : 		_Myres(0)

  011c2	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  011cc	68 00 00 00 00	 push	 OFFSET ??_C@_03NBFOK@net@

; 3976 : 		_My_data._Mysize = 0;

  011d1	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  011db	c7 85 0c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T20[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  011e5	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T20[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  011ec	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  011f1	c6 45 fc 48	 mov	 BYTE PTR __$EHRec$[ebp+8], 72 ; 00000048H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  011f5	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+24]
  011fb	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  011fd	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+40], 0

; 1785 : 		_Myres(0)

  01207	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+44], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01211	68 00 00 00 00	 push	 OFFSET ??_C@_07BGDMAJAE@Network@

; 3976 : 		_My_data._Mysize = 0;

  01216	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+40], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01220	c7 85 24 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T20[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0122a	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01231	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  01236	c6 45 fc 49	 mov	 BYTE PTR __$EHRec$[ebp+8], 73 ; 00000049H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0123a	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+48]
  01240	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  01242	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+64], 0

; 1785 : 		_Myres(0)

  0124c	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+68], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01256	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KDFOEONK@Network?5Information@

; 3976 : 		_My_data._Mysize = 0;

  0125b	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+64], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01265	c7 85 3c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T20[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0126f	c6 85 28 ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01276	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  0127b	c6 45 fc 4a	 mov	 BYTE PTR __$EHRec$[ebp+8], 74 ; 0000004aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0127f	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+72]
  01285	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  01287	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+88], 0

; 1785 : 		_Myres(0)

  01291	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+92], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0129b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@

; 3976 : 		_My_data._Mysize = 0;

  012a0	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+88], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  012aa	c7 85 54 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T20[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  012b4	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  012bb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  012c0	c6 45 fc 4b	 mov	 BYTE PTR __$EHRec$[ebp+8], 75 ; 0000004bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  012c4	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+96]
  012ca	6a 21		 push	 33			; 00000021H

; 1784 : 		_Mysize(0),

  012cc	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+112], 0

; 1785 : 		_Myres(0)

  012d6	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+116], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  012e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@

; 3976 : 		_My_data._Mysize = 0;

  012e5	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T20[ebp+112], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  012ef	c7 85 6c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T20[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  012f9	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01300	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  01305	c6 45 fc 4c	 mov	 BYTE PTR __$EHRec$[ebp+8], 76 ; 0000004cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01309	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+120]
  0130f	6a 19		 push	 25			; 00000019H

; 1784 : 		_Mysize(0),

  01311	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+136], 0

; 1785 : 		_Myres(0)

  01318	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+140], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0131f	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@

; 3976 : 		_My_data._Mysize = 0;

  01324	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+136], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0132b	c7 45 84 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+140], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01332	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR $T20[ebp+120], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01339	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  0133e	c6 45 fc 4d	 mov	 BYTE PTR __$EHRec$[ebp+8], 77 ; 0000004dH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01342	8d 4d 88	 lea	 ecx, DWORD PTR $T20[ebp+144]
  01345	6a 15		 push	 21			; 00000015H

; 1784 : 		_Mysize(0),

  01347	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+160], 0

; 1785 : 		_Myres(0)

  0134e	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+164], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01355	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@

; 3976 : 		_My_data._Mysize = 0;

  0135a	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+160], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01361	c7 45 9c 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+164], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01368	c6 45 88 00	 mov	 BYTE PTR $T20[ebp+144], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0136c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  01371	c6 45 fc 4e	 mov	 BYTE PTR __$EHRec$[ebp+8], 78 ; 0000004eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01375	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T11[ebp]

; 389  : 		: _Myfirst(),

  0137b	c7 85 d8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _net$[ebp], 0

; 390  : 		_Mylast(),

  01385	c7 85 dc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _net$[ebp+4], 0

; 391  : 		_Myend()

  0138f	c7 85 e0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _net$[ebp+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01399	8d 45 a0	 lea	 eax, DWORD PTR $T20[ebp+168]
  0139c	50		 push	 eax
  0139d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  013a3	50		 push	 eax
  013a4	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _net$[ebp]
  013aa	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 906  :     std::vector<std::string> net{ "net",

  013af	c6 45 fc 50	 mov	 BYTE PTR __$EHRec$[ebp+8], 80 ; 00000050H
  013b3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  013b9	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  013be	6a 07		 push	 7
  013c0	6a 18		 push	 24			; 00000018H
  013c2	50		 push	 eax
  013c3	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  013c8	8b 8d d8 fa ff
	ff		 mov	 ecx, DWORD PTR _net$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 912  :     if (StartThread(net[1], ThreadWMIClass, (LPVOID)&net, 0, &ahThreads[threads]))

  013ce	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  013d1	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  013d4	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  013d9	50		 push	 eax
  013da	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _net$[ebp]
  013e0	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  013e2	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 912  :     if (StartThread(net[1], ThreadWMIClass, (LPVOID)&net, 0, &ahThreads[threads]))

  013e5	50		 push	 eax
  013e6	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  013eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  013ee	84 c0		 test	 al, al
  013f0	74 01		 je	 SHORT $LN9@ThreadWMI

; 913  :     {
; 914  :         ++threads;

  013f2	47		 inc	 edi
$LN9@ThreadWMI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  013f3	6a 03		 push	 3

; 1784 : 		_Mysize(0),

  013f5	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  013ff	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]

; 1785 : 		_Myres(0)

  01405	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0140f	68 00 00 00 00	 push	 OFFSET ??_C@_03FNIGJHAM@dev@

; 3976 : 		_My_data._Mysize = 0;

  01414	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0141e	c7 85 3c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T22[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01428	c6 85 28 ff ff
	ff 00		 mov	 BYTE PTR $T22[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0142f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 932  :     std::vector<std::string> dev{ "dev",

  01434	c6 45 fc 51	 mov	 BYTE PTR __$EHRec$[ebp+8], 81 ; 00000051H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01438	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp+24]
  0143e	6a 09		 push	 9

; 1784 : 		_Mysize(0),

  01440	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+40], 0

; 1785 : 		_Myres(0)

  0144a	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+44], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01454	68 00 00 00 00	 push	 OFFSET ??_C@_09HCBPJCHD@Developer@

; 3976 : 		_My_data._Mysize = 0;

  01459	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+40], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01463	c7 85 54 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T22[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0146d	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR $T22[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01474	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 932  :     std::vector<std::string> dev{ "dev",

  01479	c6 45 fc 52	 mov	 BYTE PTR __$EHRec$[ebp+8], 82 ; 00000052H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0147d	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp+48]
  01483	6a 15		 push	 21			; 00000015H

; 1784 : 		_Mysize(0),

  01485	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+64], 0

; 1785 : 		_Myres(0)

  0148f	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+68], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01499	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KMFPDIMK@Developer?5Information@

; 3976 : 		_My_data._Mysize = 0;

  0149e	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp+64], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  014a8	c7 85 6c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T22[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  014b2	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T22[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014b9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 932  :     std::vector<std::string> dev{ "dev",

  014be	c6 45 fc 53	 mov	 BYTE PTR __$EHRec$[ebp+8], 83 ; 00000053H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014c2	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp+72]
  014c8	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  014ca	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T22[ebp+88], 0

; 1785 : 		_Myres(0)

  014d1	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T22[ebp+92], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MBMLPGOB@Win32_CodecFile@

; 3976 : 		_My_data._Mysize = 0;

  014dd	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T22[ebp+88], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  014e4	c7 45 84 0f 00
	00 00		 mov	 DWORD PTR $T22[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  014eb	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR $T22[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014f2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 932  :     std::vector<std::string> dev{ "dev",

  014f7	c6 45 fc 54	 mov	 BYTE PTR __$EHRec$[ebp+8], 84 ; 00000054H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014fb	8d 4d 88	 lea	 ecx, DWORD PTR $T22[ebp+96]
  014fe	6a 15		 push	 21			; 00000015H

; 1784 : 		_Mysize(0),

  01500	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T22[ebp+112], 0

; 1785 : 		_Myres(0)

  01507	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T22[ebp+116], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0150e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@

; 3976 : 		_My_data._Mysize = 0;

  01513	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T22[ebp+112], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0151a	c7 45 9c 0f 00
	00 00		 mov	 DWORD PTR $T22[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01521	c6 45 88 00	 mov	 BYTE PTR $T22[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01525	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 932  :     std::vector<std::string> dev{ "dev",

  0152a	c6 45 fc 55	 mov	 BYTE PTR __$EHRec$[ebp+8], 85 ; 00000055H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0152e	8d 45 a0	 lea	 eax, DWORD PTR $T22[ebp+120]
  01531	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T10[ebp]
  01537	8d 8d e4 fa ff
	ff		 lea	 ecx, DWORD PTR _dev$[ebp]

; 389  : 		: _Myfirst(),

  0153d	c7 85 e4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _dev$[ebp], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01547	50		 push	 eax
  01548	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]

; 390  : 		_Mylast(),

  0154e	c7 85 e8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _dev$[ebp+4], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01558	50		 push	 eax

; 391  : 		_Myend()

  01559	c7 85 ec fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _dev$[ebp+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01563	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 932  :     std::vector<std::string> dev{ "dev",

  01568	c6 45 fc 57	 mov	 BYTE PTR __$EHRec$[ebp+8], 87 ; 00000057H
  0156c	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  01572	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01577	6a 05		 push	 5
  01579	6a 18		 push	 24			; 00000018H
  0157b	50		 push	 eax
  0157c	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  01581	8b 8d e4 fa ff
	ff		 mov	 ecx, DWORD PTR _dev$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 945  :     if (StartThread(dev[1], ThreadWMIClass, (LPVOID)&dev, 0, &ahThreads[threads]))

  01587	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  0158a	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  0158d	50		 push	 eax
  0158e	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  01590	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 945  :     if (StartThread(dev[1], ThreadWMIClass, (LPVOID)&dev, 0, &ahThreads[threads]))

  01593	8d 85 e4 fa ff
	ff		 lea	 eax, DWORD PTR _dev$[ebp]
  01599	50		 push	 eax
  0159a	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  0159f	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  015a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  015a7	84 c0		 test	 al, al
  015a9	74 01		 je	 SHORT $LN10@ThreadWMI

; 946  :     {
; 947  :         ++threads;

  015ab	47		 inc	 edi
$LN10@ThreadWMI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  015ac	6a 04		 push	 4

; 1784 : 		_Mysize(0),

  015ae	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  015b8	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]

; 1785 : 		_Myres(0)

  015be	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  015c8	68 00 00 00 00	 push	 OFFSET ??_C@_04GCPMIEJC@util@

; 3976 : 		_My_data._Mysize = 0;

  015cd	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  015d7	c7 85 34 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  015e1	c6 85 20 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  015e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  015ed	c6 45 fc 58	 mov	 BYTE PTR __$EHRec$[ebp+8], 88 ; 00000058H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  015f1	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+24]
  015f7	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  015f9	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+40], 0

; 1785 : 		_Myres(0)

  01603	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+44], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0160d	68 00 00 00 00	 push	 OFFSET ??_C@_07HCOFHGI@Utility@

; 3976 : 		_My_data._Mysize = 0;

  01612	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+40], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0161c	c7 85 4c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+44], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01626	c6 85 38 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0162d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01632	c6 45 fc 59	 mov	 BYTE PTR __$EHRec$[ebp+8], 89 ; 00000059H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01636	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+48]
  0163c	6a 13		 push	 19			; 00000013H

; 1784 : 		_Mysize(0),

  0163e	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+64], 0

; 1785 : 		_Myres(0)

  01648	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+68], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01652	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DMCOJOJG@Utility?5Information@

; 3976 : 		_My_data._Mysize = 0;

  01657	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+64], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01661	c7 85 64 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+68], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0166b	c6 85 50 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+48], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01672	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01677	c6 45 fc 5a	 mov	 BYTE PTR __$EHRec$[ebp+8], 90 ; 0000005aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0167b	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+72]
  01681	6a 11		 push	 17			; 00000011H

; 1784 : 		_Mysize(0),

  01683	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+88], 0

; 1785 : 		_Myres(0)

  0168d	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+92], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01697	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DPAOPBJD@Win32_BaseService@

; 3976 : 		_My_data._Mysize = 0;

  0169c	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+88], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  016a6	c7 85 7c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+92], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  016b0	c6 85 68 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+72], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  016b7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  016bc	c6 45 fc 5b	 mov	 BYTE PTR __$EHRec$[ebp+8], 91 ; 0000005bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  016c0	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+96]
  016c6	6a 17		 push	 23			; 00000017H

; 1784 : 		_Mysize(0),

  016c8	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+112], 0

; 1785 : 		_Myres(0)

  016d2	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+116], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  016dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@

; 3976 : 		_My_data._Mysize = 0;

  016e1	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+112], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  016eb	c7 85 94 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+116], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  016f5	c6 85 80 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+96], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  016fc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01701	c6 45 fc 5c	 mov	 BYTE PTR __$EHRec$[ebp+8], 92 ; 0000005cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01705	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+120]
  0170b	6a 0d		 push	 13			; 0000000dH

; 1784 : 		_Mysize(0),

  0170d	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+136], 0

; 1785 : 		_Myres(0)

  01717	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+140], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01721	68 00 00 00 00	 push	 OFFSET ??_C@_0O@MLAGCNDM@Win32_Desktop@

; 3976 : 		_My_data._Mysize = 0;

  01726	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+136], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01730	c7 85 ac fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+140], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0173a	c6 85 98 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+120], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01741	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01746	c6 45 fc 5d	 mov	 BYTE PTR __$EHRec$[ebp+8], 93 ; 0000005dH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0174a	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+144]
  01750	6a 14		 push	 20			; 00000014H

; 1784 : 		_Mysize(0),

  01752	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+160], 0

; 1785 : 		_Myres(0)

  0175c	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+164], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01766	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@

; 3976 : 		_My_data._Mysize = 0;

  0176b	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+160], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01775	c7 85 c4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+164], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0177f	c6 85 b0 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+144], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01786	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  0178b	c6 45 fc 5e	 mov	 BYTE PTR __$EHRec$[ebp+8], 94 ; 0000005eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0178f	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+184], 0

; 1785 : 		_Myres(0)

  01799	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+188], 0

; 3976 : 		_My_data._Mysize = 0;

  017a3	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+184], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  017ad	c7 85 dc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+188], 15 ; 0000000fH

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  017b7	6a 09		 push	 9
  017b9	68 00 00 00 00	 push	 OFFSET ??_C@_09BEHCCOGC@Win32_Fan@
  017be	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+168]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  017c4	c6 85 c8 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+168], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  017cb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  017d0	c6 45 fc 5f	 mov	 BYTE PTR __$EHRec$[ebp+8], 95 ; 0000005fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  017d4	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+192]
  017da	6a 15		 push	 21			; 00000015H

; 1784 : 		_Mysize(0),

  017dc	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+208], 0

; 1785 : 		_Myres(0)

  017e6	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+212], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  017f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@

; 3976 : 		_My_data._Mysize = 0;

  017f5	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+208], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  017ff	c7 85 f4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+212], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01809	c6 85 e0 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+192], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01810	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01815	c6 45 fc 60	 mov	 BYTE PTR __$EHRec$[ebp+8], 96 ; 00000060H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01819	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+216]
  0181f	6a 0e		 push	 14			; 0000000eH

; 1784 : 		_Mysize(0),

  01821	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+232], 0

; 1785 : 		_Myres(0)

  0182b	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+236], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01835	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GFMPEM@Win32_PageFile@

; 3976 : 		_My_data._Mysize = 0;

  0183a	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+232], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01844	c7 85 0c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+236], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0184e	c6 85 f8 fe ff
	ff 00		 mov	 BYTE PTR $T17[ebp+216], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01855	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  0185a	c6 45 fc 61	 mov	 BYTE PTR __$EHRec$[ebp+8], 97 ; 00000061H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0185e	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+240]
  01864	6a 12		 push	 18			; 00000012H

; 1784 : 		_Mysize(0),

  01866	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+256], 0

; 1785 : 		_Myres(0)

  01870	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+260], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0187a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@

; 3976 : 		_My_data._Mysize = 0;

  0187f	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+256], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01889	c7 85 24 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+260], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01893	c6 85 10 ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp+240], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0189a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  0189f	c6 45 fc 62	 mov	 BYTE PTR __$EHRec$[ebp+8], 98 ; 00000062H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  018a3	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+264]
  018a9	6a 0b		 push	 11			; 0000000bH

; 1784 : 		_Mysize(0),

  018ab	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+280], 0

; 1785 : 		_Myres(0)

  018b5	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+284], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  018bf	68 00 00 00 00	 push	 OFFSET ??_C@_0M@GFHBIAHO@Win32_Proxy@

; 3976 : 		_My_data._Mysize = 0;

  018c4	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+280], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  018ce	c7 85 3c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+284], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  018d8	c6 85 28 ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp+264], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  018df	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  018e4	c6 45 fc 63	 mov	 BYTE PTR __$EHRec$[ebp+8], 99 ; 00000063H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  018e8	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+288]
  018ee	6a 0b		 push	 11			; 0000000bH

; 1784 : 		_Mysize(0),

  018f0	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+304], 0

; 1785 : 		_Myres(0)

  018fa	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+308], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01904	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MCIKNCEL@Win32_Share@

; 3976 : 		_My_data._Mysize = 0;

  01909	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+304], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01913	c7 85 54 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+308], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0191d	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp+288], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01924	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01929	c6 45 fc 64	 mov	 BYTE PTR __$EHRec$[ebp+8], 100 ; 00000064H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0192d	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+312]
  01933	6a 1e		 push	 30			; 0000001eH

; 1784 : 		_Mysize(0),

  01935	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+328], 0

; 1785 : 		_Myres(0)

  0193f	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+332], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01949	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@

; 3976 : 		_My_data._Mysize = 0;

  0194e	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T17[ebp+328], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01958	c7 85 6c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T17[ebp+332], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01962	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp+312], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01969	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  0196e	c6 45 fc 65	 mov	 BYTE PTR __$EHRec$[ebp+8], 101 ; 00000065H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01972	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+336]
  01978	6a 10		 push	 16			; 00000010H

; 1784 : 		_Mysize(0),

  0197a	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+352], 0

; 1785 : 		_Myres(0)

  01981	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+356], 0

; 3976 : 		_My_data._Mysize = 0;

  01988	c7 45 80 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+352], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0198f	c7 45 84 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+356], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01996	c6 85 70 ff ff
	ff 00		 mov	 BYTE PTR $T17[ebp+336], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0199d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BBHCGAKO@Win32_WMISetting@
  019a2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  019a7	c6 45 fc 66	 mov	 BYTE PTR __$EHRec$[ebp+8], 102 ; 00000066H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  019ab	8d 4d 88	 lea	 ecx, DWORD PTR $T17[ebp+360]
  019ae	6a 1a		 push	 26			; 0000001aH

; 1784 : 		_Mysize(0),

  019b0	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+376], 0

; 1785 : 		_Myres(0)

  019b7	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+380], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  019be	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@

; 3976 : 		_My_data._Mysize = 0;

  019c3	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+376], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  019ca	c7 45 9c 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+380], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  019d1	c6 45 88 00	 mov	 BYTE PTR $T17[ebp+360], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  019d5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  019da	c6 45 fc 67	 mov	 BYTE PTR __$EHRec$[ebp+8], 103 ; 00000067H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  019de	8d 45 a0	 lea	 eax, DWORD PTR $T17[ebp+384]
  019e1	ff b5 04 fb ff
	ff		 push	 DWORD PTR $T9[ebp]
  019e7	8d 8d f0 fa ff
	ff		 lea	 ecx, DWORD PTR _util$[ebp]

; 389  : 		: _Myfirst(),

  019ed	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _util$[ebp], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  019f7	50		 push	 eax
  019f8	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]

; 390  : 		_Mylast(),

  019fe	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _util$[ebp+4], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01a08	50		 push	 eax

; 391  : 		_Myend()

  01a09	c7 85 f8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _util$[ebp+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  01a13	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 952  :     std::vector<std::string> util{ "util",

  01a18	c6 45 fc 69	 mov	 BYTE PTR __$EHRec$[ebp+8], 105 ; 00000069H
  01a1c	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01a22	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01a27	6a 10		 push	 16			; 00000010H
  01a29	6a 18		 push	 24			; 00000018H
  01a2b	50		 push	 eax
  01a2c	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  01a31	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR _util$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 963  :     if (StartThread(util[1], ThreadWMIClass, (LPVOID)&util, 0, &ahThreads[threads]))

  01a37	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  01a3a	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  01a3d	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIClass@@YGIPAX@Z ; ThreadWMIClass
  01a42	50		 push	 eax
  01a43	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _util$[ebp]
  01a49	6a 00		 push	 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  01a4b	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 963  :     if (StartThread(util[1], ThreadWMIClass, (LPVOID)&util, 0, &ahThreads[threads]))

  01a4e	50		 push	 eax
  01a4f	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  01a54	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a57	84 c0		 test	 al, al
  01a59	74 01		 je	 SHORT $LN11@ThreadWMI

; 964  :     {
; 965  :         ++threads;

  01a5b	47		 inc	 edi
$LN11@ThreadWMI:

; 966  :     }
; 967  :     //UTIL **********
; 968  : 
; 969  :     Log(LOG_DEBUG_WMI, __LINE__, "-- ThrdWMI, Waitg %u thrs", threads);

  01a5c	57		 push	 edi
  01a5d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@COLFJDO@?9?9?5ThrdWMI?0?5Waitg?5?$CFu?5thrs@
  01a62	68 c9 03 00 00	 push	 969			; 000003c9H
  01a67	6a 40		 push	 64			; 00000040H
  01a69	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01a6e	83 c4 10	 add	 esp, 16			; 00000010H

; 970  :     WaitForMultipleObjects(threads, ahThreads, TRUE, INFINITE);

  01a71	8d 45 a0	 lea	 eax, DWORD PTR _ahThreads$[ebp]
  01a74	6a ff		 push	 -1
  01a76	6a 01		 push	 1
  01a78	50		 push	 eax
  01a79	57		 push	 edi
  01a7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForMultipleObjects@16
  01a80	33 f6		 xor	 esi, esi

; 971  :     for (DWORD x = 0; x < threads; x++)

  01a82	85 ff		 test	 edi, edi
  01a84	74 0f		 je	 SHORT $LN3@ThreadWMI
$LL4@ThreadWMI:

; 972  :     {
; 973  :         CloseHandle(ahThreads[x]);

  01a86	ff 74 b5 a0	 push	 DWORD PTR _ahThreads$[ebp+esi*4]
  01a8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  01a90	46		 inc	 esi
  01a91	3b f7		 cmp	 esi, edi
  01a93	72 f1		 jb	 SHORT $LL4@ThreadWMI
$LN3@ThreadWMI:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 639  :     tickEnd = SysTick();

  01a95	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 640  :     timeElapsed = (static_cast<double>(tickEnd - tickStart) / static_cast<double>(SECOND));

  01a9a	2b 85 fc fa ff
	ff		 sub	 eax, DWORD PTR _tickStart$2$[ebp]
  01aa0	8b c8		 mov	 ecx, eax
  01aa2	1b 95 00 fb ff
	ff		 sbb	 edx, DWORD PTR _tickStart$1$[ebp]
  01aa8	e8 00 00 00 00	 call	 __ultod3
  01aad	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  01ab5	f2 0f 11 85 9c
	fa ff ff	 movsd	 QWORD PTR _timeElapsed$1$[ebp], xmm0

; 641  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  01abd	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  01ac5	e8 00 00 00 00	 call	 __dtoul3
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 981  :     Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMI, Out, %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  01aca	6a 00		 push	 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 641  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  01acc	8b f2		 mov	 esi, edx
  01ace	8b f8		 mov	 edi, eax
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 981  :     Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMI, Out, %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  01ad0	68 10 0e 00 00	 push	 3600			; 00000e10H
  01ad5	56		 push	 esi
  01ad6	57		 push	 edi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 641  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  01ad7	89 bd 00 fb ff
	ff		 mov	 DWORD PTR _seconds$1$[ebp], edi
  01add	89 b5 fc fa ff
	ff		 mov	 DWORD PTR _seconds$2$[ebp], esi
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 981  :     Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMI, Out, %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  01ae3	e8 00 00 00 00	 call	 __aulldiv
  01ae8	f2 0f 10 85 9c
	fa ff ff	 movsd	 xmm0, QWORD PTR _timeElapsed$1$[ebp]
  01af0	83 ec 08	 sub	 esp, 8
  01af3	89 85 04 fb ff
	ff		 mov	 DWORD PTR tv7028[ebp], eax
  01af9	89 95 a4 fa ff
	ff		 mov	 DWORD PTR tv7027[ebp], edx
  01aff	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  01b04	6a 00		 push	 0
  01b06	6a 3c		 push	 60			; 0000003cH
  01b08	56		 push	 esi
  01b09	57		 push	 edi
  01b0a	e8 00 00 00 00	 call	 __aulldiv
  01b0f	8b 8d 00 fb ff
	ff		 mov	 ecx, DWORD PTR _seconds$1$[ebp]
  01b15	8b f0		 mov	 esi, eax
  01b17	8b fa		 mov	 edi, edx
  01b19	0f a4 f7 04	 shld	 edi, esi, 4
  01b1d	c1 e6 04	 shl	 esi, 4
  01b20	2b f0		 sub	 esi, eax
  01b22	8b 85 fc fa ff
	ff		 mov	 eax, DWORD PTR _seconds$2$[ebp]
  01b28	1b fa		 sbb	 edi, edx
  01b2a	0f a4 f7 02	 shld	 edi, esi, 2
  01b2e	c1 e6 02	 shl	 esi, 2
  01b31	2b ce		 sub	 ecx, esi
  01b33	8b b5 a4 fa ff
	ff		 mov	 esi, DWORD PTR tv7027[ebp]
  01b39	1b c7		 sbb	 eax, edi
  01b3b	8b bd 04 fb ff
	ff		 mov	 edi, DWORD PTR tv7028[ebp]
  01b41	50		 push	 eax
  01b42	51		 push	 ecx
  01b43	b9 10 0e 00 00	 mov	 ecx, 3600		; 00000e10H
  01b48	8b c6		 mov	 eax, esi
  01b4a	f7 e1		 mul	 ecx
  01b4c	ba 10 0e 00 00	 mov	 edx, 3600		; 00000e10H
  01b51	8b c8		 mov	 ecx, eax
  01b53	8b c7		 mov	 eax, edi
  01b55	f7 e2		 mul	 edx
  01b57	6a 00		 push	 0
  01b59	03 ca		 add	 ecx, edx
  01b5b	8b 95 00 fb ff
	ff		 mov	 edx, DWORD PTR _seconds$1$[ebp]
  01b61	2b d0		 sub	 edx, eax
  01b63	8b 85 fc fa ff
	ff		 mov	 eax, DWORD PTR _seconds$2$[ebp]
  01b69	6a 3c		 push	 60			; 0000003cH
  01b6b	1b c1		 sbb	 eax, ecx
  01b6d	50		 push	 eax
  01b6e	52		 push	 edx
  01b6f	e8 00 00 00 00	 call	 __aulldiv
  01b74	52		 push	 edx
  01b75	50		 push	 eax
  01b76	56		 push	 esi
  01b77	57		 push	 edi
  01b78	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MMEAEDPF@?$DM?$DM?5ThrdWMI?0?5Out?0?5?$CF02llu?3?$CF02llu?3@
  01b7d	68 d5 03 00 00	 push	 981			; 000003d5H
  01b82	6a 40		 push	 64			; 00000040H
  01b84	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 982  :     _endthreadex(0);

  01b89	6a 00		 push	 0
  01b8b	e8 00 00 00 00	 call	 __endthreadex
  01b90	83 c4 30	 add	 esp, 48			; 00000030H

; 983  :     return 0;

  01b93	c6 45 fc 57	 mov	 BYTE PTR __$EHRec$[ebp+8], 87 ; 00000057H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01b97	8d 8d f0 fa ff
	ff		 lea	 ecx, DWORD PTR _util$[ebp]
  01b9d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01ba2	c6 45 fc 50	 mov	 BYTE PTR __$EHRec$[ebp+8], 80 ; 00000050H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01ba6	8d 8d e4 fa ff
	ff		 lea	 ecx, DWORD PTR _dev$[ebp]
  01bac	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01bb1	c6 45 fc 47	 mov	 BYTE PTR __$EHRec$[ebp+8], 71 ; 00000047H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01bb5	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _net$[ebp]
  01bbb	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01bc0	c6 45 fc 38	 mov	 BYTE PTR __$EHRec$[ebp+8], 56 ; 00000038H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01bc4	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR _sysInfo$[ebp]
  01bca	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01bcf	c6 45 fc 2b	 mov	 BYTE PTR __$EHRec$[ebp+8], 43 ; 0000002bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01bd3	8d 8d c0 fa ff
	ff		 lea	 ecx, DWORD PTR _memory$[ebp]
  01bd9	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01bde	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01be2	8d 8d b4 fa ff
	ff		 lea	 ecx, DWORD PTR _data$[ebp]
  01be8	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01bed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  01bf4	8d 8d a8 fa ff
	ff		 lea	 ecx, DWORD PTR _hwInfo$[ebp]
  01bfa	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 983  :     return 0;

  01bff	33 c0		 xor	 eax, eax

; 984  : }

  01c01	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01c04	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01c0b	59		 pop	 ecx
  01c0c	5f		 pop	 edi
  01c0d	5e		 pop	 esi
  01c0e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01c11	33 cd		 xor	 ecx, ebp
  01c13	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01c18	8b e5		 mov	 esp, ebp
  01c1a	5d		 pop	 ebp
  01c1b	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$0:
  00000	8d 8d 08 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$1:
  0000b	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+24]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$2:
  00016	8d 8d 38 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+48]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$3:
  00021	8d 8d 50 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+72]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$4:
  0002c	8d 8d 68 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+96]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$5:
  00037	8d 8d 80 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+120]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$6:
  00042	8d 8d 98 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+144]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$7:
  0004d	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+168]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$8:
  00058	8d 8d c8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+192]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$9:
  00063	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+216]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$10:
  0006e	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+240]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$11:
  00079	8d 8d 10 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+264]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$12:
  00084	8d 8d 28 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+288]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$13:
  0008f	8d 8d 40 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+312]
  00095	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$14:
  0009a	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+336]
  000a0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$15:
  000a5	8d 8d 70 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+360]
  000ab	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$16:
  000b0	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+384]
  000b6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$17:
  000bb	8d 8d a0 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+408]
  000c1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$18:
  000c6	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+432]
  000cc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$19:
  000d1	8d 8d d0 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+456]
  000d7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$20:
  000dc	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+480]
  000e2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$21:
  000e7	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+504]
  000ed	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$22:
  000f2	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+528]
  000f8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$23:
  000fd	8d 8d 30 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+552]
  00103	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$24:
  00108	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+576]
  0010e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$25:
  00113	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+600]
  00119	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$26:
  0011e	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+624]
  00124	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$27:
  00129	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+648]
  0012f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$28:
  00134	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+672]
  0013a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$29:
  0013f	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+696]
  00145	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$30:
  0014a	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+720]
  00150	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$31:
  00155	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp+744]
  0015b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$33:
  00160	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00165	6a 21		 push	 33			; 00000021H
  00167	6a 18		 push	 24			; 00000018H
  00169	8d 85 08 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00175	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$34:
  00176	8d 8d a8 fa ff
	ff		 lea	 ecx, DWORD PTR _hwInfo$[ebp]
  0017c	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$35:
  00181	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00187	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$36:
  0018c	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+24]
  00192	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$37:
  00197	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+48]
  0019d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$38:
  001a2	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+72]
  001a8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$39:
  001ad	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+96]
  001b3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$40:
  001b8	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp+120]
  001be	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$42:
  001c3	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001c8	6a 07		 push	 7
  001ca	6a 18		 push	 24			; 00000018H
  001cc	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  001d8	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$43:
  001d9	8d 8d b4 fa ff
	ff		 lea	 ecx, DWORD PTR _data$[ebp]
  001df	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$44:
  001e4	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  001ea	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$45:
  001ef	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+24]
  001f5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$46:
  001fa	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+48]
  00200	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$47:
  00205	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+72]
  0020b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$48:
  00210	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+96]
  00216	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$49:
  0021b	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+120]
  00221	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$50:
  00226	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+144]
  0022c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$51:
  00231	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+168]
  00237	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$52:
  0023c	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+192]
  00242	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$53:
  00247	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp+216]
  0024d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$55:
  00252	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00257	6a 0b		 push	 11			; 0000000bH
  00259	6a 18		 push	 24			; 00000018H
  0025b	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00261	50		 push	 eax
  00262	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00267	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$56:
  00268	8d 8d c0 fa ff
	ff		 lea	 ecx, DWORD PTR _memory$[ebp]
  0026e	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$57:
  00273	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00279	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$58:
  0027e	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+24]
  00284	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$59:
  00289	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+48]
  0028f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$60:
  00294	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+72]
  0029a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$61:
  0029f	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+96]
  002a5	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$62:
  002aa	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+120]
  002b0	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$63:
  002b5	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+144]
  002bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$64:
  002c0	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+168]
  002c6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$65:
  002cb	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+192]
  002d1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$66:
  002d6	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+216]
  002dc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$67:
  002e1	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+240]
  002e7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$68:
  002ec	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp+264]
  002f2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$70:
  002f7	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002fc	6a 0d		 push	 13			; 0000000dH
  002fe	6a 18		 push	 24			; 00000018H
  00300	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00306	50		 push	 eax
  00307	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0030c	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$71:
  0030d	8d 8d cc fa ff
	ff		 lea	 ecx, DWORD PTR _sysInfo$[ebp]
  00313	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$72:
  00318	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  0031e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$73:
  00323	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+24]
  00329	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$74:
  0032e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+48]
  00334	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$75:
  00339	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+72]
  0033f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$76:
  00344	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+96]
  0034a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$77:
  0034f	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp+120]
  00355	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$79:
  0035a	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0035f	6a 07		 push	 7
  00361	6a 18		 push	 24			; 00000018H
  00363	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0036f	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$80:
  00370	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _net$[ebp]
  00376	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$81:
  0037b	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00381	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$82:
  00386	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp+24]
  0038c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$83:
  00391	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp+48]
  00397	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$84:
  0039c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp+72]
  003a2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$86:
  003a7	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  003ac	6a 05		 push	 5
  003ae	6a 18		 push	 24			; 00000018H
  003b0	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  003b6	50		 push	 eax
  003b7	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  003bc	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$87:
  003bd	8d 8d e4 fa ff
	ff		 lea	 ecx, DWORD PTR _dev$[ebp]
  003c3	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$88:
  003c8	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  003ce	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$89:
  003d3	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+24]
  003d9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$90:
  003de	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+48]
  003e4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$91:
  003e9	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+72]
  003ef	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$92:
  003f4	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+96]
  003fa	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$93:
  003ff	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+120]
  00405	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$94:
  0040a	8d 8d b0 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+144]
  00410	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$95:
  00415	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+168]
  0041b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$96:
  00420	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+192]
  00426	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$97:
  0042b	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+216]
  00431	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$98:
  00436	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+240]
  0043c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$99:
  00441	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+264]
  00447	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$100:
  0044c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+288]
  00452	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$101:
  00457	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+312]
  0045d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$102:
  00462	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp+336]
  00468	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$104:
  0046d	68 00 00 00 00	 push	 OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00472	6a 10		 push	 16			; 00000010H
  00474	6a 18		 push	 24			; 00000018H
  00476	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0047c	50		 push	 eax
  0047d	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00482	c3		 ret	 0
__unwindfunclet$?ThreadWMI@@YGIPAX@Z$105:
  00483	8d 8d f0 fa ff
	ff		 lea	 ecx, DWORD PTR _util$[ebp]
  00489	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?ThreadWMI@@YGIPAX@Z:
  0048e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00492	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00495	8b 8a 9c fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1380]
  0049b	33 c8		 xor	 ecx, eax
  0049d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a2	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  004a5	33 c8		 xor	 ecx, eax
  004a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ac	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThreadWMI@@YGIPAX@Z
  004b1	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThreadWMI@@YGIPAX@Z ENDP				; ThreadWMI
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN4@HRESULT_FR
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN4@HRESULT_FR:
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??0_bstr_t@@QAE@PBD@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_bstr_t@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 915  :     return ::operator new(sz);

  00027	6a 0c		 push	 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 311  :     : m_Data(new Data_t(s))

  0002e	8b f0		 mov	 esi, eax

; 915  :     return ::operator new(sz);

  00030	83 c4 04	 add	 esp, 4

; 311  :     : m_Data(new Data_t(s))

  00033	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 f6		 test	 esi, esi
  0003f	74 1a		 je	 SHORT $LN4@bstr_t

; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);

  00041	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00044	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004b	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00052	e8 00 00 00 00	 call	 ?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
  00057	89 06		 mov	 DWORD PTR [esi], eax

; 311  :     : m_Data(new Data_t(s))

  00059	eb 02		 jmp	 SHORT $LN5@bstr_t
$LN4@bstr_t:
  0005b	33 f6		 xor	 esi, esi
$LN5@bstr_t:
  0005d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	89 37		 mov	 DWORD PTR [edi], esi

; 313  :     if (m_Data == NULL) {

  00066	85 f6		 test	 esi, esi
  00068	74 15		 je	 SHORT $LN14@bstr_t

; 315  :     }
; 316  : }

  0006a	8b c7		 mov	 eax, edi
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
$LN14@bstr_t:

; 314  :         _com_issue_error(E_OUTOFMEMORY);

  0007f	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00084	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN12@bstr_t:
  00089	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_bstr_t@@QAE@PBD@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$??0_bstr_t@@QAE@PBD@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_bstr_t@@QAE@PBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_bstr_t@@QAE@PBD@Z ENDP				; _bstr_t::_bstr_t
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??0_bstr_t@@QAE@PB_W@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$dead$ = 8						; size = 4
??0_bstr_t@@QAE@PB_W@Z PROC				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_bstr_t@@QAE@PB_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 915  :     return ::operator new(sz);

  00027	6a 0c		 push	 12			; 0000000cH
  00029	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 321  :     : m_Data(new Data_t(s))

  0002e	8b f0		 mov	 esi, eax

; 915  :     return ::operator new(sz);

  00030	83 c4 04	 add	 esp, 4

; 321  :     : m_Data(new Data_t(s))

  00033	89 75 f0	 mov	 DWORD PTR $T2[ebp], esi
  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	85 f6		 test	 esi, esi
  0003f	74 21		 je	 SHORT $LN4@bstr_t

; 691  :     m_wstr = ::SysAllocString(s);

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@
  00046	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004d	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  0005a	89 06		 mov	 DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

  0005c	85 c0		 test	 eax, eax
  0005e	74 26		 je	 SHORT $LN16@bstr_t
  00060	eb 02		 jmp	 SHORT $LN5@bstr_t
$LN4@bstr_t:

; 321  :     : m_Data(new Data_t(s))

  00062	33 f6		 xor	 esi, esi
$LN5@bstr_t:
  00064	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006b	89 37		 mov	 DWORD PTR [edi], esi

; 323  :     if (m_Data == NULL) {

  0006d	85 f6		 test	 esi, esi
  0006f	74 1f		 je	 SHORT $LN17@bstr_t

; 325  :     }
; 326  : }

  00071	8b c7		 mov	 eax, edi
  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
$LN16@bstr_t:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

  00086	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0008b	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN17@bstr_t:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

  00090	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00095	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN14@bstr_t:
  0009a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_bstr_t@@QAE@PB_W@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$??0_bstr_t@@QAE@PB_W@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_bstr_t@@QAE@PB_W@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_bstr_t@@QAE@PB_W@Z ENDP				; _bstr_t::_bstr_t
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_bstr_t@@QAE@XZ PROC					; _bstr_t::~_bstr_t, COMDAT
; _this$ = ecx

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_bstr_t@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 637  :     if (m_Data != NULL) {

  00027	8b 37		 mov	 esi, DWORD PTR [edi]
  00029	85 f6		 test	 esi, esi
  0002b	74 4a		 je	 SHORT $LN4@bstr_t

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  0002d	83 c8 ff	 or	 eax, -1
  00030	f0 0f c1 46 08	 lock	  xadd	 DWORD PTR [esi+8], eax
  00035	48		 dec	 eax

; 774  :     if (cRef == 0) {

  00036	75 39		 jne	 SHORT $LN12@bstr_t

; 775  :         delete this;

  00038	85 f6		 test	 esi, esi
  0003a	74 35		 je	 SHORT $LN12@bstr_t

; 930  :     if (m_wstr != NULL) {

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	85 c0		 test	 eax, eax
  00040	74 0d		 je	 SHORT $LN17@bstr_t

; 931  :         ::SysFreeString(m_wstr);

  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

  00049	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN17@bstr_t:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  0004f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00052	85 c0		 test	 eax, eax
  00054	74 10		 je	 SHORT $LN18@bstr_t

; 936  :         delete [] m_str;

  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0005c	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  0005f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN18@bstr_t:
  00066	6a 0c		 push	 12			; 0000000cH
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006e	83 c4 08	 add	 esp, 8
$LN12@bstr_t:

; 639  :         m_Data = NULL;

  00071	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN4@bstr_t:

; 343  :     _Free();
; 344  : }

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_bstr_t@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_bstr_t@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_bstr_t@@QAE@XZ ENDP					; _bstr_t::~_bstr_t
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??B_bstr_t@@QBEPA_WXZ
_TEXT	SEGMENT
??B_bstr_t@@QBEPA_WXZ PROC				; _bstr_t::operator wchar_t *, COMDAT
; _this$ = ecx

; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 03		 je	 SHORT $LN3@operator
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 480  : }

  00008	c3		 ret	 0
$LN3@operator:

; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

  00009	33 c0		 xor	 eax, eax

; 480  : }

  0000b	c3		 ret	 0
??B_bstr_t@@QBEPA_WXZ ENDP				; _bstr_t::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Free@_bstr_t@@AAEXXZ PROC				; _bstr_t::_Free, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Free@_bstr_t@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 637  :     if (m_Data != NULL) {

  00027	8b 37		 mov	 esi, DWORD PTR [edi]
  00029	85 f6		 test	 esi, esi
  0002b	74 4a		 je	 SHORT $LN2@Free

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  0002d	83 c8 ff	 or	 eax, -1
  00030	f0 0f c1 46 08	 lock	  xadd	 DWORD PTR [esi+8], eax
  00035	48		 dec	 eax

; 774  :     if (cRef == 0) {

  00036	75 39		 jne	 SHORT $LN10@Free

; 775  :         delete this;

  00038	85 f6		 test	 esi, esi
  0003a	74 35		 je	 SHORT $LN10@Free

; 930  :     if (m_wstr != NULL) {

  0003c	8b 06		 mov	 eax, DWORD PTR [esi]
  0003e	85 c0		 test	 eax, eax
  00040	74 0d		 je	 SHORT $LN15@Free

; 931  :         ::SysFreeString(m_wstr);

  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

  00049	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN15@Free:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  0004f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00052	85 c0		 test	 eax, eax
  00054	74 10		 je	 SHORT $LN16@Free

; 936  :         delete [] m_str;

  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0005c	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  0005f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN16@Free:
  00066	6a 0c		 push	 12			; 0000000cH
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006e	83 c4 08	 add	 esp, 8
$LN10@Free:

; 638  :         m_Data->Release();
; 639  :         m_Data = NULL;

  00071	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN2@Free:

; 640  :     }
; 641  : }

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Free@_bstr_t@@AAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Free@_bstr_t@@AAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Free@_bstr_t@@AAEXXZ ENDP				; _bstr_t::_Free
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0Data_t@_bstr_t@@QAE@PBD@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 682  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 683  :     m_wstr = _com_util::ConvertStringToBSTR(s);

  00004	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00010	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00017	e8 00 00 00 00	 call	 ?ConvertStringToBSTR@_com_util@@YGPA_WPBD@Z ; _com_util::ConvertStringToBSTR
  0001c	89 06		 mov	 DWORD PTR [esi], eax

; 684  : }

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0Data_t@_bstr_t@@QAE@PBD@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??0Data_t@_bstr_t@@QAE@PB_W@Z
_TEXT	SEGMENT
_s$dead$ = 8						; size = 4
??0Data_t@_bstr_t@@QAE@PB_W@Z PROC			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 690  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 691  :     m_wstr = ::SysAllocString(s);

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@
  00008	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000f	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  0001c	89 06		 mov	 DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

  0001e	85 c0		 test	 eax, eax
  00020	74 06		 je	 SHORT $LN6@Data_t

; 695  :     }
; 696  : }

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	c2 04 00	 ret	 4
$LN6@Data_t:

; 694  :         _com_issue_error(E_OUTOFMEMORY);

  00028	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0002d	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN4@Data_t:
  00032	cc		 int	 3
??0Data_t@_bstr_t@@QAE@PB_W@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Release@Data_t@_bstr_t@@QAEKXZ PROC			; _bstr_t::Data_t::Release, COMDAT
; _this$ = ecx

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Release@Data_t@_bstr_t@@QAEKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  00026	83 cf ff	 or	 edi, -1
  00029	f0 0f c1 7e 08	 lock	  xadd	 DWORD PTR [esi+8], edi
  0002e	4f		 dec	 edi

; 774  :     if (cRef == 0) {

  0002f	75 39		 jne	 SHORT $LN16@Release

; 775  :         delete this;

  00031	85 f6		 test	 esi, esi
  00033	74 35		 je	 SHORT $LN16@Release

; 930  :     if (m_wstr != NULL) {

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	85 c0		 test	 eax, eax
  00039	74 0d		 je	 SHORT $LN12@Release

; 931  :         ::SysFreeString(m_wstr);

  0003b	50		 push	 eax
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN12@Release:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  00048	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004b	85 c0		 test	 eax, eax
  0004d	74 10		 je	 SHORT $LN13@Release

; 936  :         delete [] m_str;

  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00055	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  00058	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN13@Release:
  0005f	6a 0c		 push	 12			; 0000000cH
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00067	83 c4 08	 add	 esp, 8
$LN16@Release:

; 776  :     }
; 777  : 
; 778  :     return cRef;
; 779  : }

  0006a	8b c7		 mov	 eax, edi
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Release@Data_t@_bstr_t@@QAEKXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Release@Data_t@_bstr_t@@QAEKXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Release@Data_t@_bstr_t@@QAEKXZ ENDP			; _bstr_t::Data_t::Release
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$dead$ = 8					; size = 4
??_GData_t@_bstr_t@@AAEPAXI@Z PROC			; _bstr_t::Data_t::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_GData_t@_bstr_t@@AAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 930  :     if (m_wstr != NULL) {

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN7@scalar

; 931  :         ::SysFreeString(m_wstr);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN7@scalar:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003b	85 c0		 test	 eax, eax
  0003d	74 10		 je	 SHORT $LN8@scalar

; 936  :         delete [] m_str;

  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00045	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  00048	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN8@scalar:
  0004f	6a 0c		 push	 12			; 0000000cH
  00051	56		 push	 esi
  00052	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00057	83 c4 08	 add	 esp, 8
  0005a	8b c6		 mov	 eax, esi
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	5e		 pop	 esi
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_GData_t@_bstr_t@@AAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_GData_t@_bstr_t@@AAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_GData_t@_bstr_t@@AAEPAXI@Z ENDP			; _bstr_t::Data_t::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ
_TEXT	SEGMENT
?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ PROC		; _bstr_t::Data_t::GetWString, COMDAT
; _this$ = ecx

; 819  :     return m_wstr;

  00000	8b c1		 mov	 eax, ecx

; 820  : }

  00002	c3		 ret	 0
?GetWString@Data_t@_bstr_t@@QAEAAPA_WXZ ENDP		; _bstr_t::Data_t::GetWString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT
??2Data_t@_bstr_t@@SAPAXI@Z PROC			; _bstr_t::Data_t::operator new, COMDAT
; _sz$dead$ = ecx

; 915  :     return ::operator new(sz);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00007	83 c4 04	 add	 esp, 4

; 916  : }

  0000a	c3		 ret	 0
??2Data_t@_bstr_t@@SAPAXI@Z ENDP			; _bstr_t::Data_t::operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1Data_t@_bstr_t@@AAE@XZ PROC				; _bstr_t::Data_t::~Data_t, COMDAT
; _this$ = ecx

; 922  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1Data_t@_bstr_t@@AAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 930  :     if (m_wstr != NULL) {

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN4@Data_t

; 931  :         ::SysFreeString(m_wstr);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN4@Data_t:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003b	85 c0		 test	 eax, eax
  0003d	74 10		 je	 SHORT $LN5@Data_t

; 936  :         delete [] m_str;

  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00045	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  00048	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN5@Data_t:

; 923  :     _Free();
; 924  : }

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1Data_t@_bstr_t@@AAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1Data_t@_bstr_t@@AAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1Data_t@_bstr_t@@AAE@XZ ENDP				; _bstr_t::Data_t::~Data_t
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?_Free@Data_t@_bstr_t@@AAEXXZ PROC			; _bstr_t::Data_t::_Free, COMDAT
; _this$ = ecx

; 929  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Free@Data_t@_bstr_t@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 930  :     if (m_wstr != NULL) {

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN2@Free

; 931  :         ::SysFreeString(m_wstr);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 932  :         m_wstr = NULL;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN2@Free:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  00038	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003b	85 c0		 test	 eax, eax
  0003d	74 10		 je	 SHORT $LN3@Free

; 936  :         delete [] m_str;

  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00045	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  00048	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN3@Free:

; 938  :     }
; 939  : }

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Free@Data_t@_bstr_t@@AAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Free@Data_t@_bstr_t@@AAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Free@Data_t@_bstr_t@@AAEXXZ ENDP			; _bstr_t::Data_t::_Free
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR _dwExceptionFlags$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dwExceptionCode$[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlexcept.h
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 44   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 43   : 		m_hr( hr )

  00003	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 45   : 	}

  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )
; 69   : 	{
; 70   : 		AfxThrowMemoryException();
; 71   : 	}
; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );
; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );

  00003	ff 75 08	 push	 DWORD PTR _hr$[ebp]
  00006	8d 4d 08	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0CAtlException@ATL@@QAE@J@Z ; ATL::CAtlException::CAtlException
  0000e	68 00 00 00 00	 push	 OFFSET __TI1?AVCAtlException@ATL@@
  00013	8b c1		 mov	 eax, ecx
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@AtlThrowIm:
  0001b	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	ff 75 10	 push	 DWORD PTR _Flags$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwSpinCount$[ebp]
  00009	ff 75 08	 push	 DWORD PTR _lpCriticalSection$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 123  : 	CComCriticalSection() throw()

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 124  : 	{
; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 126  : 	}

  00003	8b c1		 mov	 eax, ecx
  00005	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00008	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
  0000d	c3		 ret	 0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 130  : 	}

  00000	c3		 ret	 0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 143  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Init@CComCriticalSection@ATL@@QAEJXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00022	6a 00		 push	 0
  00024	6a 00		 push	 0
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0002d	85 c0		 test	 eax, eax
  0002f	75 21		 jne	 SHORT $LN10@Init

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00037	85 c0		 test	 eax, eax
  00039	7e 19		 jle	 SHORT $LN9@Init
  0003b	0f b7 c0	 movzx	 eax, ax
  0003e	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 151  : 	}

  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN10@Init:

; 148  : 		}
; 149  : 
; 150  : 		return hRes;

  00052	33 c0		 xor	 eax, eax
$LN9@Init:

; 151  : 	}

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Init@CComCriticalSection@ATL@@QAEJXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Init@CComCriticalSection@ATL@@QAEJXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 154  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Term@CComCriticalSection@ATL@@QAEJXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 155  : 		DeleteCriticalSection(&m_sec);

  00022	51		 push	 ecx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 156  : 		return S_OK;

  00029	33 c0		 xor	 eax, eax

; 157  : 	}

  0002b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00035	59		 pop	 ecx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Term@CComCriticalSection@ATL@@QAEJXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Term@CComCriticalSection@ATL@@QAEJXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$dead$ = ecx

; 290  : 		return m_hInst;

  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 291  : 	}

  00005	c3		 ret	 0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z
_TEXT	SEGMENT
?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z PROC ; ATL::AtlSafeArrayGetActualVartype, COMDAT
; _psaArray$ = ecx
; _pvtType$ = edx

; 522  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b fa		 mov	 edi, edx
  00005	8b d9		 mov	 ebx, ecx

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00007	57		 push	 edi
  00008	53		 push	 ebx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8
  0000f	8b f0		 mov	 esi, eax

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00011	85 f6		 test	 esi, esi
  00013	78 29		 js	 SHORT $LN5@AtlSafeArr

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  00015	85 ff		 test	 edi, edi
  00017	74 25		 je	 SHORT $LN5@AtlSafeArr
  00019	66 83 3f 0d	 cmp	 WORD PTR [edi], 13	; 0000000dH
  0001d	75 1f		 jne	 SHORT $LN5@AtlSafeArr

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0001f	85 db		 test	 ebx, ebx
  00021	74 1b		 je	 SHORT $LN5@AtlSafeArr
  00023	66 8b 43 02	 mov	 ax, WORD PTR [ebx+2]
  00027	b9 40 04 00 00	 mov	 ecx, 1088		; 00000440H
  0002c	66 23 c1	 and	 ax, cx
  0002f	66 3b c1	 cmp	 ax, cx
  00032	75 08		 jne	 SHORT $LN8@AtlSafeArr

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00034	b8 09 00 00 00	 mov	 eax, 9
  00039	66 89 07	 mov	 WORD PTR [edi], ax
$LN8@AtlSafeArr:

; 541  : 			}
; 542  : 		}
; 543  : 	}
; 544  : 
; 545  : 	return hrSystem;
; 546  : }

  0003c	8b c6		 mov	 eax, esi
$LN5@AtlSafeArr:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	c3		 ret	 0
?AtlSafeArrayGetActualVartype@ATL@@YAJPAUtagSAFEARRAY@@PAG@Z ENDP ; ATL::AtlSafeArrayGetActualVartype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcomcli.h
;	COMDAT ??BCComBSTR@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
??BCComBSTR@ATL@@QBEPA_WXZ PROC				; ATL::CComBSTR::operator wchar_t *, COMDAT
; _this$ = ecx

; 888  :         return m_str;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 889  :     }

  00002	c3		 ret	 0
??BCComBSTR@ATL@@QBEPA_WXZ ENDP				; ATL::CComBSTR::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$dead$ = ecx

; 2586 : 	CAtlComModule() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00022	6a 00		 push	 0
  00024	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2588 : 		cbSize = 0;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00031	6a 00		 push	 0
  00033	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00038	0f 29 05 10 00
	00 00		 movaps	 XMMWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16, xmm0
  0003f	66 0f d6 05 20
	00 00 00	 movq	 QWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+32, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2590 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

  00047	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+4, OFFSET ___ImageBase

; 2591 : 
; 2592 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

  00051	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8, OFFSET ___pobjMapEntryFirst+4

; 2593 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

  0005b	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12, OFFSET ___pobjMapEntryLast
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0006b	85 c0		 test	 eax, eax
  0006d	75 31		 jne	 SHORT $LN2@CAtlComMod

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00075	85 c0		 test	 eax, eax
  00077	7e 0a		 jle	 SHORT $LN18@CAtlComMod
  00079	0f b7 c0	 movzx	 eax, ax
  0007c	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2595 : 		if (FAILED(m_csObjMap.Init()))

  00081	85 c0		 test	 eax, eax
$LN18@CAtlComMod:
  00083	79 1b		 jns	 SHORT $LN2@CAtlComMod

; 2596 : 		{
; 2597 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2598 : 			ATLASSERT(0);
; 2599 : 			CAtlBaseModule::m_bInitFailed = true;

  00085	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2604 : 	}

  0008c	b8 00 00 00 00	 mov	 eax, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN2@CAtlComMod:

; 2600 : 			return;
; 2601 : 		}
; 2602 : 		// Set cbSize on success.
; 2603 : 		cbSize = sizeof(_ATL_COM_MODULE);

  000a0	c7 05 00 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2604 : 	}

  000aa	b8 00 00 00 00	 mov	 eax, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0CAtlComModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CAtlComModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$dead$ = ecx

; 2607 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlComModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2614 : 		if (cbSize == 0)

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
  0002b	74 57		 je	 SHORT $LN3@CAtlComMod

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  0002d	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
  00033	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
  00039	3b f1		 cmp	 esi, ecx
  0003b	73 32		 jae	 SHORT $LN5@CAtlComMod
  0003d	0f 1f 00	 npad	 3
$LL6@CAtlComMod:

; 2618 : 		{
; 2619 : 			if (*ppEntry != NULL)

  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	85 c0		 test	 eax, eax
  00044	74 22		 je	 SHORT $LN4@CAtlComMod

; 2620 : 			{
; 2621 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00046	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 2622 : 
; 2623 : 				if (pCache->pCF != NULL)

  00049	8b 07		 mov	 eax, DWORD PTR [edi]
  0004b	85 c0		 test	 eax, eax
  0004d	74 19		 je	 SHORT $LN4@CAtlComMod

; 2624 : 				{
; 2625 : 					// Decode factory pointer if it's not null
; 2626 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  0004f	50		 push	 eax
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2627 : 					_Analysis_assume_(factory != nullptr);
; 2628 : 					factory->Release();

  00056	50		 push	 eax
  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2629 : 					pCache->pCF = NULL;

  0005c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00062	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
$LN4@CAtlComMod:

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00068	83 c6 04	 add	 esi, 4
  0006b	3b f1		 cmp	 esi, ecx
  0006d	72 d1		 jb	 SHORT $LL6@CAtlComMod
$LN5@CAtlComMod:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  0006f	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2637 : 		cbSize = 0;

  0007a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
$LN3@CAtlComMod:

; 2608 : 		Term();
; 2609 : 	}

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$dead$ = ecx

; 2614 : 		if (cbSize == 0)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
  00007	74 5d		 je	 SHORT $LN1@Term

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00009	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
  0000f	56		 push	 esi
  00010	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
  00016	3b f1		 cmp	 esi, ecx
  00018	73 36		 jae	 SHORT $LN3@Term
  0001a	57		 push	 edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Term:

; 2618 : 		{
; 2619 : 			if (*ppEntry != NULL)

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	85 c0		 test	 eax, eax
  00024	74 22		 je	 SHORT $LN2@Term

; 2620 : 			{
; 2621 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00026	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 2622 : 
; 2623 : 				if (pCache->pCF != NULL)

  00029	8b 07		 mov	 eax, DWORD PTR [edi]
  0002b	85 c0		 test	 eax, eax
  0002d	74 19		 je	 SHORT $LN2@Term

; 2624 : 				{
; 2625 : 					// Decode factory pointer if it's not null
; 2626 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2627 : 					_Analysis_assume_(factory != nullptr);
; 2628 : 					factory->Release();

  00036	50		 push	 eax
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2629 : 					pCache->pCF = NULL;

  0003c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00042	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
$LN2@Term:

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00048	83 c6 04	 add	 esi, 4
  0004b	3b f1		 cmp	 esi, ecx
  0004d	72 d1		 jb	 SHORT $LL4@Term
  0004f	5f		 pop	 edi
$LN3@Term:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00050	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2637 : 		cbSize = 0;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
  00065	5e		 pop	 esi
$LN1@Term:

; 2638 : 	}

  00066	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$dead$ = ecx
  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00008	0f 29 05 10 00
	00 00		 movaps	 XMMWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16, xmm0
  0000f	66 0f d6 05 20
	00 00 00	 movq	 QWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+32, xmm0
  00017	c3		 ret	 0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$dead$ = ecx
  00000	c3		 ret	 0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0000f	85 c0		 test	 eax, eax
  00011	75 29		 jne	 SHORT $LN4@dynamic

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00019	85 c0		 test	 eax, eax
  0001b	7e 0a		 jle	 SHORT $LN19@dynamic
  0001d	0f b7 c0	 movzx	 eax, ax
  00020	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2595 : 		if (FAILED(m_csObjMap.Init()))

  00025	85 c0		 test	 eax, eax
$LN19@dynamic:
  00027	79 13		 jns	 SHORT $LN4@dynamic

; 2716 : __declspec(selectany) CAtlComModule _AtlComModule;

  00029	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2599 : 			CAtlBaseModule::m_bInitFailed = true;

  0002e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2716 : __declspec(selectany) CAtlComModule _AtlComModule;

  00035	e8 00 00 00 00	 call	 _atexit
  0003a	59		 pop	 ecx
  0003b	c3		 ret	 0
$LN4@dynamic:
  0003c	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2603 : 		cbSize = sizeof(_ATL_COM_MODULE);

  00041	c7 05 00 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2716 : __declspec(selectany) CAtlComModule _AtlComModule;

  0004b	e8 00 00 00 00	 call	 _atexit
  00050	59		 pop	 ecx
  00051	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT

; 2614 : 		if (cbSize == 0)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
  00007	74 5d		 je	 SHORT $LN5@dynamic

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00009	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
  0000f	56		 push	 esi
  00010	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
  00016	3b f1		 cmp	 esi, ecx
  00018	73 36		 jae	 SHORT $LN7@dynamic
  0001a	57		 push	 edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL8@dynamic:

; 2618 : 		{
; 2619 : 			if (*ppEntry != NULL)

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	85 c0		 test	 eax, eax
  00024	74 22		 je	 SHORT $LN6@dynamic

; 2620 : 			{
; 2621 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00026	8b 78 10	 mov	 edi, DWORD PTR [eax+16]

; 2622 : 
; 2623 : 				if (pCache->pCF != NULL)

  00029	8b 07		 mov	 eax, DWORD PTR [edi]
  0002b	85 c0		 test	 eax, eax
  0002d	74 19		 je	 SHORT $LN6@dynamic

; 2624 : 				{
; 2625 : 					// Decode factory pointer if it's not null
; 2626 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2627 : 					_Analysis_assume_(factory != nullptr);
; 2628 : 					factory->Release();

  00036	50		 push	 eax
  00037	8b 08		 mov	 ecx, DWORD PTR [eax]
  00039	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2629 : 					pCache->pCF = NULL;

  0003c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00042	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
$LN6@dynamic:

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00048	83 c6 04	 add	 esi, 4
  0004b	3b f1		 cmp	 esi, ecx
  0004d	72 d1		 jb	 SHORT $LL8@dynamic
  0004f	5f		 pop	 edi
$LN7@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00050	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2637 : 		cbSize = 0;

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 0
  00065	5e		 pop	 esi
$LN5@dynamic:
  00066	c3		 ret	 0
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$dead$ = ecx

; 2937 : 	CAtlWinModule()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CAtlWinModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  0002d	0f 11 05 04 00
	00 00		 movups	 XMMWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00034	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  0003e	66 0f d6 05 14
	00 00 00	 movq	 QWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+20, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00046	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
  00050	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2937 : 	CAtlWinModule()

  0005a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00061	6a 00		 push	 0
  00063	6a 00		 push	 0
  00065	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2939 : 		cbSize = sizeof(_ATL_WIN_MODULE);

  0006a	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 44 ; 0000002cH

; 8404 : 	pWinModule->m_pCreateWndList = NULL;

  00074	c7 05 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+28, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  00084	85 c0		 test	 eax, eax
  00086	75 27		 jne	 SHORT $LN27@CAtlWinMod

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  0008e	85 c0		 test	 eax, eax
  00090	7e 0a		 jle	 SHORT $LN29@CAtlWinMod
  00092	0f b7 c0	 movzx	 eax, ax
  00095	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2941 : 		if (FAILED(hr))

  0009a	85 c0		 test	 eax, eax
$LN29@CAtlWinMod:
  0009c	79 11		 jns	 SHORT $LN27@CAtlWinMod

; 2942 : 		{
; 2943 : 			ATLASSERT(0);
; 2944 : 			CAtlBaseModule::m_bInitFailed = true;

  0009e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2945 : 			cbSize = 0;

  000a5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 0
$LN27@CAtlWinMod:

; 2946 : 			return;
; 2947 : 		}
; 2948 : 	}

  000af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b6	b8 00 00 00 00	 mov	 eax, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c5	59		 pop	 ecx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CAtlWinModule@ATL@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
__unwindfunclet$??0CAtlWinModule@ATL@@QAE@XZ$0:
  0000b	e9 00 00 00 00	 jmp	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??0CAtlWinModule@ATL@@QAE@XZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CAtlWinModule@ATL@@QAE@XZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$dead$ = ecx

; 2951 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 7655 : 	if (pWinModule->cbSize == 0)

  00035	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 290  : 		return m_hInst;

  0003a	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00040	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7655 : 	if (pWinModule->cbSize == 0)

  00043	85 c0		 test	 eax, eax
  00045	0f 84 8a 00 00
	00		 je	 $LN8@CAtlWinMod

; 7656 : 		return S_OK;
; 7657 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0004b	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0004e	0f 85 81 00 00
	00		 jne	 $LN8@CAtlWinMod

; 7658 : 		return E_INVALIDARG;
; 7659 : 
; 7660 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00054	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  00059	33 f6		 xor	 esi, esi
  0005b	85 c0		 test	 eax, eax
  0005d	7e 30		 jle	 SHORT $LN10@CAtlWinMod
  0005f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__UnregisterClassA@8
$LL11@CAtlWinMod:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00065	85 f6		 test	 esi, esi
  00067	0f 88 b0 00 00
	00		 js	 $LN49@CAtlWinMod
  0006d	3b f0		 cmp	 esi, eax
  0006f	0f 8d a8 00 00
	00		 jge	 $LN49@CAtlWinMod

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  00075	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7661 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0007a	51		 push	 ecx
  0007b	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  0007f	50		 push	 eax
  00080	ff d7		 call	 edi
  00082	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  00087	46		 inc	 esi
  00088	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0008b	3b f0		 cmp	 esi, eax
  0008d	7c d6		 jl	 SHORT $LL11@CAtlWinMod
$LN10@CAtlWinMod:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

  0008f	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00095	85 c9		 test	 ecx, ecx
  00097	74 13		 je	 SHORT $LN27@CAtlWinMod

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 _free
  0009f	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  000a2	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN27@CAtlWinMod:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  000ac	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

  000b1	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0

; 224  : 		m_nAllocSize = 0;

  000bb	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7664 : 	pWinModule->cbSize = 0;

  000cb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 0
$LN8@CAtlWinMod:
  000d5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

  000dc	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  000e1	85 c0		 test	 eax, eax
  000e3	74 13		 je	 SHORT $LN42@CAtlWinMod

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _free
  000eb	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  000ee	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN42@CAtlWinMod:

; 223  : 		m_nSize = 0;

  000f8	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0

; 224  : 		m_nAllocSize = 0;

  00102	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2953 : 	}

  0010c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00116	59		 pop	 ecx
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
$LN49@CAtlWinMod:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  0011d	6a 01		 push	 1
  0011f	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00124	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN60@CAtlWinMod:
  00129	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$0:
  00000	e9 00 00 00 00	 jmp	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__unwindfunclet$??1CAtlWinModule@ATL@@QAE@XZ$1:
  00005	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00008	83 c1 20	 add	 ecx, 32			; 00000020H
  0000b	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAtlWinModule@ATL@@QAE@XZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$dead$ = ecx

; 7655 : 	if (pWinModule->cbSize == 0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A

; 2956 : 	{

  00005	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 290  : 		return m_hInst;

  00006	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7655 : 	if (pWinModule->cbSize == 0)

  0000c	85 c0		 test	 eax, eax
  0000e	74 7a		 je	 SHORT $LN5@Term

; 7656 : 		return S_OK;
; 7657 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00010	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00013	75 75		 jne	 SHORT $LN5@Term

; 7658 : 		return E_INVALIDARG;
; 7659 : 
; 7660 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00015	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  0001a	56		 push	 esi
  0001b	33 f6		 xor	 esi, esi
  0001d	85 c0		 test	 eax, eax
  0001f	7e 23		 jle	 SHORT $LN7@Term
$LL8@Term:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00021	85 f6		 test	 esi, esi
  00023	78 67		 js	 SHORT $LN31@Term
  00025	3b f0		 cmp	 esi, eax
  00027	7d 63		 jge	 SHORT $LN31@Term
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7661 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  00029	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  0002e	57		 push	 edi
  0002f	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  0003a	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  0003f	46		 inc	 esi
  00040	3b f0		 cmp	 esi, eax
  00042	7c dd		 jl	 SHORT $LL8@Term
$LN7@Term:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

  00044	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00049	5e		 pop	 esi
  0004a	85 c0		 test	 eax, eax
  0004c	74 13		 je	 SHORT $LN24@Term

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _free
  00054	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  00057	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN24@Term:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00061	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

  00066	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0

; 224  : 		m_nAllocSize = 0;

  00070	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7664 : 	pWinModule->cbSize = 0;

  00080	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 0
$LN5@Term:
  0008a	5f		 pop	 edi

; 2958 : 	}

  0008b	c3		 ret	 0
$LN31@Term:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  0008c	6a 01		 push	 1
  0008e	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00093	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN38@Term:
  00098	cc		 int	 3
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$dead$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	0f 57 c0	 xorps	 xmm0, xmm0
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  0002d	0f 11 05 04 00
	00 00		 movups	 XMMWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00034	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  0003e	66 0f d6 05 14
	00 00 00	 movq	 QWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+20, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00046	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
  00050	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
  0005a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00061	b8 00 00 00 00	 mov	 eax, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
__ehhandler$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$dead$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0002a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 216  : 		if(m_aT != NULL)

  00031	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00036	85 c0		 test	 eax, eax
  00038	74 13		 je	 SHORT $LN18@ATL_WIN_MO

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _free
  00040	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  00043	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN18@ATL_WIN_MO:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

  0004d	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
  00057	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
__ehhandler$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
__$EHRec$ = -12						; size = 12
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2972 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__E_AtlWinModule@ATL@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2937 : 	CAtlWinModule()

  00022	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2939 : 		cbSize = sizeof(_ATL_WIN_MODULE);

  00032	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 44 ; 0000002cH

; 8404 : 	pWinModule->m_pCreateWndList = NULL;

  0003c	c7 05 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+28, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0004c	85 c0		 test	 eax, eax
  0004e	75 27		 jne	 SHORT $LN4@dynamic

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00056	85 c0		 test	 eax, eax
  00058	7e 0a		 jle	 SHORT $LN29@dynamic
  0005a	0f b7 c0	 movzx	 eax, ax
  0005d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2941 : 		if (FAILED(hr))

  00062	85 c0		 test	 eax, eax
$LN29@dynamic:
  00064	79 11		 jns	 SHORT $LN4@dynamic

; 2942 : 		{
; 2943 : 			ATLASSERT(0);
; 2944 : 			CAtlBaseModule::m_bInitFailed = true;

  00066	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2945 : 			cbSize = 0;

  0006d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 0
$LN4@dynamic:

; 2946 : 			return;
; 2947 : 		}
; 2948 : 	}

  00077	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 2972 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  0007e	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  00083	e8 00 00 00 00	 call	 _atexit
  00088	83 c4 04	 add	 esp, 4
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__E_AtlWinModule@ATL@@YAXXZ$1:
  00000	b9 20 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00005	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
__unwindfunclet$??__E_AtlWinModule@ATL@@YAXXZ$0:
  0000a	e9 00 00 00 00	 jmp	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??__E_AtlWinModule@ATL@@YAXXZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__E_AtlWinModule@ATL@@YAXXZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__F_AtlWinModule@ATL@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 2951 : 	{

  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 7655 : 	if (pWinModule->cbSize == 0)

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 290  : 		return m_hInst;

  00030	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7655 : 	if (pWinModule->cbSize == 0)

  00036	85 c0		 test	 eax, eax
  00038	0f 84 84 00 00
	00		 je	 $LN10@dynamic

; 7656 : 		return S_OK;
; 7657 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0003e	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00041	0f 85 7b 00 00
	00		 jne	 $LN10@dynamic

; 7658 : 		return E_INVALIDARG;
; 7659 : 
; 7660 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00047	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  0004c	33 f6		 xor	 esi, esi
  0004e	85 c0		 test	 eax, eax
  00050	7e 2b		 jle	 SHORT $LN12@dynamic
$LL13@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00052	85 f6		 test	 esi, esi
  00054	0f 88 b0 00 00
	00		 js	 $LN52@dynamic
  0005a	3b f0		 cmp	 esi, eax
  0005c	0f 8d a8 00 00
	00		 jge	 $LN52@dynamic

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  00062	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7661 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  00067	57		 push	 edi
  00068	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassA@8
  00073	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  00078	46		 inc	 esi
  00079	3b f0		 cmp	 esi, eax
  0007b	7c d5		 jl	 SHORT $LL13@dynamic
$LN12@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

  0007d	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00082	85 c0		 test	 eax, eax
  00084	74 13		 je	 SHORT $LN29@dynamic

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _free
  0008c	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  0008f	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00099	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

  0009e	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0

; 224  : 		m_nAllocSize = 0;

  000a8	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7664 : 	pWinModule->cbSize = 0;

  000b8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 0
$LN10@dynamic:
  000c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

  000c9	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  000ce	85 c0		 test	 eax, eax
  000d0	74 13		 je	 SHORT $LN44@dynamic

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _free
  000d8	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  000db	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN44@dynamic:

; 223  : 		m_nSize = 0;

  000e5	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0

; 224  : 		m_nAllocSize = 0;

  000ef	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00103	59		 pop	 ecx
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
$LN52@dynamic:

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  0010a	6a 01		 push	 1
  0010c	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00111	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN63@dynamic:
  00116	cc		 int	 3
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__F_AtlWinModule@ATL@@YAXXZ$0:
  00000	e9 00 00 00 00	 jmp	 ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__unwindfunclet$??__F_AtlWinModule@ATL@@YAXXZ$1:
  00005	b9 20 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  0000a	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
__ehhandler$??__F_AtlWinModule@ATL@@YAXXZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__F_AtlWinModule@ATL@@YAXXZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_hInst$1$ = -4						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT
; _pWinModule$dead$ = ecx
; _hInst$ = edx

; 7652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7653 : 	if (pWinModule == NULL)
; 7654 : 		return E_INVALIDARG;
; 7655 : 	if (pWinModule->cbSize == 0)

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
  00009	8b ca		 mov	 ecx, edx
  0000b	89 4d fc	 mov	 DWORD PTR _hInst$1$[ebp], ecx
  0000e	85 c0		 test	 eax, eax
  00010	0f 84 8a 00 00
	00		 je	 $LN34@AtlWinModu

; 7656 : 		return S_OK;
; 7657 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00016	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00019	74 09		 je	 SHORT $LN7@AtlWinModu

; 7658 : 		return E_INVALIDARG;

  0001b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 7666 : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN7@AtlWinModu:

; 7659 : 
; 7660 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00024	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  00029	56		 push	 esi
  0002a	33 f6		 xor	 esi, esi
  0002c	85 c0		 test	 eax, eax
  0002e	7e 2a		 jle	 SHORT $LN3@AtlWinModu
  00030	57		 push	 edi
  00031	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__UnregisterClassA@8
$LL4@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00037	85 f6		 test	 esi, esi
  00039	78 6b		 js	 SHORT $LN26@AtlWinModu
  0003b	3b f0		 cmp	 esi, eax
  0003d	7d 67		 jge	 SHORT $LN26@AtlWinModu
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7661 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  0003f	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00044	51		 push	 ecx
  00045	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  00049	50		 push	 eax
  0004a	ff d7		 call	 edi
  0004c	a1 24 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36
  00051	46		 inc	 esi
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _hInst$1$[ebp]
  00055	3b f0		 cmp	 esi, eax
  00057	7c de		 jl	 SHORT $LL4@AtlWinModu
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00059	5f		 pop	 edi
$LN3@AtlWinModu:

; 216  : 		if(m_aT != NULL)

  0005a	a1 20 00 00 00	 mov	 eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  0005f	5e		 pop	 esi
  00060	85 c0		 test	 eax, eax
  00062	74 13		 je	 SHORT $LN20@AtlWinModu

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _free
  0006a	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  0006d	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN20@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00077	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

  0007c	c7 05 24 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0

; 224  : 		m_nAllocSize = 0;

  00086	c7 05 28 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 7664 : 	pWinModule->cbSize = 0;

  00096	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 0
$LN34@AtlWinModu:

; 7666 : }

  000a0	33 c0		 xor	 eax, eax
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN26@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  000a6	6a 01		 push	 1
  000a8	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  000ad	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN33@AtlWinModu:
  000b2	cc		 int	 3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT
; _pWinModule$dead$ = ecx

; 8397 : 	if (pWinModule == NULL)
; 8398 : 		return E_INVALIDARG;
; 8399 : 
; 8400 : 	// check only in the DLL
; 8401 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00000	83 3d 00 00 00
	00 2c		 cmp	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A, 44 ; 0000002cH
  00007	74 06		 je	 SHORT $LN3@AtlWinModu

; 8402 : 		return E_INVALIDARG;

  00009	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 8413 : }

  0000e	c3		 ret	 0
$LN3@AtlWinModu:
  0000f	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 144  : 		HRESULT hRes = S_OK;

  00010	33 f6		 xor	 esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 8404 : 	pWinModule->m_pCreateWndList = NULL;

  00012	c7 05 1c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+28, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  0001c	56		 push	 esi
  0001d	56		 push	 esi
  0001e	68 04 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+4
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  00029	85 c0		 test	 eax, eax
  0002b	75 15		 jne	 SHORT $LN14@AtlWinModu

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00033	8b f0		 mov	 esi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00035	85 f6		 test	 esi, esi
  00037	7e 09		 jle	 SHORT $LN14@AtlWinModu
  00039	0f b7 f6	 movzx	 esi, si
  0003c	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
$LN14@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlbase.h

; 8412 : 	return hr;

  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi

; 8413 : }

  00045	c3		 ret	 0
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
__Bytes$2 = -32056					; size = 4
__Bytes$3 = -32052					; size = 4
__Bytes$4 = -32048					; size = 4
__Bytes$5 = -32044					; size = 4
__Bytes$6 = -32040					; size = 4
__Bytes$7 = -32036					; size = 4
__Bytes$8 = -32032					; size = 4
__Bytes$9 = -32028					; size = 4
__Bytes$10 = -32024					; size = 4
__Bytes$11 = -32020					; size = 4
__Bytes$12 = -32016					; size = 4
__Bytes$13 = -32012					; size = 4
__Bytes$14 = -32008					; size = 4
__Bytes$15 = -32004					; size = 4
_i$16 = -32000						; size = 4
__Bytes$17 = -31996					; size = 4
__Bytes$18 = -31992					; size = 4
_i$19 = -31988						; size = 4
__Bytes$20 = -31984					; size = 4
__Bytes$21 = -31980					; size = 4
__Bytes$22 = -31976					; size = 4
__Bytes$23 = -31972					; size = 4
_i$24 = -31968						; size = 4
__Bytes$25 = -31964					; size = 4
_i$26 = -31960						; size = 4
__Bytes$27 = -31956					; size = 4
_i$28 = -31952						; size = 4
__Bytes$29 = -31948					; size = 4
_i$30 = -31944						; size = 4
_i$31 = -31940						; size = 4
_timeElapsed$32 = -31936				; size = 8
_xml$GSCopy$ = -31932					; size = 4
_tickStart$ = -31928					; size = 8
_tickEnd$33 = -31920					; size = 8
tv6719 = -31916						; size = 4
_lpulProperties$GSCopy$ = -31916			; size = 4
tv6720 = -31912						; size = 4
_lpszOption$GSCopy$ = -31912				; size = 4
_hWmiMutex$ = -31908					; size = 4
_xml$GSCopy$1$ = -31904					; size = 4
_pEnumerator$ = -31900					; size = 4
_vr8$34 = -31896					; size = 12
_vr4$35 = -31884					; size = 12
_vui8$36 = -31872					; size = 12
_vui4$37 = -31860					; size = 12
_vui2$38 = -31848					; size = 12
_vui1$39 = -31836					; size = 12
_seconds$40 = -31824					; size = 8
tv5758 = -31820						; size = 4
_vbstr$41 = -31812					; size = 12
_uReturn$42 = -31800					; size = 4
$T43 = -31800						; size = 4
_properties$1$ = -31796					; size = 4
_pLoc$ = -31792						; size = 4
_pSvc$ = -31788						; size = 4
_lpszOption$GSCopy$1$ = -31784				; size = 4
$T44 = -31780						; size = 4
_properties$ = -31780					; size = 4
_vtProp$45 = -31776					; size = 16
_sd$46 = -31776						; size = 20
_hres$6$ = -31752					; size = 4
_hres$4$ = -31752					; size = 4
tv6888 = -31752						; size = 4
$T47 = -31752						; size = 4
_pclsObj$48 = -31752					; size = 4
_x$49 = -31748						; size = 4
$T50 = -31748						; size = 4
$T51 = -31744						; size = 24
$T52 = -31720						; size = 24
$T53 = -31696						; size = 24
$T54 = -31672						; size = 24
$T55 = -31648						; size = 24
$T56 = -31624						; size = 24
$T57 = -31600						; size = 24
$T58 = -31576						; size = 24
$T59 = -31552						; size = 24
$T60 = -31528						; size = 24
$T61 = -31504						; size = 24
$T62 = -31480						; size = 24
$T63 = -31456						; size = 24
$T64 = -31432						; size = 24
$T65 = -31408						; size = 24
$T66 = -31384						; size = 24
$T67 = -31360						; size = 24
$T68 = -31336						; size = 24
$T69 = -31312						; size = 24
$T70 = -31288						; size = 24
$T71 = -31264						; size = 24
_temp$72 = -31240					; size = 24
_temp$73 = -31240					; size = 24
_id$74 = -31240						; size = 24
_value$75 = -31216					; size = 24
_tag$76 = -31216					; size = 24
_tszProperty$77 = -31192				; size = 20000
_szValue$78 = -11192					; size = 10000
_szSelect$ = -1192					; size = 260
_processed$ = -928					; size = 260
_sMember$79 = -664					; size = 100
_elapsedTime$80 = -560					; size = 260
_idx$81 = -560						; size = 260
_temp$82 = -296						; size = 260
__$ArrayPad$ = -28					; size = 4
__$EHRec$ = -16						; size = 16
_lpulProperties$ = 8					; size = 4
?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z PROC			; WMIex
; _lpszOption$ = ecx
; _xml$ = edx

; 56   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	53		 push	 ebx
  00026	51		 push	 ecx
  00027	b8 24 7d 00 00	 mov	 eax, 32036		; 00007d24H
  0002c	e8 00 00 00 00	 call	 __chkstk
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003b	56		 push	 esi
  0003c	57		 push	 edi
  0003d	50		 push	 eax
  0003e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00041	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00047	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0004a	8b f2		 mov	 esi, edx
  0004c	89 b5 60 83 ff
	ff		 mov	 DWORD PTR _xml$GSCopy$1$[ebp], esi
  00052	8b c1		 mov	 eax, ecx
  00054	89 85 d8 83 ff
	ff		 mov	 DWORD PTR _lpszOption$GSCopy$1$[ebp], eax
  0005a	89 85 58 83 ff
	ff		 mov	 DWORD PTR _lpszOption$GSCopy$[ebp], eax
  00060	89 b5 44 83 ff
	ff		 mov	 DWORD PTR _xml$GSCopy$[ebp], esi
  00066	8b 43 08	 mov	 eax, DWORD PTR _lpulProperties$[ebx]
  00069	89 85 54 83 ff
	ff		 mov	 DWORD PTR _lpulProperties$GSCopy$[ebp], eax

; 57   :     unsigned long properties = 0;

  0006f	c7 85 cc 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _properties$1$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 77   :     char sMember[100] = { 0 };

  00079	6a 64		 push	 100			; 00000064H
  0007b	6a 00		 push	 0
  0007d	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR _sMember$79[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _memset
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0008c	68 00 00 00 00	 push	 OFFSET ?gbTerminate@@3HA ; gbTerminate
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00096	6a 63		 push	 99			; 00000063H
  00098	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR _sMember$79[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 __snprintf
  000a4	83 c4 10	 add	 esp, 16			; 00000010H

; 79   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  000a7	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR _sMember$79[ebp]
  000ad	50		 push	 eax
  000ae	6a 00		 push	 0
  000b0	6a 00		 push	 0
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  000b8	8b f8		 mov	 edi, eax

; 80   :     WaitForSingleObject(hdTh, INFINITE);

  000ba	6a ff		 push	 -1
  000bc	57		 push	 edi
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 81   : 
; 82   :     int const iRetVal = *piProtectedVar;

  000c3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbTerminate@@3HA ; gbTerminate

; 83   : 
; 84   :     ReleaseMutex(hdTh);

  000c9	57		 push	 edi
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 85   :     CloseHandle(hdTh);

  000d0	57		 push	 edi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 60   :     if (_thGetInt(&gbTerminate) == TRUE)

  000d7	83 fe 01	 cmp	 esi, 1
  000da	0f 84 44 27 00
	00		 je	 $LN2881@WMIex

; 61   :     {
; 62   :         //process is ending - do not process because it spends to much time
; 63   :         return true;
; 64   :     }
; 65   : 
; 66   :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMI, %s", lpszOption);

  000e0	8b b5 d8 83 ff
	ff		 mov	 esi, DWORD PTR _lpszOption$GSCopy$1$[ebp]
  000e6	56		 push	 esi
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NGFAGIOG@?$DO?$DO?5WMI?0?5?$CFs@
  000ec	6a 42		 push	 66			; 00000042H
  000ee	6a 40		 push	 64			; 00000040H
  000f0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000f5	83 c4 10	 add	 esp, 16			; 00000010H

; 67   : 
; 68   :     if (!lpszOption)

  000f8	85 f6		 test	 esi, esi
  000fa	75 0e		 jne	 SHORT $LN33@WMIex

; 69   :     {
; 70   :         Log(LOG_DEBUG, __LINE__, "<< WMI, Null class name");

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@BJBFJFDH@?$DM?$DM?5WMI?0?5Null?5class?5name@
  00101	6a 46		 push	 70			; 00000046H
  00103	6a 10		 push	 16			; 00000010H

; 71   :         return true;

  00105	e9 12 27 00 00	 jmp	 $LN2882@WMIex
$LN33@WMIex:

; 72   :     }
; 73   : 
; 74   :     HANDLE hWmiMutex = CreateMutex(NULL, FALSE, "SysStatus_WMI_Mutex");

  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FCECJKPH@SysStatus_WMI_Mutex@
  0010f	6a 00		 push	 0
  00111	6a 00		 push	 0
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00119	8b f8		 mov	 edi, eax
  0011b	89 bd 5c 83 ff
	ff		 mov	 DWORD PTR _hWmiMutex$[ebp], edi

; 75   :     if (WaitForSingleObject(hWmiMutex, MINUTE) != WAIT_OBJECT_0)

  00121	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00126	57		 push	 edi
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0012d	85 c0		 test	 eax, eax
  0012f	74 21		 je	 SHORT $LN34@WMIex

; 76   :     {
; 77   :         //need to be restarted
; 78   :         Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, %s Mutex 0x%p timeout", lpszOption, hWmiMutex);

  00131	57		 push	 edi
  00132	56		 push	 esi
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@LNIDFIJJ@?$DM?$DM?5WMI?0?5?$CFs?5Mutex?50x?$CFp?5timeout@
  00138	6a 4e		 push	 78			; 0000004eH
  0013a	6a 40		 push	 64			; 00000040H
  0013c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00141	83 c4 14	 add	 esp, 20			; 00000014H

; 79   :         CloseHandle(hWmiMutex);

  00144	57		 push	 edi
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 80   :         return false;

  0014b	32 c0		 xor	 al, al
  0014d	e9 d4 26 00 00	 jmp	 $LN1@WMIex
$LN34@WMIex:

; 81   :     }
; 82   : 
; 83   :     uint64_t tickStart = SysTick();

  00152	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  00157	89 85 48 83 ff
	ff		 mov	 DWORD PTR _tickStart$[ebp], eax
  0015d	89 95 4c 83 ff
	ff		 mov	 DWORD PTR _tickStart$[ebp+4], edx

; 84   : 
; 85   :     // Initialize COM.
; 86   :     hres = CoInitializeEx(0, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY);

  00163	6a 08		 push	 8
  00165	6a 00		 push	 0
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeEx@8

; 87   :     if (FAILED(hres))

  0016d	85 c0		 test	 eax, eax
  0016f	79 25		 jns	 SHORT $LN35@WMIex

; 88   :     {
; 89   :         Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, Failed to initialize COM library, 0x%.8X", hres);

  00171	50		 push	 eax
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@MKNIEHI@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5CO@
  00177	6a 59		 push	 89			; 00000059H
  00179	6a 40		 push	 64			; 00000040H
  0017b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00180	83 c4 10	 add	 esp, 16			; 00000010H

; 90   :         ReleaseMutex(hWmiMutex);

  00183	57		 push	 edi
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 91   :         CloseHandle(hWmiMutex);

  0018a	57		 push	 edi
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 92   :         return true;

  00191	e9 8e 26 00 00	 jmp	 $LN2881@WMIex
$LN35@WMIex:

; 93   :     }
; 94   : 
; 95   :     static bool secInitialized{ false };
; 96   : 
; 97   :     if (!secInitialized)

  00196	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?secInitialized@?1??WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z@4_NA, 0
  0019d	0f 85 84 00 00
	00		 jne	 $LN36@WMIex
  001a3	0f 57 c0	 xorps	 xmm0, xmm0

; 98   :     {
; 99   :         // Initialize 
; 100  :         SECURITY_DESCRIPTOR sd = { 0 };

  001a6	0f 11 85 e0 83
	ff ff		 movups	 XMMWORD PTR _sd$46[ebp], xmm0
  001ad	c7 85 f0 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _sd$46[ebp+16], 0

; 101  :         InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

  001b7	6a 01		 push	 1
  001b9	8d 85 e0 83 ff
	ff		 lea	 eax, DWORD PTR _sd$46[ebp]
  001bf	50		 push	 eax
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeSecurityDescriptor@8

; 102  :         SetSecurityDescriptorDacl(&sd, TRUE, (PACL) nullptr, FALSE);

  001c6	6a 00		 push	 0
  001c8	6a 00		 push	 0
  001ca	6a 01		 push	 1
  001cc	8d 85 e0 83 ff
	ff		 lea	 eax, DWORD PTR _sd$46[ebp]
  001d2	50		 push	 eax
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetSecurityDescriptorDacl@16

; 103  : 
; 104  :         hres = CoInitializeSecurity(

  001d9	6a 00		 push	 0
  001db	6a 00		 push	 0
  001dd	6a 00		 push	 0
  001df	6a 03		 push	 3
  001e1	6a 01		 push	 1
  001e3	6a 00		 push	 0
  001e5	6a 00		 push	 0
  001e7	6a ff		 push	 -1
  001e9	6a 00		 push	 0
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeSecurity@36

; 105  :             NULL, //&sd,
; 106  :             -1,      // COM negotiates service
; 107  :             NULL,    // Authentication services
; 108  :             NULL,    // Reserved
; 109  :             RPC_C_AUTHN_LEVEL_NONE, //RPC_C_AUTHN_LEVEL_PKT, //RPC_C_AUTHN_LEVEL_DEFAULT,    // authentication
; 110  :             RPC_C_IMP_LEVEL_IMPERSONATE,  // Impersonation
; 111  :             NULL,             // Authentication info 
; 112  :             EOAC_NONE,        // Additional capabilities
; 113  :             NULL              // Reserved
; 114  :         );
; 115  : 
; 116  :         if (FAILED(hres))

  001f1	85 c0		 test	 eax, eax
  001f3	79 2b		 jns	 SHORT $LN37@WMIex

; 117  :         {
; 118  :             Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, Failed to initialize security, 0x%.8x", hres);

  001f5	50		 push	 eax
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@MICKHOIN@?$DM?$DM?5WMI?0?5Failed?5to?5initialize?5se@
  001fb	6a 76		 push	 118			; 00000076H
$LN2891@WMIex:

; 718  : }

  001fd	6a 40		 push	 64			; 00000040H
  001ff	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00204	83 c4 10	 add	 esp, 16			; 00000010H
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
  0020d	57		 push	 edi
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  00214	57		 push	 edi
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0021b	e9 04 26 00 00	 jmp	 $LN2881@WMIex
$LN37@WMIex:

; 119  :             CoUninitialize();
; 120  :             ReleaseMutex(hWmiMutex);
; 121  :             CloseHandle(hWmiMutex);
; 122  :             return true;
; 123  :         }
; 124  : 
; 125  :         secInitialized = true;

  00220	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?secInitialized@?1??WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z@4_NA, 1
$LN36@WMIex:

; 126  :     }
; 127  : 
; 128  :     // Obtain the initial locater to Windows Management
; 129  :     // on a particular host computer.
; 130  :     IWbemLocator *pLoc = 0;

  00227	c7 85 d0 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pLoc$[ebp], 0

; 131  : 
; 132  :     hres = CoCreateInstance(

  00231	8d 85 d0 83 ff
	ff		 lea	 eax, DWORD PTR _pLoc$[ebp]
  00237	50		 push	 eax
  00238	68 00 00 00 00	 push	 OFFSET _IID_IWbemLocator
  0023d	6a 01		 push	 1
  0023f	6a 00		 push	 0
  00241	68 00 00 00 00	 push	 OFFSET _CLSID_WbemLocator
  00246	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 133  :         CLSID_WbemLocator,
; 134  :         0,
; 135  :         CLSCTX_INPROC_SERVER,
; 136  :         IID_IWbemLocator, (LPVOID *)&pLoc);
; 137  : 
; 138  :     if (FAILED(hres))

  0024c	85 c0		 test	 eax, eax
  0024e	79 0d		 jns	 SHORT $LN38@WMIex

; 139  :     {
; 140  :         Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, Failed to create IWbemLocator object,0x%.8x", hres);

  00250	50		 push	 eax
  00251	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HCGLOFPJ@?$DM?$DM?5WMI?0?5Failed?5to?5create?5IWbemL@
  00256	68 8c 00 00 00	 push	 140			; 0000008cH

; 141  :         CoUninitialize();
; 142  :         ReleaseMutex(hWmiMutex);
; 143  :         CloseHandle(hWmiMutex);
; 144  :         return true;

  0025b	eb a0		 jmp	 SHORT $LN2891@WMIex
$LN38@WMIex:

; 145  :     }
; 146  : 
; 147  :     IWbemServices *pSvc = 0;

  0025d	c7 85 d4 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pSvc$[ebp], 0

; 153  :     hres = pLoc->ConnectServer(

  00267	8b 85 d0 83 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  0026d	8b 00		 mov	 eax, DWORD PTR [eax]
  0026f	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 915  :     return ::operator new(sz);

  00272	6a 0c		 push	 12			; 0000000cH
  00274	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00279	83 c4 04	 add	 esp, 4

; 321  :     : m_Data(new Data_t(s))

  0027c	8b f0		 mov	 esi, eax
  0027e	89 b5 f8 83 ff
	ff		 mov	 DWORD PTR $T47[ebp], esi
  00284	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0028b	85 f6		 test	 esi, esi
  0028d	74 25		 je	 SHORT $LN174@WMIex

; 689  :     : m_str(NULL), m_RefCount(1)

  0028f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00296	c7 46 08 01 00
	00 00		 mov	 DWORD PTR [esi+8], 1

; 690  : {
; 691  :     m_wstr = ::SysAllocString(s);

  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@BJADHBOD@?$AAR?$AAO?$AAO?$AAT?$AA?2?$AAC?$AAI?$AAM?$AAV?$AA2@
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  002a8	89 06		 mov	 DWORD PTR [esi], eax

; 692  : 
; 693  :     if (m_wstr == NULL && s != NULL) {

  002aa	85 c0		 test	 eax, eax
  002ac	0f 84 92 25 00
	00		 je	 $LN2895@WMIex
  002b2	eb 02		 jmp	 SHORT $LN175@WMIex
$LN174@WMIex:

; 321  :     : m_Data(new Data_t(s))

  002b4	33 f6		 xor	 esi, esi
$LN175@WMIex:
  002b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002bd	89 b5 dc 83 ff
	ff		 mov	 DWORD PTR $T44[ebp], esi
  002c3	85 f6		 test	 esi, esi

; 322  : {
; 323  :     if (m_Data == NULL) {

  002c5	0f 84 83 25 00
	00		 je	 $LN2896@WMIex
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 153  :     hres = pLoc->ConnectServer(

  002cb	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  002d2	8d 85 d4 83 ff
	ff		 lea	 eax, DWORD PTR _pSvc$[ebp]
  002d8	50		 push	 eax
  002d9	6a 00		 push	 0
  002db	6a 00		 push	 0
  002dd	6a 00		 push	 0
  002df	6a 00		 push	 0
  002e1	6a 00		 push	 0
  002e3	6a 00		 push	 0
  002e5	ff 36		 push	 DWORD PTR [esi]
  002e7	ff b5 d0 83 ff
	ff		 push	 DWORD PTR _pLoc$[ebp]
  002ed	ff d7		 call	 edi
  002ef	89 85 f8 83 ff
	ff		 mov	 DWORD PTR _hres$4$[ebp], eax
  002f5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  002fc	83 c9 ff	 or	 ecx, -1
  002ff	f0 0f c1 4e 08	 lock	  xadd	 DWORD PTR [esi+8], ecx
  00304	49		 dec	 ecx

; 774  :     if (cRef == 0) {

  00305	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__SysFreeString@4
  0030b	75 37		 jne	 SHORT $LN201@WMIex

; 930  :     if (m_wstr != NULL) {

  0030d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0030f	85 c9		 test	 ecx, ecx
  00311	74 09		 je	 SHORT $LN206@WMIex

; 931  :         ::SysFreeString(m_wstr);

  00313	51		 push	 ecx
  00314	ff d7		 call	 edi

; 932  :         m_wstr = NULL;

  00316	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN206@WMIex:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  0031c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0031f	85 c0		 test	 eax, eax
  00321	74 10		 je	 SHORT $LN207@WMIex

; 936  :         delete [] m_str;

  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00329	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  0032c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN207@WMIex:
  00333	6a 0c		 push	 12			; 0000000cH
  00335	56		 push	 esi
  00336	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0033b	83 c4 08	 add	 esp, 8

; 774  :     if (cRef == 0) {

  0033e	8b 85 f8 83 ff
	ff		 mov	 eax, DWORD PTR _hres$4$[ebp]
$LN201@WMIex:

; 639  :         m_Data = NULL;

  00344	c7 85 dc 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T44[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 164  :     if (FAILED(hres))

  0034e	85 c0		 test	 eax, eax
  00350	79 40		 jns	 SHORT $LN39@WMIex

; 165  :     {
; 166  :         Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, Could not connect, 0x%.8x", hres);

  00352	50		 push	 eax
  00353	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BGNNPBKC@?$DM?$DM?5WMI?0?5Could?5not?5connect?0?50x?$CF?4@
  00358	68 a6 00 00 00	 push	 166			; 000000a6H
  0035d	6a 40		 push	 64			; 00000040H
  0035f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00364	83 c4 10	 add	 esp, 16			; 00000010H
$LN2893@WMIex:

; 718  : }

  00367	8b 85 d0 83 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  0036d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0036f	50		 push	 eax
  00370	ff 51 08	 call	 DWORD PTR [ecx+8]
  00373	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
  00379	8b b5 5c 83 ff
	ff		 mov	 esi, DWORD PTR _hWmiMutex$[ebp]
  0037f	56		 push	 esi
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  00386	56		 push	 esi
  00387	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0038d	e9 92 24 00 00	 jmp	 $LN2881@WMIex
$LN39@WMIex:

; 167  :         pLoc->Release();
; 168  :         CoUninitialize();
; 169  :         ReleaseMutex(hWmiMutex);
; 170  :         CloseHandle(hWmiMutex);
; 171  :         return true;
; 172  :     }
; 173  : 
; 174  :     Log(LOG_DEBUG_WMI, __LINE__, "-- WMI, Connected to ROOT\\CIMV2 WMI namespace");

  00392	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@HCPFANAN@?9?9?5WMI?0?5Connected?5to?5ROOT?2CIMV2@
  00397	68 ae 00 00 00	 push	 174			; 000000aeH
  0039c	6a 40		 push	 64			; 00000040H
  0039e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 175  : 
; 176  :     // Set the IWbemServices proxy so that impersonation
; 177  :     // of the user (client) occurs.
; 178  :     hres = CoSetProxyBlanket(

  003a6	6a 00		 push	 0
  003a8	6a 00		 push	 0
  003aa	6a 03		 push	 3
  003ac	6a 03		 push	 3
  003ae	6a 00		 push	 0
  003b0	6a 00		 push	 0
  003b2	6a 0a		 push	 10			; 0000000aH
  003b4	ff b5 d4 83 ff
	ff		 push	 DWORD PTR _pSvc$[ebp]
  003ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoSetProxyBlanket@32

; 179  :         pSvc,                         // the proxy to set
; 180  :         RPC_C_AUTHN_WINNT,            // authentication service
; 181  :         RPC_C_AUTHZ_NONE,             // authorization service
; 182  :         NULL,                         // Server principal name
; 183  :         RPC_C_AUTHN_LEVEL_CALL,       // authentication level
; 184  :         RPC_C_IMP_LEVEL_IMPERSONATE,  // impersonation level
; 185  :         NULL,                         // client identity 
; 186  :         EOAC_NONE                     // proxy capabilities     
; 187  :     );
; 188  : 
; 189  :     if (FAILED(hres))

  003c0	85 c0		 test	 eax, eax
  003c2	79 23		 jns	 SHORT $LN40@WMIex

; 190  :     {
; 191  :         Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, Could not set proxy blanket, 0x%.8x", hres);

  003c4	50		 push	 eax
  003c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PEEMIANH@?$DM?$DM?5WMI?0?5Could?5not?5set?5proxy?5bla@
  003ca	68 bf 00 00 00	 push	 191			; 000000bfH
  003cf	6a 40		 push	 64			; 00000040H
  003d1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003d6	83 c4 10	 add	 esp, 16			; 00000010H

; 192  :         pSvc->Release();

  003d9	8b 85 d4 83 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  003df	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e1	50		 push	 eax
  003e2	ff 51 08	 call	 DWORD PTR [ecx+8]

; 193  :         pLoc->Release();
; 194  :         CoUninitialize();
; 195  :         ReleaseMutex(hWmiMutex);
; 196  :         CloseHandle(hWmiMutex);
; 197  :         return true;

  003e5	eb 80		 jmp	 SHORT $LN2893@WMIex
$LN40@WMIex:

; 198  :     }
; 199  : 
; 200  :     // Use the IWbemServices pointer to make requests of WMI. 
; 201  :     // Make requests here:
; 202  : 
; 203  :     char szSelect[_MAX_PATH] = { 0 };

  003e7	68 04 01 00 00	 push	 260			; 00000104H
  003ec	6a 00		 push	 0
  003ee	8d 85 58 fb ff
	ff		 lea	 eax, DWORD PTR _szSelect$[ebp]
  003f4	50		 push	 eax
  003f5	e8 00 00 00 00	 call	 _memset
  003fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  :     _snprintf(szSelect, sizeof(szSelect), "SELECT * FROM %s", lpszOption);

  003fd	8b b5 d8 83 ff
	ff		 mov	 esi, DWORD PTR _lpszOption$GSCopy$1$[ebp]
  00403	56		 push	 esi
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MNPFNNGI@SELECT?5?$CK?5FROM?5?$CFs@
  00409	68 04 01 00 00	 push	 260			; 00000104H
  0040e	8d 85 58 fb ff
	ff		 lea	 eax, DWORD PTR _szSelect$[ebp]
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 __snprintf

; 205  :     Log(LOG_DEBUG_WMI, __LINE__, "-- WMI, Querying properties for %s", lpszOption);

  0041a	56		 push	 esi
  0041b	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@LDAAPKBB@?9?9?5WMI?0?5Querying?5properties?5for@
  00420	68 cd 00 00 00	 push	 205			; 000000cdH
  00425	6a 40		 push	 64			; 00000040H
  00427	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0042c	83 c4 20	 add	 esp, 32			; 00000020H

; 206  : 
; 207  :     // Query for all properties
; 208  :     IEnumWbemClassObject* pEnumerator = NULL;

  0042f	c7 85 64 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _pEnumerator$[ebp], 0

; 209  :     hres = pSvc->ExecQuery(

  00439	8b 85 d4 83 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  0043f	8b 00		 mov	 eax, DWORD PTR [eax]
  00441	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00444	89 85 f8 83 ff
	ff		 mov	 DWORD PTR tv6888[ebp], eax
  0044a	8d 85 58 fb ff
	ff		 lea	 eax, DWORD PTR _szSelect$[ebp]
  00450	50		 push	 eax
  00451	8d 8d c8 83 ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00457	e8 00 00 00 00	 call	 ??0_bstr_t@@QAE@PBD@Z	; _bstr_t::_bstr_t
  0045c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

  00463	8b 30		 mov	 esi, DWORD PTR [eax]
  00465	85 f6		 test	 esi, esi
  00467	74 04		 je	 SHORT $LN211@WMIex
  00469	8b 36		 mov	 esi, DWORD PTR [esi]
  0046b	eb 02		 jmp	 SHORT $LN212@WMIex
$LN211@WMIex:
  0046d	33 f6		 xor	 esi, esi
$LN212@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 209  :     hres = pSvc->ExecQuery(

  0046f	68 00 00 00 00	 push	 OFFSET ??_C@_03LJNDFDHG@WQL@
  00474	8d 8d fc 83 ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  0047a	e8 00 00 00 00	 call	 ??0_bstr_t@@QAE@PBD@Z	; _bstr_t::_bstr_t
  0047f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 479  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

  00483	8b 00		 mov	 eax, DWORD PTR [eax]
  00485	85 c0		 test	 eax, eax
  00487	74 04		 je	 SHORT $LN217@WMIex
  00489	8b 00		 mov	 eax, DWORD PTR [eax]
  0048b	eb 02		 jmp	 SHORT $LN218@WMIex
$LN217@WMIex:
  0048d	33 c0		 xor	 eax, eax
$LN218@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 209  :     hres = pSvc->ExecQuery(

  0048f	8d 8d 64 83 ff
	ff		 lea	 ecx, DWORD PTR _pEnumerator$[ebp]
  00495	51		 push	 ecx
  00496	6a 00		 push	 0
  00498	6a 30		 push	 48			; 00000030H
  0049a	56		 push	 esi
  0049b	50		 push	 eax
  0049c	ff b5 d4 83 ff
	ff		 push	 DWORD PTR _pSvc$[ebp]
  004a2	ff 95 f8 83 ff
	ff		 call	 DWORD PTR tv6888[ebp]
  004a8	89 85 f8 83 ff
	ff		 mov	 DWORD PTR _hres$6$[ebp], eax
  004ae	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 637  :     if (m_Data != NULL) {

  004b2	8b b5 fc 83 ff
	ff		 mov	 esi, DWORD PTR $T50[ebp]
  004b8	85 f6		 test	 esi, esi
  004ba	74 4a		 je	 SHORT $LN224@WMIex

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  004bc	83 c9 ff	 or	 ecx, -1
  004bf	f0 0f c1 4e 08	 lock	  xadd	 DWORD PTR [esi+8], ecx
  004c4	49		 dec	 ecx

; 774  :     if (cRef == 0) {

  004c5	75 35		 jne	 SHORT $LN232@WMIex

; 775  :         delete this;

  004c7	85 f6		 test	 esi, esi
  004c9	74 31		 je	 SHORT $LN232@WMIex

; 930  :     if (m_wstr != NULL) {

  004cb	8b 06		 mov	 eax, DWORD PTR [esi]
  004cd	85 c0		 test	 eax, eax
  004cf	74 09		 je	 SHORT $LN237@WMIex

; 931  :         ::SysFreeString(m_wstr);

  004d1	50		 push	 eax
  004d2	ff d7		 call	 edi

; 932  :         m_wstr = NULL;

  004d4	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN237@WMIex:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  004da	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  004dd	85 c0		 test	 eax, eax
  004df	74 10		 je	 SHORT $LN238@WMIex

; 936  :         delete [] m_str;

  004e1	50		 push	 eax
  004e2	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  004e7	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  004ea	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN238@WMIex:
  004f1	6a 0c		 push	 12			; 0000000cH
  004f3	56		 push	 esi
  004f4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004f9	83 c4 08	 add	 esp, 8
$LN232@WMIex:

; 639  :         m_Data = NULL;

  004fc	c7 85 fc 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp], 0
$LN224@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 209  :     hres = pSvc->ExecQuery(

  00506	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 637  :     if (m_Data != NULL) {

  0050d	8b b5 c8 83 ff
	ff		 mov	 esi, DWORD PTR $T43[ebp]
  00513	85 f6		 test	 esi, esi
  00515	74 4a		 je	 SHORT $LN243@WMIex

; 773  :     unsigned long cRef = InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount));

  00517	83 c8 ff	 or	 eax, -1
  0051a	f0 0f c1 46 08	 lock	  xadd	 DWORD PTR [esi+8], eax
  0051f	48		 dec	 eax

; 774  :     if (cRef == 0) {

  00520	75 35		 jne	 SHORT $LN251@WMIex

; 775  :         delete this;

  00522	85 f6		 test	 esi, esi
  00524	74 31		 je	 SHORT $LN251@WMIex

; 930  :     if (m_wstr != NULL) {

  00526	8b 06		 mov	 eax, DWORD PTR [esi]
  00528	85 c0		 test	 eax, eax
  0052a	74 09		 je	 SHORT $LN256@WMIex

; 931  :         ::SysFreeString(m_wstr);

  0052c	50		 push	 eax
  0052d	ff d7		 call	 edi

; 932  :         m_wstr = NULL;

  0052f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN256@WMIex:

; 933  :     }
; 934  : 
; 935  :     if (m_str != NULL) {

  00535	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00538	85 c0		 test	 eax, eax
  0053a	74 10		 je	 SHORT $LN257@WMIex

; 936  :         delete [] m_str;

  0053c	50		 push	 eax
  0053d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00542	83 c4 04	 add	 esp, 4

; 937  :         m_str = NULL;

  00545	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN257@WMIex:
  0054c	6a 0c		 push	 12			; 0000000cH
  0054e	56		 push	 esi
  0054f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00554	83 c4 08	 add	 esp, 8
$LN251@WMIex:

; 639  :         m_Data = NULL;

  00557	c7 85 c8 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T43[ebp], 0
$LN243@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 216  :     if (xml)

  00561	8b bd 60 83 ff
	ff		 mov	 edi, DWORD PTR _xml$GSCopy$1$[ebp]
  00567	85 ff		 test	 edi, edi
  00569	0f 84 f2 00 00
	00		 je	 $LN41@WMIex
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0056f	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tag$76[ebp+16], 0

; 1785 : 		_Myres(0)

  00579	c7 85 24 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tag$76[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  00583	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tag$76[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0058d	c7 85 24 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _tag$76[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00597	c6 85 10 86 ff
	ff 00		 mov	 BYTE PTR _tag$76[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 218  :         std::string tag;

  0059e	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 219  :         tag.assign(&lpszOption[6]); //minus: Win32_

  005a5	8b b5 d8 83 ff
	ff		 mov	 esi, DWORD PTR _lpszOption$GSCopy$1$[ebp]
  005ab	8d 46 06	 lea	 eax, DWORD PTR [esi+6]
  005ae	50		 push	 eax
  005af	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _tag$76[ebp]
  005b5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 220  :         xml->Createtag(tag);

  005ba	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _tag$76[ebp]
  005c0	50		 push	 eax
  005c1	8b cf		 mov	 ecx, edi
  005c3	e8 00 00 00 00	 call	 ?Createtag@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::Createtag
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1803 : 		value_type * _Result = _Bx._Buf;

  005c8	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _tag$76[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  005ce	83 bd 24 86 ff
	ff 10		 cmp	 DWORD PTR _tag$76[ebp+20], 16 ; 00000010H

; 1804 : 		if (_Large_string_engaged())

  005d5	0f 43 85 10 86
	ff ff		 cmovae	 eax, DWORD PTR _tag$76[ebp]

; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  005dc	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tag$76[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  005e6	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 223  :         tag.assign(lpszOption);

  005e9	56		 push	 esi
  005ea	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _tag$76[ebp]
  005f0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 224  :         xml->AddComment(tag);

  005f5	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _tag$76[ebp]
  005fb	50		 push	 eax
  005fc	8b cf		 mov	 ecx, edi
  005fe	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 225  :     }

  00603	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0060a	8b 95 24 86 ff
	ff		 mov	 edx, DWORD PTR _tag$76[ebp+20]
  00610	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00613	72 2f		 jb	 SHORT $LN336@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00615	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00616	8b 8d 10 86 ff
	ff		 mov	 ecx, DWORD PTR _tag$76[ebp]
  0061c	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0061e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00624	72 14		 jb	 SHORT $LN335@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00626	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00629	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0062c	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0062e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00631	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00634	0f 87 1e 22 00
	00		 ja	 $LN2897@WMIex
$LN335@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0063a	52		 push	 edx
  0063b	51		 push	 ecx
  0063c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00641	83 c4 08	 add	 esp, 8
$LN336@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00644	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _tag$76[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0064e	c7 85 24 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _tag$76[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00658	c6 85 10 86 ff
	ff 00		 mov	 BYTE PTR _tag$76[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 226  :     else

  0065f	eb 16		 jmp	 SHORT $LN42@WMIex
$LN41@WMIex:

; 227  :     {
; 228  :         Log(LOG_HEADER, __LINE__, lpszOption);

  00661	8b b5 d8 83 ff
	ff		 mov	 esi, DWORD PTR _lpszOption$GSCopy$1$[ebp]
  00667	56		 push	 esi
  00668	68 e4 00 00 00	 push	 228			; 000000e4H
  0066d	6a 02		 push	 2
  0066f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00674	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@WMIex:

; 229  :     }
; 230  : 
; 231  :     if (FAILED(hres))

  00677	8b 85 f8 83 ff
	ff		 mov	 eax, DWORD PTR _hres$6$[ebp]
  0067d	85 c0		 test	 eax, eax
  0067f	0f 89 cd 00 00
	00		 jns	 $LN43@WMIex

; 232  :     {
; 233  :         Log(LOG_DEBUG_WMI, __LINE__, "-- WMI, Query for %s failed, 0x%.8x", lpszOption, hres);

  00685	50		 push	 eax
  00686	56		 push	 esi
  00687	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EKEEEJHG@?9?9?5WMI?0?5Query?5for?5?$CFs?5failed?0?50x@
  0068c	68 e9 00 00 00	 push	 233			; 000000e9H
  00691	6a 40		 push	 64			; 00000040H
  00693	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00698	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@WMIex:

; 667  :     }
; 668  : 
; 669  :     //process the number of properties processed
; 670  :     if (lpulProperties) {

  0069b	8b 85 54 83 ff
	ff		 mov	 eax, DWORD PTR _lpulProperties$GSCopy$[ebp]
  006a1	8b b5 cc 83 ff
	ff		 mov	 esi, DWORD PTR _properties$1$[ebp]
  006a7	85 c0		 test	 eax, eax
  006a9	74 02		 je	 SHORT $LN116@WMIex

; 671  :         *lpulProperties = properties;

  006ab	89 30		 mov	 DWORD PTR [eax], esi
$LN116@WMIex:

; 672  :     }
; 673  : 
; 674  :     char processed[_MAX_PATH] = { 0 };

  006ad	68 04 01 00 00	 push	 260			; 00000104H
  006b2	6a 00		 push	 0
  006b4	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR _processed$[ebp]
  006ba	50		 push	 eax
  006bb	e8 00 00 00 00	 call	 _memset
  006c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 675  :     _snprintf(processed, sizeof(processed), "%lu properties processed", properties);

  006c3	56		 push	 esi
  006c4	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LOAJDHFE@?$CFlu?5properties?5processed@
  006c9	68 04 01 00 00	 push	 260			; 00000104H
  006ce	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR _processed$[ebp]
  006d4	50		 push	 eax
  006d5	e8 00 00 00 00	 call	 __snprintf
  006da	83 c4 10	 add	 esp, 16			; 00000010H

; 676  : 
; 677  :     if (xml)

  006dd	85 ff		 test	 edi, edi
  006df	0f 84 19 1f 00
	00		 je	 $LN117@WMIex
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  006e5	c7 85 08 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$73[ebp+16], 0

; 1785 : 		_Myres(0)

  006ef	c7 85 0c 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$73[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  006f9	c7 85 08 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$73[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00703	c7 85 0c 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _temp$73[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0070d	c6 85 f8 85 ff
	ff 00		 mov	 BYTE PTR _temp$73[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 679  :         std::string temp;

  00714	c7 45 fc 25 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 37 ; 00000025H

; 680  :         temp.append(processed);

  0071b	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR _processed$[ebp]
  00721	50		 push	 eax
  00722	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _temp$73[ebp]
  00728	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 681  :         xml->AddComment(temp);

  0072d	8d 85 f8 85 ff
	ff		 lea	 eax, DWORD PTR _temp$73[ebp]
  00733	50		 push	 eax
  00734	8b cf		 mov	 ecx, edi
  00736	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 682  :     }

  0073b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00742	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _temp$73[ebp]
  00748	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 683  :     else

  0074d	e9 c2 1e 00 00	 jmp	 $LN118@WMIex
$LN43@WMIex:

; 234  :     }
; 235  :     else
; 236  :     {
; 237  :         IWbemClassObject *pclsObj;
; 238  :         ULONG uReturn = 0;

  00752	c7 85 c8 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _uReturn$42[ebp], 0
  0075c	0f 1f 40 00	 npad	 4
$LL2@WMIex:

; 239  : 
; 240  :         while (pEnumerator && _thGetInt(&gbTerminate) == FALSE)

  00760	83 bd 64 83 ff
	ff 00		 cmp	 DWORD PTR _pEnumerator$[ebp], 0
  00767	0f 84 2e ff ff
	ff		 je	 $LN3@WMIex
  0076d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gbTerminate@@3HA ; gbTerminate
  00772	e8 00 00 00 00	 call	 ?_thGetInt@@YAHPAH@Z	; _thGetInt
  00777	85 c0		 test	 eax, eax
  00779	0f 85 1c ff ff
	ff		 jne	 $LN3@WMIex

; 241  :         {
; 242  :             hres = pEnumerator->Next(WBEM_INFINITE, 1,

  0077f	8b 8d 64 83 ff
	ff		 mov	 ecx, DWORD PTR _pEnumerator$[ebp]
  00785	8b 01		 mov	 eax, DWORD PTR [ecx]
  00787	8d 95 c8 83 ff
	ff		 lea	 edx, DWORD PTR _uReturn$42[ebp]
  0078d	52		 push	 edx
  0078e	8d 95 f8 83 ff
	ff		 lea	 edx, DWORD PTR _pclsObj$48[ebp]
  00794	52		 push	 edx
  00795	6a 01		 push	 1
  00797	6a ff		 push	 -1
  00799	51		 push	 ecx
  0079a	ff 50 10	 call	 DWORD PTR [eax+16]

; 243  :                 &pclsObj, &uReturn);
; 244  : 
; 245  :             if (0 == uReturn)

  0079d	83 bd c8 83 ff
	ff 00		 cmp	 DWORD PTR _uReturn$42[ebp], 0
  007a4	0f 84 f1 fe ff
	ff		 je	 $LN3@WMIex

; 246  :             {
; 247  :                 break;
; 248  :             }
; 249  : 
; 250  :             //line.clear();
; 251  :             for (int x = 0; wmiClasses[x].pClass != NULL && _thGetInt(&gbTerminate) == FALSE; x++)

  007aa	33 f6		 xor	 esi, esi
$LN2890@WMIex:
  007ac	89 b5 fc 83 ff
	ff		 mov	 DWORD PTR _x$49[ebp], esi
  007b2	83 3c f5 00 00
	00 00 00	 cmp	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8], 0
  007ba	0f 84 2d 1e 00
	00		 je	 $LN5@WMIex
  007c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?gbTerminate@@3HA ; gbTerminate
  007c5	e8 00 00 00 00	 call	 ?_thGetInt@@YAHPAH@Z	; _thGetInt
  007ca	85 c0		 test	 eax, eax
  007cc	0f 85 1b 1e 00
	00		 jne	 $LN5@WMIex

; 252  :             {
; 253  :                 if (strcmp(wmiClasses[x].pClass, lpszOption) != 0)

  007d2	8b 34 f5 00 00
	00 00		 mov	 esi, DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8]
  007d9	8b 8d d8 83 ff
	ff		 mov	 ecx, DWORD PTR _lpszOption$GSCopy$1$[ebp]
  007df	8b c6		 mov	 eax, esi
$LL2850@WMIex:
  007e1	8a 10		 mov	 dl, BYTE PTR [eax]
  007e3	3a 11		 cmp	 dl, BYTE PTR [ecx]
  007e5	75 1a		 jne	 SHORT $LN2851@WMIex
  007e7	84 d2		 test	 dl, dl
  007e9	74 12		 je	 SHORT $LN2852@WMIex
  007eb	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  007ee	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  007f1	75 0e		 jne	 SHORT $LN2851@WMIex
  007f3	83 c0 02	 add	 eax, 2
  007f6	83 c1 02	 add	 ecx, 2
  007f9	84 d2		 test	 dl, dl
  007fb	75 e4		 jne	 SHORT $LL2850@WMIex
$LN2852@WMIex:
  007fd	33 c0		 xor	 eax, eax
  007ff	eb 05		 jmp	 SHORT $LN2853@WMIex
$LN2851@WMIex:
  00801	1b c0		 sbb	 eax, eax
  00803	83 c8 01	 or	 eax, 1
$LN2853@WMIex:
  00806	85 c0		 test	 eax, eax
  00808	74 11		 je	 SHORT $LN46@WMIex

; 254  :                 {
; 255  :                     Sleep(MILLISECOND);

  0080a	6a 01		 push	 1
  0080c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 246  :             {
; 247  :                 break;
; 248  :             }
; 249  : 
; 250  :             //line.clear();
; 251  :             for (int x = 0; wmiClasses[x].pClass != NULL && _thGetInt(&gbTerminate) == FALSE; x++)

  00812	8b b5 fc 83 ff
	ff		 mov	 esi, DWORD PTR _x$49[ebp]
  00818	46		 inc	 esi
  00819	eb 91		 jmp	 SHORT $LN2890@WMIex
$LN46@WMIex:

; 256  :                     continue;
; 257  :                 }
; 258  :                 VARIANT vtProp;
; 259  :                 WCHAR tszProperty[10000]{};

  0081b	68 20 4e 00 00	 push	 20000			; 00004e20H
  00820	6a 00		 push	 0
  00822	8d 85 28 86 ff
	ff		 lea	 eax, DWORD PTR _tszProperty$77[ebp]
  00828	50		 push	 eax
  00829	e8 00 00 00 00	 call	 _memset
  0082e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 260  :                 CHAR szValue[10000]{};

  00831	68 10 27 00 00	 push	 10000			; 00002710H
  00836	6a 00		 push	 0
  00838	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0083e	50		 push	 eax
  0083f	e8 00 00 00 00	 call	 _memset
  00844	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  : 
; 262  :                 properties++;

  00847	8b 8d cc 83 ff
	ff		 mov	 ecx, DWORD PTR _properties$1$[ebp]
  0084d	41		 inc	 ecx
  0084e	89 8d cc 83 ff
	ff		 mov	 DWORD PTR _properties$1$[ebp], ecx
  00854	89 8d dc 83 ff
	ff		 mov	 DWORD PTR _properties$[ebp], ecx

; 263  :                 Log(LOG_DEBUG_WMI, __LINE__, "-- WMI, Processing %.5u %s (%i) %s", properties, wmiClasses[x].pClass, x + 1, wmiClasses[x].pProperty);

  0085a	8b 85 fc 83 ff
	ff		 mov	 eax, DWORD PTR _x$49[ebp]
  00860	ff 34 c5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[eax*8+4]
  00867	40		 inc	 eax
  00868	50		 push	 eax
  00869	56		 push	 esi
  0086a	51		 push	 ecx
  0086b	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FEICJBGP@?9?9?5WMI?0?5Processing?5?$CF?45u?5?$CFs?5?$CI?$CFi?$CJ@
  00870	68 07 01 00 00	 push	 263			; 00000107H
  00875	6a 40		 push	 64			; 00000040H
  00877	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0087c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 264  : 
; 265  :                 //Convert Name Property to Unicode
; 266  :                 MultiByteToWideChar(CP_ACP, 0, (LPCSTR)wmiClasses[x].pProperty, -1, (LPWSTR)tszProperty, sizeof(tszProperty));

  0087f	68 20 4e 00 00	 push	 20000			; 00004e20H
  00884	8d 85 28 86 ff
	ff		 lea	 eax, DWORD PTR _tszProperty$77[ebp]
  0088a	50		 push	 eax
  0088b	6a ff		 push	 -1
  0088d	8b b5 fc 83 ff
	ff		 mov	 esi, DWORD PTR _x$49[ebp]
  00893	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  0089a	6a 00		 push	 0
  0089c	6a 00		 push	 0
  0089e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 267  : 
; 268  :                 // Get the value of the Name property
; 269  :                 hres = pclsObj->Get(tszProperty, 0, &vtProp, 0, 0);

  008a4	8b 8d f8 83 ff
	ff		 mov	 ecx, DWORD PTR _pclsObj$48[ebp]
  008aa	8b 01		 mov	 eax, DWORD PTR [ecx]
  008ac	6a 00		 push	 0
  008ae	6a 00		 push	 0
  008b0	8d 95 e0 83 ff
	ff		 lea	 edx, DWORD PTR _vtProp$45[ebp]
  008b6	52		 push	 edx
  008b7	6a 00		 push	 0
  008b9	8d 95 28 86 ff
	ff		 lea	 edx, DWORD PTR _tszProperty$77[ebp]
  008bf	52		 push	 edx
  008c0	51		 push	 ecx
  008c1	ff 50 10	 call	 DWORD PTR [eax+16]

; 270  :                 if (FAILED(hres))

  008c4	85 c0		 test	 eax, eax
  008c6	0f 88 15 1d 00
	00		 js	 $LN4@WMIex

; 271  :                 {
; 272  :                     //read next property of option
; 273  :                     continue;
; 274  :                 }
; 275  : 
; 276  :                 try

  008cc	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 5
  008d3	9b		 fwait
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  008d4	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _value$75[ebp+16], 0

; 1785 : 		_Myres(0)

  008de	c7 85 24 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _value$75[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  008e8	c7 85 20 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _value$75[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  008f2	c7 85 24 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _value$75[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  008fc	c6 85 10 86 ff
	ff 00		 mov	 BYTE PTR _value$75[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 278  :                     std::string value;

  00903	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6

; 279  :                     char temp[_MAX_PATH] = { 0 };

  00907	68 04 01 00 00	 push	 260			; 00000104H
  0090c	6a 00		 push	 0
  0090e	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00914	50		 push	 eax
  00915	e8 00 00 00 00	 call	 _memset
  0091a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 280  : 
; 281  :                     switch (vtProp.vt)

  0091d	8b 8d e0 83 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$45[ebp]
  00923	0f b7 c1	 movzx	 eax, cx
  00926	83 c0 fe	 add	 eax, -2			; fffffffeH
  00929	83 f8 13	 cmp	 eax, 19			; 00000013H
  0092c	0f 87 56 0d 00
	00		 ja	 $LN89@WMIex
  00932	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN2921@WMIex[eax*4]
$LN49@WMIex:

; 282  :                     {
; 283  :                     case VT_I1:
; 284  :                         if (xml)

  00939	0f be 85 e8 83
	ff ff		 movsx	 eax, BYTE PTR _vtProp$45[ebp+8]
  00940	50		 push	 eax
  00941	85 ff		 test	 edi, edi
  00943	0f 84 d8 00 00
	00		 je	 $LN50@WMIex

; 285  :                         {
; 286  :                             _snprintf(temp, sizeof(temp), "0x%.2X", vtProp.cVal);

  00949	68 00 00 00 00	 push	 OFFSET ??_C@_06DBMAJEKE@0x?$CF?42X@
  0094e	68 04 01 00 00	 push	 260			; 00000104H
  00953	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00959	50		 push	 eax
  0095a	e8 00 00 00 00	 call	 __snprintf
  0095f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00962	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00968	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0096b	0f 1f 44 00 00	 npad	 5
$LL2854@WMIex:
  00970	8a 01		 mov	 al, BYTE PTR [ecx]
  00972	41		 inc	 ecx
  00973	84 c0		 test	 al, al
  00975	75 f9		 jne	 SHORT $LL2854@WMIex
  00977	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00979	51		 push	 ecx
  0097a	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00980	50		 push	 eax
  00981	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00987	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 288  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  0098c	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00993	8d 8d 38 85 ff
	ff		 lea	 ecx, DWORD PTR $T64[ebp]
  00999	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0099e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
  009a2	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  009a8	50		 push	 eax
  009a9	8d 85 38 85 ff
	ff		 lea	 eax, DWORD PTR $T64[ebp]
  009af	50		 push	 eax
  009b0	8b cf		 mov	 ecx, edi
  009b2	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  009b7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  009bb	8b 8d 4c 85 ff
	ff		 mov	 ecx, DWORD PTR $T64[ebp+20]
  009c1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  009c4	72 3b		 jb	 SHORT $LN430@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  009c6	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009c7	89 8d 18 83 ff
	ff		 mov	 DWORD PTR __Bytes$22[ebp], ecx
  009cd	8b 95 38 85 ff
	ff		 mov	 edx, DWORD PTR $T64[ebp]
  009d3	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  009d5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  009db	72 1a		 jb	 SHORT $LN429@WMIex

; 115  : 	_Bytes += _Non_user_size;

  009dd	83 c1 23	 add	 ecx, 35			; 00000023H
  009e0	89 8d 18 83 ff
	ff		 mov	 DWORD PTR __Bytes$22[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  009e6	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  009e9	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  009ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009f1	0f 87 66 1e 00
	00		 ja	 $LN2898@WMIex
$LN429@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  009f7	51		 push	 ecx
  009f8	52		 push	 edx
  009f9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009fe	83 c4 08	 add	 esp, 8
$LN430@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00a01	c7 85 48 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T64[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00a0b	c7 85 4c 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T64[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00a15	c6 85 38 85 ff
	ff 00		 mov	 BYTE PTR $T64[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 290  :                         else

  00a1c	e9 27 1b 00 00	 jmp	 $LN90@WMIex
$LN50@WMIex:

; 291  :                         {
; 292  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.2X", wmiClasses[x].pProperty, vtProp.cVal);

  00a21	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00a28	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X@
  00a2d	68 24 01 00 00	 push	 292			; 00000124H
  00a32	6a 01		 push	 1
  00a34	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00a39	83 c4 14	 add	 esp, 20			; 00000014H

; 293  :                         }
; 294  :                         break;

  00a3c	e9 07 1b 00 00	 jmp	 $LN90@WMIex
$LN52@WMIex:

; 295  : 
; 296  :                     case VT_UI1:
; 297  :                         if (xml)

  00a41	0f b6 85 e8 83
	ff ff		 movzx	 eax, BYTE PTR _vtProp$45[ebp+8]
  00a48	50		 push	 eax
  00a49	85 ff		 test	 edi, edi
  00a4b	0f 84 d3 00 00
	00		 je	 $LN53@WMIex

; 298  :                         {
; 299  :                             _snprintf(temp, sizeof(temp), "0x%.2X", vtProp.bVal);

  00a51	68 00 00 00 00	 push	 OFFSET ??_C@_06DBMAJEKE@0x?$CF?42X@
  00a56	68 04 01 00 00	 push	 260			; 00000104H
  00a5b	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00a61	50		 push	 eax
  00a62	e8 00 00 00 00	 call	 __snprintf
  00a67	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00a6a	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00a70	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2855@WMIex:
  00a73	8a 01		 mov	 al, BYTE PTR [ecx]
  00a75	41		 inc	 ecx
  00a76	84 c0		 test	 al, al
  00a78	75 f9		 jne	 SHORT $LL2855@WMIex
  00a7a	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a7c	51		 push	 ecx
  00a7d	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00a83	50		 push	 eax
  00a84	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00a8a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 301  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  00a8f	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00a96	8d 8d 50 85 ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  00a9c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00aa1	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
  00aa5	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  00aab	50		 push	 eax
  00aac	8d 85 50 85 ff
	ff		 lea	 eax, DWORD PTR $T65[ebp]
  00ab2	50		 push	 eax
  00ab3	8b cf		 mov	 ecx, edi
  00ab5	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  00aba	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00abe	8b 8d 64 85 ff
	ff		 mov	 ecx, DWORD PTR $T65[ebp+20]
  00ac4	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00ac7	72 3b		 jb	 SHORT $LN492@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ac9	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aca	89 8d f0 82 ff
	ff		 mov	 DWORD PTR __Bytes$12[ebp], ecx
  00ad0	8b 95 50 85 ff
	ff		 mov	 edx, DWORD PTR $T65[ebp]
  00ad6	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00ad8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00ade	72 1a		 jb	 SHORT $LN491@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00ae0	83 c1 23	 add	 ecx, 35			; 00000023H
  00ae3	89 8d f0 82 ff
	ff		 mov	 DWORD PTR __Bytes$12[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00ae9	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00aec	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00aee	83 c0 fc	 add	 eax, -4			; fffffffcH
  00af1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00af4	0f 87 68 1d 00
	00		 ja	 $LN2899@WMIex
$LN491@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00afa	51		 push	 ecx
  00afb	52		 push	 edx
  00afc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b01	83 c4 08	 add	 esp, 8
$LN492@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00b04	c7 85 60 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T65[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b0e	c7 85 64 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T65[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00b18	c6 85 50 85 ff
	ff 00		 mov	 BYTE PTR $T65[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 303  :                         else

  00b1f	e9 24 1a 00 00	 jmp	 $LN90@WMIex
$LN53@WMIex:

; 304  :                         {
; 305  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.2X", wmiClasses[x].pProperty, vtProp.bVal);

  00b24	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00b2b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FJHOFDKM@?$CFs?5?$DN?50x?$CF?42X@
  00b30	68 31 01 00 00	 push	 305			; 00000131H
  00b35	6a 01		 push	 1
  00b37	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00b3c	83 c4 14	 add	 esp, 20			; 00000014H

; 306  :                         }
; 307  :                         break;

  00b3f	e9 04 1a 00 00	 jmp	 $LN90@WMIex
$LN55@WMIex:

; 308  : 
; 309  :                     case VT_I2:
; 310  :                         if (xml)

  00b44	0f bf 85 e8 83
	ff ff		 movsx	 eax, WORD PTR _vtProp$45[ebp+8]
  00b4b	50		 push	 eax
  00b4c	85 ff		 test	 edi, edi
  00b4e	0f 84 d3 00 00
	00		 je	 $LN56@WMIex

; 311  :                         {
; 312  :                             _snprintf(temp, sizeof(temp), "0x%.4X", vtProp.iVal);

  00b54	68 00 00 00 00	 push	 OFFSET ??_C@_06DFENOIBG@0x?$CF?44X@
  00b59	68 04 01 00 00	 push	 260			; 00000104H
  00b5e	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00b64	50		 push	 eax
  00b65	e8 00 00 00 00	 call	 __snprintf
  00b6a	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00b6d	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00b73	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2856@WMIex:
  00b76	8a 01		 mov	 al, BYTE PTR [ecx]
  00b78	41		 inc	 ecx
  00b79	84 c0		 test	 al, al
  00b7b	75 f9		 jne	 SHORT $LL2856@WMIex
  00b7d	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00b7f	51		 push	 ecx
  00b80	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00b86	50		 push	 eax
  00b87	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00b8d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 314  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  00b92	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00b99	8d 8d 68 85 ff
	ff		 lea	 ecx, DWORD PTR $T66[ebp]
  00b9f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ba4	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
  00ba8	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  00bae	50		 push	 eax
  00baf	8d 85 68 85 ff
	ff		 lea	 eax, DWORD PTR $T66[ebp]
  00bb5	50		 push	 eax
  00bb6	8b cf		 mov	 ecx, edi
  00bb8	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  00bbd	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00bc1	8b 8d 7c 85 ff
	ff		 mov	 ecx, DWORD PTR $T66[ebp+20]
  00bc7	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00bca	72 3b		 jb	 SHORT $LN554@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00bcc	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bcd	89 8d c8 82 ff
	ff		 mov	 DWORD PTR __Bytes$2[ebp], ecx
  00bd3	8b 95 68 85 ff
	ff		 mov	 edx, DWORD PTR $T66[ebp]
  00bd9	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00bdb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00be1	72 1a		 jb	 SHORT $LN553@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00be3	83 c1 23	 add	 ecx, 35			; 00000023H
  00be6	89 8d c8 82 ff
	ff		 mov	 DWORD PTR __Bytes$2[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00bec	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00bef	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00bf1	83 c0 fc	 add	 eax, -4			; fffffffcH
  00bf4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00bf7	0f 87 6a 1c 00
	00		 ja	 $LN2900@WMIex
$LN553@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00bfd	51		 push	 ecx
  00bfe	52		 push	 edx
  00bff	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c04	83 c4 08	 add	 esp, 8
$LN554@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00c07	c7 85 78 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T66[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00c11	c7 85 7c 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T66[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00c1b	c6 85 68 85 ff
	ff 00		 mov	 BYTE PTR $T66[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 316  :                         else

  00c22	e9 21 19 00 00	 jmp	 $LN90@WMIex
$LN56@WMIex:

; 317  :                         {
; 318  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.4X", wmiClasses[x].pProperty, vtProp.iVal);

  00c27	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00c2e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X@
  00c33	68 3e 01 00 00	 push	 318			; 0000013eH
  00c38	6a 01		 push	 1
  00c3a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00c3f	83 c4 14	 add	 esp, 20			; 00000014H

; 319  :                         }
; 320  :                         break;

  00c42	e9 01 19 00 00	 jmp	 $LN90@WMIex
$LN58@WMIex:

; 321  : 
; 322  :                     case VT_UI2:
; 323  :                         if (xml)

  00c47	0f b7 85 e8 83
	ff ff		 movzx	 eax, WORD PTR _vtProp$45[ebp+8]
  00c4e	50		 push	 eax
  00c4f	85 ff		 test	 edi, edi
  00c51	0f 84 da 00 00
	00		 je	 $LN59@WMIex

; 324  :                         {
; 325  :                             _snprintf(temp, sizeof(temp), "0x%.4X", vtProp.uiVal);

  00c57	68 00 00 00 00	 push	 OFFSET ??_C@_06DFENOIBG@0x?$CF?44X@
  00c5c	68 04 01 00 00	 push	 260			; 00000104H
  00c61	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00c67	50		 push	 eax
  00c68	e8 00 00 00 00	 call	 __snprintf
  00c6d	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00c70	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00c76	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00c79	0f 1f 80 00 00
	00 00		 npad	 7
$LL2857@WMIex:
  00c80	8a 01		 mov	 al, BYTE PTR [ecx]
  00c82	41		 inc	 ecx
  00c83	84 c0		 test	 al, al
  00c85	75 f9		 jne	 SHORT $LL2857@WMIex
  00c87	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00c89	51		 push	 ecx
  00c8a	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00c90	50		 push	 eax
  00c91	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00c97	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 327  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  00c9c	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00ca3	8d 8d 80 85 ff
	ff		 lea	 ecx, DWORD PTR $T67[ebp]
  00ca9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00cae	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  00cb2	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  00cb8	50		 push	 eax
  00cb9	8d 85 80 85 ff
	ff		 lea	 eax, DWORD PTR $T67[ebp]
  00cbf	50		 push	 eax
  00cc0	8b cf		 mov	 ecx, edi
  00cc2	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  00cc7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00ccb	8b 8d 94 85 ff
	ff		 mov	 ecx, DWORD PTR $T67[ebp+20]
  00cd1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00cd4	72 3b		 jb	 SHORT $LN616@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00cd6	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00cd7	89 8d cc 82 ff
	ff		 mov	 DWORD PTR __Bytes$3[ebp], ecx
  00cdd	8b 95 80 85 ff
	ff		 mov	 edx, DWORD PTR $T67[ebp]
  00ce3	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00ce5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00ceb	72 1a		 jb	 SHORT $LN615@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00ced	83 c1 23	 add	 ecx, 35			; 00000023H
  00cf0	89 8d cc 82 ff
	ff		 mov	 DWORD PTR __Bytes$3[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00cf6	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00cf9	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00cfb	83 c0 fc	 add	 eax, -4			; fffffffcH
  00cfe	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d01	0f 87 65 1b 00
	00		 ja	 $LN2901@WMIex
$LN615@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00d07	51		 push	 ecx
  00d08	52		 push	 edx
  00d09	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d0e	83 c4 08	 add	 esp, 8
$LN616@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00d11	c7 85 90 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T67[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d1b	c7 85 94 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T67[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00d25	c6 85 80 85 ff
	ff 00		 mov	 BYTE PTR $T67[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 329  :                         else

  00d2c	e9 17 18 00 00	 jmp	 $LN90@WMIex
$LN59@WMIex:

; 330  :                         {
; 331  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.4X", wmiClasses[x].pProperty, vtProp.uiVal);

  00d31	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00d38	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FNPDCPBO@?$CFs?5?$DN?50x?$CF?44X@
  00d3d	68 4b 01 00 00	 push	 331			; 0000014bH
  00d42	6a 01		 push	 1
  00d44	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00d49	83 c4 14	 add	 esp, 20			; 00000014H

; 332  :                         }
; 333  :                         break;

  00d4c	e9 f7 17 00 00	 jmp	 $LN90@WMIex
$LN61@WMIex:

; 334  : 
; 335  :                     case VT_I4:
; 336  :                         if (xml)

  00d51	ff b5 e8 83 ff
	ff		 push	 DWORD PTR _vtProp$45[ebp+8]
  00d57	85 ff		 test	 edi, edi
  00d59	0f 84 d3 00 00
	00		 je	 $LN62@WMIex

; 337  :                         {
; 338  :                             _snprintf(temp, sizeof(temp), "0x%.8X", vtProp.lVal);

  00d5f	68 00 00 00 00	 push	 OFFSET ??_C@_06DMFHBBHC@0x?$CF?48X@
  00d64	68 04 01 00 00	 push	 260			; 00000104H
  00d69	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00d6f	50		 push	 eax
  00d70	e8 00 00 00 00	 call	 __snprintf
  00d75	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00d78	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00d7e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2858@WMIex:
  00d81	8a 01		 mov	 al, BYTE PTR [ecx]
  00d83	41		 inc	 ecx
  00d84	84 c0		 test	 al, al
  00d86	75 f9		 jne	 SHORT $LL2858@WMIex
  00d88	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d8a	51		 push	 ecx
  00d8b	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00d91	50		 push	 eax
  00d92	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00d98	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 340  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  00d9d	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00da4	8d 8d 98 85 ff
	ff		 lea	 ecx, DWORD PTR $T68[ebp]
  00daa	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00daf	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
  00db3	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  00db9	50		 push	 eax
  00dba	8d 85 98 85 ff
	ff		 lea	 eax, DWORD PTR $T68[ebp]
  00dc0	50		 push	 eax
  00dc1	8b cf		 mov	 ecx, edi
  00dc3	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  00dc8	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00dcc	8b 8d ac 85 ff
	ff		 mov	 ecx, DWORD PTR $T68[ebp+20]
  00dd2	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00dd5	72 3b		 jb	 SHORT $LN678@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00dd7	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00dd8	89 8d d0 82 ff
	ff		 mov	 DWORD PTR __Bytes$4[ebp], ecx
  00dde	8b 95 98 85 ff
	ff		 mov	 edx, DWORD PTR $T68[ebp]
  00de4	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00de6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00dec	72 1a		 jb	 SHORT $LN677@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00dee	83 c1 23	 add	 ecx, 35			; 00000023H
  00df1	89 8d d0 82 ff
	ff		 mov	 DWORD PTR __Bytes$4[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00df7	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00dfa	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00dfc	83 c0 fc	 add	 eax, -4			; fffffffcH
  00dff	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00e02	0f 87 69 1a 00
	00		 ja	 $LN2902@WMIex
$LN677@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00e08	51		 push	 ecx
  00e09	52		 push	 edx
  00e0a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00e0f	83 c4 08	 add	 esp, 8
$LN678@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00e12	c7 85 a8 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T68[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e1c	c7 85 ac 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T68[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00e26	c6 85 98 85 ff
	ff 00		 mov	 BYTE PTR $T68[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 342  :                         else

  00e2d	e9 16 17 00 00	 jmp	 $LN90@WMIex
$LN62@WMIex:

; 343  :                         {
; 344  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.8X", wmiClasses[x].pProperty, vtProp.lVal);

  00e32	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00e39	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X@
  00e3e	68 58 01 00 00	 push	 344			; 00000158H
  00e43	6a 01		 push	 1
  00e45	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00e4a	83 c4 14	 add	 esp, 20			; 00000014H

; 345  :                         }
; 346  :                         break;

  00e4d	e9 f6 16 00 00	 jmp	 $LN90@WMIex
$LN64@WMIex:

; 347  : 
; 348  :                     case VT_UI4:
; 349  :                         if (xml)

  00e52	ff b5 e8 83 ff
	ff		 push	 DWORD PTR _vtProp$45[ebp+8]
  00e58	85 ff		 test	 edi, edi
  00e5a	0f 84 d3 00 00
	00		 je	 $LN65@WMIex

; 350  :                         {
; 351  :                             _snprintf(temp, sizeof(temp), "0x%.8X", vtProp.ulVal);

  00e60	68 00 00 00 00	 push	 OFFSET ??_C@_06DMFHBBHC@0x?$CF?48X@
  00e65	68 04 01 00 00	 push	 260			; 00000104H
  00e6a	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00e70	50		 push	 eax
  00e71	e8 00 00 00 00	 call	 __snprintf
  00e76	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00e79	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00e7f	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2859@WMIex:
  00e82	8a 01		 mov	 al, BYTE PTR [ecx]
  00e84	41		 inc	 ecx
  00e85	84 c0		 test	 al, al
  00e87	75 f9		 jne	 SHORT $LL2859@WMIex
  00e89	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e8b	51		 push	 ecx
  00e8c	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00e92	50		 push	 eax
  00e93	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00e99	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 353  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  00e9e	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00ea5	8d 8d b0 85 ff
	ff		 lea	 ecx, DWORD PTR $T69[ebp]
  00eab	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00eb0	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
  00eb4	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  00eba	50		 push	 eax
  00ebb	8d 85 b0 85 ff
	ff		 lea	 eax, DWORD PTR $T69[ebp]
  00ec1	50		 push	 eax
  00ec2	8b cf		 mov	 ecx, edi
  00ec4	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  00ec9	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00ecd	8b 8d c4 85 ff
	ff		 mov	 ecx, DWORD PTR $T69[ebp+20]
  00ed3	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00ed6	72 3b		 jb	 SHORT $LN740@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ed8	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ed9	89 8d d4 82 ff
	ff		 mov	 DWORD PTR __Bytes$5[ebp], ecx
  00edf	8b 95 b0 85 ff
	ff		 mov	 edx, DWORD PTR $T69[ebp]
  00ee5	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00ee7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00eed	72 1a		 jb	 SHORT $LN739@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00eef	83 c1 23	 add	 ecx, 35			; 00000023H
  00ef2	89 8d d4 82 ff
	ff		 mov	 DWORD PTR __Bytes$5[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00ef8	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  00efb	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00efd	83 c0 fc	 add	 eax, -4			; fffffffcH
  00f00	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00f03	0f 87 6d 19 00
	00		 ja	 $LN2903@WMIex
$LN739@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00f09	51		 push	 ecx
  00f0a	52		 push	 edx
  00f0b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00f10	83 c4 08	 add	 esp, 8
$LN740@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00f13	c7 85 c0 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T69[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00f1d	c7 85 c4 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T69[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00f27	c6 85 b0 85 ff
	ff 00		 mov	 BYTE PTR $T69[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 355  :                         else

  00f2e	e9 15 16 00 00	 jmp	 $LN90@WMIex
$LN65@WMIex:

; 356  :                         {
; 357  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.8X", wmiClasses[x].pProperty, vtProp.ulVal);

  00f33	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00f3a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FEOJNGHK@?$CFs?5?$DN?50x?$CF?48X@
  00f3f	68 65 01 00 00	 push	 357			; 00000165H
  00f44	6a 01		 push	 1
  00f46	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00f4b	83 c4 14	 add	 esp, 20			; 00000014H

; 358  :                         }
; 359  :                         break;

  00f4e	e9 f5 15 00 00	 jmp	 $LN90@WMIex
$LN67@WMIex:

; 360  : 
; 361  :                     case VT_I8:
; 362  :                         if (xml)

  00f53	ff b5 ec 83 ff
	ff		 push	 DWORD PTR _vtProp$45[ebp+12]
  00f59	ff b5 e8 83 ff
	ff		 push	 DWORD PTR _vtProp$45[ebp+8]
  00f5f	85 ff		 test	 edi, edi
  00f61	0f 84 da 00 00
	00		 je	 $LN68@WMIex

; 363  :                         {
; 364  :                             _snprintf(temp, sizeof(temp), "0x%llX", vtProp.llVal);

  00f67	68 00 00 00 00	 push	 OFFSET ??_C@_06GGPPAHKI@0x?$CFllX@
  00f6c	68 04 01 00 00	 push	 260			; 00000104H
  00f71	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00f77	50		 push	 eax
  00f78	e8 00 00 00 00	 call	 __snprintf
  00f7d	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00f80	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  00f86	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00f89	0f 1f 80 00 00
	00 00		 npad	 7
$LL2860@WMIex:
  00f90	8a 01		 mov	 al, BYTE PTR [ecx]
  00f92	41		 inc	 ecx
  00f93	84 c0		 test	 al, al
  00f95	75 f9		 jne	 SHORT $LL2860@WMIex
  00f97	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00f99	51		 push	 ecx
  00f9a	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  00fa0	50		 push	 eax
  00fa1	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  00fa7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 366  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  00fac	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  00fb3	8d 8d c8 85 ff
	ff		 lea	 ecx, DWORD PTR $T70[ebp]
  00fb9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00fbe	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH
  00fc2	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  00fc8	50		 push	 eax
  00fc9	8d 85 c8 85 ff
	ff		 lea	 eax, DWORD PTR $T70[ebp]
  00fcf	50		 push	 eax
  00fd0	8b cf		 mov	 ecx, edi
  00fd2	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  00fd7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00fdb	8b 8d dc 85 ff
	ff		 mov	 ecx, DWORD PTR $T70[ebp+20]
  00fe1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00fe4	72 3b		 jb	 SHORT $LN802@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00fe6	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00fe7	89 8d d8 82 ff
	ff		 mov	 DWORD PTR __Bytes$6[ebp], ecx
  00fed	8b 95 c8 85 ff
	ff		 mov	 edx, DWORD PTR $T70[ebp]
  00ff3	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00ff5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00ffb	72 1a		 jb	 SHORT $LN801@WMIex

; 115  : 	_Bytes += _Non_user_size;

  00ffd	83 c1 23	 add	 ecx, 35			; 00000023H
  01000	89 8d d8 82 ff
	ff		 mov	 DWORD PTR __Bytes$6[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01006	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01009	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0100b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0100e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01011	0f 87 64 18 00
	00		 ja	 $LN2904@WMIex
$LN801@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01017	51		 push	 ecx
  01018	52		 push	 edx
  01019	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0101e	83 c4 08	 add	 esp, 8
$LN802@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01021	c7 85 d8 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T70[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0102b	c7 85 dc 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T70[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01035	c6 85 c8 85 ff
	ff 00		 mov	 BYTE PTR $T70[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 368  :                         else

  0103c	e9 07 15 00 00	 jmp	 $LN90@WMIex
$LN68@WMIex:

; 369  :                         {
; 370  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.16X", wmiClasses[x].pProperty, vtProp.llVal);

  01041	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  01048	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PNKHAPAI@?$CFs?5?$DN?50x?$CF?416X@
  0104d	68 72 01 00 00	 push	 370			; 00000172H
  01052	6a 01		 push	 1
  01054	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01059	83 c4 18	 add	 esp, 24			; 00000018H

; 371  :                         }
; 372  :                         break;

  0105c	e9 e7 14 00 00	 jmp	 $LN90@WMIex
$LN70@WMIex:

; 373  : 
; 374  :                     case VT_UI8:
; 375  :                         if (xml)

  01061	ff b5 ec 83 ff
	ff		 push	 DWORD PTR _vtProp$45[ebp+12]
  01067	ff b5 e8 83 ff
	ff		 push	 DWORD PTR _vtProp$45[ebp+8]
  0106d	85 ff		 test	 edi, edi
  0106f	0f 84 d3 00 00
	00		 je	 $LN71@WMIex

; 376  :                         {
; 377  :                             _snprintf(temp, sizeof(temp), "0x%.16llX", vtProp.ullVal);

  01075	68 00 00 00 00	 push	 OFFSET ??_C@_09LCPBGOAC@0x?$CF?416llX@
  0107a	68 04 01 00 00	 push	 260			; 00000104H
  0107f	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  01085	50		 push	 eax
  01086	e8 00 00 00 00	 call	 __snprintf
  0108b	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0108e	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  01094	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2861@WMIex:
  01097	8a 01		 mov	 al, BYTE PTR [ecx]
  01099	41		 inc	 ecx
  0109a	84 c0		 test	 al, al
  0109c	75 f9		 jne	 SHORT $LL2861@WMIex
  0109e	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  010a0	51		 push	 ecx
  010a1	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  010a7	50		 push	 eax
  010a8	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  010ae	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 379  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  010b3	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  010ba	8d 8d 20 85 ff
	ff		 lea	 ecx, DWORD PTR $T63[ebp]
  010c0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  010c5	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+12], 14 ; 0000000eH
  010c9	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  010cf	50		 push	 eax
  010d0	8d 85 20 85 ff
	ff		 lea	 eax, DWORD PTR $T63[ebp]
  010d6	50		 push	 eax
  010d7	8b cf		 mov	 ecx, edi
  010d9	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  010de	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  010e2	8b 8d 34 85 ff
	ff		 mov	 ecx, DWORD PTR $T63[ebp+20]
  010e8	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  010eb	72 3b		 jb	 SHORT $LN864@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  010ed	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  010ee	89 8d dc 82 ff
	ff		 mov	 DWORD PTR __Bytes$7[ebp], ecx
  010f4	8b 95 20 85 ff
	ff		 mov	 edx, DWORD PTR $T63[ebp]
  010fa	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  010fc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01102	72 1a		 jb	 SHORT $LN863@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01104	83 c1 23	 add	 ecx, 35			; 00000023H
  01107	89 8d dc 82 ff
	ff		 mov	 DWORD PTR __Bytes$7[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0110d	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01110	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01112	83 c0 fc	 add	 eax, -4			; fffffffcH
  01115	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01118	0f 87 62 17 00
	00		 ja	 $LN2905@WMIex
$LN863@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0111e	51		 push	 ecx
  0111f	52		 push	 edx
  01120	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01125	83 c4 08	 add	 esp, 8
$LN864@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01128	c7 85 30 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T63[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01132	c7 85 34 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T63[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0113c	c6 85 20 85 ff
	ff 00		 mov	 BYTE PTR $T63[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 381  :                         else

  01143	e9 00 14 00 00	 jmp	 $LN90@WMIex
$LN71@WMIex:

; 382  :                         {
; 383  :                             Log(LOG_MESSAGE, __LINE__, "%s = 0x%.16llX", wmiClasses[x].pProperty, vtProp.ullVal);

  01148	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  0114f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BEIAOANA@?$CFs?5?$DN?50x?$CF?416llX@
  01154	68 7f 01 00 00	 push	 383			; 0000017fH
  01159	6a 01		 push	 1
  0115b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01160	83 c4 18	 add	 esp, 24			; 00000018H

; 384  :                         }
; 385  :                         break;

  01163	e9 e0 13 00 00	 jmp	 $LN90@WMIex
$LN73@WMIex:

; 386  : 
; 387  :                     case VT_R4:
; 388  :                         if (xml)

  01168	f3 0f 10 85 e8
	83 ff ff	 movss	 xmm0, DWORD PTR _vtProp$45[ebp+8]
  01170	83 ec 08	 sub	 esp, 8
  01173	0f 5a c0	 cvtps2pd xmm0, xmm0
  01176	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0117b	85 ff		 test	 edi, edi
  0117d	0f 84 d3 00 00
	00		 je	 $LN74@WMIex

; 389  :                         {
; 390  :                             _snprintf(temp, sizeof(temp), "%f", vtProp.fltVal);

  01183	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf@
  01188	68 04 01 00 00	 push	 260			; 00000104H
  0118d	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  01193	50		 push	 eax
  01194	e8 00 00 00 00	 call	 __snprintf
  01199	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0119c	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  011a2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2862@WMIex:
  011a5	8a 01		 mov	 al, BYTE PTR [ecx]
  011a7	41		 inc	 ecx
  011a8	84 c0		 test	 al, al
  011aa	75 f9		 jne	 SHORT $LL2862@WMIex
  011ac	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  011ae	51		 push	 ecx
  011af	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  011b5	50		 push	 eax
  011b6	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  011bc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 392  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  011c1	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  011c8	8d 8d e0 85 ff
	ff		 lea	 ecx, DWORD PTR $T71[ebp]
  011ce	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  011d3	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH
  011d7	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  011dd	50		 push	 eax
  011de	8d 85 e0 85 ff
	ff		 lea	 eax, DWORD PTR $T71[ebp]
  011e4	50		 push	 eax
  011e5	8b cf		 mov	 ecx, edi
  011e7	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  011ec	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  011f0	8b 8d f4 85 ff
	ff		 mov	 ecx, DWORD PTR $T71[ebp+20]
  011f6	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  011f9	72 3b		 jb	 SHORT $LN926@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  011fb	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  011fc	89 8d e0 82 ff
	ff		 mov	 DWORD PTR __Bytes$8[ebp], ecx
  01202	8b 95 e0 85 ff
	ff		 mov	 edx, DWORD PTR $T71[ebp]
  01208	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0120a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01210	72 1a		 jb	 SHORT $LN925@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01212	83 c1 23	 add	 ecx, 35			; 00000023H
  01215	89 8d e0 82 ff
	ff		 mov	 DWORD PTR __Bytes$8[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0121b	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  0121e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01220	83 c0 fc	 add	 eax, -4			; fffffffcH
  01223	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01226	0f 87 59 16 00
	00		 ja	 $LN2906@WMIex
$LN925@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0122c	51		 push	 ecx
  0122d	52		 push	 edx
  0122e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01233	83 c4 08	 add	 esp, 8
$LN926@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01236	c7 85 f0 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T71[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01240	c7 85 f4 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T71[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0124a	c6 85 e0 85 ff
	ff 00		 mov	 BYTE PTR $T71[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 394  :                         else

  01251	e9 f2 12 00 00	 jmp	 $LN90@WMIex
$LN74@WMIex:

; 395  :                         {
; 396  :                             Log(LOG_MESSAGE, __LINE__, "%s = %f", wmiClasses[x].pProperty, vtProp.fltVal);

  01256	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  0125d	68 00 00 00 00	 push	 OFFSET ??_C@_07FMFBIAH@?$CFs?5?$DN?5?$CFf@
  01262	68 8c 01 00 00	 push	 396			; 0000018cH
  01267	6a 01		 push	 1
  01269	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0126e	83 c4 18	 add	 esp, 24			; 00000018H

; 397  :                         }
; 398  :                         break;

  01271	e9 d2 12 00 00	 jmp	 $LN90@WMIex
$LN76@WMIex:

; 399  : 
; 400  :                     case VT_R8:
; 401  :                         if (xml)

  01276	83 ec 08	 sub	 esp, 8
  01279	f2 0f 10 85 e8
	83 ff ff	 movsd	 xmm0, QWORD PTR _vtProp$45[ebp+8]
  01281	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  01286	85 ff		 test	 edi, edi
  01288	0f 84 d3 00 00
	00		 je	 $LN77@WMIex

; 402  :                         {
; 403  :                             _snprintf(temp, sizeof(temp), "%e", vtProp.dblVal);

  0128e	68 00 00 00 00	 push	 OFFSET ??_C@_02CGLCDNAE@?$CFe@
  01293	68 04 01 00 00	 push	 260			; 00000104H
  01298	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  0129e	50		 push	 eax
  0129f	e8 00 00 00 00	 call	 __snprintf
  012a4	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  012a7	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  012ad	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2863@WMIex:
  012b0	8a 01		 mov	 al, BYTE PTR [ecx]
  012b2	41		 inc	 ecx
  012b3	84 c0		 test	 al, al
  012b5	75 f9		 jne	 SHORT $LL2863@WMIex
  012b7	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  012b9	51		 push	 ecx
  012ba	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  012c0	50		 push	 eax
  012c1	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  012c7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 405  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  012cc	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  012d3	8d 8d 60 84 ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  012d9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  012de	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
  012e2	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  012e8	50		 push	 eax
  012e9	8d 85 60 84 ff
	ff		 lea	 eax, DWORD PTR $T55[ebp]
  012ef	50		 push	 eax
  012f0	8b cf		 mov	 ecx, edi
  012f2	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  012f7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  012fb	8b 8d 74 84 ff
	ff		 mov	 ecx, DWORD PTR $T55[ebp+20]
  01301	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  01304	72 3b		 jb	 SHORT $LN988@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01306	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01307	89 8d e4 82 ff
	ff		 mov	 DWORD PTR __Bytes$9[ebp], ecx
  0130d	8b 95 60 84 ff
	ff		 mov	 edx, DWORD PTR $T55[ebp]
  01313	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01315	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0131b	72 1a		 jb	 SHORT $LN987@WMIex

; 115  : 	_Bytes += _Non_user_size;

  0131d	83 c1 23	 add	 ecx, 35			; 00000023H
  01320	89 8d e4 82 ff
	ff		 mov	 DWORD PTR __Bytes$9[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01326	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01329	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0132b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0132e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01331	0f 87 53 15 00
	00		 ja	 $LN2907@WMIex
$LN987@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01337	51		 push	 ecx
  01338	52		 push	 edx
  01339	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0133e	83 c4 08	 add	 esp, 8
$LN988@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01341	c7 85 70 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0134b	c7 85 74 84 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T55[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01355	c6 85 60 84 ff
	ff 00		 mov	 BYTE PTR $T55[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 407  :                         else

  0135c	e9 e7 11 00 00	 jmp	 $LN90@WMIex
$LN77@WMIex:

; 408  :                         {
; 409  :                             Log(LOG_MESSAGE, __LINE__, "%s = %e", wmiClasses[x].pProperty, vtProp.dblVal);

  01361	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  01368	68 00 00 00 00	 push	 OFFSET ??_C@_07COOIELME@?$CFs?5?$DN?5?$CFe@
  0136d	68 99 01 00 00	 push	 409			; 00000199H
  01372	6a 01		 push	 1
  01374	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01379	83 c4 18	 add	 esp, 24			; 00000018H

; 410  :                         }
; 411  :                         break;

  0137c	e9 c7 11 00 00	 jmp	 $LN90@WMIex
$LN79@WMIex:

; 412  : 
; 413  :                     case VT_BOOL:
; 414  :                         if (xml)

  01381	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04HPMIDMKH@True@
  01386	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MKDOIIA@False@
  0138b	85 ff		 test	 edi, edi
  0138d	0f 84 ac 00 00
	00		 je	 $LN80@WMIex

; 415  :                         {
; 416  :                             value.assign(vtProp.boolVal == VARIANT_TRUE ? "True" : "False");

  01393	66 83 bd e8 83
	ff ff ff	 cmp	 WORD PTR _vtProp$45[ebp+8], -1
  0139b	0f 45 c1	 cmovne	 eax, ecx
  0139e	50		 push	 eax
  0139f	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  013a5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 417  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  013aa	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  013b1	8d 8d 78 84 ff
	ff		 lea	 ecx, DWORD PTR $T56[ebp]
  013b7	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  013bc	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+12], 17 ; 00000011H
  013c0	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  013c6	50		 push	 eax
  013c7	8d 85 78 84 ff
	ff		 lea	 eax, DWORD PTR $T56[ebp]
  013cd	50		 push	 eax
  013ce	8b cf		 mov	 ecx, edi
  013d0	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  013d5	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  013d9	8b 8d 8c 84 ff
	ff		 mov	 ecx, DWORD PTR $T56[ebp+20]
  013df	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  013e2	72 3b		 jb	 SHORT $LN1044@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  013e4	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  013e5	89 8d e8 82 ff
	ff		 mov	 DWORD PTR __Bytes$10[ebp], ecx
  013eb	8b 95 78 84 ff
	ff		 mov	 edx, DWORD PTR $T56[ebp]
  013f1	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  013f3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  013f9	72 1a		 jb	 SHORT $LN1043@WMIex

; 115  : 	_Bytes += _Non_user_size;

  013fb	83 c1 23	 add	 ecx, 35			; 00000023H
  013fe	89 8d e8 82 ff
	ff		 mov	 DWORD PTR __Bytes$10[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01404	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01407	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01409	83 c0 fc	 add	 eax, -4			; fffffffcH
  0140c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0140f	0f 87 7a 14 00
	00		 ja	 $LN2908@WMIex
$LN1043@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01415	51		 push	 ecx
  01416	52		 push	 edx
  01417	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0141c	83 c4 08	 add	 esp, 8
$LN1044@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0141f	c7 85 88 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01429	c7 85 8c 84 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T56[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01433	c6 85 78 84 ff
	ff 00		 mov	 BYTE PTR $T56[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 419  :                         else

  0143a	e9 09 11 00 00	 jmp	 $LN90@WMIex
$LN80@WMIex:

; 420  :                         {
; 421  :                             Log(LOG_MESSAGE, __LINE__, "%s = %s", wmiClasses[x].pProperty, vtProp.boolVal == VARIANT_TRUE ? "True" : "False");

  0143f	66 83 bd e8 83
	ff ff ff	 cmp	 WORD PTR _vtProp$45[ebp+8], -1
  01447	0f 45 c1	 cmovne	 eax, ecx
  0144a	50		 push	 eax
  0144b	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  01452	68 00 00 00 00	 push	 OFFSET ??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs@
  01457	68 a5 01 00 00	 push	 421			; 000001a5H
  0145c	6a 01		 push	 1
  0145e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01463	83 c4 14	 add	 esp, 20			; 00000014H

; 422  :                         }
; 423  :                         break;

  01466	e9 dd 10 00 00	 jmp	 $LN90@WMIex
$LN82@WMIex:

; 424  : 
; 425  :                     case VT_BSTR:
; 426  :                         if (vtProp.bstrVal)

  0146b	8b 85 e8 83 ff
	ff		 mov	 eax, DWORD PTR _vtProp$45[ebp+8]
  01471	85 c0		 test	 eax, eax
  01473	0f 84 cf 10 00
	00		 je	 $LN90@WMIex

; 427  :                         {
; 428  :                             WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)vtProp.bstrVal, -1, (LPSTR)szValue, sizeof(szValue), NULL, NULL);

  01479	6a 00		 push	 0
  0147b	6a 00		 push	 0
  0147d	68 10 27 00 00	 push	 10000			; 00002710H
  01482	8d 8d 48 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$78[ebp]
  01488	51		 push	 ecx
  01489	6a ff		 push	 -1
  0148b	50		 push	 eax
  0148c	6a 00		 push	 0
  0148e	6a 00		 push	 0
  01490	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 429  :                             if (xml)

  01496	85 ff		 test	 edi, edi
  01498	0f 84 ba 00 00
	00		 je	 $LN84@WMIex
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0149e	8d 8d 48 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$78[ebp]
  014a4	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2864@WMIex:
  014a7	8a 01		 mov	 al, BYTE PTR [ecx]
  014a9	41		 inc	 ecx
  014aa	84 c0		 test	 al, al
  014ac	75 f9		 jne	 SHORT $LL2864@WMIex
  014ae	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014b0	51		 push	 ecx
  014b1	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  014b7	50		 push	 eax
  014b8	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  014be	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 432  :                                 xml->CreateChild(wmiClasses[x].pProperty, value);

  014c3	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  014ca	8d 8d 90 84 ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  014d0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  014d5	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
  014d9	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  014df	50		 push	 eax
  014e0	8d 85 90 84 ff
	ff		 lea	 eax, DWORD PTR $T57[ebp]
  014e6	50		 push	 eax
  014e7	8b cf		 mov	 ecx, edi
  014e9	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  014ee	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  014f2	8b 8d a4 84 ff
	ff		 mov	 ecx, DWORD PTR $T57[ebp+20]
  014f8	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  014fb	72 3b		 jb	 SHORT $LN1106@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  014fd	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  014fe	89 8d ec 82 ff
	ff		 mov	 DWORD PTR __Bytes$11[ebp], ecx
  01504	8b 95 90 84 ff
	ff		 mov	 edx, DWORD PTR $T57[ebp]
  0150a	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0150c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01512	72 1a		 jb	 SHORT $LN1105@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01514	83 c1 23	 add	 ecx, 35			; 00000023H
  01517	89 8d ec 82 ff
	ff		 mov	 DWORD PTR __Bytes$11[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0151d	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01520	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01522	83 c0 fc	 add	 eax, -4			; fffffffcH
  01525	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01528	0f 87 66 13 00
	00		 ja	 $LN2909@WMIex
$LN1105@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0152e	51		 push	 ecx
  0152f	52		 push	 edx
  01530	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01535	83 c4 08	 add	 esp, 8
$LN1106@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01538	c7 85 a0 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01542	c7 85 a4 84 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T57[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0154c	c6 85 90 84 ff
	ff 00		 mov	 BYTE PTR $T57[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 434  :                             else

  01553	e9 f0 0f 00 00	 jmp	 $LN90@WMIex
$LN84@WMIex:

; 435  :                             {
; 436  :                                 Log(LOG_MESSAGE, __LINE__, "%s = %s", wmiClasses[x].pProperty, szValue);

  01558	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0155e	50		 push	 eax
  0155f	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  01566	68 00 00 00 00	 push	 OFFSET ??_C@_07DCHAPOBD@?$CFs?5?$DN?5?$CFs@
  0156b	68 b4 01 00 00	 push	 436			; 000001b4H
  01570	6a 01		 push	 1
  01572	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01577	83 c4 14	 add	 esp, 20			; 00000014H

; 437  :                             }
; 438  :                         }
; 439  :                         break;

  0157a	e9 c9 0f 00 00	 jmp	 $LN90@WMIex
$LN86@WMIex:

; 440  : 
; 441  :                     case VT_DATE:
; 442  :                         if (xml)

  0157f	f2 0f 10 85 e8
	83 ff ff	 movsd	 xmm0, QWORD PTR _vtProp$45[ebp+8]
  01587	e8 00 00 00 00	 call	 __dtoui3
  0158c	50		 push	 eax
  0158d	85 ff		 test	 edi, edi
  0158f	0f 84 d3 00 00
	00		 je	 $LN87@WMIex

; 443  :                         {
; 444  :                             _snprintf(temp, sizeof(temp), "%lu", (unsigned long)vtProp.date);

  01595	68 00 00 00 00	 push	 OFFSET ??_C@_03FKNCMABI@?$CFlu@
  0159a	68 04 01 00 00	 push	 260			; 00000104H
  0159f	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  015a5	50		 push	 eax
  015a6	e8 00 00 00 00	 call	 __snprintf
  015ab	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  015ae	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _temp$82[ebp]
  015b4	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2865@WMIex:
  015b7	8a 01		 mov	 al, BYTE PTR [ecx]
  015b9	41		 inc	 ecx
  015ba	84 c0		 test	 al, al
  015bc	75 f9		 jne	 SHORT $LL2865@WMIex
  015be	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  015c0	51		 push	 ecx
  015c1	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$82[ebp]
  015c7	50		 push	 eax
  015c8	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  015ce	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 446  :                             xml->CreateChild(wmiClasses[x].pProperty, value);

  015d3	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  015da	8d 8d a8 84 ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  015e0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  015e5	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+12], 19 ; 00000013H
  015e9	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  015ef	50		 push	 eax
  015f0	8d 85 a8 84 ff
	ff		 lea	 eax, DWORD PTR $T58[ebp]
  015f6	50		 push	 eax
  015f7	8b cf		 mov	 ecx, edi
  015f9	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  015fe	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  01602	8b 8d bc 84 ff
	ff		 mov	 ecx, DWORD PTR $T58[ebp+20]
  01608	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0160b	72 3b		 jb	 SHORT $LN1168@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0160d	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0160e	89 8d f4 82 ff
	ff		 mov	 DWORD PTR __Bytes$13[ebp], ecx
  01614	8b 95 a8 84 ff
	ff		 mov	 edx, DWORD PTR $T58[ebp]
  0161a	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0161c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01622	72 1a		 jb	 SHORT $LN1167@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01624	83 c1 23	 add	 ecx, 35			; 00000023H
  01627	89 8d f4 82 ff
	ff		 mov	 DWORD PTR __Bytes$13[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0162d	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01630	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01632	83 c0 fc	 add	 eax, -4			; fffffffcH
  01635	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01638	0f 87 5b 12 00
	00		 ja	 $LN2910@WMIex
$LN1167@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0163e	51		 push	 ecx
  0163f	52		 push	 edx
  01640	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01645	83 c4 08	 add	 esp, 8
$LN1168@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01648	c7 85 b8 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01652	c7 85 bc 84 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T58[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0165c	c6 85 a8 84 ff
	ff 00		 mov	 BYTE PTR $T58[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 448  :                         else

  01663	e9 e0 0e 00 00	 jmp	 $LN90@WMIex
$LN87@WMIex:

; 449  :                         {
; 450  :                             Log(LOG_MESSAGE, __LINE__, "%s = %lu", wmiClasses[x].pProperty, (unsigned long)vtProp.date);

  01668	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  0166f	68 00 00 00 00	 push	 OFFSET ??_C@_08MBLOFINO@?$CFs?5?$DN?5?$CFlu@
  01674	68 c2 01 00 00	 push	 450			; 000001c2H
  01679	6a 01		 push	 1
  0167b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01680	83 c4 14	 add	 esp, 20			; 00000014H

; 451  :                         }
; 452  :                         break;

  01683	e9 c0 0e 00 00	 jmp	 $LN90@WMIex
$LN89@WMIex:

; 453  : 
; 454  :                     default:
; 455  :                         if (vtProp.vt & VT_BYREF)

  01688	f7 c1 00 40 00
	00		 test	 ecx, 16384		; 00004000H
  0168e	0f 84 b4 0e 00
	00		 je	 $LN90@WMIex

; 456  :                         {
; 457  :                             if (xml)

  01694	85 ff		 test	 edi, edi
  01696	0f 84 8f 00 00
	00		 je	 $LN1229@WMIex

; 458  :                             {
; 459  :                                 xml->Createtag(wmiClasses[x].pProperty);

  0169c	ff 34 f5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[esi*8+4]
  016a3	8d 8d c0 84 ff
	ff		 lea	 ecx, DWORD PTR $T59[ebp]
  016a9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  016ae	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+12], 20 ; 00000014H
  016b2	8d 85 c0 84 ff
	ff		 lea	 eax, DWORD PTR $T59[ebp]
  016b8	50		 push	 eax
  016b9	8b cf		 mov	 ecx, edi
  016bb	e8 00 00 00 00	 call	 ?Createtag@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::Createtag
  016c0	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  016c4	8b 8d d4 84 ff
	ff		 mov	 ecx, DWORD PTR $T59[ebp+20]
  016ca	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  016cd	72 3b		 jb	 SHORT $LN1224@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  016cf	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  016d0	89 8d f8 82 ff
	ff		 mov	 DWORD PTR __Bytes$14[ebp], ecx
  016d6	8b 95 c0 84 ff
	ff		 mov	 edx, DWORD PTR $T59[ebp]
  016dc	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  016de	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  016e4	72 1a		 jb	 SHORT $LN1223@WMIex

; 115  : 	_Bytes += _Non_user_size;

  016e6	83 c1 23	 add	 ecx, 35			; 00000023H
  016e9	89 8d f8 82 ff
	ff		 mov	 DWORD PTR __Bytes$14[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  016ef	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  016f2	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  016f4	83 c0 fc	 add	 eax, -4			; fffffffcH
  016f7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  016fa	0f 87 9e 11 00
	00		 ja	 $LN2911@WMIex
$LN1223@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01700	51		 push	 ecx
  01701	52		 push	 edx
  01702	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01707	83 c4 08	 add	 esp, 8
$LN1224@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0170a	c7 85 d0 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01714	c7 85 d4 84 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T59[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0171e	c6 85 c0 84 ff
	ff 00		 mov	 BYTE PTR $T59[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2461 : 		}

  01725	8b 8d e0 83 ff
	ff		 mov	 ecx, DWORD PTR _vtProp$45[ebp]
$LN1229@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 461  :                             unsigned short type = (vtProp.vt - VT_BYREF);

  0172b	8d 81 00 c0 ff
	ff		 lea	 eax, DWORD PTR [ecx-16384]
  01731	0f b7 f0	 movzx	 esi, ax

; 462  :                             char idx[_MAX_PATH] = { 0 };

  01734	68 04 01 00 00	 push	 260			; 00000104H
  01739	6a 00		 push	 0
  0173b	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01741	50		 push	 eax
  01742	e8 00 00 00 00	 call	 _memset
  01747	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0174a	c7 85 08 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _id$74[ebp+16], 0

; 1785 : 		_Myres(0)

  01754	c7 85 0c 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _id$74[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  0175e	c7 85 08 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _id$74[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01768	c7 85 0c 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _id$74[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01772	c6 85 f8 85 ff
	ff 00		 mov	 BYTE PTR _id$74[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 463  :                             std::string id;

  01779	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H

; 464  : 
; 465  :                             switch (type)

  0177d	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  01780	83 f8 13	 cmp	 eax, 19			; 00000013H
  01783	0f 87 67 0d 00
	00		 ja	 $LN2709@WMIex
  01789	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN2866@WMIex[eax]
  01790	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN2922@WMIex[eax*4]
$LN92@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  01797	c7 85 a4 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui1$39[ebp], 0

; 390  : 		_Mylast(),

  017a1	c7 85 a8 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui1$39[ebp+4], 0

; 391  : 		_Myend()

  017ab	c7 85 ac 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui1$39[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 470  :                                 std::vector<BYTE> vui1;

  017b5	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+12], 22 ; 00000016H

; 471  :                                 FromVariant(vtProp, vui1);

  017b9	83 ec 10	 sub	 esp, 16			; 00000010H
  017bc	8b c4		 mov	 eax, esp
  017be	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  017c5	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  017c8	8d 8d a4 83 ff
	ff		 lea	 ecx, DWORD PTR _vui1$39[ebp]
  017ce	e8 00 00 00 00	 call	 ??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ; FromVariant<unsigned char>
  017d3	83 c4 10	 add	 esp, 16			; 00000010H

; 472  :                                 for (unsigned int i = 0; i < vui1.size(); i++)

  017d6	33 f6		 xor	 esi, esi
$LN2883@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  017d8	89 b5 00 83 ff
	ff		 mov	 DWORD PTR _i$16[ebp], esi
  017de	8b 85 a8 83 ff
	ff		 mov	 eax, DWORD PTR _vui1$39[ebp+4]
  017e4	8b 8d a4 83 ff
	ff		 mov	 ecx, DWORD PTR _vui1$39[ebp]
  017ea	2b c1		 sub	 eax, ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 472  :                                 for (unsigned int i = 0; i < vui1.size(); i++)

  017ec	3b f0		 cmp	 esi, eax
  017ee	0f 83 4b 01 00
	00		 jae	 $LN12@WMIex

; 473  :                                 {
; 474  :                                     if (xml)

  017f4	85 ff		 test	 edi, edi
  017f6	0f 84 1e 01 00
	00		 je	 $LN93@WMIex

; 475  :                                     {
; 476  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  017fc	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  017ff	50		 push	 eax
  01800	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  01805	68 04 01 00 00	 push	 260			; 00000104H
  0180a	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01810	50		 push	 eax
  01811	e8 00 00 00 00	 call	 __snprintf

; 477  :                                         _snprintf(szValue, sizeof(szValue), "0x%.2X", vui1[i]);

  01816	8b 85 a4 83 ff
	ff		 mov	 eax, DWORD PTR _vui1$39[ebp]
  0181c	0f b6 04 30	 movzx	 eax, BYTE PTR [eax+esi]
  01820	50		 push	 eax
  01821	68 00 00 00 00	 push	 OFFSET ??_C@_06DBMAJEKE@0x?$CF?42X@
  01826	68 10 27 00 00	 push	 10000			; 00002710H
  0182b	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01831	50		 push	 eax
  01832	e8 00 00 00 00	 call	 __snprintf
  01837	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0183a	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _idx$81[ebp]
  01840	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2867@WMIex:
  01843	8a 01		 mov	 al, BYTE PTR [ecx]
  01845	41		 inc	 ecx
  01846	84 c0		 test	 al, al
  01848	75 f9		 jne	 SHORT $LL2867@WMIex
  0184a	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0184c	51		 push	 ecx
  0184d	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01853	50		 push	 eax
  01854	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  0185a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0185f	8d 8d 48 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$78[ebp]
  01865	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2868@WMIex:
  01868	8a 01		 mov	 al, BYTE PTR [ecx]
  0186a	41		 inc	 ecx
  0186b	84 c0		 test	 al, al
  0186d	75 f9		 jne	 SHORT $LL2868@WMIex
  0186f	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01871	51		 push	 ecx
  01872	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01878	50		 push	 eax
  01879	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  0187f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 481  :                                         xml->CreateChild(idx, value);

  01884	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0188a	50		 push	 eax
  0188b	8d 8d d8 84 ff
	ff		 lea	 ecx, DWORD PTR $T60[ebp]
  01891	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01896	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+12], 23 ; 00000017H
  0189a	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  018a0	50		 push	 eax
  018a1	8d 85 d8 84 ff
	ff		 lea	 eax, DWORD PTR $T60[ebp]
  018a7	50		 push	 eax
  018a8	8b cf		 mov	 ecx, edi
  018aa	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  018af	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+12], 22 ; 00000016H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  018b3	8b 8d ec 84 ff
	ff		 mov	 ecx, DWORD PTR $T60[ebp+20]
  018b9	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  018bc	72 3b		 jb	 SHORT $LN1342@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  018be	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  018bf	89 8d fc 82 ff
	ff		 mov	 DWORD PTR __Bytes$15[ebp], ecx
  018c5	8b 95 d8 84 ff
	ff		 mov	 edx, DWORD PTR $T60[ebp]
  018cb	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  018cd	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  018d3	72 1a		 jb	 SHORT $LN1341@WMIex

; 115  : 	_Bytes += _Non_user_size;

  018d5	83 c1 23	 add	 ecx, 35			; 00000023H
  018d8	89 8d fc 82 ff
	ff		 mov	 DWORD PTR __Bytes$15[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  018de	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  018e1	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  018e3	83 c0 fc	 add	 eax, -4			; fffffffcH
  018e6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  018e9	0f 87 b4 0f 00
	00		 ja	 $LN2912@WMIex
$LN1341@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  018ef	51		 push	 ecx
  018f0	52		 push	 edx
  018f1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  018f6	83 c4 08	 add	 esp, 8
$LN1342@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  018f9	c7 85 e8 84 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01903	c7 85 ec 84 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T60[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0190d	c6 85 d8 84 ff
	ff 00		 mov	 BYTE PTR $T60[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 472  :                                 for (unsigned int i = 0; i < vui1.size(); i++)

  01914	46		 inc	 esi
  01915	e9 be fe ff ff	 jmp	 $LN2883@WMIex
$LN93@WMIex:

; 482  :                                     }
; 483  :                                     else
; 484  :                                     {
; 485  :                                         _snprintf(szValue, sizeof(szValue), "%s.0x%.2X", szValue, vui1[i]);

  0191a	0f b6 04 31	 movzx	 eax, BYTE PTR [ecx+esi]
  0191e	50		 push	 eax
  0191f	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01925	50		 push	 eax
  01926	68 00 00 00 00	 push	 OFFSET ??_C@_09MDIAGEEM@?$CFs?40x?$CF?42X@
  0192b	68 10 27 00 00	 push	 10000			; 00002710H
  01930	50		 push	 eax
  01931	e8 00 00 00 00	 call	 __snprintf
  01936	83 c4 14	 add	 esp, 20			; 00000014H

; 472  :                                 for (unsigned int i = 0; i < vui1.size(); i++)

  01939	46		 inc	 esi
  0193a	e9 99 fe ff ff	 jmp	 $LN2883@WMIex
$LN12@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0193f	89 8d a8 83 ff
	ff		 mov	 DWORD PTR _vui1$39[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 489  :                             }

  01945	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  01949	8b 95 a4 83 ff
	ff		 mov	 edx, DWORD PTR _vui1$39[ebp]
  0194f	85 d2		 test	 edx, edx
  01951	0f 84 99 0b 00
	00		 je	 $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  01957	8b 8d ac 83 ff
	ff		 mov	 ecx, DWORD PTR _vui1$39[ebp+8]
  0195d	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0195f	89 8d 04 83 ff
	ff		 mov	 DWORD PTR __Bytes$17[ebp], ecx
  01965	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01967	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0196d	72 1a		 jb	 SHORT $LN1487@WMIex

; 115  : 	_Bytes += _Non_user_size;

  0196f	83 c1 23	 add	 ecx, 35			; 00000023H
  01972	89 8d 04 83 ff
	ff		 mov	 DWORD PTR __Bytes$17[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01978	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  0197b	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0197d	83 c0 fc	 add	 eax, -4			; fffffffcH
  01980	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01983	0f 87 1f 0f 00
	00		 ja	 $LN2913@WMIex
$LN1487@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01989	51		 push	 ecx
  0198a	52		 push	 edx
  0198b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01990	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  01993	c7 85 a4 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui1$39[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  0199d	c7 85 a8 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui1$39[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  019a7	c7 85 ac 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui1$39[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 490  :                             break;

  019b1	e9 3a 0b 00 00	 jmp	 $LN2709@WMIex
$LN95@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  019b6	c7 85 98 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui2$38[ebp], 0

; 390  : 		_Mylast(),

  019c0	c7 85 9c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui2$38[ebp+4], 0

; 391  : 		_Myend()

  019ca	c7 85 a0 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui2$38[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 495  :                                 std::vector<USHORT> vui2;

  019d4	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+12], 24 ; 00000018H

; 496  :                                 FromVariant(vtProp, vui2);

  019d8	83 ec 10	 sub	 esp, 16			; 00000010H
  019db	8b c4		 mov	 eax, esp
  019dd	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  019e4	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  019e7	8d 8d 98 83 ff
	ff		 lea	 ecx, DWORD PTR _vui2$38[ebp]
  019ed	e8 00 00 00 00	 call	 ??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z ; FromVariant<unsigned short>
  019f2	83 c4 10	 add	 esp, 16			; 00000010H

; 497  :                                 for (unsigned int i = 0; i < vui2.size(); i++)

  019f5	33 f6		 xor	 esi, esi
$LN2884@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  019f7	89 b5 0c 83 ff
	ff		 mov	 DWORD PTR _i$19[ebp], esi
  019fd	8b 85 9c 83 ff
	ff		 mov	 eax, DWORD PTR _vui2$38[ebp+4]
  01a03	8b 8d 98 83 ff
	ff		 mov	 ecx, DWORD PTR _vui2$38[ebp]
  01a09	2b c1		 sub	 eax, ecx
  01a0b	d1 f8		 sar	 eax, 1
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 497  :                                 for (unsigned int i = 0; i < vui2.size(); i++)

  01a0d	3b f0		 cmp	 esi, eax
  01a0f	0f 83 52 01 00
	00		 jae	 $LN15@WMIex

; 498  :                                 {
; 499  :                                     if (xml)

  01a15	85 ff		 test	 edi, edi
  01a17	0f 84 25 01 00
	00		 je	 $LN96@WMIex

; 500  :                                     {
; 501  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  01a1d	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01a20	50		 push	 eax
  01a21	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  01a26	68 04 01 00 00	 push	 260			; 00000104H
  01a2b	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01a31	50		 push	 eax
  01a32	e8 00 00 00 00	 call	 __snprintf

; 502  :                                         _snprintf(szValue, sizeof(szValue), "0x%.4X", vui2[i]);

  01a37	8b 85 98 83 ff
	ff		 mov	 eax, DWORD PTR _vui2$38[ebp]
  01a3d	0f b7 04 70	 movzx	 eax, WORD PTR [eax+esi*2]
  01a41	50		 push	 eax
  01a42	68 00 00 00 00	 push	 OFFSET ??_C@_06DFENOIBG@0x?$CF?44X@
  01a47	68 10 27 00 00	 push	 10000			; 00002710H
  01a4c	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01a52	50		 push	 eax
  01a53	e8 00 00 00 00	 call	 __snprintf
  01a58	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  01a5b	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _idx$81[ebp]
  01a61	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2869@WMIex:
  01a64	8a 01		 mov	 al, BYTE PTR [ecx]
  01a66	41		 inc	 ecx
  01a67	84 c0		 test	 al, al
  01a69	75 f9		 jne	 SHORT $LL2869@WMIex
  01a6b	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01a6d	51		 push	 ecx
  01a6e	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01a74	50		 push	 eax
  01a75	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  01a7b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  01a80	8d 8d 48 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$78[ebp]
  01a86	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  01a89	0f 1f 80 00 00
	00 00		 npad	 7
$LL2870@WMIex:
  01a90	8a 01		 mov	 al, BYTE PTR [ecx]
  01a92	41		 inc	 ecx
  01a93	84 c0		 test	 al, al
  01a95	75 f9		 jne	 SHORT $LL2870@WMIex
  01a97	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01a99	51		 push	 ecx
  01a9a	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01aa0	50		 push	 eax
  01aa1	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  01aa7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 506  :                                         xml->CreateChild(idx, value);

  01aac	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01ab2	50		 push	 eax
  01ab3	8d 8d f0 84 ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  01ab9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01abe	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+12], 25 ; 00000019H
  01ac2	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  01ac8	50		 push	 eax
  01ac9	8d 85 f0 84 ff
	ff		 lea	 eax, DWORD PTR $T61[ebp]
  01acf	50		 push	 eax
  01ad0	8b cf		 mov	 ecx, edi
  01ad2	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  01ad7	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+12], 24 ; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  01adb	8b 8d 04 85 ff
	ff		 mov	 ecx, DWORD PTR $T61[ebp+20]
  01ae1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  01ae4	72 3b		 jb	 SHORT $LN1596@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01ae6	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01ae7	89 8d 08 83 ff
	ff		 mov	 DWORD PTR __Bytes$18[ebp], ecx
  01aed	8b 95 f0 84 ff
	ff		 mov	 edx, DWORD PTR $T61[ebp]
  01af3	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01af5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01afb	72 1a		 jb	 SHORT $LN1595@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01afd	83 c1 23	 add	 ecx, 35			; 00000023H
  01b00	89 8d 08 83 ff
	ff		 mov	 DWORD PTR __Bytes$18[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01b06	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01b09	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01b0b	83 c0 fc	 add	 eax, -4			; fffffffcH
  01b0e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01b11	0f 87 96 0d 00
	00		 ja	 $LN2914@WMIex
$LN1595@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01b17	51		 push	 ecx
  01b18	52		 push	 edx
  01b19	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01b1e	83 c4 08	 add	 esp, 8
$LN1596@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01b21	c7 85 00 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T61[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01b2b	c7 85 04 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T61[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01b35	c6 85 f0 84 ff
	ff 00		 mov	 BYTE PTR $T61[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 497  :                                 for (unsigned int i = 0; i < vui2.size(); i++)

  01b3c	46		 inc	 esi
  01b3d	e9 b5 fe ff ff	 jmp	 $LN2884@WMIex
$LN96@WMIex:

; 507  :                                     }
; 508  :                                     else
; 509  :                                     {
; 510  :                                         _snprintf(szValue, sizeof(szValue), "%s.0x%.4X", szValue, vui2[i]);

  01b42	0f b7 04 71	 movzx	 eax, WORD PTR [ecx+esi*2]
  01b46	50		 push	 eax
  01b47	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01b4d	50		 push	 eax
  01b4e	68 00 00 00 00	 push	 OFFSET ??_C@_09MHANBIPO@?$CFs?40x?$CF?44X@
  01b53	68 10 27 00 00	 push	 10000			; 00002710H
  01b58	50		 push	 eax
  01b59	e8 00 00 00 00	 call	 __snprintf
  01b5e	83 c4 14	 add	 esp, 20			; 00000014H

; 497  :                                 for (unsigned int i = 0; i < vui2.size(); i++)

  01b61	46		 inc	 esi
  01b62	e9 90 fe ff ff	 jmp	 $LN2884@WMIex
$LN15@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  01b67	89 8d 9c 83 ff
	ff		 mov	 DWORD PTR _vui2$38[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 514  :                             }

  01b6d	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  01b71	8b 8d 98 83 ff
	ff		 mov	 ecx, DWORD PTR _vui2$38[ebp]
  01b77	85 c9		 test	 ecx, ecx
  01b79	0f 84 71 09 00
	00		 je	 $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  01b7f	8b 85 a0 83 ff
	ff		 mov	 eax, DWORD PTR _vui2$38[ebp+8]
  01b85	2b c1		 sub	 eax, ecx
  01b87	d1 f8		 sar	 eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01b89	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  01b8c	89 95 10 83 ff
	ff		 mov	 DWORD PTR __Bytes$20[ebp], edx
  01b92	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01b94	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01b9a	72 1a		 jb	 SHORT $LN1741@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01b9c	83 c2 23	 add	 edx, 35			; 00000023H
  01b9f	89 95 10 83 ff
	ff		 mov	 DWORD PTR __Bytes$20[ebp], edx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01ba5	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01ba8	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01baa	83 c0 fc	 add	 eax, -4			; fffffffcH
  01bad	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01bb0	0f 87 fc 0c 00
	00		 ja	 $LN2915@WMIex
$LN1741@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01bb6	52		 push	 edx
  01bb7	51		 push	 ecx
  01bb8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01bbd	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  01bc0	c7 85 98 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui2$38[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  01bca	c7 85 9c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui2$38[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  01bd4	c7 85 a0 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui2$38[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 515  :                             break;

  01bde	e9 0d 09 00 00	 jmp	 $LN2709@WMIex
$LN98@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  01be3	c7 85 8c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui4$37[ebp], 0

; 390  : 		_Mylast(),

  01bed	c7 85 90 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui4$37[ebp+4], 0

; 391  : 		_Myend()

  01bf7	c7 85 94 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui4$37[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 520  :                                 std::vector<ULONG> vui4;

  01c01	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+12], 26 ; 0000001aH

; 521  :                                 FromVariant(vtProp, vui4);

  01c05	83 ec 10	 sub	 esp, 16			; 00000010H
  01c08	8b c4		 mov	 eax, esp
  01c0a	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  01c11	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  01c14	8d 8d 8c 83 ff
	ff		 lea	 ecx, DWORD PTR _vui4$37[ebp]
  01c1a	e8 00 00 00 00	 call	 ??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z ; FromVariant<unsigned long>
  01c1f	83 c4 10	 add	 esp, 16			; 00000010H

; 522  :                                 for (unsigned int i = 0; i < vui4.size(); i++)

  01c22	33 f6		 xor	 esi, esi
$LN2885@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  01c24	89 b5 3c 83 ff
	ff		 mov	 DWORD PTR _i$31[ebp], esi
  01c2a	8b 85 90 83 ff
	ff		 mov	 eax, DWORD PTR _vui4$37[ebp+4]
  01c30	8b 8d 8c 83 ff
	ff		 mov	 ecx, DWORD PTR _vui4$37[ebp]
  01c36	2b c1		 sub	 eax, ecx
  01c38	c1 f8 02	 sar	 eax, 2
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 522  :                                 for (unsigned int i = 0; i < vui4.size(); i++)

  01c3b	3b f0		 cmp	 esi, eax
  01c3d	0f 83 47 01 00
	00		 jae	 $LN18@WMIex

; 523  :                                 {
; 524  :                                     if (xml)

  01c43	85 ff		 test	 edi, edi
  01c45	0f 84 1c 01 00
	00		 je	 $LN99@WMIex

; 525  :                                     {
; 526  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  01c4b	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01c4e	50		 push	 eax
  01c4f	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  01c54	68 04 01 00 00	 push	 260			; 00000104H
  01c59	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01c5f	50		 push	 eax
  01c60	e8 00 00 00 00	 call	 __snprintf

; 527  :                                         _snprintf(szValue, sizeof(szValue), "0x%.8lX", vui4[i]);

  01c65	8b 85 8c 83 ff
	ff		 mov	 eax, DWORD PTR _vui4$37[ebp]
  01c6b	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  01c6e	68 00 00 00 00	 push	 OFFSET ??_C@_07OPDHNNBB@0x?$CF?48lX@
  01c73	68 10 27 00 00	 push	 10000			; 00002710H
  01c78	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01c7e	50		 push	 eax
  01c7f	e8 00 00 00 00	 call	 __snprintf
  01c84	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  01c87	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _idx$81[ebp]
  01c8d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2871@WMIex:
  01c90	8a 01		 mov	 al, BYTE PTR [ecx]
  01c92	41		 inc	 ecx
  01c93	84 c0		 test	 al, al
  01c95	75 f9		 jne	 SHORT $LL2871@WMIex
  01c97	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01c99	51		 push	 ecx
  01c9a	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01ca0	50		 push	 eax
  01ca1	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  01ca7	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  01cac	8d 8d 48 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$78[ebp]
  01cb2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2872@WMIex:
  01cb5	8a 01		 mov	 al, BYTE PTR [ecx]
  01cb7	41		 inc	 ecx
  01cb8	84 c0		 test	 al, al
  01cba	75 f9		 jne	 SHORT $LL2872@WMIex
  01cbc	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01cbe	51		 push	 ecx
  01cbf	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01cc5	50		 push	 eax
  01cc6	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  01ccc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 531  :                                         xml->CreateChild(idx, value);

  01cd1	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01cd7	50		 push	 eax
  01cd8	8d 8d 08 85 ff
	ff		 lea	 ecx, DWORD PTR $T62[ebp]
  01cde	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ce3	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+12], 27 ; 0000001bH
  01ce7	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  01ced	50		 push	 eax
  01cee	8d 85 08 85 ff
	ff		 lea	 eax, DWORD PTR $T62[ebp]
  01cf4	50		 push	 eax
  01cf5	8b cf		 mov	 ecx, edi
  01cf7	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  01cfc	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+12], 26 ; 0000001aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  01d00	8b 8d 1c 85 ff
	ff		 mov	 ecx, DWORD PTR $T62[ebp+20]
  01d06	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  01d09	72 3b		 jb	 SHORT $LN1850@WMIex

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01d0b	41		 inc	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01d0c	89 8d 14 83 ff
	ff		 mov	 DWORD PTR __Bytes$21[ebp], ecx
  01d12	8b 95 08 85 ff
	ff		 mov	 edx, DWORD PTR $T62[ebp]
  01d18	8b c2		 mov	 eax, edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01d1a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01d20	72 1a		 jb	 SHORT $LN1849@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01d22	83 c1 23	 add	 ecx, 35			; 00000023H
  01d25	89 8d 14 83 ff
	ff		 mov	 DWORD PTR __Bytes$21[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01d2b	8b 52 fc	 mov	 edx, DWORD PTR [edx-4]
  01d2e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01d30	83 c0 fc	 add	 eax, -4			; fffffffcH
  01d33	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01d36	0f 87 7b 0b 00
	00		 ja	 $LN2916@WMIex
$LN1849@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01d3c	51		 push	 ecx
  01d3d	52		 push	 edx
  01d3e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01d43	83 c4 08	 add	 esp, 8
$LN1850@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01d46	c7 85 18 85 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T62[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01d50	c7 85 1c 85 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T62[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01d5a	c6 85 08 85 ff
	ff 00		 mov	 BYTE PTR $T62[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 522  :                                 for (unsigned int i = 0; i < vui4.size(); i++)

  01d61	46		 inc	 esi
  01d62	e9 bd fe ff ff	 jmp	 $LN2885@WMIex
$LN99@WMIex:

; 532  :                                     }
; 533  :                                     else
; 534  :                                     {
; 535  :                                         _snprintf(szValue, sizeof(szValue), "%s.0x%.8lX", szValue, vui4[i]);

  01d67	ff 34 b1	 push	 DWORD PTR [ecx+esi*4]
  01d6a	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01d70	50		 push	 eax
  01d71	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EBBEPHKL@?$CFs?40x?$CF?48lX@
  01d76	68 10 27 00 00	 push	 10000			; 00002710H
  01d7b	50		 push	 eax
  01d7c	e8 00 00 00 00	 call	 __snprintf
  01d81	83 c4 14	 add	 esp, 20			; 00000014H

; 522  :                                 for (unsigned int i = 0; i < vui4.size(); i++)

  01d84	46		 inc	 esi
  01d85	e9 9a fe ff ff	 jmp	 $LN2885@WMIex
$LN18@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  01d8a	89 8d 90 83 ff
	ff		 mov	 DWORD PTR _vui4$37[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 539  :                             }

  01d90	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  01d94	8b 8d 8c 83 ff
	ff		 mov	 ecx, DWORD PTR _vui4$37[ebp]
  01d9a	85 c9		 test	 ecx, ecx
  01d9c	0f 84 4e 07 00
	00		 je	 $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  01da2	8b 85 94 83 ff
	ff		 mov	 eax, DWORD PTR _vui4$37[ebp+8]
  01da8	2b c1		 sub	 eax, ecx
  01daa	c1 f8 02	 sar	 eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01dad	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  01db4	89 95 1c 83 ff
	ff		 mov	 DWORD PTR __Bytes$23[ebp], edx
  01dba	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01dbc	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01dc2	72 1a		 jb	 SHORT $LN1995@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01dc4	83 c2 23	 add	 edx, 35			; 00000023H
  01dc7	89 95 1c 83 ff
	ff		 mov	 DWORD PTR __Bytes$23[ebp], edx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01dcd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01dd0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01dd2	83 c0 fc	 add	 eax, -4			; fffffffcH
  01dd5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01dd8	0f 87 de 0a 00
	00		 ja	 $LN2917@WMIex
$LN1995@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01dde	52		 push	 edx
  01ddf	51		 push	 ecx
  01de0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01de5	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  01de8	c7 85 8c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui4$37[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  01df2	c7 85 90 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui4$37[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  01dfc	c7 85 94 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui4$37[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 540  :                             break;

  01e06	e9 e5 06 00 00	 jmp	 $LN2709@WMIex
$LN101@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  01e0b	c7 85 80 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui8$36[ebp], 0

; 390  : 		_Mylast(),

  01e15	c7 85 84 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui8$36[ebp+4], 0

; 391  : 		_Myend()

  01e1f	c7 85 88 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui8$36[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 545  :                                 std::vector<ULONGLONG> vui8;

  01e29	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+12], 28 ; 0000001cH

; 546  :                                 FromVariant(vtProp, vui8);

  01e2d	83 ec 10	 sub	 esp, 16			; 00000010H
  01e30	8b c4		 mov	 eax, esp
  01e32	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  01e39	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  01e3c	8d 8d 80 83 ff
	ff		 lea	 ecx, DWORD PTR _vui8$36[ebp]
  01e42	e8 00 00 00 00	 call	 ??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ; FromVariant<unsigned __int64>
  01e47	83 c4 10	 add	 esp, 16			; 00000010H

; 547  :                                 for (unsigned int i = 0; i < vui8.size(); i++)

  01e4a	33 f6		 xor	 esi, esi
$LN2886@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  01e4c	89 b5 20 83 ff
	ff		 mov	 DWORD PTR _i$24[ebp], esi
  01e52	8b 85 84 83 ff
	ff		 mov	 eax, DWORD PTR _vui8$36[ebp+4]
  01e58	8b 8d 80 83 ff
	ff		 mov	 ecx, DWORD PTR _vui8$36[ebp]
  01e5e	2b c1		 sub	 eax, ecx
  01e60	c1 f8 03	 sar	 eax, 3
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 547  :                                 for (unsigned int i = 0; i < vui8.size(); i++)

  01e63	3b f0		 cmp	 esi, eax
  01e65	0f 83 d3 00 00
	00		 jae	 $LN21@WMIex

; 548  :                                 {
; 549  :                                     if (xml)

  01e6b	85 ff		 test	 edi, edi
  01e6d	0f 84 a4 00 00
	00		 je	 $LN102@WMIex

; 550  :                                     {
; 551  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  01e73	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  01e76	50		 push	 eax
  01e77	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  01e7c	68 04 01 00 00	 push	 260			; 00000104H
  01e81	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01e87	50		 push	 eax
  01e88	e8 00 00 00 00	 call	 __snprintf

; 552  :                                         _snprintf(szValue, sizeof(szValue), "0x%.16llX", vui8[i]);

  01e8d	8b 85 80 83 ff
	ff		 mov	 eax, DWORD PTR _vui8$36[ebp]
  01e93	ff 74 f0 04	 push	 DWORD PTR [eax+esi*8+4]
  01e97	ff 34 f0	 push	 DWORD PTR [eax+esi*8]
  01e9a	68 00 00 00 00	 push	 OFFSET ??_C@_09LCPBGOAC@0x?$CF?416llX@
  01e9f	68 10 27 00 00	 push	 10000			; 00002710H
  01ea4	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01eaa	50		 push	 eax
  01eab	e8 00 00 00 00	 call	 __snprintf
  01eb0	83 c4 24	 add	 esp, 36			; 00000024H

; 553  : 
; 554  :                                         id.assign(idx);

  01eb3	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01eb9	50		 push	 eax
  01eba	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  01ec0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 555  :                                         value.assign(szValue);

  01ec5	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01ecb	50		 push	 eax
  01ecc	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  01ed2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 556  :                                         xml->CreateChild(idx, value);

  01ed7	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  01edd	50		 push	 eax
  01ede	8d 8d 48 84 ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  01ee4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ee9	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+12], 29 ; 0000001dH
  01eed	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  01ef3	50		 push	 eax
  01ef4	8d 85 48 84 ff
	ff		 lea	 eax, DWORD PTR $T54[ebp]
  01efa	50		 push	 eax
  01efb	8b cf		 mov	 ecx, edi
  01efd	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  01f02	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+12], 28 ; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

  01f06	8d 8d 48 84 ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  01f0c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 547  :                                 for (unsigned int i = 0; i < vui8.size(); i++)

  01f11	46		 inc	 esi
  01f12	e9 35 ff ff ff	 jmp	 $LN2886@WMIex
$LN102@WMIex:

; 557  :                                     }
; 558  :                                     else
; 559  :                                     {
; 560  :                                         _snprintf(szValue, sizeof(szValue), "%s.0x%.16llX", szValue, vui8[i]);

  01f17	ff 74 f1 04	 push	 DWORD PTR [ecx+esi*8+4]
  01f1b	ff 34 f1	 push	 DWORD PTR [ecx+esi*8]
  01f1e	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  01f24	50		 push	 eax
  01f25	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HHGAEPMF@?$CFs?40x?$CF?416llX@
  01f2a	68 10 27 00 00	 push	 10000			; 00002710H
  01f2f	50		 push	 eax
  01f30	e8 00 00 00 00	 call	 __snprintf
  01f35	83 c4 18	 add	 esp, 24			; 00000018H

; 547  :                                 for (unsigned int i = 0; i < vui8.size(); i++)

  01f38	46		 inc	 esi
  01f39	e9 0e ff ff ff	 jmp	 $LN2886@WMIex
$LN21@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  01f3e	89 8d 84 83 ff
	ff		 mov	 DWORD PTR _vui8$36[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 564  :                             }

  01f44	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  01f48	8b 8d 80 83 ff
	ff		 mov	 ecx, DWORD PTR _vui8$36[ebp]
  01f4e	85 c9		 test	 ecx, ecx
  01f50	0f 84 9a 05 00
	00		 je	 $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  01f56	8b 85 88 83 ff
	ff		 mov	 eax, DWORD PTR _vui8$36[ebp+8]
  01f5c	2b c1		 sub	 eax, ecx
  01f5e	c1 f8 03	 sar	 eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01f61	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  01f68	89 95 24 83 ff
	ff		 mov	 DWORD PTR __Bytes$25[ebp], edx
  01f6e	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01f70	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01f76	72 1a		 jb	 SHORT $LN2191@WMIex

; 115  : 	_Bytes += _Non_user_size;

  01f78	83 c2 23	 add	 edx, 35			; 00000023H
  01f7b	89 95 24 83 ff
	ff		 mov	 DWORD PTR __Bytes$25[ebp], edx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01f81	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01f84	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01f86	83 c0 fc	 add	 eax, -4			; fffffffcH
  01f89	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01f8c	0f 87 2f 09 00
	00		 ja	 $LN2918@WMIex
$LN2191@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01f92	52		 push	 edx
  01f93	51		 push	 ecx
  01f94	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01f99	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  01f9c	c7 85 80 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui8$36[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  01fa6	c7 85 84 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui8$36[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  01fb0	c7 85 88 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vui8$36[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 565  :                             break;

  01fba	e9 31 05 00 00	 jmp	 $LN2709@WMIex
$LN104@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  01fbf	c7 85 74 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr4$35[ebp], 0

; 390  : 		_Mylast(),

  01fc9	c7 85 78 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr4$35[ebp+4], 0

; 391  : 		_Myend()

  01fd3	c7 85 7c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr4$35[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 569  :                                 std::vector<float> vr4;

  01fdd	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+12], 30 ; 0000001eH

; 570  :                                 FromVariant(vtProp, vr4);

  01fe1	83 ec 10	 sub	 esp, 16			; 00000010H
  01fe4	8b c4		 mov	 eax, esp
  01fe6	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  01fed	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  01ff0	8d 8d 74 83 ff
	ff		 lea	 ecx, DWORD PTR _vr4$35[ebp]
  01ff6	e8 00 00 00 00	 call	 ??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z ; FromVariant<float>
  01ffb	83 c4 10	 add	 esp, 16			; 00000010H

; 571  :                                 for (unsigned int i = 0; i < vr4.size(); i++)

  01ffe	33 f6		 xor	 esi, esi
$LN2887@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  02000	89 b5 28 83 ff
	ff		 mov	 DWORD PTR _i$26[ebp], esi
  02006	8b 85 78 83 ff
	ff		 mov	 eax, DWORD PTR _vr4$35[ebp+4]
  0200c	8b 8d 74 83 ff
	ff		 mov	 ecx, DWORD PTR _vr4$35[ebp]
  02012	2b c1		 sub	 eax, ecx
  02014	c1 f8 02	 sar	 eax, 2
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 571  :                                 for (unsigned int i = 0; i < vr4.size(); i++)

  02017	3b f0		 cmp	 esi, eax
  02019	0f 83 e5 00 00
	00		 jae	 $LN24@WMIex

; 572  :                                 {
; 573  :                                     if (xml)

  0201f	85 ff		 test	 edi, edi
  02021	0f 84 ad 00 00
	00		 je	 $LN105@WMIex

; 574  :                                     {
; 575  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  02027	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0202a	50		 push	 eax
  0202b	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  02030	68 04 01 00 00	 push	 260			; 00000104H
  02035	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0203b	50		 push	 eax
  0203c	e8 00 00 00 00	 call	 __snprintf

; 576  :                                         _snprintf(szValue, sizeof(szValue), "%f", vr4[i]);

  02041	8b 85 74 83 ff
	ff		 mov	 eax, DWORD PTR _vr4$35[ebp]
  02047	f3 0f 10 04 b0	 movss	 xmm0, DWORD PTR [eax+esi*4]
  0204c	0f 5a c0	 cvtps2pd xmm0, xmm0
  0204f	83 c4 08	 add	 esp, 8
  02052	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  02057	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf@
  0205c	68 10 27 00 00	 push	 10000			; 00002710H
  02061	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  02067	50		 push	 eax
  02068	e8 00 00 00 00	 call	 __snprintf
  0206d	83 c4 14	 add	 esp, 20			; 00000014H

; 577  : 
; 578  :                                         id.assign(idx);

  02070	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  02076	50		 push	 eax
  02077	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  0207d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 579  :                                         value.assign(szValue);

  02082	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  02088	50		 push	 eax
  02089	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  0208f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 580  :                                         xml->CreateChild(idx, value);

  02094	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0209a	50		 push	 eax
  0209b	8d 8d 00 84 ff
	ff		 lea	 ecx, DWORD PTR $T51[ebp]
  020a1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  020a6	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+12], 31 ; 0000001fH
  020aa	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  020b0	50		 push	 eax
  020b1	8d 85 00 84 ff
	ff		 lea	 eax, DWORD PTR $T51[ebp]
  020b7	50		 push	 eax
  020b8	8b cf		 mov	 ecx, edi
  020ba	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  020bf	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+12], 30 ; 0000001eH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

  020c3	8d 8d 00 84 ff
	ff		 lea	 ecx, DWORD PTR $T51[ebp]
  020c9	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 571  :                                 for (unsigned int i = 0; i < vr4.size(); i++)

  020ce	46		 inc	 esi
  020cf	e9 2c ff ff ff	 jmp	 $LN2887@WMIex
$LN105@WMIex:
  020d4	f3 0f 10 04 b1	 movss	 xmm0, DWORD PTR [ecx+esi*4]

; 581  :                                     }
; 582  :                                     else
; 583  :                                     {
; 584  :                                         _snprintf(szValue, sizeof(szValue), "%s.%f", szValue, vr4[i]);

  020d9	0f 5a c0	 cvtps2pd xmm0, xmm0
  020dc	83 ec 08	 sub	 esp, 8
  020df	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  020e4	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  020ea	50		 push	 eax
  020eb	68 00 00 00 00	 push	 OFFSET ??_C@_05OKOCMAOB@?$CFs?4?$CFf@
  020f0	68 10 27 00 00	 push	 10000			; 00002710H
  020f5	50		 push	 eax
  020f6	e8 00 00 00 00	 call	 __snprintf
  020fb	83 c4 18	 add	 esp, 24			; 00000018H

; 571  :                                 for (unsigned int i = 0; i < vr4.size(); i++)

  020fe	46		 inc	 esi
  020ff	e9 fc fe ff ff	 jmp	 $LN2887@WMIex
$LN24@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  02104	89 8d 78 83 ff
	ff		 mov	 DWORD PTR _vr4$35[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 588  :                             }

  0210a	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  0210e	8b 8d 74 83 ff
	ff		 mov	 ecx, DWORD PTR _vr4$35[ebp]
  02114	85 c9		 test	 ecx, ecx
  02116	0f 84 d4 03 00
	00		 je	 $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0211c	8b 85 7c 83 ff
	ff		 mov	 eax, DWORD PTR _vr4$35[ebp+8]
  02122	2b c1		 sub	 eax, ecx
  02124	c1 f8 02	 sar	 eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  02127	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0212e	89 95 2c 83 ff
	ff		 mov	 DWORD PTR __Bytes$27[ebp], edx
  02134	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  02136	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0213c	72 1a		 jb	 SHORT $LN2387@WMIex

; 115  : 	_Bytes += _Non_user_size;

  0213e	83 c2 23	 add	 edx, 35			; 00000023H
  02141	89 95 2c 83 ff
	ff		 mov	 DWORD PTR __Bytes$27[ebp], edx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  02147	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0214a	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0214c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0214f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  02152	0f 87 6e 07 00
	00		 ja	 $LN2919@WMIex
$LN2387@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  02158	52		 push	 edx
  02159	51		 push	 ecx
  0215a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0215f	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  02162	c7 85 74 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr4$35[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  0216c	c7 85 78 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr4$35[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  02176	c7 85 7c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr4$35[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 589  :                             break;

  02180	e9 6b 03 00 00	 jmp	 $LN2709@WMIex
$LN107@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  02185	c7 85 68 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr8$34[ebp], 0

; 390  : 		_Mylast(),

  0218f	c7 85 6c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr8$34[ebp+4], 0

; 391  : 		_Myend()

  02199	c7 85 70 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr8$34[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 594  :                                 std::vector<double> vr8;

  021a3	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+12], 32 ; 00000020H

; 595  :                                 FromVariant(vtProp, vr8);

  021a7	83 ec 10	 sub	 esp, 16			; 00000010H
  021aa	8b c4		 mov	 eax, esp
  021ac	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  021b3	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  021b6	8d 8d 68 83 ff
	ff		 lea	 ecx, DWORD PTR _vr8$34[ebp]
  021bc	e8 00 00 00 00	 call	 ??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z ; FromVariant<double>
  021c1	83 c4 10	 add	 esp, 16			; 00000010H

; 596  :                                 for (unsigned int i = 0; i < vr8.size(); i++)

  021c4	33 f6		 xor	 esi, esi
$LN2888@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  021c6	89 b5 30 83 ff
	ff		 mov	 DWORD PTR _i$28[ebp], esi
  021cc	8b 85 6c 83 ff
	ff		 mov	 eax, DWORD PTR _vr8$34[ebp+4]
  021d2	8b 8d 68 83 ff
	ff		 mov	 ecx, DWORD PTR _vr8$34[ebp]
  021d8	2b c1		 sub	 eax, ecx
  021da	c1 f8 03	 sar	 eax, 3
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 596  :                                 for (unsigned int i = 0; i < vr8.size(); i++)

  021dd	3b f0		 cmp	 esi, eax
  021df	0f 83 df 00 00
	00		 jae	 $LN27@WMIex

; 597  :                                 {
; 598  :                                     if (xml)

  021e5	85 ff		 test	 edi, edi
  021e7	0f 84 aa 00 00
	00		 je	 $LN108@WMIex

; 599  :                                     {
; 600  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  021ed	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  021f0	50		 push	 eax
  021f1	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  021f6	68 04 01 00 00	 push	 260			; 00000104H
  021fb	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  02201	50		 push	 eax
  02202	e8 00 00 00 00	 call	 __snprintf

; 601  :                                         _snprintf(szValue, sizeof(szValue), "%e", vr8[i]);

  02207	83 c4 08	 add	 esp, 8
  0220a	8b 85 68 83 ff
	ff		 mov	 eax, DWORD PTR _vr8$34[ebp]
  02210	f2 0f 10 04 f0	 movsd	 xmm0, QWORD PTR [eax+esi*8]
  02215	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0221a	68 00 00 00 00	 push	 OFFSET ??_C@_02CGLCDNAE@?$CFe@
  0221f	68 10 27 00 00	 push	 10000			; 00002710H
  02224	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0222a	50		 push	 eax
  0222b	e8 00 00 00 00	 call	 __snprintf
  02230	83 c4 14	 add	 esp, 20			; 00000014H

; 602  : 
; 603  :                                         id.assign(idx);

  02233	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  02239	50		 push	 eax
  0223a	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  02240	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 604  :                                         value.assign(szValue);

  02245	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0224b	50		 push	 eax
  0224c	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  02252	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 605  :                                         xml->CreateChild(idx, value);

  02257	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0225d	50		 push	 eax
  0225e	8d 8d 18 84 ff
	ff		 lea	 ecx, DWORD PTR $T52[ebp]
  02264	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  02269	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+12], 33 ; 00000021H
  0226d	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  02273	50		 push	 eax
  02274	8d 85 18 84 ff
	ff		 lea	 eax, DWORD PTR $T52[ebp]
  0227a	50		 push	 eax
  0227b	8b cf		 mov	 ecx, edi
  0227d	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  02282	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+12], 32 ; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

  02286	8d 8d 18 84 ff
	ff		 lea	 ecx, DWORD PTR $T52[ebp]
  0228c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 596  :                                 for (unsigned int i = 0; i < vr8.size(); i++)

  02291	46		 inc	 esi
  02292	e9 2f ff ff ff	 jmp	 $LN2888@WMIex
$LN108@WMIex:

; 606  :                                     }
; 607  :                                     else
; 608  :                                     {
; 609  :                                         _snprintf(szValue, sizeof(szValue), "%s.%e", szValue, vr8[i]);

  02297	83 ec 08	 sub	 esp, 8
  0229a	f2 0f 10 04 f1	 movsd	 xmm0, QWORD PTR [ecx+esi*8]
  0229f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  022a4	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  022aa	50		 push	 eax
  022ab	68 00 00 00 00	 push	 OFFSET ??_C@_05MBMPJDCC@?$CFs?4?$CFe@
  022b0	68 10 27 00 00	 push	 10000			; 00002710H
  022b5	50		 push	 eax
  022b6	e8 00 00 00 00	 call	 __snprintf
  022bb	83 c4 18	 add	 esp, 24			; 00000018H

; 596  :                                 for (unsigned int i = 0; i < vr8.size(); i++)

  022be	46		 inc	 esi
  022bf	e9 02 ff ff ff	 jmp	 $LN2888@WMIex
$LN27@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  022c4	89 8d 6c 83 ff
	ff		 mov	 DWORD PTR _vr8$34[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 613  :                             }

  022ca	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  022ce	8b 8d 68 83 ff
	ff		 mov	 ecx, DWORD PTR _vr8$34[ebp]
  022d4	85 c9		 test	 ecx, ecx
  022d6	0f 84 14 02 00
	00		 je	 $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  022dc	8b 85 70 83 ff
	ff		 mov	 eax, DWORD PTR _vr8$34[ebp+8]
  022e2	2b c1		 sub	 eax, ecx
  022e4	c1 f8 03	 sar	 eax, 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  022e7	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  022ee	89 95 34 83 ff
	ff		 mov	 DWORD PTR __Bytes$29[ebp], edx
  022f4	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  022f6	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  022fc	72 1a		 jb	 SHORT $LN2583@WMIex

; 115  : 	_Bytes += _Non_user_size;

  022fe	83 c2 23	 add	 edx, 35			; 00000023H
  02301	89 95 34 83 ff
	ff		 mov	 DWORD PTR __Bytes$29[ebp], edx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  02307	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0230a	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0230c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0230f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  02312	0f 87 b3 05 00
	00		 ja	 $LN2920@WMIex
$LN2583@WMIex:

; 207  : 	::operator delete(_Ptr, _Bytes);

  02318	52		 push	 edx
  02319	51		 push	 ecx
  0231a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0231f	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  02322	c7 85 68 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr8$34[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  0232c	c7 85 6c 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr8$34[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  02336	c7 85 70 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vr8$34[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 614  :                             break;

  02340	e9 ab 01 00 00	 jmp	 $LN2709@WMIex
$LN110@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  02345	c7 85 bc 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vbstr$41[ebp], 0

; 390  : 		_Mylast(),

  0234f	c7 85 c0 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vbstr$41[ebp+4], 0

; 391  : 		_Myend()

  02359	c7 85 c4 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vbstr$41[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 618  :                                 std::vector<BSTR> vbstr;

  02363	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+12], 34 ; 00000022H

; 619  :                                 FromVariant(vtProp, vbstr);

  02367	83 ec 10	 sub	 esp, 16			; 00000010H
  0236a	8b c4		 mov	 eax, esp
  0236c	0f 10 85 e0 83
	ff ff		 movups	 xmm0, XMMWORD PTR _vtProp$45[ebp]
  02373	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  02376	8d 8d bc 83 ff
	ff		 lea	 ecx, DWORD PTR _vbstr$41[ebp]
  0237c	e8 00 00 00 00	 call	 ??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ; FromVariant<wchar_t *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  02381	8b 85 c0 83 ff
	ff		 mov	 eax, DWORD PTR _vbstr$41[ebp+4]
  02387	2b 85 bc 83 ff
	ff		 sub	 eax, DWORD PTR _vbstr$41[ebp]
  0238d	c1 f8 02	 sar	 eax, 2
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 621  :                                 Log(LOG_MESSAGE, __LINE__, "%s, %d:", wmiClasses[x].pProperty, vbstr.size());

  02390	50		 push	 eax
  02391	8b 85 fc 83 ff
	ff		 mov	 eax, DWORD PTR _x$49[ebp]
  02397	ff 34 c5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[eax*8+4]
  0239e	68 00 00 00 00	 push	 OFFSET ??_C@_07LKPPIONC@?$CFs?0?5?$CFd?3@
  023a3	68 6d 02 00 00	 push	 621			; 0000026dH
  023a8	6a 01		 push	 1
  023aa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  023af	83 c4 24	 add	 esp, 36			; 00000024H

; 622  :                                 for (unsigned int i = 0; i < vbstr.size(); i++)

  023b2	33 f6		 xor	 esi, esi
$LN2889@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  023b4	89 b5 38 83 ff
	ff		 mov	 DWORD PTR _i$30[ebp], esi
  023ba	8b 85 c0 83 ff
	ff		 mov	 eax, DWORD PTR _vbstr$41[ebp+4]
  023c0	8b 8d bc 83 ff
	ff		 mov	 ecx, DWORD PTR _vbstr$41[ebp]
  023c6	2b c1		 sub	 eax, ecx
  023c8	c1 f8 02	 sar	 eax, 2
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 622  :                                 for (unsigned int i = 0; i < vbstr.size(); i++)

  023cb	3b f0		 cmp	 esi, eax
  023cd	0f 83 d9 00 00
	00		 jae	 $LN30@WMIex

; 623  :                                 {
; 624  :                                     WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)vbstr[i], -1, (LPSTR)szValue, sizeof(szValue), NULL, NULL);

  023d3	6a 00		 push	 0
  023d5	6a 00		 push	 0
  023d7	68 10 27 00 00	 push	 10000			; 00002710H
  023dc	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  023e2	50		 push	 eax
  023e3	6a ff		 push	 -1
  023e5	ff 34 b1	 push	 DWORD PTR [ecx+esi*4]
  023e8	6a 00		 push	 0
  023ea	6a 00		 push	 0
  023ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 625  :                                     if (xml)

  023f2	46		 inc	 esi
  023f3	85 ff		 test	 edi, edi
  023f5	0f 84 7a 00 00
	00		 je	 $LN111@WMIex

; 626  :                                     {
; 627  :                                         _snprintf(idx, sizeof(idx), "%.3u", i + 1);

  023fb	56		 push	 esi
  023fc	68 00 00 00 00	 push	 OFFSET ??_C@_04EHEKGOB@?$CF?43u@
  02401	68 04 01 00 00	 push	 260			; 00000104H
  02406	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0240c	50		 push	 eax
  0240d	e8 00 00 00 00	 call	 __snprintf
  02412	83 c4 10	 add	 esp, 16			; 00000010H

; 628  : 
; 629  :                                         id.assign(idx);

  02415	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0241b	50		 push	 eax
  0241c	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  02422	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 630  :                                         value.assign(szValue);

  02427	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0242d	50		 push	 eax
  0242e	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  02434	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 631  :                                         xml->CreateChild(idx, value);

  02439	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _idx$81[ebp]
  0243f	50		 push	 eax
  02440	8d 8d 30 84 ff
	ff		 lea	 ecx, DWORD PTR $T53[ebp]
  02446	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0244b	c6 45 fc 23	 mov	 BYTE PTR __$EHRec$[ebp+12], 35 ; 00000023H
  0244f	8d 85 10 86 ff
	ff		 lea	 eax, DWORD PTR _value$75[ebp]
  02455	50		 push	 eax
  02456	8d 85 30 84 ff
	ff		 lea	 eax, DWORD PTR $T53[ebp]
  0245c	50		 push	 eax
  0245d	8b cf		 mov	 ecx, edi
  0245f	e8 00 00 00 00	 call	 ?CreateChild@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; xmlwriter::CreateChild
  02464	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+12], 34 ; 00000022H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2460 : 		_Tidy_deallocate();

  02468	8d 8d 30 84 ff
	ff		 lea	 ecx, DWORD PTR $T53[ebp]
  0246e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 633  :                                     else

  02473	eb 1c		 jmp	 SHORT $LN112@WMIex
$LN111@WMIex:

; 634  :                                     {
; 635  :                                         Log(LOG_MESSAGE, __LINE__, "\t> %.3d %s", i + 1, szValue);

  02475	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0247b	50		 push	 eax
  0247c	56		 push	 esi
  0247d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EBBAMLMD@?7?$DO?5?$CF?43d?5?$CFs@
  02482	68 7b 02 00 00	 push	 635			; 0000027bH
  02487	6a 01		 push	 1
  02489	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0248e	83 c4 14	 add	 esp, 20			; 00000014H
$LN112@WMIex:

; 636  :                                     }
; 637  :                                     memset(szValue, 0x00, sizeof(szValue));

  02491	68 10 27 00 00	 push	 10000			; 00002710H
  02496	6a 00		 push	 0
  02498	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  0249e	50		 push	 eax
  0249f	e8 00 00 00 00	 call	 _memset
  024a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 622  :                                 for (unsigned int i = 0; i < vbstr.size(); i++)

  024a7	e9 08 ff ff ff	 jmp	 $LN2889@WMIex
$LN30@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  024ac	89 8d c0 83 ff
	ff		 mov	 DWORD PTR _vbstr$41[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 640  :                             }

  024b2	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+12], 21 ; 00000015H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  024b6	8b 8d bc 83 ff
	ff		 mov	 ecx, DWORD PTR _vbstr$41[ebp]
  024bc	85 c9		 test	 ecx, ecx
  024be	74 30		 je	 SHORT $LN2709@WMIex

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  024c0	8b 85 c4 83 ff
	ff		 mov	 eax, DWORD PTR _vbstr$41[ebp+8]
  024c6	2b c1		 sub	 eax, ecx
  024c8	c1 f8 02	 sar	 eax, 2

; 1916 : 			this->_Getal().deallocate(this->_Myfirst(), capacity());

  024cb	50		 push	 eax
  024cc	51		 push	 ecx
  024cd	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PA_W@std@@QAEXQAPA_WI@Z ; std::allocator<wchar_t *>::deallocate

; 1918 : 			this->_Myfirst() = pointer();

  024d2	c7 85 bc 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vbstr$41[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  024dc	c7 85 c0 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vbstr$41[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  024e6	c7 85 c4 83 ff
	ff 00 00 00 00	 mov	 DWORD PTR _vbstr$41[ebp+8], 0
$LN2709@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 643  :                             if (xml)

  024f0	85 ff		 test	 edi, edi
  024f2	74 09		 je	 SHORT $LN113@WMIex

; 644  :                             {
; 645  :                                 xml->CloseLasttag();

  024f4	8b cf		 mov	 ecx, edi
  024f6	e8 00 00 00 00	 call	 ?CloseLasttag@xmlwriter@@QAEXXZ ; xmlwriter::CloseLasttag

; 646  :                             }
; 647  :                             else

  024fb	eb 3c		 jmp	 SHORT $LN115@WMIex
$LN113@WMIex:

; 648  :                             {
; 649  :                                 if (strlen(szValue) > 0)

  024fd	8d 8d 48 d4 ff
	ff		 lea	 ecx, DWORD PTR _szValue$78[ebp]
  02503	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2873@WMIex:
  02506	8a 01		 mov	 al, BYTE PTR [ecx]
  02508	41		 inc	 ecx
  02509	84 c0		 test	 al, al
  0250b	75 f9		 jne	 SHORT $LL2873@WMIex
  0250d	2b ca		 sub	 ecx, edx
  0250f	74 28		 je	 SHORT $LN115@WMIex

; 650  :                                 {
; 651  :                                     Log(LOG_MESSAGE, __LINE__, "%s = %d", wmiClasses[x].pProperty, szValue);

  02511	8d 85 48 d4 ff
	ff		 lea	 eax, DWORD PTR _szValue$78[ebp]
  02517	50		 push	 eax
  02518	8b 85 fc 83 ff
	ff		 mov	 eax, DWORD PTR _x$49[ebp]
  0251e	ff 34 c5 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[eax*8+4]
  02525	68 00 00 00 00	 push	 OFFSET ??_C@_07DHPDHKIF@?$CFs?5?$DN?5?$CFd@
  0252a	68 8b 02 00 00	 push	 651			; 0000028bH
  0252f	6a 01		 push	 1
  02531	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  02536	83 c4 14	 add	 esp, 20			; 00000014H
$LN115@WMIex:

; 652  :                                 }
; 653  :                             }
; 654  :                         }   //END: if(vtProp.vt & VT_BYREF)

  02539	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  0253d	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  02543	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN90@WMIex:

; 655  :                         break;
; 656  :                     }   //END: switch(vtProp.vt)
; 657  : 
; 658  :                     VariantClear(&vtProp);

  02548	8d 85 e0 83 ff
	ff		 lea	 eax, DWORD PTR _vtProp$45[ebp]
  0254e	50		 push	 eax
  0254f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 659  :                 }   //END: try

  02555	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  02559	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  0255f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 660  :                 catch (...)
; 661  :                 {

  02564	9b		 fwait
  02565	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 246  :             {
; 247  :                 break;
; 248  :             }
; 249  : 
; 250  :             //line.clear();
; 251  :             for (int x = 0; wmiClasses[x].pClass != NULL && _thGetInt(&gbTerminate) == FALSE; x++)

  0256c	8b b5 fc 83 ff
	ff		 mov	 esi, DWORD PTR _x$49[ebp]
  02572	46		 inc	 esi
  02573	e9 34 e2 ff ff	 jmp	 $LN2890@WMIex
__catch$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$0:
  02578	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]

; 662  :                     Log(LOG_DEBUG_WMI, __LINE__, "-- WMI, Catch unhndld excpetion on %.5u %s (%i) %s", properties, wmiClasses[x].pClass, x + 1, wmiClasses[x].pProperty);

  0257b	8b 8d fc 83 ff
	ff		 mov	 ecx, DWORD PTR _x$49[ebp]
  02581	ff 34 cd 04 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[ecx*8+4]
  02588	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0258b	50		 push	 eax
  0258c	ff 34 cd 00 00
	00 00		 push	 DWORD PTR ?wmiClasses@@3PAU_wmi_classes_@@A[ecx*8]
  02593	ff b5 dc 83 ff
	ff		 push	 DWORD PTR _properties$[ebp]
  02599	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@MNMANIEP@?9?9?5WMI?0?5Catch?5unhndld?5excpetion@
  0259e	68 96 02 00 00	 push	 662			; 00000296H
  025a3	6a 40		 push	 64			; 00000040H
  025a5	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  025aa	83 c4 1c	 add	 esp, 28			; 0000001cH

; 663  :                 }

  025ad	b8 00 00 00 00	 mov	 eax, $LN2879@WMIex
  025b2	c3		 ret	 0
$LN2879@WMIex:
  025b3	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
  025b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  025bd	8b 85 dc 83 ff
	ff		 mov	 eax, DWORD PTR _properties$[ebp]
  025c3	89 85 cc 83 ff
	ff		 mov	 DWORD PTR _properties$1$[ebp], eax
  025c9	8b bd 44 83 ff
	ff		 mov	 edi, DWORD PTR _xml$GSCopy$[ebp]
  025cf	89 bd 60 83 ff
	ff		 mov	 DWORD PTR _xml$GSCopy$1$[ebp], edi
  025d5	8b 85 58 83 ff
	ff		 mov	 eax, DWORD PTR _lpszOption$GSCopy$[ebp]
  025db	89 85 d8 83 ff
	ff		 mov	 DWORD PTR _lpszOption$GSCopy$1$[ebp], eax
$LN4@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 246  :             {
; 247  :                 break;
; 248  :             }
; 249  : 
; 250  :             //line.clear();
; 251  :             for (int x = 0; wmiClasses[x].pClass != NULL && _thGetInt(&gbTerminate) == FALSE; x++)

  025e1	8b b5 fc 83 ff
	ff		 mov	 esi, DWORD PTR _x$49[ebp]
  025e7	46		 inc	 esi
  025e8	e9 bf e1 ff ff	 jmp	 $LN2890@WMIex
$LN5@WMIex:

; 664  :             }
; 665  :             pclsObj->Release();

  025ed	8b 85 f8 83 ff
	ff		 mov	 eax, DWORD PTR _pclsObj$48[ebp]
  025f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  025f5	50		 push	 eax
  025f6	ff 51 08	 call	 DWORD PTR [ecx+8]

; 666  :         }   //END: while (pEnumerator)

  025f9	e9 62 e1 ff ff	 jmp	 $LL2@WMIex
$LN117@WMIex:

; 684  :     {
; 685  :         Log(LOG_MESSAGE, __LINE__, processed);

  025fe	8d 85 60 fc ff
	ff		 lea	 eax, DWORD PTR _processed$[ebp]
  02604	50		 push	 eax
  02605	68 ad 02 00 00	 push	 685			; 000002adH
  0260a	6a 01		 push	 1
  0260c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  02611	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN118@WMIex:

; 686  :     }
; 687  : 
; 688  :     // Cleanup
; 689  :     // ========
; 690  : 
; 691  :     pSvc->Release();

  02614	8b 85 d4 83 ff
	ff		 mov	 eax, DWORD PTR _pSvc$[ebp]
  0261a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0261c	50		 push	 eax
  0261d	ff 51 08	 call	 DWORD PTR [ecx+8]

; 692  :     pLoc->Release();

  02620	8b 85 d0 83 ff
	ff		 mov	 eax, DWORD PTR _pLoc$[ebp]
  02626	8b 08		 mov	 ecx, DWORD PTR [eax]
  02628	50		 push	 eax
  02629	ff 51 08	 call	 DWORD PTR [ecx+8]

; 693  :     CoUninitialize();

  0262c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0

; 694  :     if (xml)

  02632	85 ff		 test	 edi, edi
  02634	0f 84 a7 01 00
	00		 je	 $LN119@WMIex
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0263a	c7 85 08 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$72[ebp+16], 0

; 1785 : 		_Myres(0)

  02644	c7 85 0c 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$72[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  0264e	c7 85 08 86 ff
	ff 00 00 00 00	 mov	 DWORD PTR _temp$72[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  02658	c7 85 0c 86 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _temp$72[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  02662	c6 85 f8 85 ff
	ff 00		 mov	 BYTE PTR _temp$72[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 696  :         std::string temp;

  02669	c7 45 fc 26 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 38 ; 00000026H

; 697  :         char elapsedTime[_MAX_PATH] = { 0 };

  02670	68 04 01 00 00	 push	 260			; 00000104H
  02675	6a 00		 push	 0
  02677	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _elapsedTime$80[ebp]
  0267d	50		 push	 eax
  0267e	e8 00 00 00 00	 call	 _memset
  02683	83 c4 0c	 add	 esp, 12			; 0000000cH
  02686	0f 57 c0	 xorps	 xmm0, xmm0

; 698  :         uint64_t tickEnd{};

  02689	66 0f 13 85 50
	83 ff ff	 movlpd	 QWORD PTR _tickEnd$33[ebp], xmm0

; 699  :         double timeElapsed{};

  02691	f2 0f 11 85 40
	83 ff ff	 movsd	 QWORD PTR _timeElapsed$32[ebp], xmm0

; 700  :         uint64_t seconds{};

  02699	66 0f 13 85 b0
	83 ff ff	 movlpd	 QWORD PTR _seconds$40[ebp], xmm0

; 701  :         CalcElapsedTime(tickStart, tickEnd, timeElapsed, seconds);

  026a1	8d 85 b0 83 ff
	ff		 lea	 eax, DWORD PTR _seconds$40[ebp]
  026a7	50		 push	 eax
  026a8	ff b5 4c 83 ff
	ff		 push	 DWORD PTR _tickStart$[ebp+4]
  026ae	ff b5 48 83 ff
	ff		 push	 DWORD PTR _tickStart$[ebp]
  026b4	8d 95 40 83 ff
	ff		 lea	 edx, DWORD PTR _timeElapsed$32[ebp]
  026ba	8d 8d 50 83 ff
	ff		 lea	 ecx, DWORD PTR _tickEnd$33[ebp]
  026c0	e8 00 00 00 00	 call	 ?CalcElapsedTime@@YAX_KAA_KAAN1@Z ; CalcElapsedTime
  026c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 
; 703  :         _snprintf(elapsedTime, sizeof(elapsedTime), "Elapsed Time: %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  026c8	6a 00		 push	 0
  026ca	68 10 0e 00 00	 push	 3600			; 00000e10H
  026cf	8b bd b4 83 ff
	ff		 mov	 edi, DWORD PTR _seconds$40[ebp+4]
  026d5	57		 push	 edi
  026d6	8b b5 b0 83 ff
	ff		 mov	 esi, DWORD PTR _seconds$40[ebp]
  026dc	56		 push	 esi
  026dd	e8 00 00 00 00	 call	 __aulldiv
  026e2	89 85 58 83 ff
	ff		 mov	 DWORD PTR tv6720[ebp], eax
  026e8	89 95 54 83 ff
	ff		 mov	 DWORD PTR tv6719[ebp], edx
  026ee	83 ec 08	 sub	 esp, 8
  026f1	f2 0f 10 85 40
	83 ff ff	 movsd	 xmm0, QWORD PTR _timeElapsed$32[ebp]
  026f9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  026fe	6a 00		 push	 0
  02700	6a 3c		 push	 60			; 0000003cH
  02702	57		 push	 edi
  02703	56		 push	 esi
  02704	e8 00 00 00 00	 call	 __aulldiv
  02709	8b f0		 mov	 esi, eax
  0270b	8b fa		 mov	 edi, edx
  0270d	0f a4 f7 04	 shld	 edi, esi, 4
  02711	c1 e6 04	 shl	 esi, 4
  02714	2b f0		 sub	 esi, eax
  02716	1b fa		 sbb	 edi, edx
  02718	0f a4 f7 02	 shld	 edi, esi, 2
  0271c	c1 e6 02	 shl	 esi, 2
  0271f	8b 8d b0 83 ff
	ff		 mov	 ecx, DWORD PTR _seconds$40[ebp]
  02725	2b ce		 sub	 ecx, esi
  02727	8b 85 b4 83 ff
	ff		 mov	 eax, DWORD PTR _seconds$40[ebp+4]
  0272d	1b c7		 sbb	 eax, edi
  0272f	50		 push	 eax
  02730	51		 push	 ecx
  02731	b9 10 0e 00 00	 mov	 ecx, 3600		; 00000e10H
  02736	8b b5 54 83 ff
	ff		 mov	 esi, DWORD PTR tv6719[ebp]
  0273c	8b c6		 mov	 eax, esi
  0273e	f7 e1		 mul	 ecx
  02740	8b c8		 mov	 ecx, eax
  02742	8b bd 58 83 ff
	ff		 mov	 edi, DWORD PTR tv6720[ebp]
  02748	8b c7		 mov	 eax, edi
  0274a	ba 10 0e 00 00	 mov	 edx, 3600		; 00000e10H
  0274f	f7 e2		 mul	 edx
  02751	03 ca		 add	 ecx, edx
  02753	8b 95 b0 83 ff
	ff		 mov	 edx, DWORD PTR _seconds$40[ebp]
  02759	2b d0		 sub	 edx, eax
  0275b	8b 85 b4 83 ff
	ff		 mov	 eax, DWORD PTR _seconds$40[ebp+4]
  02761	1b c1		 sbb	 eax, ecx
  02763	6a 00		 push	 0
  02765	6a 3c		 push	 60			; 0000003cH
  02767	50		 push	 eax
  02768	52		 push	 edx
  02769	e8 00 00 00 00	 call	 __aulldiv
  0276e	52		 push	 edx
  0276f	50		 push	 eax
  02770	56		 push	 esi
  02771	57		 push	 edi
  02772	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NIHPHPOO@Elapsed?5Time?3?5?$CF02llu?3?$CF02llu?3?$CF02@
  02777	68 04 01 00 00	 push	 260			; 00000104H
  0277c	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _elapsedTime$80[ebp]
  02782	50		 push	 eax
  02783	e8 00 00 00 00	 call	 __snprintf
  02788	83 c4 2c	 add	 esp, 44			; 0000002cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0278b	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _elapsedTime$80[ebp]
  02791	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL2874@WMIex:
  02794	8a 01		 mov	 al, BYTE PTR [ecx]
  02796	41		 inc	 ecx
  02797	84 c0		 test	 al, al
  02799	75 f9		 jne	 SHORT $LL2874@WMIex
  0279b	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0279d	51		 push	 ecx
  0279e	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _elapsedTime$80[ebp]
  027a4	50		 push	 eax
  027a5	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _temp$72[ebp]
  027ab	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 706  :         xml->AddComment(temp);

  027b0	8d 85 f8 85 ff
	ff		 lea	 eax, DWORD PTR _temp$72[ebp]
  027b6	50		 push	 eax
  027b7	8b 8d 60 83 ff
	ff		 mov	 ecx, DWORD PTR _xml$GSCopy$1$[ebp]
  027bd	e8 00 00 00 00	 call	 ?AddComment@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::AddComment

; 707  :         xml->CloseLasttag();

  027c2	8b 8d 60 83 ff
	ff		 mov	 ecx, DWORD PTR _xml$GSCopy$1$[ebp]
  027c8	e8 00 00 00 00	 call	 ?CloseLasttag@xmlwriter@@QAEXXZ ; xmlwriter::CloseLasttag

; 708  :     }

  027cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  027d4	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _temp$72[ebp]
  027da	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 709  :     else

  027df	eb 1b		 jmp	 SHORT $LN120@WMIex
$LN119@WMIex:

; 710  :     {
; 711  :         LogElapsedTime(__LINE__, tickStart);

  027e1	ff b5 4c 83 ff
	ff		 push	 DWORD PTR _tickStart$[ebp+4]
  027e7	ff b5 48 83 ff
	ff		 push	 DWORD PTR _tickStart$[ebp]
  027ed	33 d2		 xor	 edx, edx
  027ef	b9 c7 02 00 00	 mov	 ecx, 711		; 000002c7H
  027f4	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime
  027f9	83 c4 08	 add	 esp, 8
$LN120@WMIex:

; 712  :     }
; 713  :     ReleaseMutex(hWmiMutex);

  027fc	8b b5 5c 83 ff
	ff		 mov	 esi, DWORD PTR _hWmiMutex$[ebp]
  02802	56		 push	 esi
  02803	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 714  :     CloseHandle(hWmiMutex);

  02809	56		 push	 esi
  0280a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 715  : 
; 716  :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMI, ret True");

  02810	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@INLDOGMP@?$DM?$DM?5WMI?0?5ret?5True@
  02815	68 cc 02 00 00	 push	 716			; 000002ccH
  0281a	6a 40		 push	 64			; 00000040H
$LN2882@WMIex:

; 718  : }

  0281c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  02821	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2881@WMIex:
  02824	b0 01		 mov	 al, 1
$LN1@WMIex:
  02826	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  02829	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  02830	59		 pop	 ecx
  02831	5f		 pop	 edi
  02832	5e		 pop	 esi
  02833	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  02836	33 cd		 xor	 ecx, ebp
  02838	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0283d	8b e5		 mov	 esp, ebp
  0283f	5d		 pop	 ebp
  02840	8b e3		 mov	 esp, ebx
  02842	5b		 pop	 ebx
  02843	c3		 ret	 0
$LN2895@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\comutil.h

; 694  :         _com_issue_error(E_OUTOFMEMORY);

  02844	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  02849	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN2896@WMIex:

; 324  :         _com_issue_error(E_OUTOFMEMORY);

  0284e	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  02853	e8 00 00 00 00	 call	 ?_com_issue_error@@YGXJ@Z ; _com_issue_error
$LN2897@WMIex:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  02858	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2898@WMIex:
  0285d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2899@WMIex:
  02862	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2900@WMIex:
  02867	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2901@WMIex:
  0286c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2902@WMIex:
  02871	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2903@WMIex:
  02876	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2904@WMIex:
  0287b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2905@WMIex:
  02880	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2906@WMIex:
  02885	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2907@WMIex:
  0288a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2908@WMIex:
  0288f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2909@WMIex:
  02894	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2910@WMIex:
  02899	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2911@WMIex:
  0289e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2912@WMIex:
  028a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2913@WMIex:
  028a8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2914@WMIex:
  028ad	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2915@WMIex:
  028b2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2916@WMIex:
  028b7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2917@WMIex:
  028bc	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2918@WMIex:
  028c1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2919@WMIex:
  028c6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2920@WMIex:
  028cb	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN2880@WMIex:
$LN2921@WMIex:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 718  : }

  028d0	00 00 00 00	 DD	 $LN55@WMIex
  028d4	00 00 00 00	 DD	 $LN61@WMIex
  028d8	00 00 00 00	 DD	 $LN73@WMIex
  028dc	00 00 00 00	 DD	 $LN76@WMIex
  028e0	00 00 00 00	 DD	 $LN89@WMIex
  028e4	00 00 00 00	 DD	 $LN86@WMIex
  028e8	00 00 00 00	 DD	 $LN82@WMIex
  028ec	00 00 00 00	 DD	 $LN89@WMIex
  028f0	00 00 00 00	 DD	 $LN89@WMIex
  028f4	00 00 00 00	 DD	 $LN79@WMIex
  028f8	00 00 00 00	 DD	 $LN89@WMIex
  028fc	00 00 00 00	 DD	 $LN89@WMIex
  02900	00 00 00 00	 DD	 $LN89@WMIex
  02904	00 00 00 00	 DD	 $LN89@WMIex
  02908	00 00 00 00	 DD	 $LN49@WMIex
  0290c	00 00 00 00	 DD	 $LN52@WMIex
  02910	00 00 00 00	 DD	 $LN58@WMIex
  02914	00 00 00 00	 DD	 $LN64@WMIex
  02918	00 00 00 00	 DD	 $LN67@WMIex
  0291c	00 00 00 00	 DD	 $LN70@WMIex
$LN2922@WMIex:
  02920	00 00 00 00	 DD	 $LN95@WMIex
  02924	00 00 00 00	 DD	 $LN98@WMIex
  02928	00 00 00 00	 DD	 $LN104@WMIex
  0292c	00 00 00 00	 DD	 $LN107@WMIex
  02930	00 00 00 00	 DD	 $LN110@WMIex
  02934	00 00 00 00	 DD	 $LN92@WMIex
  02938	00 00 00 00	 DD	 $LN101@WMIex
  0293c	00 00 00 00	 DD	 $LN2709@WMIex
$LN2866@WMIex:
  02940	00		 DB	 0
  02941	01		 DB	 1
  02942	02		 DB	 2
  02943	03		 DB	 3
  02944	07		 DB	 7
  02945	03		 DB	 3
  02946	04		 DB	 4
  02947	07		 DB	 7
  02948	07		 DB	 7
  02949	07		 DB	 7
  0294a	07		 DB	 7
  0294b	07		 DB	 7
  0294c	07		 DB	 7
  0294d	07		 DB	 7
  0294e	05		 DB	 5
  0294f	05		 DB	 5
  02950	00		 DB	 0
  02951	01		 DB	 1
  02952	06		 DB	 6
  02953	06		 DB	 6
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$38:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 85 f8 83 ff
	ff		 mov	 eax, DWORD PTR $T47[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$2:
  00012	8d 8d dc 83 ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$3:
  0001d	8d 8d c8 83 ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$4:
  00028	8d 8d fc 83 ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1_bstr_t@@QAE@XZ	; _bstr_t::~_bstr_t
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$5:
  00033	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _tag$76[ebp]
  00039	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$36:
  0003e	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _temp$73[ebp]
  00044	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$6:
  00049	8d 8d 10 86 ff
	ff		 lea	 ecx, DWORD PTR _value$75[ebp]
  0004f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$7:
  00054	8d 8d 38 85 ff
	ff		 lea	 ecx, DWORD PTR $T64[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$8:
  0005f	8d 8d 50 85 ff
	ff		 lea	 ecx, DWORD PTR $T65[ebp]
  00065	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$9:
  0006a	8d 8d 68 85 ff
	ff		 lea	 ecx, DWORD PTR $T66[ebp]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$10:
  00075	8d 8d 80 85 ff
	ff		 lea	 ecx, DWORD PTR $T67[ebp]
  0007b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$11:
  00080	8d 8d 98 85 ff
	ff		 lea	 ecx, DWORD PTR $T68[ebp]
  00086	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$12:
  0008b	8d 8d b0 85 ff
	ff		 lea	 ecx, DWORD PTR $T69[ebp]
  00091	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$13:
  00096	8d 8d c8 85 ff
	ff		 lea	 ecx, DWORD PTR $T70[ebp]
  0009c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$14:
  000a1	8d 8d 20 85 ff
	ff		 lea	 ecx, DWORD PTR $T63[ebp]
  000a7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$15:
  000ac	8d 8d e0 85 ff
	ff		 lea	 ecx, DWORD PTR $T71[ebp]
  000b2	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$16:
  000b7	8d 8d 60 84 ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp]
  000bd	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$17:
  000c2	8d 8d 78 84 ff
	ff		 lea	 ecx, DWORD PTR $T56[ebp]
  000c8	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$18:
  000cd	8d 8d 90 84 ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp]
  000d3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$19:
  000d8	8d 8d a8 84 ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  000de	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$20:
  000e3	8d 8d c0 84 ff
	ff		 lea	 ecx, DWORD PTR $T59[ebp]
  000e9	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$21:
  000ee	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _id$74[ebp]
  000f4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$22:
  000f9	8d 8d a4 83 ff
	ff		 lea	 ecx, DWORD PTR _vui1$39[ebp]
  000ff	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$23:
  00104	8d 8d d8 84 ff
	ff		 lea	 ecx, DWORD PTR $T60[ebp]
  0010a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$24:
  0010f	8d 8d 98 83 ff
	ff		 lea	 ecx, DWORD PTR _vui2$38[ebp]
  00115	e9 00 00 00 00	 jmp	 ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$25:
  0011a	8d 8d f0 84 ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  00120	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$26:
  00125	8d 8d 8c 83 ff
	ff		 lea	 ecx, DWORD PTR _vui4$37[ebp]
  0012b	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$27:
  00130	8d 8d 08 85 ff
	ff		 lea	 ecx, DWORD PTR $T62[ebp]
  00136	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$28:
  0013b	8d 8d 80 83 ff
	ff		 lea	 ecx, DWORD PTR _vui8$36[ebp]
  00141	e9 00 00 00 00	 jmp	 ??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$29:
  00146	8d 8d 48 84 ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  0014c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$30:
  00151	8d 8d 74 83 ff
	ff		 lea	 ecx, DWORD PTR _vr4$35[ebp]
  00157	e9 00 00 00 00	 jmp	 ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$31:
  0015c	8d 8d 00 84 ff
	ff		 lea	 ecx, DWORD PTR $T51[ebp]
  00162	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$32:
  00167	8d 8d 68 83 ff
	ff		 lea	 ecx, DWORD PTR _vr8$34[ebp]
  0016d	e9 00 00 00 00	 jmp	 ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$33:
  00172	8d 8d 18 84 ff
	ff		 lea	 ecx, DWORD PTR $T52[ebp]
  00178	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$34:
  0017d	8d 8d bc 83 ff
	ff		 lea	 ecx, DWORD PTR _vbstr$41[ebp]
  00183	e9 00 00 00 00	 jmp	 ??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$35:
  00188	8d 8d 30 84 ff
	ff		 lea	 ecx, DWORD PTR $T53[ebp]
  0018e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z$37:
  00193	8d 8d f8 85 ff
	ff		 lea	 ecx, DWORD PTR _temp$72[ebp]
  00199	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z:
  0019e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  001a2	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  001a5	8b 8a c4 82 ff
	ff		 mov	 ecx, DWORD PTR [edx-32060]
  001ab	33 c8		 xor	 ecx, eax
  001ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b2	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  001b5	33 c8		 xor	 ecx, eax
  001b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001bc	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z
  001c1	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ENDP			; WMIex
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
?WMI@@YAXPBDPAK@Z PROC					; WMI
; _lpszOption$ = ecx
; _lpulProperties$ = edx

; 721  : {

  00000	51		 push	 ecx

; 722  :     WMIex(lpszOption, nullptr, lpulProperties);

  00001	52		 push	 edx
  00002	33 d2		 xor	 edx, edx
  00004	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  00009	83 c4 04	 add	 esp, 4

; 723  : }

  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
?WMI@@YAXPBDPAK@Z ENDP					; WMI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stack
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stack
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
_TEXT	SEGMENT
_timeElapsed$1$ = -1028					; size = 8
_lpData$GSCopy$1$ = -1020				; size = 4
_list$ = -1016						; size = 12
_tickStart$1$ = -1004					; size = 4
tv1717 = -1004						; size = 4
_tickStart$2$ = -1000					; size = 4
tv1718 = -1000						; size = 4
tv1721 = -996						; size = 4
_size$1$ = -996						; size = 4
_this$ = -996						; size = 4
tv1722 = -992						; size = 4
_cnt$1$ = -992						; size = 4
_this$5 = -992						; size = 4
_fileName$6 = -988					; size = 24
_xml$7 = -964						; size = 68
_newFile$ = -896					; size = 260
_temp$8 = -636						; size = 260
_sMember$9 = -376					; size = 100
_oldFile$ = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?ThreadWMIClass@@YGIPAX@Z PROC				; ThreadWMIClass

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ThreadWMIClass@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f8 03 00
	00		 sub	 esp, 1016		; 000003f8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 5d 08	 mov	 ebx, DWORD PTR _lpData$[ebp]

; 730  :     std::vector<std::string>* plist = (std::vector<std::string>*)lpData;
; 731  : 
; 732  :     Log(LOG_DEBUG_WMI, __LINE__, ">> ThrdWMICls, 0x%p", lpData);

  00031	53		 push	 ebx
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CMGEPGOJ@?$DO?$DO?5ThrdWMICls?0?50x?$CFp@
  00037	68 dc 02 00 00	 push	 732			; 000002dcH
  0003c	6a 40		 push	 64			; 00000040H
  0003e	89 9d 04 fc ff
	ff		 mov	 DWORD PTR _lpData$GSCopy$1$[ebp], ebx
  00044	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 733  : 
; 734  :     if (nullptr == lpData)

  0004c	85 db		 test	 ebx, ebx
  0004e	75 24		 jne	 SHORT $LN13@ThreadWMIC

; 735  :     {
; 736  :         Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMICls, Input null", lpData);

  00050	53		 push	 ebx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MEBHLELC@?$DM?$DM?5ThrdWMICls?0?5Input?5null@
  00056	68 e0 02 00 00	 push	 736			; 000002e0H
  0005b	6a 40		 push	 64			; 00000040H
  0005d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 737  :         _endthreadex(ERROR_INVALID_DATA);

  00062	6a 0d		 push	 13			; 0000000dH
  00064	e8 00 00 00 00	 call	 __endthreadex
  00069	83 c4 14	 add	 esp, 20			; 00000014H

; 738  :         return ERROR_INVALID_DATA;

  0006c	8d 43 0d	 lea	 eax, DWORD PTR [ebx+13]
  0006f	e9 b4 07 00 00	 jmp	 $LN1@ThreadWMIC
$LN13@ThreadWMIC:

; 739  :     }
; 740  : 
; 741  :     std::vector<std::string> const list = *plist;

  00074	53		 push	 ebx
  00075	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _list$[ebp]
  0007b	e8 00 00 00 00	 call	 ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00080	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 742  : 
; 743  :     //find the last file
; 744  :     HANDLE hXmlFile = NULL;
; 745  :     int x;
; 746  :     for (x = 9; x >= 0; x--)

  00087	be 09 00 00 00	 mov	 esi, 9
  0008c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateFileA@28
$LL4@ThreadWMIC:

; 748  :         char temp[_MAX_PATH] = { 0 };

  00092	68 04 01 00 00	 push	 260			; 00000104H
  00097	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  0009d	6a 00		 push	 0
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  000a5	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _list$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 748  :         char temp[_MAX_PATH] = { 0 };

  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000ae	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  000b2	72 02		 jb	 SHORT $LN35@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN35@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 749  :         _snprintf(temp, sizeof(temp), "%s_%s_%.1d.xml", gszLogFilePrefix, list[0].c_str(), x);

  000b6	56		 push	 esi
  000b7	50		 push	 eax
  000b8	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GEABHMOE@?$CFs_?$CFs_?$CF?41d?4xml@
  000c2	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  000c8	68 04 01 00 00	 push	 260			; 00000104H
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 __snprintf

; 750  :         Log(LOG_DEBUG_WMI, __LINE__, "-- ThrdWMICls, Trying opng %s", temp);

  000d3	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  000d9	50		 push	 eax
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KIFPLLFC@?9?9?5ThrdWMICls?0?5Trying?5opng?5?$CFs@
  000df	68 ee 02 00 00	 push	 750			; 000002eeH
  000e4	6a 40		 push	 64			; 00000040H
  000e6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000eb	83 c4 28	 add	 esp, 40			; 00000028H

; 751  :         hXmlFile = CreateFile(temp, GENERIC_READ | GENERIC_WRITE,

  000ee	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  000f4	6a 00		 push	 0
  000f6	68 80 00 00 00	 push	 128			; 00000080H
  000fb	6a 03		 push	 3
  000fd	6a 00		 push	 0
  000ff	6a 03		 push	 3
  00101	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00106	50		 push	 eax
  00107	ff d3		 call	 ebx
  00109	8b f8		 mov	 edi, eax

; 752  :             FILE_SHARE_READ | FILE_SHARE_WRITE,
; 753  :             NULL,
; 754  :             OPEN_EXISTING,
; 755  :             FILE_ATTRIBUTE_NORMAL,
; 756  :             NULL);
; 757  :         if (hXmlFile != INVALID_HANDLE_VALUE)

  0010b	83 ff ff	 cmp	 edi, -1
  0010e	75 0b		 jne	 SHORT $LN588@ThreadWMIC

; 742  : 
; 743  :     //find the last file
; 744  :     HANDLE hXmlFile = NULL;
; 745  :     int x;
; 746  :     for (x = 9; x >= 0; x--)

  00110	83 ee 01	 sub	 esi, 1
  00113	0f 89 79 ff ff
	ff		 jns	 $LL4@ThreadWMIC

; 752  :             FILE_SHARE_READ | FILE_SHARE_WRITE,
; 753  :             NULL,
; 754  :             OPEN_EXISTING,
; 755  :             FILE_ATTRIBUTE_NORMAL,
; 756  :             NULL);
; 757  :         if (hXmlFile != INVALID_HANDLE_VALUE)

  00119	eb 4e		 jmp	 SHORT $LN15@ThreadWMIC
$LN588@ThreadWMIC:

; 758  :         {
; 759  :             Log(LOG_DEBUG_WMI, __LINE__, "-- ThrdWMICls, Last file fnd: %s", temp);

  0011b	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  00121	50		 push	 eax
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MFKPEIAE@?9?9?5ThrdWMICls?0?5Last?5file?5fnd?3?5?$CF@
  00127	68 f7 02 00 00	 push	 759			; 000002f7H
  0012c	6a 40		 push	 64			; 00000040H
  0012e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00133	83 c4 10	 add	 esp, 16			; 00000010H

; 760  :             CloseHandle(hXmlFile);

  00136	57		 push	 edi
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 761  :             hXmlFile = NULL;
; 762  : 
; 763  :             //all file were filled, removed the last one
; 764  :             if (x == 9) {

  0013d	83 fe 09	 cmp	 esi, 9
  00140	75 27		 jne	 SHORT $LN15@ThreadWMIC

; 765  :                 Log(LOG_DEBUG_WMI, __LINE__, "-- ThrdWMICls, Removing %s - oldest file", temp);

  00142	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  00148	50		 push	 eax
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FDBGIAB@?9?9?5ThrdWMICls?0?5Removing?5?$CFs?5?9?5ol@
  0014e	68 fd 02 00 00	 push	 765			; 000002fdH
  00153	6a 40		 push	 64			; 00000040H
  00155	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 766  :                 remove((char*)temp);

  0015a	8d 85 84 fd ff
	ff		 lea	 eax, DWORD PTR _temp$8[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 _remove
  00166	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@ThreadWMIC:

; 767  :             }
; 768  : 
; 769  :             break;      //last one was found
; 770  :         }
; 771  :     }
; 772  : 
; 773  :     //rename the last one to the previous
; 774  :     char newFile[_MAX_PATH] = { 0 };

  00169	68 04 01 00 00	 push	 260			; 00000104H
  0016e	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  00174	6a 00		 push	 0
  00176	50		 push	 eax
  00177	e8 00 00 00 00	 call	 _memset

; 775  :     char oldFile[_MAX_PATH] = { 0 };

  0017c	68 04 01 00 00	 push	 260			; 00000104H
  00181	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  00187	6a 00		 push	 0
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 _memset
  0018f	83 c4 18	 add	 esp, 24			; 00000018H

; 776  :     for (; x >= 0; x--)

  00192	85 f6		 test	 esi, esi
  00194	0f 88 a0 00 00
	00		 js	 $LN6@ThreadWMIC
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL7@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  001a0	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _list$[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001a6	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  001aa	72 02		 jb	 SHORT $LN56@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  001ac	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN56@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 779  :         _snprintf(newFile, sizeof(newFile), "%s_%s_%.1d.xml", gszLogFilePrefix, list[0].c_str(), x + 1);

  001ae	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  001b1	50		 push	 eax
  001b2	51		 push	 ecx
  001b3	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GEABHMOE@?$CFs_?$CFs_?$CF?41d?4xml@
  001bd	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  001c3	68 04 01 00 00	 push	 260			; 00000104H
  001c8	50		 push	 eax
  001c9	e8 00 00 00 00	 call	 __snprintf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  001ce	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _list$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 779  :         _snprintf(newFile, sizeof(newFile), "%s_%s_%.1d.xml", gszLogFilePrefix, list[0].c_str(), x + 1);

  001d4	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001d7	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  001db	72 02		 jb	 SHORT $LN77@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  001dd	8b 00		 mov	 eax, DWORD PTR [eax]
$LN77@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 780  :         _snprintf(oldFile, sizeof(oldFile), "%s_%s_%.1d.xml", gszLogFilePrefix, list[0].c_str(), x);

  001df	56		 push	 esi
  001e0	50		 push	 eax
  001e1	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  001e6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GEABHMOE@?$CFs_?$CFs_?$CF?41d?4xml@
  001eb	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  001f1	68 04 01 00 00	 push	 260			; 00000104H
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 __snprintf

; 781  : 
; 782  :         Log(LOG_DEBUG_WMI, __LINE__, "-- ThrdWMICls, Renaming %s -> %s", oldFile, newFile);

  001fc	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  00202	50		 push	 eax
  00203	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  00209	50		 push	 eax
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FAJHAFKJ@?9?9?5ThrdWMICls?0?5Renaming?5?$CFs?5?9?$DO?5?$CF@
  0020f	68 0e 03 00 00	 push	 782			; 0000030eH
  00214	6a 40		 push	 64			; 00000040H
  00216	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 783  :         static_cast<void>(rename((const char*)oldFile, (const char*)newFile));

  0021b	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  00221	50		 push	 eax
  00222	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 _rename
  0022e	83 c4 34	 add	 esp, 52			; 00000034H
  00231	83 ee 01	 sub	 esi, 1
  00234	0f 89 66 ff ff
	ff		 jns	 $LL7@ThreadWMIC
$LN6@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0023a	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _list$[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00240	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00244	72 02		 jb	 SHORT $LN98@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00246	8b 00		 mov	 eax, DWORD PTR [eax]
$LN98@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 787  :     _snprintf(newFile, sizeof(newFile), "%s_%s_0.xml", gszLogFilePrefix, list[0].c_str());

  00248	50		 push	 eax
  00249	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  0024e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EJAENGON@?$CFs_?$CFs_0?4xml@
  00253	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  00259	68 04 01 00 00	 push	 260			; 00000104H
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 __snprintf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00264	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _list$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 787  :     _snprintf(newFile, sizeof(newFile), "%s_%s_0.xml", gszLogFilePrefix, list[0].c_str());

  0026a	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0026d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00271	72 02		 jb	 SHORT $LN119@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00273	8b 00		 mov	 eax, DWORD PTR [eax]
$LN119@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 788  :     _snprintf(oldFile, sizeof(oldFile), "%s_%s.xml", gszLogFilePrefix, list[0].c_str());

  00275	50		 push	 eax
  00276	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_09LJCHENPN@?$CFs_?$CFs?4xml@
  00280	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  00286	68 04 01 00 00	 push	 260			; 00000104H
  0028b	50		 push	 eax
  0028c	e8 00 00 00 00	 call	 __snprintf

; 789  :     Log(LOG_DEBUG_WMI, __LINE__, "-- ThrdWMICls, Remaining %s -> %s", oldFile, newFile);

  00291	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  00297	50		 push	 eax
  00298	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  0029e	50		 push	 eax
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FAKIJPEF@?9?9?5ThrdWMICls?0?5Remaining?5?$CFs?5?9?$DO?5@
  002a4	68 15 03 00 00	 push	 789			; 00000315H
  002a9	6a 40		 push	 64			; 00000040H
  002ab	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 790  :     static_cast<void>(rename((const char*)oldFile, (const char*)newFile));

  002b0	8d 85 80 fc ff
	ff		 lea	 eax, DWORD PTR _newFile$[ebp]
  002b6	50		 push	 eax
  002b7	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  002bd	50		 push	 eax
  002be	e8 00 00 00 00	 call	 _rename
  002c3	83 c4 30	 add	 esp, 48			; 00000030H

; 792  :     uint64_t tickStart = SysTick();

  002c6	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  002cb	8b d8		 mov	 ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  002cd	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _fileName$6[ebp+16], 0

; 1785 : 		_Myres(0)

  002d7	c7 85 38 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _fileName$6[ebp+20], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 792  :     uint64_t tickStart = SysTick();

  002e1	89 9d 18 fc ff
	ff		 mov	 DWORD PTR _tickStart$2$[ebp], ebx
  002e7	89 95 14 fc ff
	ff		 mov	 DWORD PTR _tickStart$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

  002ed	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _fileName$6[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002f7	c7 85 38 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR _fileName$6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00301	c6 85 24 fc ff
	ff 00		 mov	 BYTE PTR _fileName$6[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 793  :     {   std::string fileName;

  00308	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0030c	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _oldFile$[ebp]
  00312	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL613@ThreadWMIC:
  00315	8a 01		 mov	 al, BYTE PTR [ecx]
  00317	41		 inc	 ecx
  00318	84 c0		 test	 al, al
  0031a	75 f9		 jne	 SHORT $LL613@ThreadWMIC
  0031c	2b ca		 sub	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0031e	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _oldFile$[ebp]
  00324	51		 push	 ecx
  00325	50		 push	 eax
  00326	8d 8d 24 fc ff
	ff		 lea	 ecx, DWORD PTR _fileName$6[ebp]
  0032c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 32   : xmlwriter::xmlwriter(std::string const& sTmp, DebugMsg dbg) : sXmlFile(sTmp), pDebug(dbg), iLevel(0)

  00331	8d 85 24 fc ff
	ff		 lea	 eax, DWORD PTR _fileName$6[ebp]
  00337	50		 push	 eax
  00338	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp]
  0033e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00343	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00347	c7 85 54 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+24], 0

; 390  : 		_Mylast(),

  00351	c7 85 58 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+28], 0

; 391  : 		_Myend()

  0035b	c7 85 5c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+32], 0
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 33   : {

  00365	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00369	8d 85 68 fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp+44]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 52   : 		return (::operator new(_Bytes));

  0036f	6a 08		 push	 8
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 32   : xmlwriter::xmlwriter(std::string const& sTmp, DebugMsg dbg) : sXmlFile(sTmp), pDebug(dbg), iLevel(0)

  00371	c7 85 64 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+40], 0

; 33   : {

  0037b	89 85 1c fc ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stack

; 30   : 		: c()

  00381	89 85 20 fc ff
	ff		 mov	 DWORD PTR _this$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00387	c7 85 68 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+44], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 680  : 		: _Map(),

  00391	c7 85 6c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+48], 0

; 681  : 		_Mapsize(0),

  0039b	c7 85 70 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+52], 0

; 682  : 		_Myoff(0),

  003a5	c7 85 74 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+56], 0

; 683  : 		_Mysize(0)

  003af	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+60], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 52   : 		return (::operator new(_Bytes));

  003b9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 787  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  003be	89 85 68 fc ff
	ff		 mov	 DWORD PTR _xml$7[ebp+44], eax

; 789  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  003c4	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp+44]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  003ca	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  003d0	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 789  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  003d7	8b 85 68 fc ff
	ff		 mov	 eax, DWORD PTR _xml$7[ebp+44]
  003dd	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 33   : {

  003df	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  003e3	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003e9	83 bd 50 fc ff
	ff 10		 cmp	 DWORD PTR _xml$7[ebp+20], 16 ; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 35   :     fp = fopen(sXmlFile.c_str(), "w");

  003f0	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1815 : 		if (_Large_string_engaged())

  003f5	0f 43 85 3c fc
	ff ff		 cmovae	 eax, DWORD PTR _xml$7[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 35   :     fp = fopen(sXmlFile.c_str(), "w");

  003fc	50		 push	 eax
  003fd	c7 85 7c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+64], OFFSET ?DebugStringToFile@@YAXPADH@Z ; DebugStringToFile
  00407	c7 85 64 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _xml$7[ebp+40], 0
  00411	e8 00 00 00 00	 call	 _fopen
  00416	83 c4 0c	 add	 esp, 12			; 0000000cH
  00419	89 85 60 fc ff
	ff		 mov	 DWORD PTR _xml$7[ebp+36], eax

; 36   :     if (fp == nullptr)

  0041f	85 c0		 test	 eax, eax
  00421	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  00427	75 09		 jne	 SHORT $LN156@ThreadWMIC

; 37   :     {
; 38   :         Write(__LINE__, "Unable to open output file");

  00429	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DCOMEIOP@Unable?5to?5open?5output?5file@
  0042e	6a 26		 push	 38			; 00000026H

; 39   :         return;

  00430	eb 07		 jmp	 SHORT $LN617@ThreadWMIC
$LN156@ThreadWMIC:

; 40   :     }
; 41   :     else
; 42   :     {
; 43   :         Write(__LINE__, "<?xml version=\"1.0\" encoding=\"UTF-8\"\?>");

  00432	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MHPNFOKF@?$DM?$DPxml?5version?$DN?$CC1?40?$CC?5encoding?$DN?$CCU@
  00437	6a 2b		 push	 43			; 0000002bH
$LN617@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 795  :         xmlwriter xml(fileName, DebugStringToFile);

  00439	50		 push	 eax
  0043a	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write
  0043f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00442	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 797  :         xml.Createtag(list[1]);

  00446	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0044c	8b 85 08 fc ff
	ff		 mov	 eax, DWORD PTR _list$[ebp]
  00452	83 c0 18	 add	 eax, 24			; 00000018H
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 797  :         xml.Createtag(list[1]);

  00455	50		 push	 eax
  00456	e8 00 00 00 00	 call	 ?Createtag@xmlwriter@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; xmlwriter::Createtag
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0045b	8b bd 08 fc ff
	ff		 mov	 edi, DWORD PTR _list$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 152  :     Write(__LINE__, "\n");

  00461	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  00467	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  0046c	68 98 00 00 00	 push	 152			; 00000098H
  00471	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  00472	83 c7 30	 add	 edi, 48			; 00000030H
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 152  :     Write(__LINE__, "\n");

  00475	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write

; 153  : 
; 154  :     //Indent properly
; 155  :     for (int iTmp = 0; iTmp < iLevel; iTmp++)

  0047a	33 f6		 xor	 esi, esi
  0047c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047f	39 b5 64 fc ff
	ff		 cmp	 DWORD PTR _xml$7[ebp+40], esi
  00485	7e 2b		 jle	 SHORT $LN293@ThreadWMIC
  00487	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL294@ThreadWMIC:

; 156  :         Write(__LINE__, "\t");

  00490	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7@
  00495	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  0049b	68 9c 00 00 00	 push	 156			; 0000009cH
  004a0	50		 push	 eax
  004a1	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write
  004a6	46		 inc	 esi
  004a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  004aa	3b b5 64 fc ff
	ff		 cmp	 esi, DWORD PTR _xml$7[ebp+40]
  004b0	7c de		 jl	 SHORT $LL294@ThreadWMIC
$LN293@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  004b2	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  004b6	72 02		 jb	 SHORT $LN303@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  004b8	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN303@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 158  :     Write(__LINE__, "<!-- %s -->", sComment.c_str());

  004ba	57		 push	 edi
  004bb	68 00 00 00 00	 push	 OFFSET ??_C@_0M@BAIKGCLN@?$DM?$CB?9?9?5?$CFs?5?9?9?$DO@
  004c0	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  004c6	68 9e 00 00 00	 push	 158			; 0000009eH
  004cb	50		 push	 eax
  004cc	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  004d1	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _lpData$GSCopy$1$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 158  :     Write(__LINE__, "<!-- %s -->", sComment.c_str());

  004d7	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 801  :         for (decltype(size) cnt = 3; cnt < size && _thGetInt(&gbTerminate) == FALSE; ++cnt)

  004da	c7 85 20 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR _cnt$1$[ebp], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  004e4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  004e7	2b 08		 sub	 ecx, DWORD PTR [eax]
  004e9	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  004ee	f7 e9		 imul	 ecx
  004f0	c1 fa 02	 sar	 edx, 2
  004f3	8b c2		 mov	 eax, edx
  004f5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  004f8	03 c2		 add	 eax, edx
  004fa	89 85 1c fc ff
	ff		 mov	 DWORD PTR _size$1$[ebp], eax
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 801  :         for (decltype(size) cnt = 3; cnt < size && _thGetInt(&gbTerminate) == FALSE; ++cnt)

  00500	83 f8 03	 cmp	 eax, 3
  00503	0f 86 ad 00 00
	00		 jbe	 $LN586@ThreadWMIC
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 158  :     Write(__LINE__, "<!-- %s -->", sComment.c_str());

  00509	bb 48 00 00 00	 mov	 ebx, 72			; 00000048H
  0050e	66 90		 npad	 2
$LL10@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 77   :     char sMember[100] = { 0 };

  00510	6a 64		 push	 100			; 00000064H
  00512	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$9[ebp]
  00518	6a 00		 push	 0
  0051a	50		 push	 eax
  0051b	e8 00 00 00 00	 call	 _memset

; 78   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00520	68 00 00 00 00	 push	 OFFSET ?gbTerminate@@3HA ; gbTerminate
  00525	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0052a	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$9[ebp]
  00530	6a 63		 push	 99			; 00000063H
  00532	50		 push	 eax
  00533	e8 00 00 00 00	 call	 __snprintf
  00538	83 c4 1c	 add	 esp, 28			; 0000001cH

; 79   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0053b	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$9[ebp]
  00541	50		 push	 eax
  00542	6a 00		 push	 0
  00544	6a 00		 push	 0
  00546	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0054c	8b f8		 mov	 edi, eax

; 80   :     WaitForSingleObject(hdTh, INFINITE);

  0054e	6a ff		 push	 -1
  00550	57		 push	 edi
  00551	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 81   : 
; 82   :     int const iRetVal = *piProtectedVar;

  00557	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbTerminate@@3HA ; gbTerminate

; 83   : 
; 84   :     ReleaseMutex(hdTh);

  0055d	57		 push	 edi
  0055e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 85   :     CloseHandle(hdTh);

  00564	57		 push	 edi
  00565	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 801  :         for (decltype(size) cnt = 3; cnt < size && _thGetInt(&gbTerminate) == FALSE; ++cnt)

  0056b	85 f6		 test	 esi, esi
  0056d	75 41		 jne	 SHORT $LN614@ThreadWMIC
  0056f	90		 npad	 1
$LL11@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  00570	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _list$[ebp]
  00576	03 cb		 add	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00578	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0057c	72 02		 jb	 SHORT $LN341@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0057e	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN341@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 803  :             while (WMIex(list[cnt].c_str(), &xml) == false);

  00580	6a 00		 push	 0
  00582	8d 95 3c fc ff
	ff		 lea	 edx, DWORD PTR _xml$7[ebp]
  00588	e8 00 00 00 00	 call	 ?WMIex@@YA_NPBDPAVxmlwriter@@PAK@Z ; WMIex
  0058d	83 c4 04	 add	 esp, 4
  00590	84 c0		 test	 al, al
  00592	74 dc		 je	 SHORT $LL11@ThreadWMIC

; 801  :         for (decltype(size) cnt = 3; cnt < size && _thGetInt(&gbTerminate) == FALSE; ++cnt)

  00594	8b 85 20 fc ff
	ff		 mov	 eax, DWORD PTR _cnt$1$[ebp]
  0059a	83 c3 18	 add	 ebx, 24			; 00000018H
  0059d	40		 inc	 eax
  0059e	89 85 20 fc ff
	ff		 mov	 DWORD PTR _cnt$1$[ebp], eax
  005a4	3b 85 1c fc ff
	ff		 cmp	 eax, DWORD PTR _size$1$[ebp]
  005aa	0f 82 60 ff ff
	ff		 jb	 $LL10@ThreadWMIC
$LN614@ThreadWMIC:
  005b0	8b 9d 18 fc ff
	ff		 mov	 ebx, DWORD PTR _tickStart$2$[ebp]
$LN586@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 99   :     while (sTagStack.size() != 0)

  005b6	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _xml$7[ebp+60], 0
  005bd	0f 84 c8 00 00
	00		 je	 $LN349@ThreadWMIC
$LL348@ThreadWMIC:

; 100  :     {
; 101  :         Write(__LINE__, "\n");

  005c3	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  005c8	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  005ce	6a 65		 push	 101			; 00000065H
  005d0	50		 push	 eax
  005d1	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write

; 102  :         iLevel--;

  005d6	8b 85 64 fc ff
	ff		 mov	 eax, DWORD PTR _xml$7[ebp+40]
  005dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  005df	48		 dec	 eax

; 103  : 
; 104  :         //Indent properly
; 105  :         for (int iTmp = 0; iTmp < iLevel; iTmp++)

  005e0	33 f6		 xor	 esi, esi
  005e2	89 85 64 fc ff
	ff		 mov	 DWORD PTR _xml$7[ebp+40], eax
  005e8	85 c0		 test	 eax, eax
  005ea	7e 23		 jle	 SHORT $LN351@ThreadWMIC
  005ec	0f 1f 40 00	 npad	 4
$LL352@ThreadWMIC:

; 106  :             Write(__LINE__, "\t");

  005f0	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7@
  005f5	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  005fb	6a 6a		 push	 106			; 0000006aH
  005fd	50		 push	 eax
  005fe	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write
  00603	46		 inc	 esi
  00604	83 c4 0c	 add	 esp, 12			; 0000000cH
  00607	3b b5 64 fc ff
	ff		 cmp	 esi, DWORD PTR _xml$7[ebp+40]
  0060d	7c e1		 jl	 SHORT $LL352@ThreadWMIC
$LN351@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0060f	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR _xml$7[ebp+44]
  00615	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 1244 : 		return (iterator(this->_Myoff() + this->_Mysize(),

  00617	8b 95 78 fc ff
	ff		 mov	 edx, DWORD PTR _xml$7[ebp+60]
  0061d	8b b5 74 fc ff
	ff		 mov	 esi, DWORD PTR _xml$7[ebp+56]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00623	85 c9		 test	 ecx, ecx

; 120  : 		if (_Myproxy != _Right._Myproxy)

  00625	74 08		 je	 SHORT $LN415@ThreadWMIC

; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);

  00627	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 148  : 		if (_Parent == nullptr)

  00629	85 c9		 test	 ecx, ecx
  0062b	74 02		 je	 SHORT $LN415@ThreadWMIC

; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;

  0062d	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN415@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 571  : 		this->_Myoff += _Off;

  0062f	4a		 dec	 edx
  00630	03 d6		 add	 edx, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00632	85 c0		 test	 eax, eax

; 120  : 		if (_Myproxy != _Right._Myproxy)

  00634	74 10		 je	 SHORT $LN612@ThreadWMIC

; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);

  00636	8b 00		 mov	 eax, DWORD PTR [eax]

; 148  : 		if (_Parent == nullptr)

  00638	85 c0		 test	 eax, eax
  0063a	74 0a		 je	 SHORT $LN612@ThreadWMIC

; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;

  0063c	8b 00		 mov	 eax, DWORD PTR [eax]

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  0063e	85 c0		 test	 eax, eax
  00640	74 04		 je	 SHORT $LN612@ThreadWMIC
  00642	8b 00		 mov	 eax, DWORD PTR [eax]
  00644	eb 02		 jmp	 SHORT $LN449@ThreadWMIC
$LN612@ThreadWMIC:
  00646	33 c0		 xor	 eax, eax
$LN449@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 690  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

  00648	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  0064b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\deque

; 690  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

  0064e	49		 dec	 ecx
  0064f	23 ca		 and	 ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  00651	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00654	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00658	72 02		 jb	 SHORT $LN471@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0065a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN471@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 108  :         Write(__LINE__, "</%s>", sTagStack.top().c_str());

  0065c	50		 push	 eax
  0065d	68 00 00 00 00	 push	 OFFSET ??_C@_05POIKLDCH@?$DM?1?$CFs?$DO@
  00662	8d 85 3c fc ff
	ff		 lea	 eax, DWORD PTR _xml$7[ebp]
  00668	6a 6c		 push	 108			; 0000006cH
  0066a	50		 push	 eax
  0066b	e8 00 00 00 00	 call	 ?Write@xmlwriter@@AAAXHPBDZZ ; xmlwriter::Write
  00670	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stack

; 125  : 		c.pop_back();

  00673	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp+44]
  00679	e8 00 00 00 00	 call	 ?pop_back@?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::pop_back
; File c:\users\giulif\downloads\study\git\sysstatus\xmlwriter.cpp

; 99   :     while (sTagStack.size() != 0)

  0067e	83 bd 78 fc ff
	ff 00		 cmp	 DWORD PTR _xml$7[ebp+60], 0
  00685	0f 85 38 ff ff
	ff		 jne	 $LL348@ThreadWMIC
$LN349@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 806  :     }

  0068b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0068f	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp]
  00695	e8 00 00 00 00	 call	 ??1xmlwriter@@QAE@XZ	; xmlwriter::~xmlwriter
  0069a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0069e	8b 95 38 fc ff
	ff		 mov	 edx, DWORD PTR _fileName$6[ebp+20]
  006a4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  006a7	72 2f		 jb	 SHORT $LN521@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006a9	8b 8d 24 fc ff
	ff		 mov	 ecx, DWORD PTR _fileName$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  006af	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006b0	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  006b2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  006b8	72 14		 jb	 SHORT $LN520@ThreadWMIC

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  006ba	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  006bd	83 c2 23	 add	 edx, 35			; 00000023H
  006c0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006c2	83 c0 fc	 add	 eax, -4			; fffffffcH
  006c5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006c8	0f 87 78 01 00
	00		 ja	 $LN619@ThreadWMIC
$LN520@ThreadWMIC:

; 207  : 	::operator delete(_Ptr, _Bytes);

  006ce	52		 push	 edx
  006cf	51		 push	 ecx
  006d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  006d5	83 c4 08	 add	 esp, 8
$LN521@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  006d8	c7 85 34 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _fileName$6[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  006e2	c7 85 38 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR _fileName$6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  006ec	c6 85 24 fc ff
	ff 00		 mov	 BYTE PTR _fileName$6[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 639  :     tickEnd = SysTick();

  006f3	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 640  :     timeElapsed = (static_cast<double>(tickEnd - tickStart) / static_cast<double>(SECOND));

  006f8	2b c3		 sub	 eax, ebx
  006fa	8b c8		 mov	 ecx, eax
  006fc	1b 95 14 fc ff
	ff		 sbb	 edx, DWORD PTR _tickStart$1$[ebp]
  00702	e8 00 00 00 00	 call	 __ultod3
  00707	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  0070f	f2 0f 11 85 fc
	fb ff ff	 movsd	 QWORD PTR _timeElapsed$1$[ebp], xmm0

; 641  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  00717	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0071f	e8 00 00 00 00	 call	 __dtoul3
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 812  :     Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMICls, %s, %02llu:%02llu:%02llu, %.3f s", plist->at(0).c_str(), seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  00724	6a 00		 push	 0
  00726	6a 3c		 push	 60			; 0000003cH
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 641  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  00728	8b fa		 mov	 edi, edx
  0072a	8b d8		 mov	 ebx, eax
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 812  :     Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMICls, %s, %02llu:%02llu:%02llu, %.3f s", plist->at(0).c_str(), seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  0072c	57		 push	 edi
  0072d	53		 push	 ebx
  0072e	e8 00 00 00 00	 call	 __aulldiv
  00733	8b c8		 mov	 ecx, eax
  00735	8b f2		 mov	 esi, edx
  00737	0f a4 ce 04	 shld	 esi, ecx, 4
  0073b	6a 00		 push	 0
  0073d	c1 e1 04	 shl	 ecx, 4
  00740	2b c8		 sub	 ecx, eax
  00742	8b c3		 mov	 eax, ebx
  00744	68 10 0e 00 00	 push	 3600			; 00000e10H
  00749	1b f2		 sbb	 esi, edx
  0074b	0f a4 ce 02	 shld	 esi, ecx, 2
  0074f	57		 push	 edi
  00750	c1 e1 02	 shl	 ecx, 2
  00753	2b c1		 sub	 eax, ecx
  00755	89 85 18 fc ff
	ff		 mov	 DWORD PTR tv1718[ebp], eax
  0075b	8b c7		 mov	 eax, edi
  0075d	1b c6		 sbb	 eax, esi
  0075f	53		 push	 ebx
  00760	89 85 14 fc ff
	ff		 mov	 DWORD PTR tv1717[ebp], eax
  00766	e8 00 00 00 00	 call	 __aulldiv
  0076b	8b f0		 mov	 esi, eax
  0076d	b9 10 0e 00 00	 mov	 ecx, 3600		; 00000e10H
  00772	8b c2		 mov	 eax, edx
  00774	89 b5 20 fc ff
	ff		 mov	 DWORD PTR tv1722[ebp], esi
  0077a	89 85 1c fc ff
	ff		 mov	 DWORD PTR tv1721[ebp], eax
  00780	f7 e1		 mul	 ecx
  00782	ba 10 0e 00 00	 mov	 edx, 3600		; 00000e10H
  00787	8b c8		 mov	 ecx, eax
  00789	8b c6		 mov	 eax, esi
  0078b	f7 e2		 mul	 edx
  0078d	6a 00		 push	 0
  0078f	03 ca		 add	 ecx, edx
  00791	2b d8		 sub	 ebx, eax
  00793	6a 3c		 push	 60			; 0000003cH
  00795	1b f9		 sbb	 edi, ecx
  00797	57		 push	 edi
  00798	53		 push	 ebx
  00799	e8 00 00 00 00	 call	 __aulldiv
  0079e	8b d8		 mov	 ebx, eax
  007a0	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  007a2	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _lpData$GSCopy$1$[ebp]
  007a8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  007ab	8b 30		 mov	 esi, DWORD PTR [eax]
  007ad	2b ce		 sub	 ecx, esi
  007af	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  007b4	f7 e9		 imul	 ecx
  007b6	c1 fa 02	 sar	 edx, 2
  007b9	8b c2		 mov	 eax, edx
  007bb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  007be	03 c2		 add	 eax, edx

; 1750 : 		if (size() <= _Pos)

  007c0	0f 84 85 00 00
	00		 je	 $LN620@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  007c6	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  007ca	72 02		 jb	 SHORT $LN573@ThreadWMIC
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  007cc	8b 36		 mov	 esi, DWORD PTR [esi]
$LN573@ThreadWMIC:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 812  :     Log(LOG_DEBUG_WMI, __LINE__, "<< ThrdWMICls, %s, %02llu:%02llu:%02llu, %.3f s", plist->at(0).c_str(), seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  007ce	f2 0f 10 85 fc
	fb ff ff	 movsd	 xmm0, QWORD PTR _timeElapsed$1$[ebp]
  007d6	83 ec 08	 sub	 esp, 8
  007d9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  007de	ff b5 14 fc ff
	ff		 push	 DWORD PTR tv1717[ebp]
  007e4	ff b5 18 fc ff
	ff		 push	 DWORD PTR tv1718[ebp]
  007ea	57		 push	 edi
  007eb	53		 push	 ebx
  007ec	ff b5 1c fc ff
	ff		 push	 DWORD PTR tv1721[ebp]
  007f2	ff b5 20 fc ff
	ff		 push	 DWORD PTR tv1722[ebp]
  007f8	56		 push	 esi
  007f9	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NFLHPILJ@?$DM?$DM?5ThrdWMICls?0?5?$CFs?0?5?$CF02llu?3?$CF02ll@
  007fe	68 2c 03 00 00	 push	 812			; 0000032cH
  00803	6a 40		 push	 64			; 00000040H
  00805	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 813  :     _endthreadex(0);

  0080a	6a 00		 push	 0
  0080c	e8 00 00 00 00	 call	 __endthreadex
  00811	83 c4 34	 add	 esp, 52			; 00000034H

; 814  :     return 0;

  00814	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  0081b	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _list$[ebp]
  00821	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 814  :     return 0;

  00826	33 c0		 xor	 eax, eax
$LN1@ThreadWMIC:

; 815  : }

  00828	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0082b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00832	59		 pop	 ecx
  00833	5f		 pop	 edi
  00834	5e		 pop	 esi
  00835	5b		 pop	 ebx
  00836	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00839	33 cd		 xor	 ecx, ebp
  0083b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00840	8b e5		 mov	 esp, ebp
  00842	5d		 pop	 ebp
  00843	c2 04 00	 ret	 4
$LN619@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00846	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN620@ThreadWMIC:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1752 : 			_Xrange();

  0084b	e8 00 00 00 00	 call	 ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
$LN616@ThreadWMIC:
  00850	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$0:
  00000	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR _list$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$1:
  0000b	8d 8d 24 fc ff
	ff		 lea	 ecx, DWORD PTR _fileName$6[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$3:
  00016	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$4:
  00021	8d 8d 54 fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp+24]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$7:
  0002c	8b 8d 20 fc ff
	ff		 mov	 ecx, DWORD PTR _this$5[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$_Deque_alloc@U?$_Deque_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Deque_alloc<std::_Deque_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$6:
  00037	8b 8d 1c fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~deque<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$5:
  00042	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp+44]
  00048	e9 00 00 00 00	 jmp	 ??1?$stack@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$deque@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@XZ
__unwindfunclet$?ThreadWMIClass@@YGIPAX@Z$2:
  0004d	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR _xml$7[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1xmlwriter@@QAE@XZ	; xmlwriter::~xmlwriter
__ehhandler$?ThreadWMIClass@@YGIPAX@Z:
  00058	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0005c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0005f	8b 8a f8 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1032]
  00065	33 c8		 xor	 ecx, eax
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0006f	33 c8		 xor	 ecx, eax
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThreadWMIClass@@YGIPAX@Z
  0007b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThreadWMIClass@@YGIPAX@Z ENDP				; ThreadWMIClass
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEAAPA_WI@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::~vector<wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAE@XZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::vector<wchar_t *,std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z PROC	; std::vector<double,std::allocator<double> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@NV?$allocator@N@std@@@std@@QAEAANI@Z ENDP	; std::vector<double,std::allocator<double> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC	; std::vector<double,std::allocator<double> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP	; std::vector<double,std::allocator<double> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ PROC	; std::vector<double,std::allocator<double> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@NV?$allocator@N@std@@@std@@QAEXXZ ENDP	; std::vector<double,std::allocator<double> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 f8	 and	 edx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::~vector<double,std::allocator<double> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ PROC	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@NV?$allocator@N@std@@@std@@QAE@XZ ENDP	; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z PROC	; std::vector<float,std::allocator<float> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@MV?$allocator@M@std@@@std@@QAEAAMI@Z ENDP	; std::vector<float,std::allocator<float> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC	; std::vector<float,std::allocator<float> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP	; std::vector<float,std::allocator<float> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ PROC	; std::vector<float,std::allocator<float> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@MV?$allocator@M@std@@@std@@QAEXXZ ENDP	; std::vector<float,std::allocator<float> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::~vector<float,std::allocator<float> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ PROC	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@MV?$allocator@M@std@@@std@@QAE@XZ ENDP	; std::vector<float,std::allocator<float> >::vector<float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@_KV?$allocator@_K@std@@@std@@QAEAA_KI@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@_KV?$allocator@_K@std@@@std@@QAEXXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 f8	 and	 edx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::~vector<unsigned __int64,std::allocator<unsigned __int64> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@_KV?$allocator@_K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::vector<unsigned __int64,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@KV?$allocator@K@std@@@std@@QAEAAKI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@GV?$allocator@G@std@@@std@@QAEAAGI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	d1 f8		 sar	 eax, 1

; 1705 : 		}

  00007	c3		 ret	 0
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 fe	 and	 edx, -2			; fffffffeH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::~vector<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::vector<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	03 45 08	 add	 eax, DWORD PTR __Pos$[ebp]

; 1737 : 		}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1705 : 		}

  00005	c3		 ret	 0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1593 : 		}

  00005	c3		 ret	 0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@PA_W$07@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@operator
  0000a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000d	7d 09		 jge	 SHORT $LN3@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN5@operator:
  00024	cc		 int	 3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 216  : 		if(m_aT != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _free
  0000f	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;
; 225  :     }

  00018	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 162  : 	}

  00003	c3		 ret	 0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 121  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\initializer_list
;	COMDAT ??0?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 37   : 		{	// construct with pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 		: _First(_First_arg), _Last(_Last_arg)

  00003	8b 45 08	 mov	 eax, DWORD PTR __First_arg$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 38   : 		}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 1740 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1741 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1742 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1743 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1744 : 
; 1745 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]

; 1746 : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 734  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi

; 389  : 		: _Myfirst(),

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 390  : 		_Mylast(),

  00036	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 391  : 		_Myend()

  0003d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 591  : 		return (_Get_data()._Mylast);

  00044	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00047	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0004a	2b 17		 sub	 edx, DWORD PTR [edi]
  0004c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00051	f7 ea		 imul	 edx
  00053	c1 fa 02	 sar	 edx, 2
  00056	8b c2		 mov	 eax, edx
  00058	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005b	03 c2		 add	 eax, edx

; 735  : 		if (_Buy(_Right.size()))

  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
  00063	84 c0		 test	 al, al
  00065	74 1f		 je	 SHORT $LN7@vector

; 736  : 			{	// nonzero, fill it
; 737  : 			_TRY_BEGIN

  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 738  : 			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());

  0006e	ff 36		 push	 DWORD PTR [esi]
  00070	ff 77 04	 push	 DWORD PTR [edi+4]
  00073	ff 37		 push	 DWORD PTR [edi]
  00075	8b ce		 mov	 ecx, esi
  00077	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  0007c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@vector:

; 742  : 			_CATCH_END
; 743  : 			}
; 744  : 		}

  00086	8b c6		 mov	 eax, esi
  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 04 00	 ret	 4
__catch$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$0:

; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();

  0009c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 741  : 			_RERAISE;

  000a4	6a 00		 push	 0
  000a6	6a 00		 push	 0
  000a8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN64@vector:
  000ad	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Ilist$ = 8						; size = 8
$T1 = 12						; size = 1
__Al$dead$ = 16						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 728  : 		{	// construct from initializer_list, optional allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00004	ff 75 0c	 push	 DWORD PTR $T1[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 0c	 push	 DWORD PTR __Ilist$[ebp+4]
  0000c	ff 75 08	 push	 DWORD PTR __Ilist$[ebp]

; 389  : 		: _Myfirst(),

  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 390  : 		_Mylast(),

  00015	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 391  : 		_Myend()

  0001c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 729  : 		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  00023	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>

; 730  : 		}

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c2 0c 00	 ret	 12			; 0000000cH
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@V?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1804 : 		if (_Large_string_engaged())

  00004	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0000b	72 06		 jb	 SHORT $LN18@clear
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2872 : 		}

  00012	c3		 ret	 0
$LN18@clear:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00013	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2872 : 		}

  00016	c3		 ret	 0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W0@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W0@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@NV?$allocator@N@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@AAEXXZ PROC	; std::vector<double,std::allocator<double> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 f8	 and	 edx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@NV?$allocator@N@std@@@std@@AAEXXZ ENDP	; std::vector<double,std::allocator<double> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN0@Z PROC ; std::vector<double,std::allocator<double> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN0@Z ENDP ; std::vector<double,std::allocator<double> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AAEXXZ PROC	; std::vector<float,std::allocator<float> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@MV?$allocator@M@std@@@std@@AAEXXZ ENDP	; std::vector<float,std::allocator<float> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 f8	 and	 edx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K0@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K0@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fe	 and	 edx, -2			; fffffffeH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@GV?$allocator@G@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\initializer_list
;	COMDAT ?end@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?end@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::end, COMDAT
; _this$ = ecx

; 47   : 		return (_Last);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 48   : 		}

  00003	c3		 ret	 0
?end@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\initializer_list
;	COMDAT ?begin@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?begin@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::begin, COMDAT
; _this$ = ecx

; 42   : 		return (_First);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 43   : 		}

  00002	c3		 ret	 0
?begin@?$initializer_list@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::initializer_list<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA?AV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA?AV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 897  : 		return (_Al);

  00000	8b c1		 mov	 eax, ecx

; 898  : 		}

  00002	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SA?AV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAPAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$allocator@PA_W@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$allocator@PA_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QAEAAV?$allocator@PA_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PA_W@std@@QAEXQAPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PA_W@std@@QAEXQAPA_WI@Z PROC	; std::allocator<wchar_t *>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8

; 993  : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003d	cc		 int	 3
?deallocate@?$allocator@PA_W@std@@QAEXQAPA_WI@Z ENDP	; std::allocator<wchar_t *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAPANXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$allocator@N@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$allocator@N@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QAEAAV?$allocator@N@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@N@std@@QAEXQANI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@N@std@@QAEXQANI@Z PROC		; std::allocator<double>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8

; 993  : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003d	cc		 int	 3
?deallocate@?$allocator@N@std@@QAEXQANI@Z ENDP		; std::allocator<double>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAPAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$allocator@M@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$allocator@M@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QAEAAV?$allocator@M@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@M@std@@QAEXQAMI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@M@std@@QAEXQAMI@Z PROC		; std::allocator<float>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8

; 993  : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003d	cc		 int	 3
?deallocate@?$allocator@M@std@@QAEXQAMI@Z ENDP		; std::allocator<float>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAPA_KXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$allocator@_K@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$allocator@_K@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QAEAAV?$allocator@_K@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 03	 sar	 eax, 3

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_K@std@@QAEXQA_KI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_K@std@@QAEXQA_KI@Z PROC	; std::allocator<unsigned __int64>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8

; 993  : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003d	cc		 int	 3
?deallocate@?$allocator@_K@std@@QAEXQA_KI@Z ENDP	; std::allocator<unsigned __int64>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$allocator@K@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$allocator@K@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$allocator@K@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXQAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXQAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8

; 993  : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003d	cc		 int	 3
?deallocate@?$allocator@K@std@@QAEXQAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$allocator@G@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$allocator@G@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$allocator@G@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	d1 f8		 sar	 eax, 1

; 1716 : 		}

  00007	c3		 ret	 0
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXQAGI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@G@std@@QAEXQAGI@Z PROC		; std::allocator<unsigned short>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0000c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00012	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00017	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001a	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00022	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00024	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00026	51		 push	 ecx
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002d	83 c4 08	 add	 esp, 8

; 993  : 		}

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00034	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  00039	cc		 int	 3
?deallocate@?$allocator@G@std@@QAEXQAGI@Z ENDP		; std::allocator<unsigned short>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$allocator@PA_W@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$allocator@PA_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAEAAV?$allocator@PA_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABQAPA_WXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$allocator@N@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$allocator@N@2@XZ PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAEAAV?$allocator@N@2@XZ ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABQANXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@M@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$allocator@M@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$allocator@M@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAEAAV?$allocator@M@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABQAMXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@_K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$allocator@_K@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$allocator@_K@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAEAAV?$allocator@_K@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABQA_KXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$allocator@K@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$allocator@K@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAEAAV?$allocator@K@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABQAKXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$allocator@G@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$allocator@G@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAEAAV?$allocator@G@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAGXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_pszCategoryName$dead$ = 8				; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$dead$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
  00005	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 216  : 		if(m_aT != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 0f		 je	 SHORT $LN13@CSimpleArr

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _free
  00031	83 c4 04	 add	 esp, 4

; 221  : 			m_aT = NULL;

  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN13@CSimpleArr:

; 311  : 	RemoveAll();
; 312  : }

  0003a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00041	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv392 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; FromVariant<unsigned char>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 25 01 00
	00		 je	 $LN125@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 17 01 00
	00		 js	 $LN133@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv392[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv392[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 ee 00 00
	00		 js	 $LN133@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  0008b	0f 85 ea 00 00
	00		 jne	 $LN135@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 d5 00 00
	00		 js	 $LN124@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 c6 00 00
	00		 js	 $LN136@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<<lambda_1c24340e0c23a1361b49dbc3231bff51> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 58		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 89 00 00
	00		 js	 $LN124@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 68		 jl	 SHORT $LN125@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 6a		 js	 SHORT $LN124@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 4b		 jg	 SHORT $LN125@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	2b c3		 sub	 eax, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  00125	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00128	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  0012b	8b 00		 mov	 eax, DWORD PTR [eax]
  0012d	88 0c 07	 mov	 BYTE PTR [edi+eax], cl
  00130	47		 inc	 edi
  00131	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  00134	72 aa		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  00136	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  0013d	56		 push	 esi
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00144	85 c0		 test	 eax, eax
  00146	78 11		 js	 SHORT $LN114@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00148	56		 push	 esi
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0014f	33 c9		 xor	 ecx, ecx
  00151	85 c0		 test	 eax, eax
  00153	0f 49 f1	 cmovns	 esi, ecx
  00156	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN114@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  00159	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0015c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00163	59		 pop	 ecx
  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	5b		 pop	 ebx
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN125@FromVarian:
  0016b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00170	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  00175	52		 push	 edx
  00176	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0017b	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00180	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN124@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN136@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN131@FromVarian:
  00191	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>
__ehhandler$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@E@@YAXUtagVARIANT@@AAV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; FromVariant<unsigned char>
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv395 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z PROC ; FromVariant<unsigned short>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 29 01 00
	00		 je	 $LN125@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 1b 01 00
	00		 js	 $LN133@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv395[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv395[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 f2 00 00
	00		 js	 $LN133@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  0008b	0f 85 ee 00 00
	00		 jne	 $LN135@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 d9 00 00
	00		 js	 $LN124@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 ca 00 00
	00		 js	 $LN136@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 5c		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 8d 00 00
	00		 js	 $LN124@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 6c		 jl	 SHORT $LN125@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 6e		 js	 SHORT $LN124@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 4f		 jg	 SHORT $LN125@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	8b cf		 mov	 ecx, edi
  00125	2b cb		 sub	 ecx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  00127	0f b7 0c 48	 movzx	 ecx, WORD PTR [eax+ecx*2]
  0012b	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  0012e	8b 00		 mov	 eax, DWORD PTR [eax]
  00130	66 89 0c 78	 mov	 WORD PTR [eax+edi*2], cx
  00134	47		 inc	 edi
  00135	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  00138	72 a6		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  0013a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  00141	56		 push	 esi
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00148	85 c0		 test	 eax, eax
  0014a	78 11		 js	 SHORT $LN114@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  0014c	56		 push	 esi
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  00153	33 c9		 xor	 ecx, ecx
  00155	85 c0		 test	 eax, eax
  00157	0f 49 f1	 cmovns	 esi, ecx
  0015a	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN114@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0015d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00160	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00167	59		 pop	 ecx
  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
$LN125@FromVarian:
  0016f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00174	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0017f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00184	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN124@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN136@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN131@FromVarian:
  00195	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>
__ehhandler$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@G@@YAXUtagVARIANT@@AAV?$vector@GV?$allocator@G@std@@@std@@@Z ENDP ; FromVariant<unsigned short>
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv398 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; FromVariant<unsigned long>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 27 01 00
	00		 je	 $LN125@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 19 01 00
	00		 js	 $LN133@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv398[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv398[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 f0 00 00
	00		 js	 $LN133@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 13	 cmp	 cx, 19			; 00000013H
  0008b	0f 85 ec 00 00
	00		 jne	 $LN135@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 d7 00 00
	00		 js	 $LN124@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 c8 00 00
	00		 js	 $LN136@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Resize<<lambda_41cf2654fb7f54282f884164b4804166> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 5a		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 8b 00 00
	00		 js	 $LN124@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 6a		 jl	 SHORT $LN125@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 6c		 js	 SHORT $LN124@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 4d		 jg	 SHORT $LN125@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	8b cf		 mov	 ecx, edi
  00125	2b cb		 sub	 ecx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  00127	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0012a	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  0012d	8b 00		 mov	 eax, DWORD PTR [eax]
  0012f	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
  00132	47		 inc	 edi
  00133	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  00136	72 a8		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  00138	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  0013f	56		 push	 esi
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00146	85 c0		 test	 eax, eax
  00148	78 11		 js	 SHORT $LN114@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  0014a	56		 push	 esi
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  00151	33 c9		 xor	 ecx, ecx
  00153	85 c0		 test	 eax, eax
  00155	0f 49 f1	 cmovns	 esi, ecx
  00158	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN114@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0015b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0015e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00165	59		 pop	 ecx
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN125@FromVarian:
  0016d	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00172	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  00177	52		 push	 edx
  00178	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0017d	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00182	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN124@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN136@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN131@FromVarian:
  00193	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>
__ehhandler$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@K@@YAXUtagVARIANT@@AAV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; FromVariant<unsigned long>
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv386 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z PROC ; FromVariant<unsigned __int64>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 2f 01 00
	00		 je	 $LN125@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 21 01 00
	00		 js	 $LN133@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv386[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv386[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 f8 00 00
	00		 js	 $LN133@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 15	 cmp	 cx, 21			; 00000015H
  0008b	0f 85 f4 00 00
	00		 jne	 $LN135@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 df 00 00
	00		 js	 $LN124@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 d0 00 00
	00		 js	 $LN136@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Resize<<lambda_37d2edcfa81498688f5009d219c6f7fd> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 62		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 93 00 00
	00		 js	 $LN124@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 72		 jl	 SHORT $LN125@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 74		 js	 SHORT $LN124@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 55		 jg	 SHORT $LN125@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	8b cf		 mov	 ecx, edi
  00125	2b cb		 sub	 ecx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  00127	8b 14 c8	 mov	 edx, DWORD PTR [eax+ecx*8]
  0012a	8b 4c c8 04	 mov	 ecx, DWORD PTR [eax+ecx*8+4]
  0012e	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  00131	8b 00		 mov	 eax, DWORD PTR [eax]
  00133	89 14 f8	 mov	 DWORD PTR [eax+edi*8], edx
  00136	89 4c f8 04	 mov	 DWORD PTR [eax+edi*8+4], ecx
  0013a	47		 inc	 edi
  0013b	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  0013e	72 a0		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  00140	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  00147	56		 push	 esi
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  0014e	85 c0		 test	 eax, eax
  00150	78 11		 js	 SHORT $LN114@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00152	56		 push	 esi
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  00159	33 c9		 xor	 ecx, ecx
  0015b	85 c0		 test	 eax, eax
  0015d	0f 49 f1	 cmovns	 esi, ecx
  00160	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN114@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  00163	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00166	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016d	59		 pop	 ecx
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
$LN125@FromVarian:
  00175	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0017a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0017f	52		 push	 edx
  00180	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00185	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0018a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN124@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN136@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  00195	50		 push	 eax
  00196	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN131@FromVarian:
  0019b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ ; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>
__ehhandler$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@_K@@YAXUtagVARIANT@@AAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ENDP ; FromVariant<unsigned __int64>
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv393 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z PROC ; FromVariant<float>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 2b 01 00
	00		 je	 $LN125@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 1d 01 00
	00		 js	 $LN133@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv393[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv393[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 f4 00 00
	00		 js	 $LN133@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 04	 cmp	 cx, 4
  0008b	0f 85 f0 00 00
	00		 jne	 $LN135@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 db 00 00
	00		 js	 $LN124@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 cc 00 00
	00		 js	 $LN136@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z ; std::vector<float,std::allocator<float> >::_Resize<<lambda_d7a4910ec896527b17c46ceb55731b6b> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 5e		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 8f 00 00
	00		 js	 $LN124@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 6e		 jl	 SHORT $LN125@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 70		 js	 SHORT $LN124@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 51		 jg	 SHORT $LN125@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	8b cf		 mov	 ecx, edi
  00125	2b cb		 sub	 ecx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  00127	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [eax+ecx*4]
  0012c	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  0012f	8b 00		 mov	 eax, DWORD PTR [eax]
  00131	f3 0f 11 04 b8	 movss	 DWORD PTR [eax+edi*4], xmm0
  00136	47		 inc	 edi
  00137	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  0013a	72 a4		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  0013c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  00143	56		 push	 esi
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  0014a	85 c0		 test	 eax, eax
  0014c	78 11		 js	 SHORT $LN114@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  0014e	56		 push	 esi
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  00155	33 c9		 xor	 ecx, ecx
  00157	85 c0		 test	 eax, eax
  00159	0f 49 f1	 cmovns	 esi, ecx
  0015c	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN114@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00162	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00169	59		 pop	 ecx
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN125@FromVarian:
  00171	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00176	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00181	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00186	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN124@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN136@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN131@FromVarian:
  00197	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@M$03@ATL@@QAE@XZ ; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>
__ehhandler$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@M@@YAXUtagVARIANT@@AAV?$vector@MV?$allocator@M@std@@@std@@@Z ENDP ; FromVariant<float>
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv393 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z PROC ; FromVariant<double>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 2b 01 00
	00		 je	 $LN125@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 1d 01 00
	00		 js	 $LN133@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv393[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv393[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 f4 00 00
	00		 js	 $LN133@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 05	 cmp	 cx, 5
  0008b	0f 85 f0 00 00
	00		 jne	 $LN135@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 db 00 00
	00		 js	 $LN124@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 cc 00 00
	00		 js	 $LN136@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z ; std::vector<double,std::allocator<double> >::_Resize<<lambda_72b2ca492da4f1408aac84fdabcda767> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 5e		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 8f 00 00
	00		 js	 $LN124@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 6e		 jl	 SHORT $LN125@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 70		 js	 SHORT $LN124@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 51		 jg	 SHORT $LN125@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	8b cf		 mov	 ecx, edi
  00125	2b cb		 sub	 ecx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  00127	f2 0f 10 04 c8	 movsd	 xmm0, QWORD PTR [eax+ecx*8]
  0012c	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  0012f	8b 00		 mov	 eax, DWORD PTR [eax]
  00131	f2 0f 11 04 f8	 movsd	 QWORD PTR [eax+edi*8], xmm0
  00136	47		 inc	 edi
  00137	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  0013a	72 a4		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  0013c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  00143	56		 push	 esi
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  0014a	85 c0		 test	 eax, eax
  0014c	78 11		 js	 SHORT $LN114@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  0014e	56		 push	 esi
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  00155	33 c9		 xor	 ecx, ecx
  00157	85 c0		 test	 eax, eax
  00159	0f 49 f1	 cmovns	 esi, ecx
  0015c	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN114@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00162	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00169	59		 pop	 ecx
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
$LN125@FromVarian:
  00171	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00176	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0017b	52		 push	 edx
  0017c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00181	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00186	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN124@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN136@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN131@FromVarian:
  00197	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@N$04@ATL@@QAE@XZ ; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>
__ehhandler$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@N@@YAXUtagVARIANT@@AAV?$vector@NV?$allocator@N@std@@@std@@@Z ENDP ; FromVariant<double>
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcomcli.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
;	COMDAT ??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
_TEXT	SEGMENT
_Count$1$ = -32						; size = 4
_Vec$1$ = -28						; size = 4
_SafeArray$ = -24					; size = 4
_lUBound$2 = -20					; size = 4
_lLBound$3 = -20					; size = 4
_vt$4 = -16						; size = 2
__$EHRec$ = -12						; size = 12
_Var$ = 8						; size = 16
tv398 = 20						; size = 4
_lLBound$5 = 20						; size = 4
_lUBound$6 = 20						; size = 4
??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z PROC ; FromVariant<wchar_t *>, COMDAT
; _Vec$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e4	 mov	 DWORD PTR _Vec$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _SafeArray$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 41   :     CComSafeArray<T> SafeArray;

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  0003b	8b 75 10	 mov	 esi, DWORD PTR _Var$[ebp+8]
  0003e	85 f6		 test	 esi, esi
  00040	0f 84 27 01 00
	00		 je	 $LN127@FromVarian
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  00046	8d 45 f0	 lea	 eax, DWORD PTR _vt$4[ebp]
  00049	50		 push	 eax
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  00051	8b 4d f0	 mov	 ecx, DWORD PTR _vt$4[ebp]
  00054	8b d0		 mov	 edx, eax
  00056	85 d2		 test	 edx, edx
  00058	0f 88 19 01 00
	00		 js	 $LN135@FromVarian

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0005e	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00062	75 1b		 jne	 SHORT $LN18@FromVarian

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  00064	b8 40 04 00 00	 mov	 eax, 1088		; 00000440H
  00069	bb 09 00 00 00	 mov	 ebx, 9
  0006e	89 45 14	 mov	 DWORD PTR tv398[ebp], eax
  00071	66 23 46 02	 and	 ax, WORD PTR [esi+2]
  00075	66 3b 45 14	 cmp	 ax, WORD PTR tv398[ebp]
  00079	0f 44 cb	 cmove	 ecx, ebx
  0007c	89 4d f0	 mov	 DWORD PTR _vt$4[ebp], ecx
$LN18@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  0007f	85 d2		 test	 edx, edx
  00081	0f 88 f0 00 00
	00		 js	 $LN135@FromVarian

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00087	66 83 f9 08	 cmp	 cx, 8
  0008b	0f 85 ec 00 00
	00		 jne	 $LN137@FromVarian

; 595  : 		return SafeArrayLock(m_psa);

  00091	56		 push	 esi

; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00092	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi

; 595  : 		return SafeArrayLock(m_psa);

  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0009b	8d 45 ec	 lea	 eax, DWORD PTR _lLBound$3[ebp]
  0009e	50		 push	 eax
  0009f	6a 01		 push	 1
  000a1	56		 push	 esi
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  000a8	85 c0		 test	 eax, eax
  000aa	0f 88 d7 00 00
	00		 js	 $LN126@FromVarian

; 297  : 			AtlThrow(hRes);
; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  000b0	8d 45 14	 lea	 eax, DWORD PTR _lUBound$6[ebp]
  000b3	50		 push	 eax
  000b4	6a 01		 push	 1
  000b6	56		 push	 esi
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  000bd	85 c0		 test	 eax, eax
  000bf	0f 88 c8 00 00
	00		 js	 $LN138@FromVarian

; 302  : 		return (lUBound - lLBound + 1);

  000c5	8b 5d 14	 mov	 ebx, DWORD PTR _lUBound$6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000c8	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000ca	2b 5d ec	 sub	 ebx, DWORD PTR _lLBound$3[ebp]
  000cd	43		 inc	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000ce	57		 push	 edi
  000cf	53		 push	 ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 302  : 		return (lUBound - lLBound + 1);

  000d0	89 5d e0	 mov	 DWORD PTR _Count$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  000d3	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Resize<<lambda_9015b627a392ed02a76b60582322ef4a> >
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 45   :     for (ULONG Index = 0; Index < Count; Index++)

  000d8	33 ff		 xor	 edi, edi
  000da	85 db		 test	 ebx, ebx
  000dc	74 5a		 je	 SHORT $LN3@FromVarian
  000de	66 90		 npad	 2
$LL4@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  000e0	8d 45 14	 lea	 eax, DWORD PTR _lLBound$5[ebp]
  000e3	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _lLBound$5[ebp], 0
  000ea	50		 push	 eax
  000eb	6a 01		 push	 1
  000ed	56		 push	 esi
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  000f4	85 c0		 test	 eax, eax
  000f6	0f 88 8b 00 00
	00		 js	 $LN126@FromVarian

; 277  : 			AtlThrow(hRes);
; 278  : 		return lLBound;

  000fc	8b 5d 14	 mov	 ebx, DWORD PTR _lLBound$5[ebp]
  000ff	3b fb		 cmp	 edi, ebx

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00101	7c 6a		 jl	 SHORT $LN127@FromVarian

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00103	8d 45 ec	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00106	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  0010d	50		 push	 eax
  0010e	6a 01		 push	 1
  00110	56		 push	 esi
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00117	85 c0		 test	 eax, eax
  00119	78 6c		 js	 SHORT $LN126@FromVarian

; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  0011b	3b 7d ec	 cmp	 edi, DWORD PTR _lUBound$2[ebp]
  0011e	7f 4d		 jg	 SHORT $LN127@FromVarian

; 348  : 			AtlThrow(E_INVALIDARG);
; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  00120	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00123	8b cf		 mov	 ecx, edi
  00125	2b cb		 sub	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcomcli.h

; 888  :         return m_str;

  00127	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 47   :         Vec[Index] = SafeArray.GetAt(Index);

  0012a	8b 45 e4	 mov	 eax, DWORD PTR _Vec$1$[ebp]
  0012d	8b 00		 mov	 eax, DWORD PTR [eax]
  0012f	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
  00132	47		 inc	 edi
  00133	3b 7d e0	 cmp	 edi, DWORD PTR _Count$1$[ebp]
  00136	72 a8		 jb	 SHORT $LL4@FromVarian
$LN3@FromVarian:

; 49   : }

  00138	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 600  : 		return SafeArrayUnlock(m_psa);

  0013f	56		 push	 esi
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00146	85 c0		 test	 eax, eax
  00148	78 11		 js	 SHORT $LN116@FromVarian

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  0014a	56		 push	 esi
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  00151	33 c9		 xor	 ecx, ecx
  00153	85 c0		 test	 eax, eax
  00155	0f 49 f1	 cmovns	 esi, ecx
  00158	89 75 e8	 mov	 DWORD PTR _SafeArray$[ebp], esi
$LN116@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  0015b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0015e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00165	59		 pop	 ecx
  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN127@FromVarian:
  0016d	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00172	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN135@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 208  : 		ATLENSURE_SUCCEEDED(hRes);

  00177	52		 push	 edx
  00178	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN137@FromVarian:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  0017d	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00182	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN126@FromVarian:
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 49   : }

  00187	50		 push	 eax
  00188	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN138@FromVarian:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 301  : 			AtlThrow(hRes);

  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN133@FromVarian:
  00193	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _SafeArray$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ ; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>
__ehhandler$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$FromVariant@PA_W@@YAXUtagVARIANT@@AAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ENDP ; FromVariant<wchar_t *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,void>, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 431  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 431  : 		}

  00016	c2 04 00	 ret	 4
??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>, COMDAT
; _this$ = ecx

; 704  : 		{	// initialize with [_First, _Last), avoid leaking, forward iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 ec	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 1235 : 	return (_Last - _First);

  00030	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00033	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  00036	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0003b	f7 ea		 imul	 edx
  0003d	c1 fa 02	 sar	 edx, 2
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00045	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 705  : 		if (_Buy(_Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)))))

  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
  0004d	84 c0		 test	 al, al
  0004f	74 20		 je	 SHORT $LN7@Range_cons

; 706  : 			{	// nonzero, fill it
; 707  : 			_TRY_BEGIN

  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 708  : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

  00058	ff 36		 push	 DWORD PTR [esi]
  0005a	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0005d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 ??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
  00067	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0006a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@Range_cons:

; 712  : 			_CATCH_END
; 713  : 			}
; 714  : 		}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 0c 00	 ret	 12			; 0000000cH
__catch$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z$0:

; 709  : 			_CATCH_ALL
; 710  : 			_Tidy();

  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 711  : 			_RERAISE;

  0008d	6a 00		 push	 0
  0008f	6a 00		 push	 0
  00091	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@Range_cons:
  00096	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Range_construct_or_tidy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z PROC ; std::_Destroy_range<std::allocator<double> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@@Z ENDP ; std::_Destroy_range<std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z PROC ; std::_Destroy_range<std::allocator<float> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@@Z ENDP ; std::_Destroy_range<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned __int64> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z PROC		; ATL::CComSafeArray<double,5>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5b		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4d		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 31		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 32		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 13		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	2b 75 fc	 sub	 esi, DWORD PTR _lLBound$1[ebp]
  00051	5f		 pop	 edi
  00052	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00055	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  00058	5e		 pop	 esi

; 351  : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00064	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00069	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007f	cc		 int	 3
?GetAt@?$CComSafeArray@N$04@ATL@@QAEAANJ@Z ENDP		; ATL::CComSafeArray<double,5>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<double,5>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@N$04@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<double,5>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<double,5>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 05	 cmp	 cx, 5
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@N$04@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<double,5>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@N$04@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@N$04@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@N$04@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@N$04@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@N$04@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@N$04@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<double,5>::~CComSafeArray<double,5>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@N$04@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@N$04@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<double,5>::CComSafeArray<double,5>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@N$04@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<double,5>::CComSafeArray<double,5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z PROC		; ATL::CComSafeArray<float,4>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5b		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4d		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 31		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 32		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 13		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	2b 75 fc	 sub	 esi, DWORD PTR _lLBound$1[ebp]
  00051	5f		 pop	 edi
  00052	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00055	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00058	5e		 pop	 esi

; 351  : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00064	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00069	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007f	cc		 int	 3
?GetAt@?$CComSafeArray@M$03@ATL@@QAEAAMJ@Z ENDP		; ATL::CComSafeArray<float,4>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<float,4>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@M$03@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<float,4>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<float,4>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 04	 cmp	 cx, 4
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@M$03@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<float,4>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@M$03@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@M$03@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@M$03@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@M$03@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@M$03@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@M$03@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<float,4>::~CComSafeArray<float,4>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@M$03@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@M$03@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<float,4>::CComSafeArray<float,4>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@M$03@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<float,4>::CComSafeArray<float,4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z PROC	; ATL::CComSafeArray<unsigned __int64,21>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5b		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4d		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 31		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 32		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 13		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	2b 75 fc	 sub	 esi, DWORD PTR _lLBound$1[ebp]
  00051	5f		 pop	 edi
  00052	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00055	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  00058	5e		 pop	 esi

; 351  : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00064	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00069	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007f	cc		 int	 3
?GetAt@?$CComSafeArray@_K$0BF@@ATL@@QAEAA_KJ@Z ENDP	; ATL::CComSafeArray<unsigned __int64,21>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned __int64,21>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@_K$0BF@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned __int64,21>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned __int64,21>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 15	 cmp	 cx, 21			; 00000015H
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@_K$0BF@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned __int64,21>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned __int64,21>::~CComSafeArray<unsigned __int64,21>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned __int64,21>::CComSafeArray<unsigned __int64,21>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@_K$0BF@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned __int64,21>::CComSafeArray<unsigned __int64,21>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5b		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4d		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 31		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 32		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 13		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	2b 75 fc	 sub	 esi, DWORD PTR _lLBound$1[ebp]
  00051	5f		 pop	 edi
  00052	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00055	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00058	5e		 pop	 esi

; 351  : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00064	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00069	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007f	cc		 int	 3
?GetAt@?$CComSafeArray@K$0BD@@ATL@@QAEAAKJ@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@K$0BD@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned long,19>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 13	 cmp	 cx, 19			; 00000013H
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@K$0BD@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned long,19>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@K$0BD@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned long,19>::~CComSafeArray<unsigned long,19>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned long,19>::CComSafeArray<unsigned long,19>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@K$0BD@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned long,19>::CComSafeArray<unsigned long,19>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5b		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4d		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 31		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 32		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 13		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	2b 75 fc	 sub	 esi, DWORD PTR _lLBound$1[ebp]
  00051	5f		 pop	 edi
  00052	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00055	8d 04 70	 lea	 eax, DWORD PTR [eax+esi*2]
  00058	5e		 pop	 esi

; 351  : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00064	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00069	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007f	cc		 int	 3
?GetAt@?$CComSafeArray@G$0BC@@ATL@@QAEAAGJ@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@G$0BC@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned short,18>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 12	 cmp	 cx, 18			; 00000012H
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@G$0BC@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned short,18>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@G$0BC@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned short,18>::~CComSafeArray<unsigned short,18>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned short,18>::CComSafeArray<unsigned short,18>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@G$0BC@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned short,18>::CComSafeArray<unsigned short,18>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5a		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4c		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 30		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 31		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 12		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	5f		 pop	 edi
  0004f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00052	2b 45 fc	 sub	 eax, DWORD PTR _lLBound$1[ebp]
  00055	03 c6		 add	 eax, esi
  00057	5e		 pop	 esi

; 351  : 	}

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005e	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00063	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00068	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006d	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007e	cc		 int	 3
?GetAt@?$CComSafeArray@E$0BB@@ATL@@QAEAAEJ@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@E$0BB@@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<unsigned char,17>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 11	 cmp	 cx, 17			; 00000011H
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@E$0BB@@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<unsigned char,17>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@E$0BB@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned char,17>::~CComSafeArray<unsigned char,17>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<unsigned char,17>::CComSafeArray<unsigned char,17>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@E$0BB@@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<unsigned char,17>::CComSafeArray<unsigned char,17>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PA_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PA_W@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<wchar_t *> >::_Vector_val<std::_Simple_types<wchar_t *> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PA_W@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<wchar_t *> >::_Vector_val<std::_Simple_types<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Resize<<lambda_9015b627a392ed02a76b60582322ef4a> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QAEXI@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_9015b627a392ed02a76b60582322ef4a>@@QBE@PAPA_WI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_9015b627a392ed02a76b60582322ef4a>@@QBE@PAPA_WI@Z PROC ; <lambda_9015b627a392ed02a76b60582322ef4a>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1480 : 			};

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??R<lambda_9015b627a392ed02a76b60582322ef4a>@@QBE@PAPA_WI@Z ENDP ; <lambda_9015b627a392ed02a76b60582322ef4a>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_9015b627a392ed02a76b60582322ef4a>@@QAE@QAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_9015b627a392ed02a76b60582322ef4a>@@QAE@QAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z PROC ; <lambda_9015b627a392ed02a76b60582322ef4a>::<lambda_9015b627a392ed02a76b60582322ef4a>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_9015b627a392ed02a76b60582322ef4a>@@QAE@QAV?$vector@PA_WV?$allocator@PA_W@std@@@std@@@Z ENDP ; <lambda_9015b627a392ed02a76b60582322ef4a>::<lambda_9015b627a392ed02a76b60582322ef4a>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@PA_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PA_W@std@@QAE@XZ PROC			; std::allocator<wchar_t *>::allocator<wchar_t *>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PA_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t *>::allocator<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@N@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<double> >::_Vector_val<std::_Simple_types<double> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@N@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<double> >::_Vector_val<std::_Simple_types<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z PROC ; std::vector<double,std::allocator<double> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z ; std::vector<double,std::allocator<double> >::_Resize<<lambda_72b2ca492da4f1408aac84fdabcda767> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@NV?$allocator@N@std@@@std@@QAEXI@Z ENDP ; std::vector<double,std::allocator<double> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_72b2ca492da4f1408aac84fdabcda767>@@QBE@PANI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_72b2ca492da4f1408aac84fdabcda767>@@QBE@PANI@Z PROC ; <lambda_72b2ca492da4f1408aac84fdabcda767>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1480 : 			};

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??R<lambda_72b2ca492da4f1408aac84fdabcda767>@@QBE@PANI@Z ENDP ; <lambda_72b2ca492da4f1408aac84fdabcda767>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_72b2ca492da4f1408aac84fdabcda767>@@QAE@QAV?$vector@NV?$allocator@N@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_72b2ca492da4f1408aac84fdabcda767>@@QAE@QAV?$vector@NV?$allocator@N@std@@@std@@@Z PROC ; <lambda_72b2ca492da4f1408aac84fdabcda767>::<lambda_72b2ca492da4f1408aac84fdabcda767>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_72b2ca492da4f1408aac84fdabcda767>@@QAE@QAV?$vector@NV?$allocator@N@std@@@std@@@Z ENDP ; <lambda_72b2ca492da4f1408aac84fdabcda767>::<lambda_72b2ca492da4f1408aac84fdabcda767>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@N@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@N@std@@QAE@XZ PROC			; std::allocator<double>::allocator<double>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@N@std@@QAE@XZ ENDP			; std::allocator<double>::allocator<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@M@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<float> >::_Vector_val<std::_Simple_types<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z PROC ; std::vector<float,std::allocator<float> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z ; std::vector<float,std::allocator<float> >::_Resize<<lambda_d7a4910ec896527b17c46ceb55731b6b> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@MV?$allocator@M@std@@@std@@QAEXI@Z ENDP ; std::vector<float,std::allocator<float> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QBE@PAMI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QBE@PAMI@Z PROC ; <lambda_d7a4910ec896527b17c46ceb55731b6b>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1480 : 			};

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??R<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QBE@PAMI@Z ENDP ; <lambda_d7a4910ec896527b17c46ceb55731b6b>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QAE@QAV?$vector@MV?$allocator@M@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QAE@QAV?$vector@MV?$allocator@M@std@@@std@@@Z PROC ; <lambda_d7a4910ec896527b17c46ceb55731b6b>::<lambda_d7a4910ec896527b17c46ceb55731b6b>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_d7a4910ec896527b17c46ceb55731b6b>@@QAE@QAV?$vector@MV?$allocator@M@std@@@std@@@Z ENDP ; <lambda_d7a4910ec896527b17c46ceb55731b6b>::<lambda_d7a4910ec896527b17c46ceb55731b6b>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@M@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@M@std@@QAE@XZ PROC			; std::allocator<float>::allocator<float>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@M@std@@QAE@XZ ENDP			; std::allocator<float>::allocator<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@_K@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned __int64> >::_Vector_val<std::_Simple_types<unsigned __int64> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@_K@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned __int64> >::_Vector_val<std::_Simple_types<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Resize<<lambda_37d2edcfa81498688f5009d219c6f7fd> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@_KV?$allocator@_K@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QBE@PA_KI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QBE@PA_KI@Z PROC ; <lambda_37d2edcfa81498688f5009d219c6f7fd>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1480 : 			};

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??R<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QBE@PA_KI@Z ENDP ; <lambda_37d2edcfa81498688f5009d219c6f7fd>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QAE@QAV?$vector@_KV?$allocator@_K@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QAE@QAV?$vector@_KV?$allocator@_K@std@@@std@@@Z PROC ; <lambda_37d2edcfa81498688f5009d219c6f7fd>::<lambda_37d2edcfa81498688f5009d219c6f7fd>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_37d2edcfa81498688f5009d219c6f7fd>@@QAE@QAV?$vector@_KV?$allocator@_K@std@@@std@@@Z ENDP ; <lambda_37d2edcfa81498688f5009d219c6f7fd>::<lambda_37d2edcfa81498688f5009d219c6f7fd>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@_K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_K@std@@QAE@XZ PROC			; std::allocator<unsigned __int64>::allocator<unsigned __int64>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@_K@std@@QAE@XZ ENDP			; std::allocator<unsigned __int64>::allocator<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Resize<<lambda_41cf2654fb7f54282f884164b4804166> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@KV?$allocator@K@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_41cf2654fb7f54282f884164b4804166>@@QBE@PAKI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_41cf2654fb7f54282f884164b4804166>@@QBE@PAKI@Z PROC ; <lambda_41cf2654fb7f54282f884164b4804166>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1480 : 			};

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
??R<lambda_41cf2654fb7f54282f884164b4804166>@@QBE@PAKI@Z ENDP ; <lambda_41cf2654fb7f54282f884164b4804166>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_41cf2654fb7f54282f884164b4804166>@@QAE@QAV?$vector@KV?$allocator@K@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_41cf2654fb7f54282f884164b4804166>@@QAE@QAV?$vector@KV?$allocator@K@std@@@std@@@Z PROC ; <lambda_41cf2654fb7f54282f884164b4804166>::<lambda_41cf2654fb7f54282f884164b4804166>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_41cf2654fb7f54282f884164b4804166>@@QAE@QAV?$vector@KV?$allocator@K@std@@@std@@@Z ENDP ; <lambda_41cf2654fb7f54282f884164b4804166>::<lambda_41cf2654fb7f54282f884164b4804166>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@G@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned short> >::_Vector_val<std::_Simple_types<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@GV?$allocator@G@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QBE@PAGI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QBE@PAGI@Z PROC ; <lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 00	 lea	 edi, DWORD PTR [eax+eax]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000e	57		 push	 edi
  0000f	6a 00		 push	 0
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 _memset
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001a	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1480 : 			};

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??R<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QBE@PAGI@Z ENDP ; <lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QAE@QAV?$vector@GV?$allocator@G@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QAE@QAV?$vector@GV?$allocator@G@std@@@std@@@Z PROC ; <lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>::<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@QAE@QAV?$vector@GV?$allocator@G@std@@@std@@@Z ENDP ; <lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>::<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@G@std@@QAE@XZ PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@G@std@@QAE@XZ ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00003	51		 push	 ecx
  00004	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00007	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<<lambda_1c24340e0c23a1361b49dbc3231bff51> >

; 1483 : 		}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QBE@PAEI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QBE@PAEI@Z PROC ; <lambda_1c24340e0c23a1361b49dbc3231bff51>::operator(), COMDAT
; _this$dead$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1478 : 			{

  00007	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	6a 00		 push	 0
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 1480 : 			};

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??R<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QBE@PAEI@Z ENDP ; <lambda_1c24340e0c23a1361b49dbc3231bff51>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QAE@QAV?$vector@EV?$allocator@E@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QAE@QAV?$vector@EV?$allocator@E@std@@@std@@@Z PROC ; <lambda_1c24340e0c23a1361b49dbc3231bff51>::<lambda_1c24340e0c23a1361b49dbc3231bff51>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0<lambda_1c24340e0c23a1361b49dbc3231bff51>@@QAE@QAV?$vector@EV?$allocator@E@std@@@std@@@Z ENDP ; <lambda_1c24340e0c23a1361b49dbc3231bff51>::<lambda_1c24340e0c23a1361b49dbc3231bff51>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z
_TEXT	SEGMENT
_lLBound$1 = -4						; size = 4
_lUBound$2 = 8						; size = 4
_lIndex$ = 8						; size = 4
?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::GetAt, COMDAT
; _this$ = ecx

; 339  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 340  : 		ATLASSUME(m_psa != NULL);
; 341  : 		if(m_psa == NULL)

  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 5b		 je	 SHORT $LN24@GetAt

; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  0000e	8d 4d fc	 lea	 ecx, DWORD PTR _lLBound$1[ebp]
  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$1[ebp], 0
  00018	51		 push	 ecx
  00019	6a 01		 push	 1
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00022	85 c0		 test	 eax, eax
  00024	78 4d		 js	 SHORT $LN25@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00026	8b 75 08	 mov	 esi, DWORD PTR _lIndex$[ebp]
  00029	3b 75 fc	 cmp	 esi, DWORD PTR _lLBound$1[ebp]
  0002c	7c 31		 jl	 SHORT $LN7@GetAt

; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0002e	8d 45 08	 lea	 eax, DWORD PTR _lUBound$2[ebp]
  00031	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _lUBound$2[ebp], 0
  00038	50		 push	 eax
  00039	6a 01		 push	 1
  0003b	ff 37		 push	 DWORD PTR [edi]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00043	85 c0		 test	 eax, eax
  00045	78 32		 js	 SHORT $LN26@GetAt

; 343  : 
; 344  : 		LONG lLBound = GetLowerBound();
; 345  : 		ATLASSERT(lIndex >= lLBound);
; 346  : 		ATLASSERT(lIndex <= GetUpperBound());
; 347  : 		if ((lIndex < lLBound) || (lIndex > GetUpperBound()))

  00047	3b 75 08	 cmp	 esi, DWORD PTR _lUBound$2[ebp]
  0004a	7f 13		 jg	 SHORT $LN7@GetAt

; 349  : 
; 350  : 		return ((typename _ATL_AutomationType<T>::_typewrapper*)m_psa->pvData)[lIndex-lLBound];

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	2b 75 fc	 sub	 esi, DWORD PTR _lLBound$1[ebp]
  00051	5f		 pop	 edi
  00052	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00055	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]
  00058	5e		 pop	 esi

; 351  : 	}

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN7@GetAt:

; 348  : 			AtlThrow(E_INVALIDARG);

  0005f	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00064	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN24@GetAt:

; 342  : 			AtlThrow(E_FAIL);

  00069	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0006e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN25@GetAt:

; 277  : 			AtlThrow(hRes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN26@GetAt:

; 286  : 			AtlThrow(hRes);

  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN22@GetAt:
  0007f	cc		 int	 3
?GetAt@?$CComSafeArray@PA_W$07@ATL@@QAEAAVCComBSTR@2@J@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::GetAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z
_TEXT	SEGMENT
_lLBound$ = -8						; size = 4
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z PROC	; ATL::CComSafeArray<wchar_t *,8>::GetCount, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 291  : 		ATLASSUME(m_psa != NULL);
; 292  : 		ATLASSERT(uDim < GetDimensions());
; 293  : 		LONG lLBound, lUBound;
; 294  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 295  : 		ATLASSERT(SUCCEEDED(hRes));
; 296  : 		if(FAILED(hRes))

  00017	85 c0		 test	 eax, eax
  00019	78 20		 js	 SHORT $LN10@GetCount

; 298  : 		hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  0001b	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  0001e	50		 push	 eax
  0001f	6a 01		 push	 1
  00021	ff 36		 push	 DWORD PTR [esi]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12
  00029	5e		 pop	 esi

; 299  : 		ATLASSERT(SUCCEEDED(hRes));
; 300  : 		if(FAILED(hRes))

  0002a	85 c0		 test	 eax, eax
  0002c	78 13		 js	 SHORT $LN11@GetCount

; 302  : 		return (lUBound - lLBound + 1);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]
  00031	2b 45 f8	 sub	 eax, DWORD PTR _lLBound$[ebp]
  00034	40		 inc	 eax

; 303  : 	}

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
$LN10@GetCount:

; 297  : 			AtlThrow(hRes);

  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN11@GetCount:

; 301  : 			AtlThrow(hRes);

  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN8@GetCount:
  00047	cc		 int	 3
?GetCount@?$CComSafeArray@PA_W$07@ATL@@QBEKI@Z ENDP	; ATL::CComSafeArray<wchar_t *,8>::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z
_TEXT	SEGMENT
_vt$ = -4						; size = 2
_psaSrc$ = 8						; size = 4
?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z PROC ; ATL::CComSafeArray<wchar_t *,8>::Attach, COMDAT
; _this$ = ecx

; 203  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 204  : 		ATLENSURE_THROW(psaSrc != NULL, E_INVALIDARG);

  00005	8b 75 08	 mov	 esi, DWORD PTR _psaSrc$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	74 65		 je	 SHORT $LN62@Attach
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlcore.h

; 523  : 	HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

  0000f	8d 45 fc	 lea	 eax, DWORD PTR _vt$[ebp]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetVartype@8

; 524  : 
; 525  : 	if(FAILED(hrSystem))

  0001a	85 c0		 test	 eax, eax
  0001c	78 60		 js	 SHORT $LN61@Attach

; 526  : 	{
; 527  : 		return hrSystem;
; 528  : 	}
; 529  : 
; 530  : 	/*
; 531  : 	When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
; 532  : 	it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
; 533  : 	*/
; 534  : 	if(pvtType && *pvtType==VT_UNKNOWN)

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _vt$[ebp]
  00021	66 83 f9 0d	 cmp	 cx, 13			; 0000000dH
  00025	75 19		 jne	 SHORT $LN11@Attach
  00027	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]

; 535  : 	{
; 536  : 		if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))

  0002b	ba 40 04 00 00	 mov	 edx, 1088		; 00000440H
  00030	66 23 c2	 and	 ax, dx
  00033	66 3b c2	 cmp	 ax, dx
  00036	75 08		 jne	 SHORT $LN11@Attach

; 537  : 		{
; 538  : 			if(psaArray->fFeatures & FADF_DISPATCH)
; 539  : 			{
; 540  : 				*pvtType=VT_DISPATCH;

  00038	b9 09 00 00 00	 mov	 ecx, 9
  0003d	89 4d fc	 mov	 DWORD PTR _vt$[ebp], ecx
$LN11@Attach:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00040	66 83 f9 08	 cmp	 cx, 8
  00044	75 2e		 jne	 SHORT $LN62@Attach

; 579  : 		if (m_psa != NULL)

  00046	8b 07		 mov	 eax, DWORD PTR [edi]
  00048	85 c0		 test	 eax, eax
  0004a	74 17		 je	 SHORT $LN26@Attach

; 600  : 		return SafeArrayUnlock(m_psa);

  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00053	85 c0		 test	 eax, eax
  00055	78 27		 js	 SHORT $LN61@Attach

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00057	ff 37		 push	 DWORD PTR [edi]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0005f	85 c0		 test	 eax, eax
  00061	78 1b		 js	 SHORT $LN61@Attach
$LN26@Attach:

; 595  : 		return SafeArrayLock(m_psa);

  00063	56		 push	 esi

; 210  : 
; 211  : 		hRes = Destroy();
; 212  : 		ATLENSURE_SUCCEEDED(hRes);
; 213  : 
; 214  : 		m_psa = const_cast<LPSAFEARRAY>(psaSrc);

  00064	89 37		 mov	 DWORD PTR [edi], esi

; 595  : 		return SafeArrayLock(m_psa);

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 215  : 		hRes = Lock();
; 216  : 
; 217  : 		return hRes;

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 218  : 	}

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN62@Attach:

; 209  : 		ATLENSURE_THROW(vt == GetType(), E_INVALIDARG);

  00074	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00079	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN61@Attach:

; 218  : 	}

  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN63@Attach:
  00084	cc		 int	 3
?Attach@?$CComSafeArray@PA_W$07@ATL@@QAEJPBUtagSAFEARRAY@@@Z ENDP ; ATL::CComSafeArray<wchar_t *,8>::Attach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>, COMDAT
; _this$ = ecx

; 196  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 579  : 		if (m_psa != NULL)

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 1d		 je	 SHORT $LN6@CComSafeAr

; 600  : 		return SafeArrayUnlock(m_psa);

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 582  : 			if (SUCCEEDED(hRes))

  00032	85 c0		 test	 eax, eax
  00034	78 12		 js	 SHORT $LN6@CComSafeAr

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0003e	85 c0		 test	 eax, eax
  00040	78 06		 js	 SHORT $LN6@CComSafeAr

; 586  : 					m_psa = NULL;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@CComSafeAr:

; 197  : 		HRESULT hRes = Destroy();
; 198  : 		DBG_UNREFERENCED_LOCAL_VARIABLE(hRes);
; 199  : 		ATLASSERT(SUCCEEDED(hRes));
; 200  : 	}

  00048	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00052	59		 pop	 ecx
  00053	5e		 pop	 esi
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CComSafeArray@PA_W$07@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<wchar_t *,8>::~CComSafeArray<wchar_t *,8>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ PROC		; ATL::CComSafeArray<wchar_t *,8>::CComSafeArray<wchar_t *,8>, COMDAT
; _this$ = ecx

; 144  : 	CComSafeArray() throw() : m_psa(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 146  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CComSafeArray@PA_W$07@ATL@@QAE@XZ ENDP		; ATL::CComSafeArray<wchar_t *,8>::CComSafeArray<wchar_t *,8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<double,5>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@N$04@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<double,5>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ PROC		; ATL::CComSafeArray<double,5>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@N$04@ATL@@QAEJXZ ENDP		; ATL::CComSafeArray<double,5>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ PROC		; ATL::CComSafeArray<double,5>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 05 00 00 00	 mov	 eax, 5

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@N$04@ATL@@QBEGXZ ENDP		; ATL::CComSafeArray<double,5>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<double,5>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<double,5>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<double,5>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@N$04@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<double,5>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<float,4>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@M$03@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<float,4>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ PROC		; ATL::CComSafeArray<float,4>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@M$03@ATL@@QAEJXZ ENDP		; ATL::CComSafeArray<float,4>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ PROC		; ATL::CComSafeArray<float,4>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 04 00 00 00	 mov	 eax, 4

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@M$03@ATL@@QBEGXZ ENDP		; ATL::CComSafeArray<float,4>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<float,4>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<float,4>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<float,4>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@M$03@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<float,4>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned __int64,21>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned __int64,21>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned __int64,21>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@_K$0BF@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned __int64,21>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned __int64,21>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 15 00 00 00	 mov	 eax, 21			; 00000015H

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@_K$0BF@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned __int64,21>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<unsigned __int64,21>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<unsigned __int64,21>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z PROC ; ATL::CComSafeArray<unsigned __int64,21>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@_K$0BF@@ATL@@QBEJI@Z ENDP ; ATL::CComSafeArray<unsigned __int64,21>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned long,19>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned long,19>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned long,19>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@K$0BD@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned long,19>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned long,19>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 13 00 00 00	 mov	 eax, 19			; 00000013H

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@K$0BD@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned long,19>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned long,19>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@K$0BD@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned long,19>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned short,18>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned short,18>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned short,18>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@G$0BC@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned short,18>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned short,18>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@G$0BC@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned short,18>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned short,18>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@G$0BC@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned short,18>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned char,17>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned char,17>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<unsigned char,17>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@E$0BB@@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<unsigned char,17>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<unsigned char,17>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 11 00 00 00	 mov	 eax, 17			; 00000011H

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@E$0BB@@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<unsigned char,17>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lUBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetUpperBound, COMDAT
; _this$ = ecx

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 282  : 		ATLASSUME(m_psa != NULL);
; 283  : 		LONG lUBound = 0;
; 284  : 		HRESULT hRes = SafeArrayGetUBound(m_psa, uDim+1, &lUBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lUBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lUBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetUBound@12

; 285  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetUpperBo

; 287  : 		return lUBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lUBound$[ebp]

; 288  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetUpperBo:

; 286  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetUpperBo:
  0002c	cc		 int	 3
?GetUpperBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetUpperBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z
_TEXT	SEGMENT
_lLBound$ = -4						; size = 4
_uDim$dead$ = 8						; size = 4
?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z PROC	; ATL::CComSafeArray<unsigned char,17>::GetLowerBound, COMDAT
; _this$ = ecx

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 273  : 		ATLASSUME(m_psa != NULL);
; 274  : 		LONG lLBound = 0;
; 275  : 		HRESULT hRes = SafeArrayGetLBound(m_psa, uDim+1, &lLBound);

  00004	8d 45 fc	 lea	 eax, DWORD PTR _lLBound$[ebp]
  00007	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lLBound$[ebp], 0
  0000e	50		 push	 eax
  0000f	6a 01		 push	 1
  00011	ff 31		 push	 DWORD PTR [ecx]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayGetLBound@12

; 276  : 		if (FAILED(hRes))

  00019	85 c0		 test	 eax, eax
  0001b	78 09		 js	 SHORT $LN9@GetLowerBo

; 278  : 		return lLBound;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _lLBound$[ebp]

; 279  : 	}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN9@GetLowerBo:

; 277  : 			AtlThrow(hRes);

  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN7@GetLowerBo:
  0002c	cc		 int	 3
?GetLowerBound@?$CComSafeArray@E$0BB@@ATL@@QBEJI@Z ENDP	; ATL::CComSafeArray<unsigned char,17>::GetLowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEPAPA_WPAPA_WI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEPAPA_WPAPA_WI@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1813 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?_Udefault@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEPAPA_WPAPA_WI@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@NV?$allocator@N@std@@@std@@AAEPANPANI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@NV?$allocator@N@std@@@std@@AAEPANPANI@Z PROC ; std::vector<double,std::allocator<double> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1813 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?_Udefault@?$vector@NV?$allocator@N@std@@@std@@AAEPANPANI@Z ENDP ; std::vector<double,std::allocator<double> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@MV?$allocator@M@std@@@std@@AAEPAMPAMI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@MV?$allocator@M@std@@@std@@AAEPAMPAMI@Z PROC ; std::vector<float,std::allocator<float> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1813 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?_Udefault@?$vector@MV?$allocator@M@std@@@std@@AAEPAMPAMI@Z ENDP ; std::vector<float,std::allocator<float> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@_KV?$allocator@_K@std@@@std@@AAEPA_KPA_KI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@_KV?$allocator@_K@std@@@std@@AAEPA_KPA_KI@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1813 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?_Udefault@?$vector@_KV?$allocator@_K@std@@@std@@AAEPA_KPA_KI@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAKI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAKI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _memset
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001e	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi

; 1813 : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?_Udefault@?$vector@KV?$allocator@K@std@@@std@@AAEPAKPAKI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@GV?$allocator@G@std@@@std@@AAEPAGPAGI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@GV?$allocator@G@std@@@std@@AAEPAGPAGI@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00006	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  0000a	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000b	8d 3c 00	 lea	 edi, DWORD PTR [eax+eax]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000e	57		 push	 edi
  0000f	6a 00		 push	 0
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 _memset
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001a	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi

; 1813 : 		}

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?_Udefault@?$vector@GV?$allocator@G@std@@@std@@AAEPAGPAGI@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ
_TEXT	SEGMENT
?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<wchar_t *,8>::Lock, COMDAT
; _this$ = ecx

; 594  : 		ATLASSUME(m_psa != NULL);
; 595  : 		return SafeArrayLock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayLock@4

; 596  : 	}

  00008	c3		 ret	 0
?Lock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<wchar_t *,8>::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ
_TEXT	SEGMENT
?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ PROC	; ATL::CComSafeArray<wchar_t *,8>::Destroy, COMDAT
; _this$ = ecx

; 577  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 578  : 		HRESULT hRes = S_OK;
; 579  : 		if (m_psa != NULL)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 1f		 je	 SHORT $LN13@Destroy

; 600  : 		return SafeArrayUnlock(m_psa);

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 580  : 		{
; 581  : 			hRes = Unlock();
; 582  : 			if (SUCCEEDED(hRes))

  00010	85 c0		 test	 eax, eax
  00012	78 16		 js	 SHORT $LN4@Destroy

; 583  : 			{
; 584  : 				hRes = SafeArrayDestroy(m_psa);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayDestroy@4

; 585  : 				if (SUCCEEDED(hRes))

  0001c	85 c0		 test	 eax, eax
  0001e	78 0a		 js	 SHORT $LN4@Destroy

; 586  : 					m_psa = NULL;

  00020	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00026	5e		 pop	 esi

; 590  : 	}

  00027	c3		 ret	 0
$LN13@Destroy:

; 587  : 			}
; 588  : 		}
; 589  : 		return hRes;

  00028	33 c0		 xor	 eax, eax
$LN4@Destroy:
  0002a	5e		 pop	 esi

; 590  : 	}

  0002b	c3		 ret	 0
?Destroy@?$CComSafeArray@PA_W$07@ATL@@QAEJXZ ENDP	; ATL::CComSafeArray<wchar_t *,8>::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ
_TEXT	SEGMENT
?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ PROC	; ATL::CComSafeArray<wchar_t *,8>::GetType, COMDAT
; _this$dead$ = ecx

; 311  : 		return _vartype;

  00000	b8 08 00 00 00	 mov	 eax, 8

; 312  : 	}

  00005	c3		 ret	 0
?GetType@?$CComSafeArray@PA_W$07@ATL@@QBEGXZ ENDP	; ATL::CComSafeArray<wchar_t *,8>::GetType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<double,5>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@N$04@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<double,5>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<float,4>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@M$03@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<float,4>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ PROC	; ATL::CComSafeArray<unsigned __int64,21>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@_K$0BF@@ATL@@IAEJXZ ENDP	; ATL::CComSafeArray<unsigned __int64,21>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned long,19>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@K$0BD@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned long,19>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned short,18>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@G$0BC@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned short,18>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ PROC		; ATL::CComSafeArray<unsigned char,17>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@E$0BB@@ATL@@IAEJXZ ENDP		; ATL::CComSafeArray<unsigned char,17>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\atlmfc\include\atlsafe.h
;	COMDAT ?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ
_TEXT	SEGMENT
?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ PROC	; ATL::CComSafeArray<wchar_t *,8>::Unlock, COMDAT
; _this$ = ecx

; 599  : 		ATLASSUME(m_psa != NULL);
; 600  : 		return SafeArrayUnlock(m_psa);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SafeArrayUnlock@4

; 601  : 	}

  00008	c3		 ret	 0
?Unlock@?$CComSafeArray@PA_W$07@ATL@@IAEJXZ ENDP	; ATL::CComSafeArray<wchar_t *,8>::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
??$distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1235 : 	return (_Last - _First);

  00000	2b d1		 sub	 edx, ecx
  00002	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00007	f7 ea		 imul	 edx
  00009	c1 fa 02	 sar	 edx, 2
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 1241 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1242 : 	}

  00013	c3		 ret	 0
??$distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z
_TEXT	SEGMENT
__Backout$2 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>, COMDAT
; _this$ = ecx

; 1822 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 147  : 		: _First(_Dest),

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]

; 214  : 	_Seek_wrapped(_Dest,

  0002b	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 148  : 		_Last(_Dest),

  0002e	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi
  00031	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi

; 149  : 		_Al(_Al_)

  00034	89 4d f0	 mov	 DWORD PTR __Backout$2[ebp+8], ecx

; 187  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 188  : 	for (; _First != _Last; ++_First)

  0003e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00041	3b f3		 cmp	 esi, ebx
  00043	74 15		 je	 SHORT $LN23@Ucopy
$LL24@Ucopy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00045	56		 push	 esi
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  0004d	83 c7 18	 add	 edi, 24			; 00000018H

; 188  : 	for (; _First != _Last; ++_First)

  00050	83 c6 18	 add	 esi, 24			; 00000018H

; 165  : 		++_Last;

  00053	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi

; 188  : 	for (; _First != _Last; ++_First)

  00056	3b f3		 cmp	 esi, ebx
  00058	75 eb		 jne	 SHORT $LL24@Ucopy
$LN23@Ucopy:

; 170  : 		_First = _Last;

  0005a	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi

; 193  : 	return (_Backout._Release());

  0005d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 		_Destroy_range(_First, _Last, _Al);

  00064	8b d7		 mov	 edx, edi
  00066	51		 push	 ecx
  00067	8b cf		 mov	 ecx, edi
  00069	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1823 : 		return (_Uninitialized_copy(_First, _Last, _Dest, this->_Getal()));

  00071	8b c7		 mov	 eax, edi

; 1824 : 		}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Ucopy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBV21@0PAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<wchar_t *> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<double> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@N@std@@@std@@YAXPAN0AAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<float> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@M@std@@@std@@YAXPAM0AAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned __int64> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@_K@std@@@std@@YAXPA_K0AAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned long> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned short> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z
_TEXT	SEGMENT
tv925 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$1$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Resize<<lambda_9015b627a392ed02a76b60582322ef4a> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$1$[ebp], esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8b c3		 mov	 eax, ebx
  00037	2b c2		 sub	 eax, edx
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	2b ca		 sub	 ecx, edx
  00044	c1 f9 02	 sar	 ecx, 2

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00047	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0004a	3b f9		 cmp	 edi, ecx
  0004c	0f 86 28 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00052	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00058	0f 87 52 01 00
	00		 ja	 $LN335@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005e	8b d1		 mov	 edx, ecx
  00060	d1 ea		 shr	 edx, 1
  00062	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006d	8b c7		 mov	 eax, edi
  0006f	89 7d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], edi
  00072	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00077	3b c7		 cmp	 eax, edi
  00079	0f 42 c7	 cmovb	 eax, edi
  0007c	89 45 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], eax
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0007f	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00086	89 4d dc	 mov	 DWORD PTR tv925[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  00089	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0008e	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00090	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00093	eb 08		 jmp	 SHORT $LN329@Resize
$LN92@Resize:
  00095	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009b	72 27		 jb	 SHORT $LN95@Resize
$LN329@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0009d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  000a0	83 ca ff	 or	 edx, -1
  000a3	3b c1		 cmp	 eax, ecx
  000a5	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ae	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000b1	85 c0		 test	 eax, eax
  000b3	0f 84 fc 00 00
	00		 je	 $LN104@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000b9	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000bc	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bf	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000c2	eb 16		 jmp	 SHORT $LN332@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	74 10		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ce	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000d1	8b d8		 mov	 ebx, eax
  000d3	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000d6	eb 05		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000d8	33 db		 xor	 ebx, ebx
$LN332@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000da	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
$LN94@Resize:
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000e0	8d 14 8b	 lea	 edx, DWORD PTR [ebx+ecx*4]

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000ea	8b c7		 mov	 eax, edi
  000ec	2b c1		 sub	 eax, ecx
  000ee	c1 e0 02	 shl	 eax, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000f1	50		 push	 eax
  000f2	6a 00		 push	 0
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000fa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000fd	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00100	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00102	83 c4 08	 add	 esp, 8
  00105	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  00108	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z ; std::_Ptr_move_cat<wchar_t *,wchar_t *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0010d	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0010f	56		 push	 esi
  00110	52		 push	 edx
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _memmove
  00117	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  00121	8b 75 e8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	85 c0		 test	 eax, eax
  00128	74 2c		 je	 SHORT $LN244@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0012a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012d	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00132	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00138	72 12		 jb	 SHORT $LN243@Resize

; 115  : 	_Bytes += _Non_user_size;

  0013a	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0013d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00140	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00142	83 c0 fc	 add	 eax, -4			; fffffffcH
  00145	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00148	77 6b		 ja	 SHORT $LN104@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014a	8b c2		 mov	 eax, edx
$LN243@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014c	51		 push	 ecx
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00153	83 c4 08	 add	 esp, 8
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00156	89 1e		 mov	 DWORD PTR [esi], ebx

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00158	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  0015b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0015e	8b 45 dc	 mov	 eax, DWORD PTR tv925[ebp]
  00161	03 c3		 add	 eax, ebx
  00163	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00166	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00169	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00170	59		 pop	 ecx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  0017a	3b f8		 cmp	 edi, eax
  0017c	76 16		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0017e	2b f8		 sub	 edi, eax
  00180	c1 e7 02	 shl	 edi, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00183	57		 push	 edi
  00184	6a 00		 push	 0
  00186	53		 push	 ebx
  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0018f	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1960 : 		}

  00192	eb 05		 jmp	 SHORT $LN333@Resize
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00194	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00196	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
$LN333@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00199	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN9@Resize:
  0019c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a6	59		 pop	 ecx
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 08 00	 ret	 8
$LN335@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001b0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PA_WV?$allocator@PA_W@std@@@std@@CAXXZ ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlength
$LN104@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  001b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001ba	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001bd	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001c0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PA_W@std@@QAEXQAPA_WI@Z ; std::allocator<wchar_t *>::deallocate

; 1451 : 			_RERAISE;

  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@Resize:
  001ce	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_9015b627a392ed02a76b60582322ef4a>@@@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXIV<lambda_9015b627a392ed02a76b60582322ef4a>@@@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Resize<<lambda_9015b627a392ed02a76b60582322ef4a> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z
_TEXT	SEGMENT
tv925 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$1$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z PROC ; std::vector<double,std::allocator<double> >::_Resize<<lambda_72b2ca492da4f1408aac84fdabcda767> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$1$[ebp], esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8b c3		 mov	 eax, ebx
  00037	2b c2		 sub	 eax, edx
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	2b ca		 sub	 ecx, edx
  00044	c1 f9 03	 sar	 ecx, 3

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00047	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0004a	3b f9		 cmp	 edi, ecx
  0004c	0f 86 28 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00052	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00058	0f 87 52 01 00
	00		 ja	 $LN335@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005e	8b d1		 mov	 edx, ecx
  00060	d1 ea		 shr	 edx, 1
  00062	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006d	8b c7		 mov	 eax, edi
  0006f	89 7d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], edi
  00072	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00077	3b c7		 cmp	 eax, edi
  00079	0f 42 c7	 cmovb	 eax, edi
  0007c	89 45 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], eax
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0007f	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00086	89 4d dc	 mov	 DWORD PTR tv925[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  00089	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0008e	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00090	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00093	eb 08		 jmp	 SHORT $LN329@Resize
$LN92@Resize:
  00095	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009b	72 27		 jb	 SHORT $LN95@Resize
$LN329@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0009d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  000a0	83 ca ff	 or	 edx, -1
  000a3	3b c1		 cmp	 eax, ecx
  000a5	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ae	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000b1	85 c0		 test	 eax, eax
  000b3	0f 84 fc 00 00
	00		 je	 $LN104@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000b9	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000bc	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bf	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000c2	eb 16		 jmp	 SHORT $LN332@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	74 10		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ce	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000d1	8b d8		 mov	 ebx, eax
  000d3	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000d6	eb 05		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000d8	33 db		 xor	 ebx, ebx
$LN332@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000da	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
$LN94@Resize:
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000e0	8d 14 cb	 lea	 edx, DWORD PTR [ebx+ecx*8]

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000ea	8b c7		 mov	 eax, edi
  000ec	2b c1		 sub	 eax, ecx
  000ee	c1 e0 03	 shl	 eax, 3

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000f1	50		 push	 eax
  000f2	6a 00		 push	 0
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000fa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000fd	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00100	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00102	83 c4 08	 add	 esp, 8
  00105	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  00108	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z ; std::_Ptr_move_cat<double,double>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0010d	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0010f	56		 push	 esi
  00110	52		 push	 edx
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _memmove
  00117	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  00121	8b 75 e8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	85 c0		 test	 eax, eax
  00128	74 2c		 je	 SHORT $LN244@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0012a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012d	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012f	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00132	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00138	72 12		 jb	 SHORT $LN243@Resize

; 115  : 	_Bytes += _Non_user_size;

  0013a	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0013d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00140	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00142	83 c0 fc	 add	 eax, -4			; fffffffcH
  00145	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00148	77 6b		 ja	 SHORT $LN104@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014a	8b c2		 mov	 eax, edx
$LN243@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014c	51		 push	 ecx
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00153	83 c4 08	 add	 esp, 8
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00156	89 1e		 mov	 DWORD PTR [esi], ebx

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00158	8d 04 fb	 lea	 eax, DWORD PTR [ebx+edi*8]
  0015b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0015e	8b 45 dc	 mov	 eax, DWORD PTR tv925[ebp]
  00161	03 c3		 add	 eax, ebx
  00163	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00166	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00169	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00170	59		 pop	 ecx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  0017a	3b f8		 cmp	 edi, eax
  0017c	76 16		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0017e	2b f8		 sub	 edi, eax
  00180	c1 e7 03	 shl	 edi, 3

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00183	57		 push	 edi
  00184	6a 00		 push	 0
  00186	53		 push	 ebx
  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0018f	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1960 : 		}

  00192	eb 05		 jmp	 SHORT $LN333@Resize
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00194	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00196	8d 04 fa	 lea	 eax, DWORD PTR [edx+edi*8]
$LN333@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00199	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN9@Resize:
  0019c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a6	59		 pop	 ecx
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 08 00	 ret	 8
$LN335@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001b0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ; std::vector<double,std::allocator<double> >::_Xlength
$LN104@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  001b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001ba	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001bd	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001c0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@N@std@@QAEXQANI@Z ; std::allocator<double>::deallocate

; 1451 : 			_RERAISE;

  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@Resize:
  001ce	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_72b2ca492da4f1408aac84fdabcda767>@@@?$vector@NV?$allocator@N@std@@@std@@AAEXIV<lambda_72b2ca492da4f1408aac84fdabcda767>@@@Z ENDP ; std::vector<double,std::allocator<double> >::_Resize<<lambda_72b2ca492da4f1408aac84fdabcda767> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z
_TEXT	SEGMENT
tv925 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$1$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z PROC ; std::vector<float,std::allocator<float> >::_Resize<<lambda_d7a4910ec896527b17c46ceb55731b6b> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$1$[ebp], esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8b c3		 mov	 eax, ebx
  00037	2b c2		 sub	 eax, edx
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	2b ca		 sub	 ecx, edx
  00044	c1 f9 02	 sar	 ecx, 2

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00047	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0004a	3b f9		 cmp	 edi, ecx
  0004c	0f 86 28 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00052	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00058	0f 87 52 01 00
	00		 ja	 $LN335@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005e	8b d1		 mov	 edx, ecx
  00060	d1 ea		 shr	 edx, 1
  00062	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006d	8b c7		 mov	 eax, edi
  0006f	89 7d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], edi
  00072	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00077	3b c7		 cmp	 eax, edi
  00079	0f 42 c7	 cmovb	 eax, edi
  0007c	89 45 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], eax
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0007f	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00086	89 4d dc	 mov	 DWORD PTR tv925[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  00089	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0008e	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00090	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00093	eb 08		 jmp	 SHORT $LN329@Resize
$LN92@Resize:
  00095	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009b	72 27		 jb	 SHORT $LN95@Resize
$LN329@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0009d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  000a0	83 ca ff	 or	 edx, -1
  000a3	3b c1		 cmp	 eax, ecx
  000a5	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ae	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000b1	85 c0		 test	 eax, eax
  000b3	0f 84 fc 00 00
	00		 je	 $LN104@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000b9	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000bc	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bf	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000c2	eb 16		 jmp	 SHORT $LN332@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	74 10		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ce	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000d1	8b d8		 mov	 ebx, eax
  000d3	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000d6	eb 05		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000d8	33 db		 xor	 ebx, ebx
$LN332@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000da	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
$LN94@Resize:
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000e0	8d 14 8b	 lea	 edx, DWORD PTR [ebx+ecx*4]

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000ea	8b c7		 mov	 eax, edi
  000ec	2b c1		 sub	 eax, ecx
  000ee	c1 e0 02	 shl	 eax, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000f1	50		 push	 eax
  000f2	6a 00		 push	 0
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000fa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000fd	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00100	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00102	83 c4 08	 add	 esp, 8
  00105	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  00108	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z ; std::_Ptr_move_cat<float,float>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0010d	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0010f	56		 push	 esi
  00110	52		 push	 edx
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _memmove
  00117	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  00121	8b 75 e8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	85 c0		 test	 eax, eax
  00128	74 2c		 je	 SHORT $LN244@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0012a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012d	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00132	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00138	72 12		 jb	 SHORT $LN243@Resize

; 115  : 	_Bytes += _Non_user_size;

  0013a	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0013d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00140	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00142	83 c0 fc	 add	 eax, -4			; fffffffcH
  00145	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00148	77 6b		 ja	 SHORT $LN104@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014a	8b c2		 mov	 eax, edx
$LN243@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014c	51		 push	 ecx
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00153	83 c4 08	 add	 esp, 8
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00156	89 1e		 mov	 DWORD PTR [esi], ebx

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00158	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  0015b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0015e	8b 45 dc	 mov	 eax, DWORD PTR tv925[ebp]
  00161	03 c3		 add	 eax, ebx
  00163	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00166	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00169	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00170	59		 pop	 ecx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  0017a	3b f8		 cmp	 edi, eax
  0017c	76 16		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0017e	2b f8		 sub	 edi, eax
  00180	c1 e7 02	 shl	 edi, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00183	57		 push	 edi
  00184	6a 00		 push	 0
  00186	53		 push	 ebx
  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0018f	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1960 : 		}

  00192	eb 05		 jmp	 SHORT $LN333@Resize
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00194	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00196	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
$LN333@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00199	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN9@Resize:
  0019c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a6	59		 pop	 ecx
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 08 00	 ret	 8
$LN335@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001b0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ; std::vector<float,std::allocator<float> >::_Xlength
$LN104@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  001b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001ba	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001bd	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001c0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@M@std@@QAEXQAMI@Z ; std::allocator<float>::deallocate

; 1451 : 			_RERAISE;

  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@Resize:
  001ce	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@?$vector@MV?$allocator@M@std@@@std@@AAEXIV<lambda_d7a4910ec896527b17c46ceb55731b6b>@@@Z ENDP ; std::vector<float,std::allocator<float> >::_Resize<<lambda_d7a4910ec896527b17c46ceb55731b6b> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z
_TEXT	SEGMENT
tv925 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$1$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Resize<<lambda_37d2edcfa81498688f5009d219c6f7fd> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$1$[ebp], esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8b c3		 mov	 eax, ebx
  00037	2b c2		 sub	 eax, edx
  00039	c1 f8 03	 sar	 eax, 3
  0003c	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	2b ca		 sub	 ecx, edx
  00044	c1 f9 03	 sar	 ecx, 3

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00047	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0004a	3b f9		 cmp	 edi, ecx
  0004c	0f 86 28 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00052	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00058	0f 87 52 01 00
	00		 ja	 $LN335@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005e	8b d1		 mov	 edx, ecx
  00060	d1 ea		 shr	 edx, 1
  00062	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006d	8b c7		 mov	 eax, edi
  0006f	89 7d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], edi
  00072	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00077	3b c7		 cmp	 eax, edi
  00079	0f 42 c7	 cmovb	 eax, edi
  0007c	89 45 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], eax
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0007f	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00086	89 4d dc	 mov	 DWORD PTR tv925[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  00089	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0008e	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00090	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00093	eb 08		 jmp	 SHORT $LN329@Resize
$LN92@Resize:
  00095	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009b	72 27		 jb	 SHORT $LN95@Resize
$LN329@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0009d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  000a0	83 ca ff	 or	 edx, -1
  000a3	3b c1		 cmp	 eax, ecx
  000a5	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ae	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000b1	85 c0		 test	 eax, eax
  000b3	0f 84 fc 00 00
	00		 je	 $LN104@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000b9	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000bc	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bf	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000c2	eb 16		 jmp	 SHORT $LN332@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	74 10		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ce	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000d1	8b d8		 mov	 ebx, eax
  000d3	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000d6	eb 05		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000d8	33 db		 xor	 ebx, ebx
$LN332@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000da	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
$LN94@Resize:
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000e0	8d 14 cb	 lea	 edx, DWORD PTR [ebx+ecx*8]

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000ea	8b c7		 mov	 eax, edi
  000ec	2b c1		 sub	 eax, ecx
  000ee	c1 e0 03	 shl	 eax, 3

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000f1	50		 push	 eax
  000f2	6a 00		 push	 0
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000fa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000fd	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00100	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00102	83 c4 08	 add	 esp, 8
  00105	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  00108	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0010d	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0010f	56		 push	 esi
  00110	52		 push	 edx
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _memmove
  00117	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  00121	8b 75 e8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	85 c0		 test	 eax, eax
  00128	74 2c		 je	 SHORT $LN244@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0012a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012d	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012f	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00132	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00138	72 12		 jb	 SHORT $LN243@Resize

; 115  : 	_Bytes += _Non_user_size;

  0013a	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0013d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00140	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00142	83 c0 fc	 add	 eax, -4			; fffffffcH
  00145	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00148	77 6b		 ja	 SHORT $LN104@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014a	8b c2		 mov	 eax, edx
$LN243@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014c	51		 push	 ecx
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00153	83 c4 08	 add	 esp, 8
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00156	89 1e		 mov	 DWORD PTR [esi], ebx

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00158	8d 04 fb	 lea	 eax, DWORD PTR [ebx+edi*8]
  0015b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0015e	8b 45 dc	 mov	 eax, DWORD PTR tv925[ebp]
  00161	03 c3		 add	 eax, ebx
  00163	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00166	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00169	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00170	59		 pop	 ecx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  0017a	3b f8		 cmp	 edi, eax
  0017c	76 16		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0017e	2b f8		 sub	 edi, eax
  00180	c1 e7 03	 shl	 edi, 3

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00183	57		 push	 edi
  00184	6a 00		 push	 0
  00186	53		 push	 ebx
  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0018f	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1960 : 		}

  00192	eb 05		 jmp	 SHORT $LN333@Resize
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00194	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00196	8d 04 fa	 lea	 eax, DWORD PTR [edx+edi*8]
$LN333@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00199	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN9@Resize:
  0019c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a6	59		 pop	 ecx
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 08 00	 ret	 8
$LN335@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001b0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlength
$LN104@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  001b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001ba	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001bd	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001c0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_K@std@@QAEXQA_KI@Z ; std::allocator<unsigned __int64>::deallocate

; 1451 : 			_RERAISE;

  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@Resize:
  001ce	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@?$vector@_KV?$allocator@_K@std@@@std@@AAEXIV<lambda_37d2edcfa81498688f5009d219c6f7fd>@@@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Resize<<lambda_37d2edcfa81498688f5009d219c6f7fd> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z
_TEXT	SEGMENT
tv925 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$1$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Resize<<lambda_41cf2654fb7f54282f884164b4804166> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$1$[ebp], esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8b c3		 mov	 eax, ebx
  00037	2b c2		 sub	 eax, edx
  00039	c1 f8 02	 sar	 eax, 2
  0003c	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00042	2b ca		 sub	 ecx, edx
  00044	c1 f9 02	 sar	 ecx, 2

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00047	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0004a	3b f9		 cmp	 edi, ecx
  0004c	0f 86 28 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00052	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00058	0f 87 52 01 00
	00		 ja	 $LN335@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005e	8b d1		 mov	 edx, ecx
  00060	d1 ea		 shr	 edx, 1
  00062	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00067	2b c2		 sub	 eax, edx
  00069	3b c8		 cmp	 ecx, eax
  0006b	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006d	8b c7		 mov	 eax, edi
  0006f	89 7d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], edi
  00072	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00077	3b c7		 cmp	 eax, edi
  00079	0f 42 c7	 cmovb	 eax, edi
  0007c	89 45 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], eax
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0007f	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00086	89 4d dc	 mov	 DWORD PTR tv925[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  00089	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0008e	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00090	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00093	eb 08		 jmp	 SHORT $LN329@Resize
$LN92@Resize:
  00095	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009b	72 27		 jb	 SHORT $LN95@Resize
$LN329@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0009d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  000a0	83 ca ff	 or	 edx, -1
  000a3	3b c1		 cmp	 eax, ecx
  000a5	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ae	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000b1	85 c0		 test	 eax, eax
  000b3	0f 84 fc 00 00
	00		 je	 $LN104@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000b9	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000bc	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000bf	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000c2	eb 16		 jmp	 SHORT $LN332@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000c4	85 c9		 test	 ecx, ecx
  000c6	74 10		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ce	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000d1	8b d8		 mov	 ebx, eax
  000d3	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000d6	eb 05		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000d8	33 db		 xor	 ebx, ebx
$LN332@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000da	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
$LN94@Resize:
  000dd	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000e0	8d 14 8b	 lea	 edx, DWORD PTR [ebx+ecx*4]

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000e3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000ea	8b c7		 mov	 eax, edi
  000ec	2b c1		 sub	 eax, ecx
  000ee	c1 e0 02	 shl	 eax, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000f1	50		 push	 eax
  000f2	6a 00		 push	 0
  000f4	52		 push	 edx
  000f5	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000fa	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000fd	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
  00100	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00102	83 c4 08	 add	 esp, 8
  00105	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  00108	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ; std::_Ptr_move_cat<unsigned long,unsigned long>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0010d	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0010f	56		 push	 esi
  00110	52		 push	 edx
  00111	53		 push	 ebx
  00112	e8 00 00 00 00	 call	 _memmove
  00117	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  00121	8b 75 e8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00124	8b 06		 mov	 eax, DWORD PTR [esi]
  00126	85 c0		 test	 eax, eax
  00128	74 2c		 je	 SHORT $LN244@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0012a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0012d	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00132	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00138	72 12		 jb	 SHORT $LN243@Resize

; 115  : 	_Bytes += _Non_user_size;

  0013a	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0013d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00140	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00142	83 c0 fc	 add	 eax, -4			; fffffffcH
  00145	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00148	77 6b		 ja	 SHORT $LN104@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0014a	8b c2		 mov	 eax, edx
$LN243@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014c	51		 push	 ecx
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00153	83 c4 08	 add	 esp, 8
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00156	89 1e		 mov	 DWORD PTR [esi], ebx

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00158	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  0015b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0015e	8b 45 dc	 mov	 eax, DWORD PTR tv925[ebp]
  00161	03 c3		 add	 eax, ebx
  00163	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00166	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00169	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00170	59		 pop	 ecx
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  0017a	3b f8		 cmp	 edi, eax
  0017c	76 16		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0017e	2b f8		 sub	 edi, eax
  00180	c1 e7 02	 shl	 edi, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00183	57		 push	 edi
  00184	6a 00		 push	 0
  00186	53		 push	 ebx
  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0018f	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1960 : 		}

  00192	eb 05		 jmp	 SHORT $LN333@Resize
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00194	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00196	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
$LN333@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00199	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN9@Resize:
  0019c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a6	59		 pop	 ecx
  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c2 08 00	 ret	 8
$LN335@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001b0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
$LN104@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  001b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001ba	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001bd	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001c0	e8 00 00 00 00	 call	 ?deallocate@?$allocator@K@std@@QAEXQAKI@Z ; std::allocator<unsigned long>::deallocate

; 1451 : 			_RERAISE;

  001c5	6a 00		 push	 0
  001c7	6a 00		 push	 0
  001c9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@Resize:
  001ce	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_41cf2654fb7f54282f884164b4804166>@@@?$vector@KV?$allocator@K@std@@@std@@AAEXIV<lambda_41cf2654fb7f54282f884164b4804166>@@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Resize<<lambda_41cf2654fb7f54282f884164b4804166> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z
_TEXT	SEGMENT
tv925 = -36						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx
  0002d	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8b c3		 mov	 eax, ebx
  00037	2b c2		 sub	 eax, edx
  00039	d1 f8		 sar	 eax, 1
  0003b	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00041	2b ca		 sub	 ecx, edx
  00043	d1 f9		 sar	 ecx, 1

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00045	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  00048	3b f9		 cmp	 edi, ecx
  0004a	0f 86 23 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00050	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00056	0f 87 4c 01 00
	00		 ja	 $LN335@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005c	8b d1		 mov	 edx, ecx
  0005e	d1 ea		 shr	 edx, 1
  00060	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00065	2b c2		 sub	 eax, edx
  00067	3b c8		 cmp	 ecx, eax
  00069	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006b	8b c7		 mov	 eax, edi
  0006d	89 7d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], edi
  00070	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00072	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00075	3b c7		 cmp	 eax, edi
  00077	0f 42 c7	 cmovb	 eax, edi
  0007a	89 45 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], eax
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0007d	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00080	89 4d dc	 mov	 DWORD PTR tv925[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  00083	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00088	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  0008a	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  0008d	eb 08		 jmp	 SHORT $LN329@Resize
$LN92@Resize:
  0008f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00095	72 27		 jb	 SHORT $LN95@Resize
$LN329@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00097	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  0009a	83 ca ff	 or	 edx, -1
  0009d	3b c1		 cmp	 eax, ecx
  0009f	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000a8	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000ab	85 c0		 test	 eax, eax
  000ad	0f 84 fa 00 00
	00		 je	 $LN104@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000b3	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  000b6	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000b9	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000bc	eb 16		 jmp	 SHORT $LN332@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000be	85 c9		 test	 ecx, ecx
  000c0	74 10		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c8	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000cb	8b d8		 mov	 ebx, eax
  000cd	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000d0	eb 05		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000d2	33 db		 xor	 ebx, ebx
$LN332@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000d4	89 5d ec	 mov	 DWORD PTR $T3[ebp], ebx
$LN94@Resize:
  000d7	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000da	8d 14 4b	 lea	 edx, DWORD PTR [ebx+ecx*2]

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000dd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000e4	8b c7		 mov	 eax, edi
  000e6	2b c1		 sub	 eax, ecx
  000e8	03 c0		 add	 eax, eax

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000ea	50		 push	 eax
  000eb	6a 00		 push	 0
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000f3	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000f6	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  000fb	83 c4 08	 add	 esp, 8
  000fe	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  00101	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ; std::_Ptr_move_cat<unsigned short,unsigned short>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00106	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00108	56		 push	 esi
  00109	52		 push	 edx
  0010a	53		 push	 ebx
  0010b	e8 00 00 00 00	 call	 _memmove
  00110	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  00113	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  0011a	8b 75 e8	 mov	 esi, DWORD PTR _this$[ebp]
  0011d	8b 06		 mov	 eax, DWORD PTR [esi]
  0011f	85 c0		 test	 eax, eax
  00121	74 2c		 je	 SHORT $LN244@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00123	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00126	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00128	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0012b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00131	72 12		 jb	 SHORT $LN243@Resize

; 115  : 	_Bytes += _Non_user_size;

  00133	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00136	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00139	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0013b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0013e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00141	77 6a		 ja	 SHORT $LN104@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00143	8b c2		 mov	 eax, edx
$LN243@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00145	51		 push	 ecx
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0014c	83 c4 08	 add	 esp, 8
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  0014f	89 1e		 mov	 DWORD PTR [esi], ebx

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00151	8d 04 7b	 lea	 eax, DWORD PTR [ebx+edi*2]
  00154	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00157	8b 45 dc	 mov	 eax, DWORD PTR tv925[ebp]
  0015a	03 c3		 add	 eax, ebx
  0015c	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00162	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00169	59		 pop	 ecx
  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  00173	3b f8		 cmp	 edi, eax
  00175	76 15		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00177	2b f8		 sub	 edi, eax
  00179	03 ff		 add	 edi, edi

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0017b	57		 push	 edi
  0017c	6a 00		 push	 0
  0017e	53		 push	 ebx
  0017f	e8 00 00 00 00	 call	 _memset
  00184	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00187	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1960 : 		}

  0018a	eb 05		 jmp	 SHORT $LN333@Resize
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  0018c	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  0018e	8d 04 7a	 lea	 eax, DWORD PTR [edx+edi*2]
$LN333@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  00191	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN9@Resize:
  00194	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00197	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019e	59		 pop	 ecx
  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c2 08 00	 ret	 8
$LN335@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001a8	e8 00 00 00 00	 call	 ?_Xlength@?$vector@GV?$allocator@G@std@@@std@@CAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlength
$LN104@Resize:

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;
; 1471 : 			}
; 1472 : 		}

  001ad	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001b2	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001b5	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001b8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$allocator@G@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
  001c0	8b c8		 mov	 ecx, eax
  001c2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@G@std@@QAEXQAGI@Z ; std::allocator<unsigned short>::deallocate

; 1451 : 			_RERAISE;

  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN331@Resize:
  001d0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@?$vector@GV?$allocator@G@std@@@std@@AAEXIV<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3>@@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Resize<<lambda_2b6654e67a91186cf2b3ea8c5d1f7ef3> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z
_TEXT	SEGMENT
__Last$1$ = -32						; size = 4
__Oldsize$1$ = -32					; size = 4
__Newcapacity$2 = -28					; size = 4
_this$1$ = -24						; size = 4
$T3 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
$T4 = 11						; size = 1
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<<lambda_1c24340e0c23a1361b49dbc3231bff51> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b d9		 mov	 ebx, ecx
  0002d	89 5d e8	 mov	 DWORD PTR _this$1$[ebp], ebx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00030	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  00033	8b 13		 mov	 edx, DWORD PTR [ebx]
  00035	8b c7		 mov	 eax, edi
  00037	2b c2		 sub	 eax, edx
  00039	89 45 e0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003c	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0003f	2b ca		 sub	 ecx, edx

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00041	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00044	3b f1		 cmp	 esi, ecx
  00046	0f 86 0d 01 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  0004c	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00052	0f 87 4a 01 00
	00		 ja	 $LN332@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00058	8b d1		 mov	 edx, ecx
  0005a	d1 ea		 shr	 edx, 1
  0005c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00061	2b c2		 sub	 eax, edx
  00063	3b c8		 cmp	 ecx, eax
  00065	76 07		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  00067	8b de		 mov	 ebx, esi
  00069	89 75 e4	 mov	 DWORD PTR __Newcapacity$2[ebp], esi
  0006c	eb 0b		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006e	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00071	3b de		 cmp	 ebx, esi
  00073	0f 42 de	 cmovb	 ebx, esi
  00076	89 5d e4	 mov	 DWORD PTR __Newcapacity$2[ebp], ebx
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00079	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0007f	72 27		 jb	 SHORT $LN94@Resize

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00081	8d 43 23	 lea	 eax, DWORD PTR [ebx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00084	83 c9 ff	 or	 ecx, -1
  00087	3b c3		 cmp	 eax, ebx
  00089	0f 46 c1	 cmovbe	 eax, ecx

; 52   : 		return (::operator new(_Bytes));

  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00095	85 c0		 test	 eax, eax
  00097	0f 84 0a 01 00
	00		 je	 $LN103@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0009d	8d 78 23	 lea	 edi, DWORD PTR [eax+35]
  000a0	83 e7 e0	 and	 edi, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000a3	89 47 fc	 mov	 DWORD PTR [edi-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000a6	eb 16		 jmp	 SHORT $LN330@Resize
$LN94@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000a8	85 db		 test	 ebx, ebx
  000aa	74 10		 je	 SHORT $LN95@Resize

; 52   : 		return (::operator new(_Bytes));

  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b2	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000b5	8b f8		 mov	 edi, eax
  000b7	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  000ba	eb 05		 jmp	 SHORT $LN93@Resize
$LN95@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000bc	33 ff		 xor	 edi, edi
$LN330@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000be	89 7d ec	 mov	 DWORD PTR $T3[ebp], edi
$LN93@Resize:
  000c1	8b 4d e0	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000c4	03 cf		 add	 ecx, edi

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000cd	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  000d0	89 45 e0	 mov	 DWORD PTR __Last$1$[ebp], eax

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000d3	2b c1		 sub	 eax, ecx
  000d5	50		 push	 eax
  000d6	6a 00		 push	 0
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  000de	8b 55 e8	 mov	 edx, DWORD PTR _this$1$[ebp]
  000e1	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000e4	8b 12		 mov	 edx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  000e6	83 c4 08	 add	 esp, 8
  000e9	8d 4d 0b	 lea	 ecx, DWORD PTR $T4[ebp]
  000ec	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ; std::_Ptr_move_cat<unsigned char,unsigned char>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  000f1	2b f2		 sub	 esi, edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  000f3	56		 push	 esi
  000f4	52		 push	 edx
  000f5	57		 push	 edi
  000f6	e8 00 00 00 00	 call	 _memmove
  000fb	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
  000fe	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  00105	8b 75 e8	 mov	 esi, DWORD PTR _this$1$[ebp]
  00108	8b 06		 mov	 eax, DWORD PTR [esi]
  0010a	85 c0		 test	 eax, eax
  0010c	74 29		 je	 SHORT $LN243@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0010e	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00111	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00113	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00119	72 12		 jb	 SHORT $LN242@Resize

; 115  : 	_Bytes += _Non_user_size;

  0011b	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0011e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00121	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00123	83 c0 fc	 add	 eax, -4			; fffffffcH
  00126	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00129	77 7c		 ja	 SHORT $LN103@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0012b	8b c2		 mov	 eax, edx
$LN242@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0012d	51		 push	 ecx
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00134	83 c4 08	 add	 esp, 8
$LN243@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00137	89 3e		 mov	 DWORD PTR [esi], edi

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00139	8b 45 e0	 mov	 eax, DWORD PTR __Last$1$[ebp]
  0013c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0013f	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  00142	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1471 : 			}
; 1472 : 		}

  00145	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00148	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014f	59		 pop	 ecx
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 08 00	 ret	 8
$LN2@Resize:

; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  00159	3b f0		 cmp	 esi, eax
  0015b	76 29		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0015d	03 f2		 add	 esi, edx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0015f	8b c6		 mov	 eax, esi
  00161	2b c7		 sub	 eax, edi
  00163	50		 push	 eax
  00164	6a 00		 push	 0
  00166	57		 push	 edi
  00167	e8 00 00 00 00	 call	 _memset
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

  0016f	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 1471 : 			}
; 1472 : 		}

  00172	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00175	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017c	59		 pop	 ecx
  0017d	5f		 pop	 edi
  0017e	5e		 pop	 esi
  0017f	5b		 pop	 ebx
  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 08 00	 ret	 8
$LN6@Resize:

; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00186	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00188	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());
; 1469 : 			_Destroy(_Newlast, this->_Mylast());
; 1470 : 			this->_Mylast() = _Newlast;

  0018b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN9@Resize:

; 1471 : 			}
; 1472 : 		}

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00198	59		 pop	 ecx
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	5b		 pop	 ebx
  0019c	8b e5		 mov	 esp, ebp
  0019e	5d		 pop	 ebp
  0019f	c2 08 00	 ret	 8
$LN332@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  001a2	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN103@Resize:

; 1471 : 			}
; 1472 : 		}

  001a7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  001ac	ff 75 e4	 push	 DWORD PTR __Newcapacity$2[ebp]
  001af	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  001b2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate

; 1451 : 			_RERAISE;

  001b7	6a 00		 push	 0
  001b9	6a 00		 push	 0
  001bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN329@Resize:
  001c0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIV<lambda_1c24340e0c23a1361b49dbc3231bff51>@@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<<lambda_1c24340e0c23a1361b49dbc3231bff51> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$01@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$01@std@@YAII@Z PROC			; std::_Get_size_of_n<2>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]

; 26   : 	if (_Max_possible < _Count)

  00006	83 ca ff	 or	 edx, -1
  00009	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0000f	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00012	0f 47 c2	 cmova	 eax, edx

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$_Get_size_of_n@$01@std@@YAII@Z ENDP			; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@@Z PROC ; std::_Uninitialized_value_construct_n<wchar_t * *,unsigned int,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@@Z ENDP ; std::_Uninitialized_value_construct_n<wchar_t * *,unsigned int,std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@@Z PROC ; std::_Uninitialized_value_construct_n<double *,unsigned int,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 d5 00 00
	00 00		 lea	 esi, DWORD PTR [edx*8]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@@Z ENDP ; std::_Uninitialized_value_construct_n<double *,unsigned int,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_value_construct_n<float *,unsigned int,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_value_construct_n<float *,unsigned int,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@@Z PROC ; std::_Uninitialized_value_construct_n<unsigned __int64 *,unsigned int,std::allocator<unsigned __int64> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 d5 00 00
	00 00		 lea	 esi, DWORD PTR [edx*8]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@@Z ENDP ; std::_Uninitialized_value_construct_n<unsigned __int64 *,unsigned int,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@@Z PROC ; std::_Uninitialized_value_construct_n<unsigned long *,unsigned int,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_value_construct_n<unsigned long *,unsigned int,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@@Z PROC ; std::_Uninitialized_value_construct_n<unsigned short *,unsigned int,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 12	 lea	 esi, DWORD PTR [edx+edx]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00005	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	56		 push	 esi
  00008	6a 00		 push	 0
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00013	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  00018	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@@Z ENDP ; std::_Uninitialized_value_construct_n<unsigned short *,unsigned int,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEXPAPA_W0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEXPAPA_W0@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEXPAPA_W0@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@PA_WV?$allocator@PA_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PA_WV?$allocator@PA_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PA_WV?$allocator@PA_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXQAPA_WII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXQAPA_WII@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXQAPA_WII@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEII@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0001a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00020	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00022	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PA_WV?$allocator@PA_W@std@@@std@@ABEII@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z ; std::_Ptr_move_cat<wchar_t *,wchar_t *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PA_WV?$allocator@PA_W@std@@@std@@QBEIXZ ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z PROC	; std::allocator<wchar_t *>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]

; 26   : 	if (_Max_possible < _Count)

  0000d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00012	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00014	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00019	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001f	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00021	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00024	83 ca ff	 or	 edx, -1
  00027	3b c1		 cmp	 eax, ecx
  00029	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00034	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0003b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003e	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00041	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00059	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z ENDP	; std::allocator<wchar_t *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@ABEXPAN0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@ABEXPAN0@Z PROC ; std::vector<double,std::allocator<double> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@ABEXPAN0@Z ENDP ; std::vector<double,std::allocator<double> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ PROC ; std::vector<double,std::allocator<double> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ENDP ; std::vector<double,std::allocator<double> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AAEXQANII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AAEXQANII@Z PROC ; std::vector<double,std::allocator<double> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e2 f8	 and	 edx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AAEXQANII@Z ENDP ; std::vector<double,std::allocator<double> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@ABEII@Z PROC ; std::vector<double,std::allocator<double> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 03	 sar	 edx, 3

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0001a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00020	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00022	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@ABEII@Z ENDP ; std::vector<double,std::allocator<double> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00@Z PROC ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z ; std::_Ptr_move_cat<double,double>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ PROC ; std::vector<double,std::allocator<double> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@NV?$allocator@N@std@@@std@@QBEIXZ ENDP ; std::vector<double,std::allocator<double> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@N@std@@QAEPANI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@N@std@@QAEPANI@Z PROC		; std::allocator<double>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]

; 26   : 	if (_Max_possible < _Count)

  0000d	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00012	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00014	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00019	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001f	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00021	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00024	83 ca ff	 or	 edx, -1
  00027	3b c1		 cmp	 eax, ecx
  00029	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00034	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0003b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003e	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00041	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00059	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@N@std@@QAEPANI@Z ENDP		; std::allocator<double>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@ABEXPAM0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@ABEXPAM0@Z PROC ; std::vector<float,std::allocator<float> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@MV?$allocator@M@std@@@std@@ABEXPAM0@Z ENDP ; std::vector<float,std::allocator<float> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ PROC ; std::vector<float,std::allocator<float> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@MV?$allocator@M@std@@@std@@CAXXZ ENDP ; std::vector<float,std::allocator<float> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AAEXQAMII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AAEXQAMII@Z PROC ; std::vector<float,std::allocator<float> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@MV?$allocator@M@std@@@std@@AAEXQAMII@Z ENDP ; std::vector<float,std::allocator<float> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@ABEII@Z PROC ; std::vector<float,std::allocator<float> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0001a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00020	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00022	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@MV?$allocator@M@std@@@std@@ABEII@Z ENDP ; std::vector<float,std::allocator<float> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00@Z PROC ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z ; std::_Ptr_move_cat<float,float>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ PROC ; std::vector<float,std::allocator<float> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@MV?$allocator@M@std@@@std@@QBEIXZ ENDP ; std::vector<float,std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@M@std@@QAEPAMI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@M@std@@QAEPAMI@Z PROC		; std::allocator<float>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]

; 26   : 	if (_Max_possible < _Count)

  0000d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00012	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00014	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00019	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001f	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00021	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00024	83 ca ff	 or	 edx, -1
  00027	3b c1		 cmp	 eax, ecx
  00029	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00034	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0003b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003e	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00041	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00059	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@M@std@@QAEPAMI@Z ENDP		; std::allocator<float>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@_KV?$allocator@_K@std@@@std@@ABEXPA_K0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@_KV?$allocator@_K@std@@@std@@ABEXPA_K0@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@_KV?$allocator@_K@std@@@std@@ABEXPA_K0@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@_KV?$allocator@_K@std@@@std@@CAXXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@_KV?$allocator@_K@std@@@std@@AAEXQA_KII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@_KV?$allocator@_K@std@@@std@@AAEXQA_KII@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e2 f8	 and	 edx, -8			; fffffff8H

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@_KV?$allocator@_K@std@@@std@@AAEXQA_KII@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@_KV?$allocator@_K@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@_KV?$allocator@_K@std@@@std@@ABEII@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 03	 sar	 edx, 3

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0001a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00020	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00022	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@_KV?$allocator@_K@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@_KV?$allocator@_K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@_K@std@@QAEPA_KI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_K@std@@QAEPA_KI@Z PROC		; std::allocator<unsigned __int64>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]

; 26   : 	if (_Max_possible < _Count)

  0000d	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00012	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00014	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00019	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001f	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00021	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00024	83 ca ff	 or	 edx, -1
  00027	3b c1		 cmp	 eax, ecx
  00029	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00034	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0003b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003e	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00041	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00059	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@_K@std@@QAEPA_KI@Z ENDP		; std::allocator<unsigned __int64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@ABEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@KV?$allocator@K@std@@@std@@AAEXQAKII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	c1 fa 02	 sar	 edx, 2

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00010	8b ca		 mov	 ecx, edx
  00012	d1 e9		 shr	 ecx, 1
  00014	2b c1		 sub	 eax, ecx
  00016	3b d0		 cmp	 edx, eax
  00018	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0001a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00020	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00022	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@KV?$allocator@K@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ; std::_Ptr_move_cat<unsigned long,unsigned long>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC		; std::allocator<unsigned long>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]

; 26   : 	if (_Max_possible < _Count)

  0000d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00012	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00014	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00019	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001f	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00021	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00024	83 ca ff	 or	 edx, -1
  00027	3b c1		 cmp	 eax, ecx
  00029	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00034	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0003b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003e	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00041	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00059	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@ABEXPAG0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@ABEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@GV?$allocator@G@std@@@std@@ABEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@GV?$allocator@G@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@GV?$allocator@G@std@@@std@@CAXXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@GV?$allocator@G@std@@@std@@CAXXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@GV?$allocator@G@std@@@std@@AAEXQAGII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@GV?$allocator@G@std@@@std@@AAEXQAGII@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e2 fe	 and	 edx, -2			; fffffffeH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001f	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	52		 push	 edx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@GV?$allocator@G@std@@@std@@AAEXQAGII@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@GV?$allocator@G@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@GV?$allocator@G@std@@@std@@ABEII@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000d	d1 fa		 sar	 edx, 1

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0000f	8b ca		 mov	 ecx, edx
  00011	d1 e9		 shr	 ecx, 1
  00013	2b c1		 sub	 eax, ecx
  00015	3b d0		 cmp	 edx, eax
  00017	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00019	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0001f	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00021	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@GV?$allocator@G@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ; std::_Ptr_move_cat<unsigned short,unsigned short>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@G@std@@QAEPAGI@Z PROC		; std::allocator<unsigned short>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]

; 26   : 	if (_Max_possible < _Count)

  00009	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0000e	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00010	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00013	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0001d	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00020	83 ca ff	 or	 edx, -1
  00023	3b c1		 cmp	 eax, ecx
  00025	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0002e	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00030	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00033	85 c9		 test	 ecx, ecx
  00035	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00037	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003a	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00044	85 c9		 test	 ecx, ecx
  00046	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004e	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00055	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00060	cc		 int	 3
?allocate@?$allocator@G@std@@QAEPAGI@Z ENDP		; std::allocator<unsigned short>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@ABEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 29		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000f	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 26		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00038	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003b	03 c1		 add	 eax, ecx
  0003d	89 0e		 mov	 DWORD PTR [esi], ecx
  0003f	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00042	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00045	03 c1		 add	 eax, ecx
  00047	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004a	5e		 pop	 esi

; 1907 : 		}

  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00054	cc		 int	 3
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00006	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000b	2b 11		 sub	 edx, DWORD PTR [ecx]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0000d	8b ca		 mov	 ecx, edx
  0000f	d1 e9		 shr	 ecx, 1
  00011	2b c1		 sub	 eax, ecx
  00013	3b d0		 cmp	 edx, eax
  00015	77 08		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00017	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001a	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0001d	73 03		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ; std::_Ptr_move_cat<unsigned char,unsigned char>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PA_W@std@@@std@@SAIABV?$allocator@PA_W@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@PA_W@std@@@std@@SAIABV?$allocator@PA_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t *> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PA_W@std@@@std@@SAIABV?$allocator@PA_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$allocator@PA_W@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$allocator@PA_W@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PA_WV?$allocator@PA_W@std@@@std@@@std@@QBEABV?$allocator@PA_W@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<wchar_t *,std::allocator<wchar_t *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z ; std::_Ptr_move_cat<wchar_t *,wchar_t *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@PA_WV?$allocator@PA_W@std@@@std@@AAEXPAPA_W00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<wchar_t *,std::allocator<wchar_t *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAIABV?$allocator@N@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAIABV?$allocator@N@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<double> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAIABV?$allocator@N@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<double> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$allocator@N@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$allocator@N@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@NV?$allocator@N@std@@@std@@@std@@QBEABV?$allocator@N@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<double,std::allocator<double> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z ; std::_Ptr_move_cat<double,double>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AAEXPAN00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<float> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@M@std@@@std@@SAIABV?$allocator@M@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$allocator@M@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$allocator@M@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@MV?$allocator@M@std@@@std@@@std@@QBEABV?$allocator@M@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<float,std::allocator<float> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z ; std::_Ptr_move_cat<float,float>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@MV?$allocator@M@std@@@std@@AAEXPAM00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<float,std::allocator<float> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_K@std@@@std@@SAIABV?$allocator@_K@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@_K@std@@@std@@SAIABV?$allocator@_K@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned __int64> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@_K@std@@@std@@SAIABV?$allocator@_K@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned __int64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$allocator@_K@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$allocator@_K@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@_KV?$allocator@_K@std@@@std@@@std@@QBEABV?$allocator@_K@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned __int64,std::allocator<unsigned __int64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@_KV?$allocator@_K@std@@@std@@AAEXPA_K00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned __int64,std::allocator<unsigned __int64> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned long> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$allocator@K@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$allocator@K@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$allocator@K@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ; std::_Ptr_move_cat<unsigned long,unsigned long>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@KV?$allocator@K@std@@@std@@AAEXPAK00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned short> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@G@std@@@std@@SAIABV?$allocator@G@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$allocator@G@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$allocator@G@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$allocator@G@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ; std::_Ptr_move_cat<unsigned short,unsigned short>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@GV?$allocator@G@std@@@std@@AAEXPAG00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ; std::_Ptr_move_cat<unsigned char,unsigned char>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$allocator@PA_W@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$allocator@PA_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PA_W@std@@V?$_Vector_val@U?$_Simple_types@PA_W@std@@@2@$00@std@@QBEABV?$allocator@PA_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t *>,std::_Vector_val<std::_Simple_types<wchar_t *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$allocator@N@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$allocator@N@2@XZ PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QBEABV?$allocator@N@2@XZ ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$allocator@M@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$allocator@M@2@XZ PROC ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@M@std@@V?$_Vector_val@U?$_Simple_types@M@std@@@2@$00@std@@QBEABV?$allocator@M@2@XZ ENDP ; std::_Compressed_pair<std::allocator<float>,std::_Vector_val<std::_Simple_types<float> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$allocator@_K@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$allocator@_K@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_K@std@@V?$_Vector_val@U?$_Simple_types@_K@std@@@2@$00@std@@QBEABV?$allocator@_K@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned __int64>,std::_Vector_val<std::_Simple_types<unsigned __int64> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$allocator@K@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$allocator@K@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@K@std@@V?$_Vector_val@U?$_Simple_types@K@std@@@2@$00@std@@QBEABV?$allocator@K@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned long>,std::_Vector_val<std::_Simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$allocator@G@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$allocator@G@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@G@std@@V?$_Vector_val@U?$_Simple_types@G@std@@@2@$00@std@@QBEABV?$allocator@G@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned short>,std::_Vector_val<std::_Simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Distance1@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Distance1@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1235 : 	return (_Last - _First);

  00000	2b d1		 sub	 edx, ecx
  00002	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00007	f7 ea		 imul	 edx
  00009	c1 fa 02	 sar	 edx, 2
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 1236 : 	}

  00013	c3		 ret	 0
??$_Distance1@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Dest$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 209  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b f1		 mov	 esi, ecx

; 147  : 		: _First(_Dest),

  0002c	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]

; 148  : 		_Last(_Dest),
; 149  : 		_Al(_Al_)

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00032	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi
  00035	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi
  00038	89 45 f0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 187  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 188  : 	for (; _First != _Last; ++_First)

  00042	3b f3		 cmp	 esi, ebx
  00044	74 15		 je	 SHORT $LN17@Uninitiali
$LL18@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00046	56		 push	 esi
  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  0004e	83 c7 18	 add	 edi, 24			; 00000018H

; 188  : 	for (; _First != _Last; ++_First)

  00051	83 c6 18	 add	 esi, 24			; 00000018H

; 165  : 		++_Last;

  00054	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi

; 188  : 	for (; _First != _Last; ++_First)

  00057	3b f3		 cmp	 esi, ebx
  00059	75 eb		 jne	 SHORT $LL18@Uninitiali
$LN17@Uninitiali:

; 170  : 		_First = _Last;

  0005b	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi

; 193  : 	return (_Backout._Release());

  0005e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 		_Destroy_range(_First, _Last, _Al);

  00065	8b d7		 mov	 edx, edi
  00067	51		 push	 ecx
  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006f	83 c4 04	 add	 esp, 4

; 210  : 		// note: only called internally from elsewhere in the STL
; 211  : 	const auto _UFirst = _Get_unwrapped(_First);
; 212  : 	const auto _ULast = _Get_unwrapped(_Last);
; 213  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 214  : 	_Seek_wrapped(_Dest,
; 215  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 216  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 217  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));
; 218  : 
; 219  : 	return (_Dest);

  00072	8b c7		 mov	 eax, edi

; 220  : 	}

  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV12@@std@@YA@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
??$_Idl_distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV12@@std@@YA@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Idl_distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 12		 mov	 edx, DWORD PTR [edx]
  00002	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00007	2b 11		 sub	 edx, DWORD PTR [ecx]
  00009	f7 ea		 imul	 edx
  0000b	c1 fa 02	 sar	 edx, 2
  0000e	8b c2		 mov	 eax, edx
  00010	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00013	03 c2		 add	 eax, edx

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00015	c3		 ret	 0
??$_Idl_distance@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV12@@std@@YA@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Idl_distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<wchar_t * *,unsigned int,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 337  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAPA_WIV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_WIAAV?$allocator@PA_W@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<wchar_t * *,unsigned int,std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<double *,unsigned int,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 d5 00 00
	00 00		 lea	 esi, DWORD PTR [edx*8]
  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 337  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PANIV?$allocator@N@std@@@std@@YAPANPANIAAV?$allocator@N@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<double *,unsigned int,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<float *,unsigned int,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 337  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAMIV?$allocator@M@std@@@std@@YAPAMPAMIAAV?$allocator@M@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<float *,unsigned int,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<unsigned __int64 *,unsigned int,std::allocator<unsigned __int64> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 d5 00 00
	00 00		 lea	 esi, DWORD PTR [edx*8]
  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 337  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PA_KIV?$allocator@_K@std@@@std@@YAPA_KPA_KIAAV?$allocator@_K@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<unsigned __int64 *,unsigned int,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<unsigned long *,unsigned int,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR [edx*4]
  00009	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0000b	56		 push	 esi
  0000c	6a 00		 push	 0
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 337  : 	}

  0001c	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAKIV?$allocator@K@std@@@std@@YAPAKPAKIAAV?$allocator@K@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<unsigned long *,unsigned int,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<unsigned short *,unsigned int,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00002	8d 34 12	 lea	 esi, DWORD PTR [edx+edx]
  00005	8b f9		 mov	 edi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00007	56		 push	 esi
  00008	6a 00		 push	 0
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00013	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00016	5f		 pop	 edi
  00017	5e		 pop	 esi

; 337  : 	}

  00018	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAGIV?$allocator@G@std@@@std@@YAPAGPAGIAAV?$allocator@G@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<unsigned short *,unsigned int,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT
; __Count$ = ecx

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;
; 26   : 	if (_Max_possible < _Count)

  00000	83 ca ff	 or	 edx, -1
  00003	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0000a	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00010	0f 47 c2	 cmova	 eax, edx

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

  00013	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W0PAPA_WAAV?$allocator@PA_W@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W0PAPA_WAAV?$allocator@PA_W@0@@Z PROC ; std::_Uninitialized_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z ; std::_Ptr_move_cat<wchar_t *,wchar_t *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W0PAPA_WAAV?$allocator@PA_W@0@@Z ENDP ; std::_Uninitialized_move<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAPA_WPAPA_W@std@@YA@ABQAPA_W0@Z
_TEXT	SEGMENT
??$_Idl_distance@PAPA_WPAPA_W@std@@YA@ABQAPA_W0@Z PROC	; std::_Idl_distance<wchar_t * *,wchar_t * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00007	c3		 ret	 0
??$_Idl_distance@PAPA_WPAPA_W@std@@YA@ABQAPA_W0@Z ENDP	; std::_Idl_distance<wchar_t * *,wchar_t * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PANPANV?$allocator@N@std@@@std@@YAPANQAN0PANAAV?$allocator@N@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PANPANV?$allocator@N@std@@@std@@YAPANQAN0PANAAV?$allocator@N@0@@Z PROC ; std::_Uninitialized_move<double *,double *,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z ; std::_Ptr_move_cat<double,double>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PANPANV?$allocator@N@std@@@std@@YAPANQAN0PANAAV?$allocator@N@0@@Z ENDP ; std::_Uninitialized_move<double *,double *,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PANPAN@std@@YA@ABQAN0@Z
_TEXT	SEGMENT
??$_Idl_distance@PANPAN@std@@YA@ABQAN0@Z PROC		; std::_Idl_distance<double *,double *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 03	 sar	 eax, 3

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00007	c3		 ret	 0
??$_Idl_distance@PANPAN@std@@YA@ABQAN0@Z ENDP		; std::_Idl_distance<double *,double *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAMPAMV?$allocator@M@std@@@std@@YAPAMQAM0PAMAAV?$allocator@M@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAMPAMV?$allocator@M@std@@@std@@YAPAMQAM0PAMAAV?$allocator@M@0@@Z PROC ; std::_Uninitialized_move<float *,float *,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z ; std::_Ptr_move_cat<float,float>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAMPAMV?$allocator@M@std@@@std@@YAPAMQAM0PAMAAV?$allocator@M@0@@Z ENDP ; std::_Uninitialized_move<float *,float *,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAMPAM@std@@YA@ABQAM0@Z
_TEXT	SEGMENT
??$_Idl_distance@PAMPAM@std@@YA@ABQAM0@Z PROC		; std::_Idl_distance<float *,float *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00007	c3		 ret	 0
??$_Idl_distance@PAMPAM@std@@YA@ABQAM0@Z ENDP		; std::_Idl_distance<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KQA_K0PA_KAAV?$allocator@_K@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KQA_K0PA_KAAV?$allocator@_K@0@@Z PROC ; std::_Uninitialized_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PA_KPA_KV?$allocator@_K@std@@@std@@YAPA_KQA_K0PA_KAAV?$allocator@_K@0@@Z ENDP ; std::_Uninitialized_move<unsigned __int64 *,unsigned __int64 *,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PA_KPA_K@std@@YA@ABQA_K0@Z
_TEXT	SEGMENT
??$_Idl_distance@PA_KPA_K@std@@YA@ABQA_K0@Z PROC	; std::_Idl_distance<unsigned __int64 *,unsigned __int64 *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 03	 sar	 eax, 3

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00007	c3		 ret	 0
??$_Idl_distance@PA_KPA_K@std@@YA@ABQA_K0@Z ENDP	; std::_Idl_distance<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z PROC ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ; std::_Ptr_move_cat<unsigned long,unsigned long>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAKPAKV?$allocator@K@std@@@std@@YAPAKQAK0PAKAAV?$allocator@K@0@@Z ENDP ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAKPAK@std@@YA@ABQAK0@Z
_TEXT	SEGMENT
??$_Idl_distance@PAKPAK@std@@YA@ABQAK0@Z PROC		; std::_Idl_distance<unsigned long *,unsigned long *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00007	c3		 ret	 0
??$_Idl_distance@PAKPAK@std@@YA@ABQAK0@Z ENDP		; std::_Idl_distance<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGQAG0PAGAAV?$allocator@G@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGQAG0PAGAAV?$allocator@G@0@@Z PROC ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ; std::_Ptr_move_cat<unsigned short,unsigned short>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAGPAGV?$allocator@G@std@@@std@@YAPAGQAG0PAGAAV?$allocator@G@0@@Z ENDP ; std::_Uninitialized_move<unsigned short *,unsigned short *,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAGPAG@std@@YA@ABQAG0@Z
_TEXT	SEGMENT
??$_Idl_distance@PAGPAG@std@@YA@ABQAG0@Z PROC		; std::_Idl_distance<unsigned short *,unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	d1 f8		 sar	 eax, 1

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00006	c3		 ret	 0
??$_Idl_distance@PAGPAG@std@@YA@ABQAG0@Z ENDP		; std::_Idl_distance<unsigned short *,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ; std::_Ptr_move_cat<unsigned char,unsigned char>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAEPAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAEPAE@std@@YA@ABQAE0@Z
_TEXT	SEGMENT
??$_Idl_distance@PAEPAE@std@@YA@ABQAE0@Z PROC		; std::_Idl_distance<unsigned char *,unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00004	c3		 ret	 0
??$_Idl_distance@PAEPAE@std@@YA@ABQAE0@Z ENDP		; std::_Idl_distance<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@@Z
_TEXT	SEGMENT
??$_Get_unwrapped@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@@Z PROC ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBV10@@Z ENDP ; std::_Get_unwrapped<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV20@@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV20@@Z PROC ; std::_Ptr_copy_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1070 : 	return {};

  00000	32 c0		 xor	 al, al

; 1071 : 	}

  00002	c3		 ret	 0
??$_Ptr_copy_cat@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABQAV20@@Z ENDP ; std::_Ptr_copy_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
_TEXT	SEGMENT
__Backout$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Dest$ = 8						; size = 4
__Al$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 186  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b f1		 mov	 esi, ecx

; 147  : 		: _First(_Dest),

  0002c	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]

; 148  : 		_Last(_Dest),
; 149  : 		_Al(_Al_)

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00032	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi
  00035	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi
  00038	89 45 f0	 mov	 DWORD PTR __Backout$[ebp+8], eax

; 187  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 188  : 	for (; _First != _Last; ++_First)

  00042	3b f3		 cmp	 esi, ebx
  00044	74 15		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00046	56		 push	 esi
  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  0004e	83 c7 18	 add	 edi, 24			; 00000018H

; 188  : 	for (; _First != _Last; ++_First)

  00051	83 c6 18	 add	 esi, 24			; 00000018H

; 165  : 		++_Last;

  00054	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi

; 188  : 	for (; _First != _Last; ++_First)

  00057	3b f3		 cmp	 esi, ebx
  00059	75 eb		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 170  : 		_First = _Last;

  0005b	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi

; 189  : 		{
; 190  : 		_Backout._Emplace_back(*_First);
; 191  : 		}
; 192  : 
; 193  : 	return (_Backout._Release());

  0005e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 		_Destroy_range(_First, _Last, _Al);

  00065	8b d7		 mov	 edx, edi
  00067	51		 push	 ecx
  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006f	83 c4 04	 add	 esp, 4

; 189  : 		{
; 190  : 		_Backout._Emplace_back(*_First);
; 191  : 		}
; 192  : 
; 193  : 	return (_Backout._Release());

  00072	8b c7		 mov	 eax, edi

; 194  : 	}

  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@QBV10@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAPA_W@std@@YAPAPA_WQAPA_W0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPA_W@std@@YAPAPA_WQAPA_W0@Z PROC	; std::_Zero_range<wchar_t * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAPA_W@std@@YAPAPA_WQAPA_W0@Z ENDP	; std::_Zero_range<wchar_t * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAN@std@@YAPANQAN0@Z
_TEXT	SEGMENT
??$_Zero_range@PAN@std@@YAPANQAN0@Z PROC		; std::_Zero_range<double *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAN@std@@YAPANQAN0@Z ENDP		; std::_Zero_range<double *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAM@std@@YAPAMQAM0@Z
_TEXT	SEGMENT
??$_Zero_range@PAM@std@@YAPAMQAM0@Z PROC		; std::_Zero_range<float *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAM@std@@YAPAMQAM0@Z ENDP		; std::_Zero_range<float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PA_K@std@@YAPA_KQA_K0@Z
_TEXT	SEGMENT
??$_Zero_range@PA_K@std@@YAPA_KQA_K0@Z PROC		; std::_Zero_range<unsigned __int64 *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PA_K@std@@YAPA_KQA_K0@Z ENDP		; std::_Zero_range<unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAK@std@@YAPAKQAK0@Z
_TEXT	SEGMENT
??$_Zero_range@PAK@std@@YAPAKQAK0@Z PROC		; std::_Zero_range<unsigned long *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAK@std@@YAPAKQAK0@Z ENDP		; std::_Zero_range<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAG@std@@YAPAGQAG0@Z
_TEXT	SEGMENT
??$_Zero_range@PAG@std@@YAPAGQAG0@Z PROC		; std::_Zero_range<unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAG@std@@YAPAGQAG0@Z ENDP		; std::_Zero_range<unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@PA_W@std@@YAPAPA_WQAPA_W@Z
_TEXT	SEGMENT
??$_Get_unwrapped@PA_W@std@@YAPAPA_WQAPA_W@Z PROC	; std::_Get_unwrapped<wchar_t *>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@PA_W@std@@YAPAPA_WQAPA_W@Z ENDP	; std::_Get_unwrapped<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@PA_WH$0A@@std@@YAPAPA_WQAPA_WH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@PA_WH$0A@@std@@YAPAPA_WQAPA_WH@Z PROC ; std::_Get_unwrapped_n<wchar_t *,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@PA_WH$0A@@std@@YAPAPA_WQAPA_WH@Z ENDP ; std::_Get_unwrapped_n<wchar_t *,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z PROC ; std::_Ptr_move_cat<wchar_t *,wchar_t *>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@PA_WPA_W@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPA_W0@Z ENDP ; std::_Ptr_move_cat<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PA_WPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W00AAV?$allocator@PA_W@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@PA_WPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W00AAV?$allocator@PA_W@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<wchar_t *,wchar_t *,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PA_WPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WQAPA_W00AAV?$allocator@PA_W@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<wchar_t *,wchar_t *,std::allocator<wchar_t *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@PA_W@std@@YAXAAPAPA_WQAPA_W@Z
_TEXT	SEGMENT
??$_Seek_wrapped@PA_W@std@@YAXAAPAPA_WQAPA_W@Z PROC	; std::_Seek_wrapped<wchar_t *>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@PA_W@std@@YAXAAPAPA_WQAPA_W@Z ENDP	; std::_Seek_wrapped<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@N@std@@YAPANQAN@Z
_TEXT	SEGMENT
??$_Get_unwrapped@N@std@@YAPANQAN@Z PROC		; std::_Get_unwrapped<double>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@N@std@@YAPANQAN@Z ENDP		; std::_Get_unwrapped<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@NH$0A@@std@@YAPANQANH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@NH$0A@@std@@YAPANQANH@Z PROC	; std::_Get_unwrapped_n<double,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@NH$0A@@std@@YAPANQANH@Z ENDP	; std::_Get_unwrapped_n<double,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z PROC ; std::_Ptr_move_cat<double,double>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@NN@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAN0@Z ENDP ; std::_Ptr_move_cat<double,double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@NNV?$allocator@N@std@@@std@@YAPANQAN00AAV?$allocator@N@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@NNV?$allocator@N@std@@@std@@YAPANQAN00AAV?$allocator@N@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<double,double,std::allocator<double> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@NNV?$allocator@N@std@@@std@@YAPANQAN00AAV?$allocator@N@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<double,double,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@N@std@@YAXAAPANQAN@Z
_TEXT	SEGMENT
??$_Seek_wrapped@N@std@@YAXAAPANQAN@Z PROC		; std::_Seek_wrapped<double>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@N@std@@YAXAAPANQAN@Z ENDP		; std::_Seek_wrapped<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@M@std@@YAPAMQAM@Z
_TEXT	SEGMENT
??$_Get_unwrapped@M@std@@YAPAMQAM@Z PROC		; std::_Get_unwrapped<float>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@M@std@@YAPAMQAM@Z ENDP		; std::_Get_unwrapped<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@MH$0A@@std@@YAPAMQAMH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@MH$0A@@std@@YAPAMQAMH@Z PROC	; std::_Get_unwrapped_n<float,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@MH$0A@@std@@YAPAMQAMH@Z ENDP	; std::_Get_unwrapped_n<float,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z PROC ; std::_Ptr_move_cat<float,float>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@MM@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAM0@Z ENDP ; std::_Ptr_move_cat<float,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPAMQAM00AAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPAMQAM00AAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<float,float,std::allocator<float> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@MMV?$allocator@M@std@@@std@@YAPAMQAM00AAV?$allocator@M@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<float,float,std::allocator<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@M@std@@YAXAAPAMQAM@Z
_TEXT	SEGMENT
??$_Seek_wrapped@M@std@@YAXAAPAMQAM@Z PROC		; std::_Seek_wrapped<float>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@M@std@@YAXAAPAMQAM@Z ENDP		; std::_Seek_wrapped<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@_K@std@@YAPA_KQA_K@Z
_TEXT	SEGMENT
??$_Get_unwrapped@_K@std@@YAPA_KQA_K@Z PROC		; std::_Get_unwrapped<unsigned __int64>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@_K@std@@YAPA_KQA_K@Z ENDP		; std::_Get_unwrapped<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@_KH$0A@@std@@YAPA_KQA_KH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@_KH$0A@@std@@YAPA_KQA_KH@Z PROC	; std::_Get_unwrapped_n<unsigned __int64,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@_KH$0A@@std@@YAPA_KQA_KH@Z ENDP	; std::_Get_unwrapped_n<unsigned __int64,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z PROC ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@_K_K@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQA_K0@Z ENDP ; std::_Ptr_move_cat<unsigned __int64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@_K_KV?$allocator@_K@std@@@std@@YAPA_KQA_K00AAV?$allocator@_K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@_K_KV?$allocator@_K@std@@@std@@YAPA_KQA_K00AAV?$allocator@_K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned __int64,unsigned __int64,std::allocator<unsigned __int64> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@_K_KV?$allocator@_K@std@@@std@@YAPA_KQA_K00AAV?$allocator@_K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned __int64,unsigned __int64,std::allocator<unsigned __int64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@_K@std@@YAXAAPA_KQA_K@Z
_TEXT	SEGMENT
??$_Seek_wrapped@_K@std@@YAXAAPA_KQA_K@Z PROC		; std::_Seek_wrapped<unsigned __int64>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@_K@std@@YAXAAPA_KQA_K@Z ENDP		; std::_Seek_wrapped<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@K@std@@YAPAKQAK@Z
_TEXT	SEGMENT
??$_Get_unwrapped@K@std@@YAPAKQAK@Z PROC		; std::_Get_unwrapped<unsigned long>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@K@std@@YAPAKQAK@Z ENDP		; std::_Get_unwrapped<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@KH$0A@@std@@YAPAKQAKH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@KH$0A@@std@@YAPAKQAKH@Z PROC	; std::_Get_unwrapped_n<unsigned long,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@KH$0A@@std@@YAPAKQAKH@Z ENDP	; std::_Get_unwrapped_n<unsigned long,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z PROC ; std::_Ptr_move_cat<unsigned long,unsigned long>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@KK@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAK0@Z ENDP ; std::_Ptr_move_cat<unsigned long,unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKQAK00AAV?$allocator@K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKQAK00AAV?$allocator@K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned long,unsigned long,std::allocator<unsigned long> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@KKV?$allocator@K@std@@@std@@YAPAKQAK00AAV?$allocator@K@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned long,unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@K@std@@YAXAAPAKQAK@Z
_TEXT	SEGMENT
??$_Seek_wrapped@K@std@@YAXAAPAKQAK@Z PROC		; std::_Seek_wrapped<unsigned long>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@K@std@@YAXAAPAKQAK@Z ENDP		; std::_Seek_wrapped<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@G@std@@YAPAGQAG@Z
_TEXT	SEGMENT
??$_Get_unwrapped@G@std@@YAPAGQAG@Z PROC		; std::_Get_unwrapped<unsigned short>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@G@std@@YAPAGQAG@Z ENDP		; std::_Get_unwrapped<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@GH$0A@@std@@YAPAGQAGH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@GH$0A@@std@@YAPAGQAGH@Z PROC	; std::_Get_unwrapped_n<unsigned short,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@GH$0A@@std@@YAPAGQAGH@Z ENDP	; std::_Get_unwrapped_n<unsigned short,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z PROC ; std::_Ptr_move_cat<unsigned short,unsigned short>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@GG@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAG0@Z ENDP ; std::_Ptr_move_cat<unsigned short,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@GGV?$allocator@G@std@@@std@@YAPAGQAG00AAV?$allocator@G@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@GGV?$allocator@G@std@@@std@@YAPAGQAG00AAV?$allocator@G@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned short,unsigned short,std::allocator<unsigned short> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@GGV?$allocator@G@std@@@std@@YAPAGQAG00AAV?$allocator@G@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned short,unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@G@std@@YAXAAPAGQAG@Z
_TEXT	SEGMENT
??$_Seek_wrapped@G@std@@YAXAAPAGQAG@Z PROC		; std::_Seek_wrapped<unsigned short>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@G@std@@YAXAAPAGQAG@Z ENDP		; std::_Seek_wrapped<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@E@std@@YAPAEQAE@Z
_TEXT	SEGMENT
??$_Get_unwrapped@E@std@@YAPAEQAE@Z PROC		; std::_Get_unwrapped<unsigned char>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@E@std@@YAPAEQAE@Z ENDP		; std::_Get_unwrapped<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@EH$0A@@std@@YAPAEQAEH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@EH$0A@@std@@YAPAEQAEH@Z PROC	; std::_Get_unwrapped_n<unsigned char,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@EH$0A@@std@@YAPAEQAEH@Z ENDP	; std::_Get_unwrapped_n<unsigned char,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z PROC ; std::_Ptr_move_cat<unsigned char,unsigned char>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@EE@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAE0@Z ENDP ; std::_Ptr_move_cat<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@EEV?$allocator@E@std@@@std@@YAPAEQAE00AAV?$allocator@E@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@EEV?$allocator@E@std@@@std@@YAPAEQAE00AAV?$allocator@E@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<unsigned char,unsigned char,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@EEV?$allocator@E@std@@@std@@YAPAEQAE00AAV?$allocator@E@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<unsigned char,unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@E@std@@YAXAAPAEQAE@Z
_TEXT	SEGMENT
??$_Seek_wrapped@E@std@@YAXAAPAEQAE@Z PROC		; std::_Seek_wrapped<unsigned char>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@E@std@@YAXAAPAEQAE@Z ENDP		; std::_Seek_wrapped<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00004	ff 75 08	 push	 DWORD PTR _<_Vals_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 163  : 		{	// construct a new element at *_Last and increment

  00007	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00009	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  00011	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00015	5e		 pop	 esi

; 166  : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$_Emplace_back@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAPA_WPAPA_W@std@@YAPAPA_WPAPA_W00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPA_WPAPA_W@std@@YAPAPA_WPAPA_W00@Z PROC ; std::_Copy_memmove<wchar_t * *,wchar_t * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAPA_WPAPA_W@std@@YAPAPA_WPAPA_W00@Z ENDP ; std::_Copy_memmove<wchar_t * *,wchar_t * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z PROC		; std::_Copy_memmove<double *,double *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PANPAN@std@@YAPANPAN00@Z ENDP		; std::_Copy_memmove<double *,double *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAMPAM@std@@YAPAMPAM00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAMPAM@std@@YAPAMPAM00@Z PROC		; std::_Copy_memmove<float *,float *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAMPAM@std@@YAPAMPAM00@Z ENDP		; std::_Copy_memmove<float *,float *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PA_KPA_K@std@@YAPA_KPA_K00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PA_KPA_K@std@@YAPA_KPA_K00@Z PROC	; std::_Copy_memmove<unsigned __int64 *,unsigned __int64 *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PA_KPA_K@std@@YAPA_KPA_K00@Z ENDP	; std::_Copy_memmove<unsigned __int64 *,unsigned __int64 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC		; std::_Copy_memmove<unsigned long *,unsigned long *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::_Copy_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z PROC		; std::_Copy_memmove<unsigned short *,unsigned short *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAGPAG@std@@YAPAGPAG00@Z ENDP		; std::_Copy_memmove<unsigned short *,unsigned short *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
END
