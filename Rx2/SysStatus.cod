; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27031.1 

	TITLE	c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0CE@OFCPEEHM@YUEN?5DA?5ELECTRONIC?5PRODUCTS?5FAC@ ; `string'
PUBLIC	??_C@_0N@BBHAKCFP@FOOSUNG?5TECH@		; `string'
PUBLIC	??_C@_0CI@BDHNOJJE@Universal?5Electronics?5Inc?4?5?$CIDBA@ ; `string'
PUBLIC	??_C@_0BC@ELLAHEBO@Atmel?5Corporation@		; `string'
PUBLIC	??_C@_07LAHLPDGH@Mitsumi@			; `string'
PUBLIC	??_C@_0BA@GKDJMMLL@Hewlett?5Packard@		; `string'
PUBLIC	??_C@_0BF@CMFLPPM@M31?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0BD@NBCHGNBK@Liteconn?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0CM@FLONKIJ@Sanwin?5?$CIHK?$CJ?5Electronic?5Technolo@ ; `string'
PUBLIC	??_C@_0CO@FLHPAOCE@Suzhou?5WEIJU?5Electronics?5Techno@ ; `string'
PUBLIC	??_C@_0BB@MGJGOJNE@Mondokey?5Limited@		; `string'
PUBLIC	??_C@_0BG@DEOCBHFP@Advantest?5Corporation@	; `string'
PUBLIC	??_C@_0BD@JJJMEBLG@iRobot?5Corporation@		; `string'
PUBLIC	??_C@_0CF@LNNLJKDF@Shenzhen?5Huiding?5Technology?5Co?4@ ; `string'
PUBLIC	??_C@_0BM@MEJFLCNJ@Elitegroup?5Computer?5Systems@ ; `string'
PUBLIC	??_C@_0BK@GHOGMBAO@VERTU?5Corporation?5Limited@	; `string'
PUBLIC	??_C@_0P@NCBHMFI@Sibridge?5Tech?4@		; `string'
PUBLIC	??_C@_0CA@HCOKNFP@Presidium?5Instruments?5Pte?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0DA@NLEDAFLA@Future?5Technology?5Devices?5Inter@ ; `string'
PUBLIC	??_C@_0BD@FGPOPKKG@Power?5Integrations@		; `string'
PUBLIC	??_C@_0CG@GMANIEBL@HIGH?5TEK?5HARNESS?5ENTERPRISE?5CO?4@ ; `string'
PUBLIC	??_C@_0CM@MILEOKEB@Astronics?5Advanced?5Electronic?5S@ ; `string'
PUBLIC	??_C@_0CN@LEICPGF@Yangtze?5Optical?5Fibre?5and?5Cable@ ; `string'
PUBLIC	??_C@_0BH@KGNDOHL@Full?5in?5Hope?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BF@PKMDPELO@Quanta?5Computer?5Inc?4@	; `string'
PUBLIC	??_C@_0CB@MNOLJHMM@Viconn?5Technology?5?$CIHK?$CJ?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0BA@KPLBOCAE@NEC?5Corporation@		; `string'
PUBLIC	??_C@_0DF@KBADGJOK@BIOMATIQUES?5IDENTIFICATION?5SOLU@ ; `string'
PUBLIC	??_C@_0CM@LNOFLHEK@Cabletech?5Electronics?5?$CIHong?5Kon@ ; `string'
PUBLIC	??_C@_0CJ@PLPMOAKE@Beijing?5Jinke?5XinAn?5Technology?5@ ; `string'
PUBLIC	??_C@_0BE@MHLNPDBP@Black?5Diamond?5Video@	; `string'
PUBLIC	??_C@_0BH@LEHBDMGE@VIA?5Technologies?0?5Inc?4@	; `string'
PUBLIC	??_C@_0L@KHHADJK@Quantec?5SA@			; `string'
PUBLIC	??_C@_0BJ@HBMJFDNE@Seeed?5Technology?5Limited@	; `string'
PUBLIC	??_C@_09ILDBIJFO@Specwerkz@			; `string'
PUBLIC	??_C@_0BB@DMJKNCDK@MCCI?5Corporation@		; `string'
PUBLIC	??_C@_0BB@NAOLNMKN@mce?9systems?5Ltd?4@		; `string'
PUBLIC	??_C@_0BH@CAOGFENG@Voxx?5Accessories?5Corp?4@	; `string'
PUBLIC	??_C@_08JBDBNMBO@Hovercam@			; `string'
PUBLIC	??_C@_0CM@GPMPJMPK@TTAF?5Elektronik?5Sanayi?5ve?5Ticar@ ; `string'
PUBLIC	??_C@_0BH@IDHICNHG@SDJ?5Technologies?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BN@BBBBJNLH@Accumetrics?5Associates?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BF@FBKKDMPD@Tyrian?5Systems?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BM@FAMHIABA@Esselte?5Leitz?5GmbH?5?$CG?5Co?4?5KG@ ; `string'
PUBLIC	??_C@_0BP@CCGHLJI@Meadowlark?5Optics?5Incorporated@ ; `string'
PUBLIC	??_C@_0M@EIJFGOMC@E?9SEEK?5Inc?4@		; `string'
PUBLIC	??_C@_0N@HBBMPLAJ@BUFFALO?5INC?4@		; `string'
PUBLIC	??_C@_0BL@DCMLCELG@Realta?5Entertainment?5Group@ ; `string'
PUBLIC	??_C@_0BB@BHCNLHHB@Zynaptic?5Limited@		; `string'
PUBLIC	??_C@_0CA@OLPMAFK@Sharkbay?5Technologies?5Pte?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@HPLMDDDJ@Pleora?5Technologies?5Inc?4@	; `string'
PUBLIC	??_C@_0BJ@NACMFIML@Vitetech?5Int?8l?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0DE@PGCKDINF@ShenZhen?5Innovate?9link?5Precisio@ ; `string'
PUBLIC	??_C@_0BP@EJPGPDCC@Giga?9Byte?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0P@DNCLHBIA@ULTRACHIP?5Inc?4@		; `string'
PUBLIC	??_C@_0CJ@CCPKGHJO@DongGuan?5City?5DHE?5Wire?5?$CG?5Cable?5@ ; `string'
PUBLIC	??_C@_0BP@OGAADAEC@SMARTMATIC?5INTERNATIONAL?5CORP?4@ ; `string'
PUBLIC	??_C@_0DD@EONFGNA@Changzhou?5Shi?5Wujin?5Miqi?5East?5E@ ; `string'
PUBLIC	??_C@_0BA@BCGCCHNK@FTK?5Corporation@		; `string'
PUBLIC	??_C@_0CJ@DBDKKFKI@Golden?5Transmart?5International?5@ ; `string'
PUBLIC	??_C@_0BG@CAKHPFKP@Electrogamez?5USA?5Inc?4@	; `string'
PUBLIC	??_C@_0BF@COFMCAMA@Tekron?5International@	; `string'
PUBLIC	??_C@_0BB@HMDKKJBN@Panda?5Ocean?5Inc?4@		; `string'
PUBLIC	??_C@_0CG@KMAMPINN@Shenzhen?5Ourconn?5Technology?5Co?4@ ; `string'
PUBLIC	??_C@_0CD@DIFILODO@G?4SKILL?5Int?8l?5Enterprice?5Co?4?0?5L@ ; `string'
PUBLIC	??_C@_0BJ@BBLEBCKI@Nuvoton?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0CI@PBJBEILB@Surplus?5Electronic?5Technology?5C@ ; `string'
PUBLIC	??_C@_0CH@DHPPNOKD@Apollo?5Electrical?5Technology?5Co@ ; `string'
PUBLIC	??_C@_08FIAKBIJJ@MEP?5TECH@			; `string'
PUBLIC	??_C@_0O@FGAHHGKD@BIAMP?5SYSTEMS@		; `string'
PUBLIC	??_C@_0BO@KAAEKANB@Glyph?5Production?5Technologies@ ; `string'
PUBLIC	??_C@_0CL@IOFNGFIH@Dongguan?5City?5Guangye?5Electroni@ ; `string'
PUBLIC	??_C@_0DE@MBFKODKB@SHEN?5ZHEN?5SHI?5YUAN?5AI?5HARDWARE?5@ ; `string'
PUBLIC	??_C@_0BC@NCPGFKEN@Sonoma?5Wire?5Works@		; `string'
PUBLIC	??_C@_0M@DMBLDCEB@iProtoXi?5Oy@			; `string'
PUBLIC	??_C@_0BL@JLOLHNCB@Shin?5Hwa?5Contech?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BL@HNBOMKEI@Marquardt?5Mechatronik?5GmbH@ ; `string'
PUBLIC	??_C@_0O@GPHCMPGC@MIRAENANOTECH@		; `string'
PUBLIC	??_C@_0BI@BOMOIKOC@Charon?5Technologies?5LLC@	; `string'
PUBLIC	??_C@_0BH@GLGOEHJJ@iDea?5USA?5Products?5Inc?4@	; `string'
PUBLIC	??_C@_0BD@JGINGPIL@Masimo?5Corporation@		; `string'
PUBLIC	??_C@_0O@ICLJDKCA@Mimetics?5Inc?4@		; `string'
PUBLIC	??_C@_0CD@LNMEEJMI@Shenzhen?5Sen5?5Technology?5Co?4?0?5L@ ; `string'
PUBLIC	??_C@_0BH@PIIGLOJL@Active?5Mind?5Technology@	; `string'
PUBLIC	??_C@_0CJ@HIEOMNPE@IBCONN?5Technologies?5?$CIShenzhen?$CJ?5@ ; `string'
PUBLIC	??_C@_0L@DOPCHCHO@Fugoo?5Inc?4@			; `string'
PUBLIC	??_C@_0BC@JGPKGMHA@Teladin?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BD@CKJDNNGP@Kent?5Displays?5Inc?4@	; `string'
PUBLIC	??_C@_0BM@CJNOHFGM@Sage?5Microelectronics?5Corp?4@ ; `string'
PUBLIC	??_C@_0BC@JALGBKPD@Yota?5Devices?5Ltd?4@	; `string'
PUBLIC	??_C@_0CI@HPLDADLK@Pan?5Xin?5Precision?5Electronics?5C@ ; `string'
PUBLIC	??_C@_0CC@ENAAKLLF@Oceanwing?5International?5Co?4?0?5Lt@ ; `string'
PUBLIC	??_C@_0CL@KGCDNOHK@Research?5?$CG?5Development?5Center?5?5@ ; `string'
PUBLIC	??_C@_0CB@MMCLOPLO@Shanghai?5DynamiCode?5Company?5Ltd@ ; `string'
PUBLIC	??_C@_0CO@NHBBDDIH@Dongguan?5Digi?9in?5Digital?5Techno@ ; `string'
PUBLIC	??_C@_06LEANDNHK@Vprime@			; `string'
PUBLIC	??_C@_0O@CDIDDBG@Creative?5Labs@		; `string'
PUBLIC	??_C@_0P@CBINLKCB@GENUSION?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BN@HOAFENMH@Wellitec?5Development?5Limited@ ; `string'
PUBLIC	??_C@_0BD@MJLLIIHL@Ineda?5Systems?5Inc?4@	; `string'
PUBLIC	??_C@_0L@KKIKDNPF@Jolla?5Ltd?4@			; `string'
PUBLIC	??_C@_0BK@KLIICOHE@Peraso?5Technologies?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0CH@LCOLLFLN@Nanjing?5Magewell?5Electronics?5Co@ ; `string'
PUBLIC	??_C@_0M@MCPHKEHG@LEAP?5Motion@			; `string'
PUBLIC	??_C@_0BC@FMELJLJG@Tmax?5Digital?5Inc?4@	; `string'
PUBLIC	??_C@_0BD@BLAKEMMK@The?5SmarTV?5Company@	; `string'
PUBLIC	??_C@_0CH@IJLFKJJB@Shenzhen?5Yiwanda?5Electronics?5Co@ ; `string'
PUBLIC	??_C@_0CA@NNFPJDN@Sanofi?9Aventis?5Deutschland?5GmbH@ ; `string'
PUBLIC	??_C@_0O@DLJLHDNK@SoftLab?5?9?5NSK@		; `string'
PUBLIC	??_C@_09BBHONFCE@ZAGG?5Inc?4@			; `string'
PUBLIC	??_C@_0BC@LOIKONEK@Nokia?5Corporation@		; `string'
PUBLIC	??_C@_0BL@LCIDFNGP@Terminus?5Circuits?5Pvt?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BL@EKMIGECI@Cellwise?5Holding?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@OMCAGFMI@SHIH?5HUA?5TECHNOLOGY?5LTD?4@ ; `string'
PUBLIC	??_C@_0BH@NMHMOMNM@Dollar?5Connection?5Ltd?4@	; `string'
PUBLIC	??_C@_0BO@KBNIJBFJ@OBSIDIAN?5RESEARCH?5CORPORATION@ ; `string'
PUBLIC	??_C@_08DNIHDIBM@Inuitive@			; `string'
PUBLIC	??_C@_0BP@IOJCEKJ@ENERMAX?5TECHNOLOGY?5CORPORATION@ ; `string'
PUBLIC	??_C@_0BG@KPGMCBHJ@Britelite?5Enterprises@	; `string'
PUBLIC	??_C@_0BJ@PBJGGOPP@Tecvox?5Connectivity?0?5LLC@	; `string'
PUBLIC	??_C@_0BC@MCIOINLF@Power?5Probe?0?5Inc?4@	; `string'
PUBLIC	??_C@_0M@PLMBFEFA@Miselu?5Inc?4@		; `string'
PUBLIC	??_C@_0O@KKEBBLNP@Wilocity?5Ltd?4@		; `string'
PUBLIC	??_C@_0CK@IDFAGKLM@FingerQ?5Macao?5Commercial?5Offsho@ ; `string'
PUBLIC	??_C@_0N@GMINFFHN@Nitero?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BC@CHFHJJHL@Xacti?5Corporation@		; `string'
PUBLIC	??_C@_0BA@JMLEHFBM@Printrbot?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BB@HFHEPOBE@COMOTA?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0CE@MAEFHCII@Shenzhen?5Zowee?5Technology?5Co?4?0?5@ ; `string'
PUBLIC	??_C@_0CE@JDKPEMPD@Imaging?5Solutions?5Group?5of?5NY?0?5@ ; `string'
PUBLIC	??_C@_0BE@FECCLEDH@Williams?5Sound?0?5LLC@	; `string'
PUBLIC	??_C@_0BK@CMDOPKDP@HashFast?5Technologies?5LLC@	; `string'
PUBLIC	??_C@_0BC@DPKKEBHA@Krypton?5Solutions@		; `string'
PUBLIC	??_C@_0CO@CKMMCADD@Shenzhen?5DTEC?5Electronic?5Techno@ ; `string'
PUBLIC	??_C@_05HMOEOKL@DUALO@				; `string'
PUBLIC	??_C@_0DG@JPDEBJJP@Singeen?5Electronics?5Technologie@ ; `string'
PUBLIC	??_C@_0BK@NLOPDBDL@SHIGA?5MEC?5Company?5Limited@ ; `string'
PUBLIC	??_C@_0BL@ENHANOON@ADPlaus?5Technology?5Limited@ ; `string'
PUBLIC	??_C@_0O@OGFEGMLJ@Choy?8s?5Import@		; `string'
PUBLIC	??_C@_0BD@FMJCOJDA@Unwired?5Technology@		; `string'
PUBLIC	??_C@_0BD@NGPFIJGG@WINTOUCH?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BE@HIFLHKGA@MESTEC?5Technologies@	; `string'
PUBLIC	??_C@_0CG@NHGMKJBI@Union?5Electric?5Plug?5?$CG?5Connector@ ; `string'
PUBLIC	??_C@_0BH@BMMLIJOO@Tekinvest?5Holding?5Ltd?4@	; `string'
PUBLIC	??_C@_0O@KBLAAA@The?5Eye?5Tribe@		; `string'
PUBLIC	??_C@_0DH@DOJBOOAF@Dongguan?5Haitai?5Precision?5Elect@ ; `string'
PUBLIC	??_C@_0M@HIPFEPEC@Canova?5Tech@			; `string'
PUBLIC	??_C@_0CI@BLMGKMKN@Shenzhen?5Carbetter?5Technology?5C@ ; `string'
PUBLIC	??_C@_0BJ@PABKADHE@PN?5Devices?5Int?8l?5Limited@ ; `string'
PUBLIC	??_C@_0DA@MGMHGHJM@Gowin?5Technology?5International?5@ ; `string'
PUBLIC	??_C@_0P@ONPNMHGL@X?4O?4Ware?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BF@DABAPGE@TOPTICA?5Photonics?5AG@	; `string'
PUBLIC	??_C@_0CP@PHPIBLMN@IMBEL?5?9?5Industria?5de?5Material?5B@ ; `string'
PUBLIC	??_C@_0O@MCBAPFNP@Silicon?5Works@		; `string'
PUBLIC	??_C@_0L@LIDEGHFG@Canopy?5Co?4@			; `string'
PUBLIC	??_C@_06OCAFANDG@TazTag@			; `string'
PUBLIC	??_C@_0CH@IOJGIKGH@Shenzhen?5Jiali?5Asia?5Industry?5Co@ ; `string'
PUBLIC	??_C@_0CD@CCJOOIOC@HANRICO?5ANFU?5ELECTRONICS?5CO?4?0?5L@ ; `string'
PUBLIC	??_C@_0L@JMLDMEEO@Molex?5Inc?4@			; `string'
PUBLIC	??_C@_0BK@BGJHIBOH@Fujitsu?5Component?5Limited@	; `string'
PUBLIC	??_C@_0BH@PDGAJDKJ@Advanced?5Micro?5Devices@	; `string'
PUBLIC	??_C@_0BL@KCFEHCNK@Lexmark?5International?5Inc?4@ ; `string'
PUBLIC	??_C@_0BI@LOPMEJIG@Alps?5Electric?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BC@NEDOGEDE@Texas?5Instruments@		; `string'
PUBLIC	??_C@_0CB@JOFOMFLH@Silicon?5Integrated?5Systems?5Corp@ ; `string'
PUBLIC	??_C@_0BC@CIDHCDNI@KYE?5Systems?5Corp?4@	; `string'
PUBLIC	??_C@_0BK@EAFCJGLH@Renesas?5Electronics?5Corp?4@ ; `string'
PUBLIC	??_C@_0BG@EOBPLLNH@Microsoft?5Corporation@	; `string'
PUBLIC	??_C@_0BD@CABKABLN@Primax?5Electronics@		; `string'
PUBLIC	??_C@_05CFGIIEPJ@EATON@				; `string'
PUBLIC	??_C@_0BO@JJGMGNMK@Wieson?5Technologies?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BE@JEFPHDAK@American?5Megatrends@	; `string'
PUBLIC	??_C@_0O@NMJDEFAN@Logitech?5Inc?4@		; `string'
PUBLIC	??_C@_0BE@FBFHEDN@Semtech?5Corporation@		; `string'
PUBLIC	??_C@_0BA@JMLOFGEB@LSI?5Corporation@		; `string'
PUBLIC	??_C@_0BC@JKCENOI@Plantronics?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BE@OKFLBHJF@Kyocera?5Corporation@	; `string'
PUBLIC	??_C@_0BD@KBJBCOHP@STMicroelectronics@		; `string'
PUBLIC	??_C@_0BC@OEHDDJBP@Foxconn?5?1?5Hon?5Hai@	; `string'
PUBLIC	??_C@_0O@KONCBIDB@ITE?5Tech?5Inc?4@		; `string'
PUBLIC	??_C@_0BM@FKEBEEJL@Samsung?5Semiconductor?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BD@LBNNEMMM@Yamaha?5Corporation@		; `string'
PUBLIC	??_C@_0O@EDCNNFOI@Hitachi?0?5Ltd?4@		; `string'
PUBLIC	??_C@_09OEADKIBB@Visioneer@			; `string'
PUBLIC	??_C@_0L@GLDEECEB@Canon?5Inc?4@			; `string'
PUBLIC	??_C@_0BC@GNNADKEG@Nikon?5Corporation@		; `string'
PUBLIC	??_C@_0BC@HJPMHLJH@Pan?5International@		; `string'
PUBLIC	??_C@_0BG@FGCLJBBL@Cypress?5Semiconductor@	; `string'
PUBLIC	??_C@_0P@POFNKNIM@ROHM?5Co?4?0?5Ltd?4@		; `string'
PUBLIC	??_C@_0BJ@IBBFBLCL@Compal?5Electronics?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BC@LODEJCJJ@Seiko?5Epson?5Corp?4@	; `string'
PUBLIC	??_C@_0BG@NAOBNEME@I?9O?5Data?5Device?0?5Inc?4@	; `string'
PUBLIC	??_C@_0N@MFGIPGKK@Fujitsu?5Ltd?4@		; `string'
PUBLIC	??_C@_0BF@DGJHAIHG@FUJIFILM?5Corporation@	; `string'
PUBLIC	??_C@_0M@CIDIGMJE@ST?9Ericsson@			; `string'
PUBLIC	??_C@_0BA@BIJNEFLL@Mentor?5Graphics@		; `string'
PUBLIC	??_C@_0BK@GLLPJAAH@Microchip?5Technology?5Inc?4@ ; `string'
PUBLIC	??_C@_0BL@BJMPMCDF@Holtek?5Semiconductor?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BG@HPBJICLA@Panasonic?5Corporation@	; `string'
PUBLIC	??_C@_0BC@NGIIFMHF@Sharp?5Corporation@		; `string'
PUBLIC	??_C@_0BB@LFOEADKM@Exar?5Corporation@		; `string'
PUBLIC	??_C@_0BE@OGMMMEDN@Identive?5Group?5Inc?4@	; `string'
PUBLIC	??_C@_0BO@CGAOADOO@Samsung?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BO@EFCPDDGG@Tokyo?5Electron?5Device?5Limited@ ; `string'
PUBLIC	??_C@_0BO@DEPAFADD@Chicony?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BI@JIJDPPMO@Newnex?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0BJ@LIIOOGBH@Brother?5Industries?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0M@LAOEDIBA@PFU?5Limited@			; `string'
PUBLIC	??_C@_0N@HPKDLJPE@Fujikura?1DDK@		; `string'
PUBLIC	??_C@_0L@IBNCPFMK@Acer?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BE@OMIFCFDP@Hosiden?5Corporation@	; `string'
PUBLIC	??_C@_0BL@EOOICECH@Belkin?5International?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0CG@MHMGALMF@Longwell?5Electronics?1Longwell?5C@ ; `string'
PUBLIC	??_C@_0BI@IEJECICL@Star?5Micronics?5Co?4?0?5LTD@ ; `string'
PUBLIC	??_C@_0BK@CJECLAIC@American?5Power?5Conversion@	; `string'
PUBLIC	??_C@_0CH@IKHGDMKC@Taiwan?5Semiconductor?5Manufactur@ ; `string'
PUBLIC	??_C@_0BP@MPHIFDML@ACON?0?5Advanced?9Connectek?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BF@OEIMDHJB@PLX?5Technology?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BH@OKBFFENA@Wacom?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0P@JMAENH@Synopsys?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BB@FOPBDEC@Sony?5Corporation@		; `string'
PUBLIC	??_C@_0BF@BLKLAKEJ@Fuji?5Xerox?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BM@FGPDBDMF@ATEN?5International?5Co?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BN@LLCBPJLE@Cadence?5Design?5Systems?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BA@PCAMLHGM@WACOM?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BB@OEOLOEBO@EIZO?5Corporation@		; `string'
PUBLIC	??_C@_0BB@LBOBFJIK@Elecom?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BH@BPNCPPJL@Conexant?5Systems?0?5Inc?4@	; `string'
PUBLIC	??_C@_0CC@JDHIHHMP@BAFO?1Quality?5Computer?5Accessori@ ; `string'
PUBLIC	??_C@_0P@DLENFJNK@Y?9E?5Data?0?5Inc?4@		; `string'
PUBLIC	??_C@_08DBEKGGBP@AVM?5GmbH@			; `string'
PUBLIC	??_C@_0BD@CDPILELF@Roland?5Corporation@		; `string'
PUBLIC	??_C@_0BE@PNCFOBBM@RATOC?5Systems?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BD@CKEFINHN@Alcor?5Micro?0?5Corp?4@	; `string'
PUBLIC	??_C@_0BC@LGOLJEOJ@OMRON?5Corporation@		; `string'
PUBLIC	??_C@_05EENIFCCI@LaCie@				; `string'
PUBLIC	??_C@_0BO@PALNNPFJ@OmniVision?5Technologies?0?5Inc?4@ ; `string'
PUBLIC	??_C@_05EBJDGKGA@Apple@				; `string'
PUBLIC	??_C@_0BH@BEKADALE@Y?4C?4?5Cable?5U?4S?4A?4?0?5Inc@ ; `string'
PUBLIC	??_C@_0DH@GPJFFKGK@Tyco?5Electronics?5Corp?4?0?5a?5TE?5Co@ ; `string'
PUBLIC	??_C@_0CA@ILGCAFHO@Kawasaki?5Microelectronics?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0O@JJANANCF@Qualcomm?0?5Inc@		; `string'
PUBLIC	??_C@_0CP@IMDHJGED@Foxlink?1Cheng?5Uei?5Precision?5Ind@ ; `string'
PUBLIC	??_C@_0BD@DNOMCPDN@Ricoh?5Company?5Ltd?4@	; `string'
PUBLIC	??_C@_0BM@OADDMKLB@Microtek?5International?5Inc?4@ ; `string'
PUBLIC	??_C@_0BE@JPKFBBCH@Symbol?5Technologies@	; `string'
PUBLIC	??_C@_0BE@CKIEML@Genesys?5Logic?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BI@KBGKOOGJ@Fuji?5Electric?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BI@NBAANMIA@Unixtar?5Technology?5Inc?4@	; `string'
PUBLIC	??_C@_0O@FPONFABH@Datalogic?5ADC@		; `string'
PUBLIC	??_C@_0BD@PJDPEADK@LeCroy?5Corporation@		; `string'
PUBLIC	??_C@_0BP@HAMNADII@Novatek?5Microelectronics?5Corp?4@ ; `string'
PUBLIC	??_C@_0BH@LJAJLGJE@SMK?5Manufacturing?5Inc?4@	; `string'
PUBLIC	??_C@_0CE@IBGJKEKA@Joinsoon?5Electronics?5Mfg?4?5Co?4?0?5@ ; `string'
PUBLIC	??_C@_0CD@BNDJFIFN@TransAct?5Technologies?5Incorpora@ ; `string'
PUBLIC	??_C@_0BH@OFHNPHHH@Seiko?5Instruments?5Inc?4@	; `string'
PUBLIC	??_C@_0BE@EBACAFBC@JPC?1MAIN?5SUPER?5Inc?4@	; `string'
PUBLIC	??_C@_0P@GAMNDPPF@Chrontel?0?5Inc?4@		; `string'
PUBLIC	??_C@_0CH@PMGKCBAF@Analog?5Devices?0?5Inc?4?5Developmen@ ; `string'
PUBLIC	??_C@_0BL@EBDNAMPI@Ji?9Haw?5Industrial?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0BC@HBOMJHJG@Suyin?5Corporation@		; `string'
PUBLIC	??_C@_0BP@BBNBDGIM@Space?5Shuttle?5Hi?9Tech?5Co?4?0Ltd?4@ ; `string'
PUBLIC	??_C@_0BL@JPOIGLAH@Glory?5Mark?5Electronic?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@HLMOOHDB@Tekcon?5Electronics?5Corp?4@	; `string'
PUBLIC	??_C@_0BE@DBNMJIBL@Sigma?5Designs?0?5Inc?4@	; `string'
PUBLIC	??_C@_0DD@MJJJJEAM@Good?5Way?5Technology?5Co?4?0?5Ltd?4?5?$CG@ ; `string'
PUBLIC	??_C@_0CA@PAFBBAIH@TSAY?9E?5?$CIBVI?$CJ?5International?5Inc?4@ ; `string'
PUBLIC	??_C@_0BJ@PKNBNCAJ@Hamamatsu?5Photonics?5K?4K?4@ ; `string'
PUBLIC	??_C@_0BJ@BPDLABPC@Total?5Technologies?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BK@PDKHMLGO@Prolific?5Technology?0?5Inc?4@ ; `string'
PUBLIC	??_C@_09JOKCKELG@Dell?5Inc?4@			; `string'
PUBLIC	??_C@_0BM@LFPCEBHN@Golden?5Bridge?5Electech?5Inc?4@ ; `string'
PUBLIC	??_C@_0BA@EMAGANPI@Tektronix?0?5Inc?4@		; `string'
PUBLIC	??_C@_0CC@NHGJCBNO@Greatland?5Electronics?5Taiwan?5Lt@ ; `string'
PUBLIC	??_C@_0P@DFEICALO@Testronic?5Labs@		; `string'
PUBLIC	??_C@_0BD@MFHNCDAI@Pixela?5Corporation@		; `string'
PUBLIC	??_C@_0BF@KBMIOCIB@Oki?5Data?5Corporation@	; `string'
PUBLIC	??_C@_0BC@PBNHDNIB@Leoco?5Corporation@		; `string'
PUBLIC	??_C@_0BJ@IAMJELKE@Bizlink?5Technology?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0L@IGNPDHHH@SIIG?0?5Inc?4@		; `string'
PUBLIC	??_C@_0P@OJHCGLE@Synaptics?5Inc?4@		; `string'
PUBLIC	??_C@_0CA@FPPDHAGC@Mitsubishi?5Electric?5Corporation@ ; `string'
PUBLIC	??_C@_0BM@BIPBCEJB@Heisei?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CA@MKILJNBK@Oki?5Electric?5Industry?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BM@JIAGMEHO@Comoss?5Electronic?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BP@JCFMJDGG@Magic?5Control?5Technology?5Corp?4@ ; `string'
PUBLIC	??_C@_0O@NNOCEOFA@Imation?5Corp?4@		; `string'
PUBLIC	??_C@_0BA@IFGJOCOG@Sunix?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BL@PJBMJABB@Lorom?5Industrial?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BK@PCICHEDF@Cyber?5Power?5Systems?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0CD@HFGLNKOO@Jess?9Link?5Products?5Co?4?0?5Ltd?4?5?$CIJ@ ; `string'
PUBLIC	??_C@_0BA@FCBANMAL@HID?5Global?5GmbH@		; `string'
PUBLIC	??_C@_0BI@OBNCJIEM@Fairchild?5Semiconductor@	; `string'
PUBLIC	??_C@_0BE@KACIGGGG@SanDisk?5Corporation@	; `string'
PUBLIC	??_C@_0CB@LGBOFDFN@Copartner?5Technology?5Corporatio@ ; `string'
PUBLIC	??_C@_0BL@MPFKAMGD@National?5Technical?5Systems@ ; `string'
PUBLIC	??_C@_0O@OCMFCBHB@Plustek?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BE@NJLEDFOB@OLYMPUS?5CORPORATION@	; `string'
PUBLIC	??_C@_0BH@MGBHEDBN@TIME?5Interconnect?5Ltd?4@	; `string'
PUBLIC	??_C@_0BN@EGFACLDP@AVerMedia?5Technologies?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BL@FNDINGLK@Carry?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@JKHOIPCI@Casio?5Computer?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@ODMCNPPD@Arasan?5Chip?5Systems?5Inc?4@ ; `string'
PUBLIC	??_C@_0CA@BNLONGOH@David?5Electronics?5Company?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BE@OPFGKFFJ@Century?5Corporation@	; `string'
PUBLIC	??_C@_0BO@CAINGGKC@Evermuch?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CB@POAJBKGF@Action?5Star?5Enterprise?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0O@COHJMHME@Wipro?5Limited@		; `string'
PUBLIC	??_C@_0BB@CEKEIHLM@MEC?5IMEX?5INC?1HPT@		; `string'
PUBLIC	??_C@_0BA@EMBEKEAB@Lauterbach?5GmbH@		; `string'
PUBLIC	??_C@_0BP@PNBHHOAN@Icron?5Technologies?5Corporation@ ; `string'
PUBLIC	??_C@_0BH@CFIMBAIC@RadioShack?5Corporation@	; `string'
PUBLIC	??_C@_0BO@JNLBBKDI@TAI?5TWUN?5ENTERPRISE?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0M@BEPEDALH@Spyrus?5Inc?4@		; `string'
PUBLIC	??_C@_0BE@PMKDDGDC@Pioneer?5Corporation@	; `string'
PUBLIC	??_C@_0L@NMFIDNE@Gemalto?5SA@			; `string'
PUBLIC	??_C@_0BJ@DEEADHEC@FARADAY?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0BF@DGGIOLK@Audio?9Technica?5Corp?4@	; `string'
PUBLIC	??_C@_0BO@BNPBHCJB@Silicon?5Motion?0?5Inc?4?5?9?5Taiwan@ ; `string'
PUBLIC	??_C@_0BF@OCKCLCDJ@Garmin?5International@	; `string'
PUBLIC	??_C@_0BE@JMAMIBAH@Toshiba?5Corporation@	; `string'
PUBLIC	??_C@_0BF@FDMCHING@Pixart?5Imaging?0?5Inc?4@	; `string'
PUBLIC	??_C@_0M@DPPDGGNF@Plextor?5LLC@			; `string'
PUBLIC	??_C@_0BG@PLHGNMC@J?4S?4T?4?5Mfg?4?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BM@LKMMOGNE@Kingston?5Technology?5Company@ ; `string'
PUBLIC	??_C@_06HLMMPIBG@NVIDIA@			; `string'
PUBLIC	??_C@_0BL@KLPBIJLK@Agilent?5Technologies?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BH@DIONPOBP@Medialogic?5Corporation@	; `string'
PUBLIC	??_C@_0O@LKCCNLNO@Polycom?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BH@NHOGNCFH@Contech?5Research?0?5Inc?4@	; `string'
PUBLIC	??_C@_0CA@NGELPCKK@Lin?5Shiung?5Enterprise?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BF@PGLGBHIA@Intersil?5Corporation@	; `string'
PUBLIC	??_C@_0BN@OHPOFJEM@Japan?5Cash?5Machine?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BC@JHLIIJEE@NISCA?5Corporation@		; `string'
PUBLIC	??_C@_0BE@OJFDPOOK@Workbit?5Corporation@	; `string'
PUBLIC	??_C@_0CD@HNEJNPKP@Electronics?5Testing?5Center?0?5Tai@ ; `string'
PUBLIC	??_C@_0BG@LAHNEDCJ@A?9FOUR?5TECH?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_06NEOADGIL@Altera@			; `string'
PUBLIC	??_C@_0BN@HOMOCJPC@Cambridge?5Silicon?5Radio?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BB@HPCCBBBB@HOYA?5Corporation@		; `string'
PUBLIC	??_C@_0BF@EKKNDOHK@Physio?9Control?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BK@IKEGAKKP@Hirose?5Electric?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BD@LHJHCFAG@COMPUTEX?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BN@FBNECLJJ@Mimaki?5Engineering?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0P@KBOGHGP@Broadcom?5Corp?4@		; `string'
PUBLIC	??_C@_0BG@IJFMHNNO@Green?5House?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0CP@BLIFGEAH@Japan?5Aviation?5Electronics?5Indu@ ; `string'
PUBLIC	??_C@_0BF@BPGMFHBM@Young?5Chang?5Co?4?5Ltd?4@	; `string'
PUBLIC	??_C@_0BM@KFMMGOHA@Wincor?5Nixdorf?5GmbH?5?$CG?5Co?5KG@ ; `string'
PUBLIC	??_C@_0BO@IKBKKFPF@Rohde?5?$CG?5Schwarz?5GmbH?5?$CG?5Co?4?5KG@ ; `string'
PUBLIC	??_C@_0CC@EIBHCLN@SANYO?5Semiconductor?5Company?5Mic@ ; `string'
PUBLIC	??_C@_0BE@HMAJKJ@Vimicro?5Corporation@		; `string'
PUBLIC	??_C@_0BC@MFIELINC@Allion?5Labs?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BG@HEOGBEPO@ASUSTek?5Computer?5Inc?4@	; `string'
PUBLIC	??_C@_0BO@KKOFHFLP@Yokogawa?5Electric?5Corporation@ ; `string'
PUBLIC	??_C@_0BP@IGDJFEE@Pan?9Asia?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@MJIIIHDL@Musical?5Electronics?5Ltd?4@	; `string'
PUBLIC	??_C@_0BN@IGCLCEEO@Sinbon?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BK@DICOBJHO@Maxim?5Integrated?5Products@	; `string'
PUBLIC	??_C@_0BN@DBGBIANO@ASIX?5Electronics?5Corporation@ ; `string'
PUBLIC	??_C@_0BP@JGDEFBDO@Murata?5Manufacturing?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BH@PKPGHPEE@Seagate?5Technology?5LLC@	; `string'
PUBLIC	??_C@_0BM@OODBLDMG@Realtek?5Semiconductor?5Corp?4@ ; `string'
PUBLIC	??_C@_0M@PBGCMNLB@Ericsson?5AB@			; `string'
PUBLIC	??_C@_0BI@GAPKJOJF@Elka?5International?5Ltd?4@	; `string'
PUBLIC	??_C@_0BG@BDCJOHPC@Taiyo?5Yuden?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_08EDJBOCE@Aeroflex@			; `string'
PUBLIC	??_C@_0BL@IIBBHDLP@Sonix?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CA@KMAKLJKD@Dong?5Guan?5Shinko?5Wire?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BH@FHGKBINA@Chant?5Sincere?5Co?4?0?5Ltd@	; `string'
PUBLIC	??_C@_0BN@KANEMGNF@Whanam?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BN@PNHCHLDH@Solid?5State?5System?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BN@KPNGPOOH@Honda?5Tsushin?5Kogyo?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0BD@PCKEPBKO@Motorola?5Solutions@		; `string'
PUBLIC	??_C@_0BO@DKFGFGHA@Singatron?5Enterprise?5Co?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BM@NGPEIKDH@emsys?5Embedded?5Systems?5GmbH@ ; `string'
PUBLIC	??_C@_0BC@ECMAKMHG@Intel?5Corporation@		; `string'
PUBLIC	??_C@_0L@OACAMJJG@Z?9Com?5INC?4@		; `string'
PUBLIC	??_C@_0BM@OOCFEMN@e?9CONN?5ELECTRONIC?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0BE@KPNEJJKA@ENE?5Technology?5Inc?4@	; `string'
PUBLIC	??_C@_0N@IDKBGBCG@NALTEC?0?5Inc?4@		; `string'
PUBLIC	??_C@_0P@MAHCGCHE@NF?5Corporation@		; `string'
PUBLIC	??_C@_0BD@KEPOILEK@Grape?5Systems?5Inc?4@	; `string'
PUBLIC	??_C@_0BF@GHDJEHFK@Volex?5?$CIAsia?$CJ?5Pte?5Ltd@ ; `string'
PUBLIC	??_C@_0CH@DILBGHLF@MEILU?5ELECTRONICS?5?$CISHENZHEN?$CJ?5CO@ ; `string'
PUBLIC	??_C@_0BH@JNDMIFOJ@Hirakawa?5Hewtech?5Corp?4@	; `string'
PUBLIC	??_C@_0CF@DEKDBPDL@Taiwan?5Line?5Tek?5Electronic?5Co?4?0@ ; `string'
PUBLIC	??_C@_0BI@BKFMOADO@Dolby?5Laboratories?5Inc?4@	; `string'
PUBLIC	??_C@_0BJ@ICKBMN@C?9MEDIA?5ELECTRONICS?5INC?4@	; `string'
PUBLIC	??_C@_0CB@CBEHKKIA@Sure?9Fire?5Electrical?5Corporatio@ ; `string'
PUBLIC	??_C@_0N@BBFDLJEL@IOGEAR?0?5Inc?4@		; `string'
PUBLIC	??_C@_0CD@LDGCJJON@Micro?9Star?5International?5Co?4?0?5L@ ; `string'
PUBLIC	??_C@_0BN@MEJNGPFO@Contek?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CH@HKHHADBM@Power?5Quotient?5International?5Co@ ; `string'
PUBLIC	??_C@_0BH@JAOPMIJP@Custom?5Engineering?5SPA@	; `string'
PUBLIC	??_C@_0BO@MECAJMAF@Liou?5Yuane?5International?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CB@BNIAIBOP@Smart?5Modular?5Technologies?0?5Inc@ ; `string'
PUBLIC	??_C@_0DB@OJLHPIE@Shenzhen?5Bao?5Hing?5Electric?5Wire@ ; `string'
PUBLIC	??_C@_0BN@DKLMDFEK@Neltron?5Industrial?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BN@PNJNPPHF@Megawin?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BP@FIEIALAE@Hsi?9Chin?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0O@DBHJNIK@MediaTek?5Inc?4@		; `string'
PUBLIC	??_C@_03PPOOIEPP@CRU@				; `string'
PUBLIC	??_C@_0BC@PLHJNEDE@ADTEC?5CORPORATION@		; `string'
PUBLIC	??_C@_0BF@LFNPLID@Ours?5Technology?5Inc?4@	; `string'
PUBLIC	??_C@_0BJ@FFOINCNP@Y?9S?5ELECTRONIC?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0BJ@EEJFEJAC@Sweetray?5Industrial?5Ltd?4@	; `string'
PUBLIC	??_C@_0BC@NLMJJEGP@Axell?5Corporation@		; `string'
PUBLIC	??_C@_0BO@HGLIFDP@InnoVISION?5Multimedia?5Limited@ ; `string'
PUBLIC	??_C@_0BN@LAJGACMM@TaiSol?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BP@OLFMJOLO@Sunrich?5Technology?5?$CIH?4K?4?$CJ?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CE@LHKAEIDJ@CSL?5Wire?5?$CG?5Plug?5?$CIShen?5Zhen?$CJ?5Com@ ; `string'
PUBLIC	??_C@_0BJ@BFCEICOB@Funai?5Electric?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BF@HHKPOBJN@Good?5Man?5Corporation@	; `string'
PUBLIC	??_C@_0CA@JKBEBDIB@YFC?9BonEagle?5Electric?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@KJGCCIGG@Nien?9Yi?5Industrial?5Corp?4@ ; `string'
PUBLIC	??_C@_0BL@PCHAGLHO@WORLDWIDE?5CABLE?5OPTO?5CORP?4@ ; `string'
PUBLIC	??_C@_0CA@JJBCDJBC@Taiyo?5Cable?5?$CIDongguan?$CJ?5Co?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CJ@GLJCMOOM@Kawai?5Musical?5Instruments?5Mfg?4?5@ ; `string'
PUBLIC	??_C@_0DE@KCDILGEE@GuangZhou?5Chief?5Tech?5Electronic@ ; `string'
PUBLIC	??_C@_0N@CHAEBCC@UQUEST?0?5LTD?4@		; `string'
PUBLIC	??_C@_0BD@KEDKNNLF@Yazaki?5Corporation@		; `string'
PUBLIC	??_C@_0BD@NPCAKEK@CviLux?5Corporation@		; `string'
PUBLIC	??_C@_0BL@OGPLHBON@Sony?5Mobile?5Communications@ ; `string'
PUBLIC	??_C@_0CJ@MNOHKIGC@CHI?5SHING?5COMPUTER?5ACCESSORIES?5@ ; `string'
PUBLIC	??_C@_0BB@FNNKEBO@Speed?5Tech?5Corp?4@		; `string'
PUBLIC	??_C@_0BE@PPCAGGEP@LG?5Electronics?5Inc?4@	; `string'
PUBLIC	??_C@_0BC@KLMPEDJE@Newly?5Corporation@		; `string'
PUBLIC	??_C@_0CB@MAFJOCHL@WENZHOU?5YIHUA?5CONNECTOR?5CO?4?0LTD@ ; `string'
PUBLIC	??_C@_0BL@DIDNCHDM@Targus?5Group?5International@ ; `string'
PUBLIC	??_C@_0BB@MCAPDOMI@ON?5Semiconductor@		; `string'
PUBLIC	??_C@_0CD@OEFJDFLG@Western?5Digital?5Technologies?0?5I@ ; `string'
PUBLIC	??_C@_0DF@EJNCJCJN@Freeway?5Electronic?5Wire?5?$CG?5Cable@ ; `string'
PUBLIC	??_C@_0BH@GGINDOFM@CANON?5ELECTRONICS?5INC?4@	; `string'
PUBLIC	??_C@_0BC@JLIOEOBP@PANTECH?5CO?4?0?5LTD?4@	; `string'
PUBLIC	??_C@_0BP@HEECLKMJ@Grand?9tek?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BC@MMEHCLPH@Robert?5Bosch?5GmbH@		; `string'
PUBLIC	??_C@_0BA@JBGEKCBJ@Lotes?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0N@MADBCNBC@Cables?5To?5Go@		; `string'
PUBLIC	??_C@_0DB@OABIDDLN@Universal?5Global?5Scientific?5Ind@ ; `string'
PUBLIC	??_C@_0BL@GMIJPDAF@Princeton?5Technology?5Corp?4@ ; `string'
PUBLIC	??_C@_0BL@BEPCHFBK@Silicon?5Laboratories?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0L@BEMBIFEP@Kycon?5Inc?4@			; `string'
PUBLIC	??_C@_0CA@BFJDJKMK@Actions?5Semiconductor?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_09GOLPFLPD@Moxa?5Inc?4@			; `string'
PUBLIC	??_C@_0DF@NDHMOMGK@Golden?5Bright?5?$CISichuan?$CJ?5Electro@ ; `string'
PUBLIC	??_C@_0BK@DEMMBJPB@VSO?5ELECTRONICS?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0CO@HLACDLIC@Master?5Hill?5Electric?5Wire?5and?5C@ ; `string'
PUBLIC	??_C@_0BG@JFAAFJPO@Tenx?5Technology?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BP@NKCLDENL@Alpha?5Imaging?5Technology?5Corp?4@ ; `string'
PUBLIC	??_C@_0CB@BGNNABKD@Sheng?5Yih?5Technologies?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0BF@FDIEEFFD@Sierra?5Wireless?5Inc?4@	; `string'
PUBLIC	??_C@_0CG@JCFADKIE@DONG?5GUAN?5JALINK?5ELECTRONICES?5C@ ; `string'
PUBLIC	??_C@_0BH@LNLMLHPJ@GlobalMedia?5Group?0?5LLC@	; `string'
PUBLIC	??_C@_0BH@HFAICOFB@ATECH?5FLASH?5TECHNOLOGY@	; `string'
PUBLIC	??_C@_0BO@MNCEAPFD@SKYCABLE?5ENTERPRISE?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0BI@KKGDFIOD@NYKO?5Technologies?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BL@FCGNNKPJ@ADATA?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BI@BANJHMOB@Aristocrat?5Technologies@	; `string'
PUBLIC	??_C@_0M@HPCCHOFJ@Bel?5Stewart@			; `string'
PUBLIC	??_C@_0BM@FDHCJPEM@MARVELL?5SEMICONDUCTOR?0?5INC?4@ ; `string'
PUBLIC	??_C@_0BC@CDINJBKA@RISO?5KAGAKU?5CORP?4@	; `string'
PUBLIC	??_C@_0BO@JGPGOHBM@Honey?5Bee?5?$CIHong?5Kong?$CJ?5Limited@ ; `string'
PUBLIC	??_C@_0CP@OPCIAOPO@Zhejiang?5Xinya?5Electronic?5Techn@ ; `string'
PUBLIC	??_C@_0BP@JPNNFCKE@LINE?5TECH?5INDUSTRIAL?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0BN@DKNOJINI@Better?5Holdings?5?$CIHK?$CJ?5Limited@ ; `string'
PUBLIC	??_C@_0BF@FPEFMCEM@Konica?5Minolta?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BP@ODBMNHOP@Katsuragawa?5Electric?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0M@IPAHGEJP@Swissbit?5AG@			; `string'
PUBLIC	??_C@_0BM@DKMEKHIM@Pericom?5Semiconductor?5Corp?4@ ; `string'
PUBLIC	??_C@_0CG@BGIJPEKA@JyeTai?5Precision?5Industrial?5Co?4@ ; `string'
PUBLIC	??_C@_0BN@BNPLLCII@AzureWave?5Technologies?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0O@EADKLFFK@ALEREON?0?5INC?4@		; `string'
PUBLIC	??_C@_0BD@MJPGJJIB@Initio?5Corporation@		; `string'
PUBLIC	??_C@_0BJ@PODMPDKE@Phison?5Electronics?5Corp?4@	; `string'
PUBLIC	??_C@_0BA@EBAJJPHC@Telechips?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BN@KECIKNAF@ABILITY?5ENTERPRISE?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0BM@KIAEGNEO@Sensor?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BA@EJBEDMD@DSP?5Group?0?5Ltd?4@		; `string'
PUBLIC	??_C@_0N@JLOFKNJM@EVATRONIX?5SA@		; `string'
PUBLIC	??_C@_0BH@BDFMJCOJ@Panstrong?5Company?5Ltd?4@	; `string'
PUBLIC	??_C@_0BA@GIDLPKMM@CTK?5Corporation@		; `string'
PUBLIC	??_C@_0BF@POKLDLPA@ATP?5Electronics?5Inc?4@	; `string'
PUBLIC	??_C@_0BC@LNFIEHCE@StarTech?4com?5Ltd?4@	; `string'
PUBLIC	??_C@_0BN@OBOFFJMJ@MOAI?5ELECTRONICS?5CORPORATION@ ; `string'
PUBLIC	??_C@_07HKBKGGAL@Ellisys@			; `string'
PUBLIC	??_C@_0BE@MEIKBKHJ@Skymedi?5Corporation@	; `string'
PUBLIC	??_C@_0BP@NFMNNPJJ@VeriSilicon?5Holdings?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@NNBEAIKI@JMicron?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0CF@KFFNHPKK@HLDS?5?$CIHitachi?9LG?5Data?5Storage?0?5@ ; `string'
PUBLIC	??_C@_0BN@PJAMMHJM@Phihong?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BG@FDFFBPKH@PNY?5Technologies?5Inc?4@	; `string'
PUBLIC	??_C@_0CI@PJGLCGBH@Rapid?5Conn?0?5Connect?5County?5Hold@ ; `string'
PUBLIC	??_C@_0BF@KCLHJFIN@D?5?$CG?5M?5Holdings?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BM@MLLCLJKN@Sunf?5Pu?5Technology?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0BM@PJFBNPPK@ALLTOP?5TECHNOLOGY?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0BN@MGGPMLNL@Palconn?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CE@PGJPGLLG@Kunshan?5Guoji?5Electronics?5Co?4?0?5@ ; `string'
PUBLIC	??_C@_0BO@KPCEMMAE@Freescale?5Semiconductor?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0CL@HBACFJJO@Shen?5Zhen?5Teamspower?5Electronic@ ; `string'
PUBLIC	??_C@_0BO@HKNGFKOP@Apexone?5Microelectronics?5Inc?4@ ; `string'
PUBLIC	??_C@_0BO@FIJNAGLJ@Seong?5Ji?5Industrial?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_06DGDFLKMM@Samtec@			; `string'
PUBLIC	??_C@_0N@GNFMIBKN@Soft?5DB?5Inc?4@		; `string'
PUBLIC	??_C@_0BO@CCKIBDCK@HongLin?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0M@OMFDOLIG@Total?5Phase@			; `string'
PUBLIC	??_C@_0CI@LPNLCPKP@Shenzhen?5Zhengerya?5Technology?5C@ ; `string'
PUBLIC	??_C@_0CK@GHEMOGNO@Dongguan?5ChingLung?5Wire?5?$CG?5Cable@ ; `string'
PUBLIC	??_C@_0BH@EKGKEMKL@silex?5technology?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BL@MBCLBNK@CANON?5IMAGING?5SYSTEMS?5INC?4@ ; `string'
PUBLIC	??_C@_0BC@LFEKPOAD@Roche?5Diagnostics@		; `string'
PUBLIC	??_C@_0BF@BACBMICM@MQP?5Electronics?5Ltd?4@	; `string'
PUBLIC	??_C@_0BI@EFCFBFPB@ASMedia?5Technology?5Inc?4@	; `string'
PUBLIC	??_C@_0BE@LLHADAIP@UD?5electronic?5corp?4@	; `string'
PUBLIC	??_C@_0CC@KBPLCNPO@Shenzhen?5Alex?5Connector?5Co?4?0?5Lt@ ; `string'
PUBLIC	??_C@_0BN@MGLGHCII@System?5Level?5Solutions?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BP@PDCKJENN@Spreadtrum?5Communications?5Inc?4@ ; `string'
PUBLIC	??_C@_0CH@GLPFKNO@ShenZhen?5Litkconn?5Technology?5Co@ ; `string'
PUBLIC	??_C@_0DI@DPFEGAEM@Dongguan?5Yangming?5Precision?5of?5@ ; `string'
PUBLIC	??_C@_0CA@FKGCAAGK@Hip?5Hing?5Cable?5?$CG?5Plug?5Mfy?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BG@PLILAAEO@DisplayLink?5?$CIUK?$CJ?5Ltd?4@ ; `string'
PUBLIC	??_C@_06EOFPOMJG@Lenovo@			; `string'
PUBLIC	??_C@_0L@IGMLMAAK@K?4K?4?5Rocky@		; `string'
PUBLIC	??_C@_0CF@KAKIFJIN@Dongguan?5YuQiu?5Electronics?5Co?4?0@ ; `string'
PUBLIC	??_C@_0BO@DPMJHMBK@Gwo?5Jinn?5Industries?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BF@MMEONNIC@Galaxy?5Far?5East?5Corp@	; `string'
PUBLIC	??_C@_0BC@HBKKPCPF@Linkiss?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0M@INPJKDFM@Google?5Inc?4@		; `string'
PUBLIC	??_C@_0CF@DABKNPLD@Fitilink?5Integrated?5Technology?0@ ; `string'
PUBLIC	??_C@_0BJ@FNMFPLIK@Nordic?5Semiconductor?5ASA@	; `string'
PUBLIC	??_C@_0CF@NLNPHLHC@Shenzhen?5Xianhe?5Technology?5Co?4?0@ ; `string'
PUBLIC	??_C@_0CJ@FJMLIAEB@Ningbo?5Broad?5Telecommunication?5@ ; `string'
PUBLIC	??_C@_0BB@PCAKKDFD@Irisguard?5UK?5Ltd@		; `string'
PUBLIC	??_C@_06CHAGPIBB@Lab126@			; `string'
PUBLIC	??_C@_0BB@PPNLBENA@BIOS?5Corporation@		; `string'
PUBLIC	??_C@_0BI@EPIBIIDM@Nuconn?5Technology?5Corp?4@	; `string'
PUBLIC	??_C@_0BC@LGPAAFDD@Dexxon?5Data?5Media@		; `string'
PUBLIC	??_C@_0CJ@HAKCLNCA@Industrial?5Technology?5Research?5@ ; `string'
PUBLIC	??_C@_0CJ@GONBANIC@Pak?5Heng?5Technology?5?$CIShenzhen?$CJ?5@ ; `string'
PUBLIC	??_C@_0BE@PPEHNAPN@Best?5Buy?5China?5Ltd?4@	; `string'
PUBLIC	??_C@_0BE@BIONMJOM@USB?9IF?5non?9workshop@	; `string'
PUBLIC	??_C@_0BI@PPNCKFLJ@Amphenol?5East?5Asia?5Ltd?4@	; `string'
PUBLIC	??_C@_0O@OPAGGINC@Astec?5America@		; `string'
PUBLIC	??_C@_0BL@EKBPAFBH@Topdisk?5Technology?5Limited@ ; `string'
PUBLIC	??_C@_0BJ@KAKHDDLA@TERMINUS?5TECHNOLOGY?5INC?4@	; `string'
PUBLIC	??_C@_0BF@IBCFPAGK@Global?5Unichip?5Corp?4@	; `string'
PUBLIC	??_C@_0BG@IOFCBCHK@Bayer?5Health?5Care?5LLC@	; `string'
PUBLIC	??_C@_0BN@GMHKDAOP@Proconn?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BH@HJFKHBGL@Simula?5Technology?5Inc?4@	; `string'
PUBLIC	??_C@_0BA@KBMPMKDN@SGS?5Taiwan?5Ltd?4@		; `string'
PUBLIC	??_C@_0BA@GPGHJPOJ@Leica?5Camera?5AG@		; `string'
PUBLIC	??_C@_0CJ@FEGEHHGG@Asia?5Tai?5Technology?5?$CIDongguan?$CJ?5@ ; `string'
PUBLIC	??_C@_0CJ@EENODCNA@Johnson?5Component?5?$CG?5Equipments?5@ ; `string'
PUBLIC	??_C@_0M@BNPJBJHO@Salcomp?5Plc@			; `string'
PUBLIC	??_C@_0CI@ENEIOO@High?5Top?5Precision?5Electronic?5C@ ; `string'
PUBLIC	??_C@_0CD@KCEJLGKF@SHEN?5ZHEN?5REX?5TECHNOLOGY?5CO?4?0?5L@ ; `string'
PUBLIC	??_C@_0BI@BAHHJBOM@Octekconn?5Incorporation@	; `string'
PUBLIC	??_C@_0BD@DPNOIOGL@ViXS?5Systems?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BN@ODKKJGBD@Plastron?5Precision?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0DA@EOOOBNLE@The?5Hong?5Kong?5Standards?5and?5Tes@ ; `string'
PUBLIC	??_C@_0CI@GNFBMNPP@ShenMing?5Electron?5?$CIDong?5Guan?$CJ?5C@ ; `string'
PUBLIC	??_C@_0O@IPLHGMF@Amlogic?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BO@IHCMPCEB@Shenzhen?5Yuanchuan?5Electronic@ ; `string'
PUBLIC	??_C@_0P@JGHIOJAI@Ford?5Motor?5Co?4@		; `string'
PUBLIC	??_C@_0CA@FCJOHAEE@Contac?5Cable?5Industrial?5Limited@ ; `string'
PUBLIC	??_C@_0CD@HFOIMFJ@Sunplus?5Innovation?5Technology?5I@ ; `string'
PUBLIC	??_C@_0CH@KIMIGBPK@Orient?5Semiconductor?5Electronic@ ; `string'
PUBLIC	??_C@_0BO@IHAPHGGJ@Lanterra?5Industrial?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CC@GEFGPOJP@SHENZHEN?5DNS?5INDUSTRIES?5CO?4?0?5LT@ ; `string'
PUBLIC	??_C@_08PDBDCLGF@LS?5Mtron@			; `string'
PUBLIC	??_C@_0BD@DCHINJIL@NONIN?5MEDICAL?5INC?4@	; `string'
PUBLIC	??_C@_0DA@PPLCBMMB@Philips?5?$CG?5Lite?9ON?5Digital?5Solut@ ; `string'
PUBLIC	??_C@_0BJ@GEGPHPDK@ALPINE?5ELECTRONICS?0?5INC?4@ ; `string'
PUBLIC	??_C@_0P@BICMBKIN@LEGRAND?5FRANCE@		; `string'
PUBLIC	??_C@_0BL@CHCFPHFA@Aces?5Electronics?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BB@EIGDHDFJ@OPEX?5CORPORATION@		; `string'
PUBLIC	??_C@_0DA@BKKOBFJG@Telecommunications?5Technology?5A@ ; `string'
PUBLIC	??_C@_0CL@OJLMBANN@NINGBO?5HENTEK?5DRAGON?5ELECTRONIC@ ; `string'
PUBLIC	??_C@_0BH@GIIFDIFG@Johnson?5Controls?0?5Inc?4@	; `string'
PUBLIC	??_C@_0CA@GDMPIAIK@Horng?5Tong?5Enterprise?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BD@JJOGFDJ@DRAGON?5JOY?5LIMITED@		; `string'
PUBLIC	??_C@_0BC@KIFIHBOP@Qisda?5Corporation@		; `string'
PUBLIC	??_C@_0BF@EEHMEIJP@Pegatron?5Corporation@	; `string'
PUBLIC	??_C@_0BC@HAMMCKPN@Fresco?5Logic?5Inc?4@	; `string'
PUBLIC	??_C@_0BL@MMCBELAO@QIXING?5INDUSTRIAL?5?$CIHK?$CJ?5CO?4@ ; `string'
PUBLIC	??_C@_0BL@NKBOOFNF@Walta?5Electronic?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0DE@IMGLKMI@Yueqing?5Changling?5Electronic?5In@ ; `string'
PUBLIC	??_C@_0CH@EKHHMHEC@Shenzhen?5My?9Power?5Technology?5Co@ ; `string'
PUBLIC	??_C@_0DD@IDOJMHNI@NINGBO?5SHUNSHENG?5COMMUNICATION?5@ ; `string'
PUBLIC	??_C@_0BK@FNCNBIIF@Parade?5Technologies?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0CE@EGHGGAJG@Document?5Capture?5Technologies?0?5@ ; `string'
PUBLIC	??_C@_0BH@NMLKIBDM@GDA?5Technologies?0?5Inc?4@	; `string'
PUBLIC	??_C@_0CD@BBLGIHKL@Actions?5Microelectronics?5Co?4?0?5L@ ; `string'
PUBLIC	??_C@_0CK@INFLCDIC@Telecommunication?5Metrology?5Cen@ ; `string'
PUBLIC	??_C@_0CO@IHINPAOL@SHEN?5ZHEN?5FORMAN?5PRECISION?5INDU@ ; `string'
PUBLIC	??_C@_0BJ@FEMBFAJG@Point?5Grey?5Research?5Inc?4@ ; `string'
PUBLIC	??_C@_0BD@LIIMMKIN@KOBIAN?5CANADA?5INC?4@	; `string'
PUBLIC	??_C@_0CB@BKOLJNN@HUNG?5TA?5H?4T?4ENTERPRISE?5CO?4?0?5LTD@ ; `string'
PUBLIC	??_C@_0BH@JAAJJDAF@Etron?5Technology?0?5Inc?4@	; `string'
PUBLIC	??_C@_0BO@OPAJPFGF@COMLINK?5ELECTRONICS?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0CH@JAHIBMAB@HIBEST?5Electronic?5?$CIDongGuan?$CJ?5Co@ ; `string'
PUBLIC	??_C@_0BG@EHNBGDFF@Other?5World?5Computing@	; `string'
PUBLIC	??_C@_0BL@BINCEHIC@Concraft?5Holding?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CH@IFPLLPOK@WIN?5WIN?5PRECISION?5INDUSTRIAL?5CO@ ; `string'
PUBLIC	??_C@_0L@PIBOCPGJ@Gefen?5Inc?4@			; `string'
PUBLIC	??_C@_0BK@LCFIOKDG@AIRTIES?5WIRELESS?5NETWORKS@	; `string'
PUBLIC	??_C@_0CD@IALAEKLI@JIANGXI?5SHIP?5ELECTRONICS?5CO?4?0?5L@ ; `string'
PUBLIC	??_C@_0CG@LKIHKKAD@Cal?9Comp?5Electronics?5?$CG?5Communic@ ; `string'
PUBLIC	??_C@_0CE@MEDMJIF@Chang?5Yang?5Electronics?5Company?5@ ; `string'
PUBLIC	??_C@_0BD@GGCBPHPK@Innostor?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0CI@NHHBKKBH@Dongguan?5Goldconn?5Electronics?5C@ ; `string'
PUBLIC	??_C@_0CC@LPIGCLDE@Morning?5Star?5Industrial?5Co?4?0?5Lt@ ; `string'
PUBLIC	??_C@_0CB@EHEKJNGP@Owl?5Computing?5Technologies?0?5Inc@ ; `string'
PUBLIC	??_C@_0BE@KDFCKAEG@Unify?5GmbH?5?$CG?5Co?4?5KG@	; `string'
PUBLIC	??_C@_0BD@GMPBKEIC@NXP?5Semiconductors@		; `string'
PUBLIC	??_C@_0CA@CAPPIABK@NIAN?5YEONG?5ENTERPRISE?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0DB@KONADFN@Changzhou?5Wujin?5BEST?5Electronic@ ; `string'
PUBLIC	??_C@_0BD@BJBLIGAM@D?9Link?5Corporation@	; `string'
PUBLIC	??_C@_0CI@GOBPPKNF@Belkin?5Electronic?5?$CIChangzhou?$CJ?5C@ ; `string'
PUBLIC	??_C@_0CF@DHGBCKNB@Freeport?5Resources?5Enterprises?5@ ; `string'
PUBLIC	??_C@_0BG@PIIFGLBL@DETAS?5TECHNOLOGY?5LTD?4@	; `string'
PUBLIC	??_C@_0CI@FBHBCILE@Shenzhen?5Tronixin?5Electronics?5C@ ; `string'
PUBLIC	??_C@_0CJ@OEPJLPBL@Unicorn?5Electronics?5Components?5@ ; `string'
PUBLIC	??_C@_0BK@DJALMDKA@CESI?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0N@JJLIGBFN@Luxshare?9ICT@		; `string'
PUBLIC	??_C@_0BA@CFCNDLPN@CE?5LINK?5LIMITED@		; `string'
PUBLIC	??_C@_0BP@FNHFFJPK@Microconn?5Electronic?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CF@MCDKIGNK@Shenzhen?5CARVE?5Electronics?5Co?4?0@ ; `string'
PUBLIC	??_C@_0BK@EIBNNPGD@FENGHUA?5KINGSUN?5CO?4?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0DE@EMOPPBDG@Sumitomo?5Electric?5Ind?4?0?5Ltd?4?0?5O@ ; `string'
PUBLIC	??_C@_0N@DAENHNHN@XIMEA?5s?4r?4o?4@		; `string'
PUBLIC	??_C@_0P@GBIKBMAL@VIA?5Labs?0?5Inc?4@		; `string'
PUBLIC	??_C@_0CF@GAGJPPB@Shenzhen?5Linoya?5Electronic?5Co?4?0@ ; `string'
PUBLIC	??_C@_0CK@LALHIFNG@Dong?5Guan?5City?5Wanhong?5Electric@ ; `string'
PUBLIC	??_C@_0CJ@CNOJBLBI@Amphenol?5AssembleTech?5?$CIXiamen?$CJ?5@ ; `string'
PUBLIC	??_C@_0BD@LDDEGFID@Y?5Soft?5Corporation@	; `string'
PUBLIC	??_C@_0BI@FBCKNBLM@JVC?5KENWOOD?5Corporation@	; `string'
PUBLIC	??_C@_0BM@BKHGEKPK@Transcend?5Information?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BF@BAPBHHHN@TMC?1Allion?5Test?5Labs@	; `string'
PUBLIC	??_C@_08EPBIMIG@CalDigit@			; `string'
PUBLIC	??_C@_0DB@LAFBKCJH@Dongguan?5Teconn?5Electronics?5Tec@ ; `string'
PUBLIC	??_C@_0BP@PBMDMJMJ@Netcom?5Technology?5?$CIHK?$CJ?5Limited@ ; `string'
PUBLIC	??_C@_0BP@FAJGPKNC@Compupack?5Technology?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CG@OHNMOHEM@Wuerth?9Elektronik?5eiSos?5GmbH?5?$CG?5@ ; `string'
PUBLIC	??_C@_0BE@BEMCGCHG@Shin?5Shin?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0CB@CHMCCAAM@3eYamaichi?5Electronics?5Co?4?0?5Ltd@ ; `string'
PUBLIC	??_C@_0CG@NEPAELKJ@Wiretek?5International?5Investmen@ ; `string'
PUBLIC	??_C@_0BG@FFGBANPN@Plugable?5Technologies@	; `string'
PUBLIC	??_C@_0BN@DJPOBBOH@T?9CONN?5PRECISION?5CORPORATION@ ; `string'
PUBLIC	??_C@_0BD@PEIOBOIA@Granite?5River?5Labs@	; `string'
PUBLIC	??_C@_0BG@JFNFEMAF@Digital?5EMC?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0CO@GPGEJOEG@Sun?5Fair?5Electric?5Wire?5?$CG?5Cable?5@ ; `string'
PUBLIC	??_C@_0CH@JIBHMNOD@Hotron?5Precision?5Electronic?5Ind@ ; `string'
PUBLIC	??_C@_0BN@LAOLKJDB@Trigence?5Semiconductor?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BH@JCNJIDNH@Motorola?5Mobility?5Inc?4@	; `string'
PUBLIC	??_C@_0CI@KOHELOKO@Karming?5Electronic?5?$CIShenzhen?$CJ?5C@ ; `string'
PUBLIC	??_C@_0O@PFEHLJC@Phase?5One?5A?1S@		; `string'
PUBLIC	??_C@_0O@LJFFELIC@Miltope?5Corp?4@		; `string'
PUBLIC	??_C@_0CF@DNEMFNPO@Kunshan?5Jiahua?5Electronics?5Co?4?0@ ; `string'
PUBLIC	??_C@_0BL@CONNOJEO@Avery?5Design?5Systems?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BI@LPLOPAA@Huawei?5Device?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_09GCGEMCFF@Tensorcom@			; `string'
PUBLIC	??_C@_0O@DNELPEDJ@Zenverge?5Inc?4@		; `string'
PUBLIC	??_C@_0CM@MLMJGOMM@Shenzhen?5Autone?9Tronic?5Technolo@ ; `string'
PUBLIC	??_C@_0BP@GJOKBILK@KangXiang?5Electronic?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BP@CBFBKCKO@IXT?5Systems?5International?5Ltd?4@ ; `string'
PUBLIC	??_C@_0BJ@OHNJGPJN@Marunix?5Electron?5Limited@	; `string'
PUBLIC	??_C@_0CH@GCMJJPNA@DONGGUAN?5LICHENG?5ELECTRONICS?5CO@ ; `string'
PUBLIC	??_C@_0CF@CFJNEAJP@BitifEye?5Digital?5Test?5Solutions@ ; `string'
PUBLIC	??_C@_0CN@EJBOGONI@ChuangYi?5Hardware?5Precision?5Mou@ ; `string'
PUBLIC	??_C@_0O@BNIKCMOM@INSIDE?5Secure@		; `string'
PUBLIC	??_C@_0BH@KJMMFBKI@Incasolution?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_0BM@GMFHMCEF@The?5Silanna?5Group?5Pty?4?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CK@PEDMBLOK@Dongguan?5City?5Qirui?5Electronics@ ; `string'
PUBLIC	??_C@_0BC@MIHCGNOI@Minebea?5Co?4?0?5Ltd?4@	; `string'
PUBLIC	??_C@_06HHAPBGEJ@BAANTO@			; `string'
PUBLIC	??_C@_0BL@LPJGBHEM@Velosti?5Technology?5Limited@ ; `string'
PUBLIC	??_C@_0BC@FEINIIOM@Anton?1Bauer?0?5Inc?4@	; `string'
PUBLIC	??_C@_0CE@BAFKLNDB@WuJiang?5XinYa?5Electronics?5Co?4?0?5@ ; `string'
PUBLIC	??_C@_0BH@EHAGJFEE@Fullconn?5Industry?5Inc?4@	; `string'
PUBLIC	??_C@_0BK@CFHJHDDG@SYNCONN?5INTERCONNECT?5INC?4@ ; `string'
PUBLIC	??_C@_0CH@IDDOGDKP@Shenzhen?5Pangngai?5Industrial?5Co@ ; `string'
PUBLIC	??_C@_0CE@JOMBCIJH@Shenzhen?5Deren?5Electronic?5Co?4?0?5@ ; `string'
PUBLIC	??_C@_0M@NMCNEDLC@Lytro?0?5Inc?4@		; `string'
PUBLIC	??_C@_0BL@DEJKGIMK@Smith?5Micro?5Software?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0BO@ONHDIMLP@ZEN?5FACTORY?5GROUP?5?$CIASIA?$CJ?5LTD?4@ ; `string'
PUBLIC	??_C@_0BO@KGBBCJH@Chain?9In?5Electronic?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CN@BNJPCKEF@TOP?5Exactitude?5Industry?5?$CIShenZh@ ; `string'
PUBLIC	??_C@_0CP@FBCGPDBL@ShenZhen?5Hogend?5Precision?5Techn@ ; `string'
PUBLIC	??_C@_0BD@PLHJJNHE@Norel?5Systems?5Ltd?4@	; `string'
PUBLIC	??_C@_0O@KMBODLJH@ASSA?5ABLOY?5AB@		; `string'
PUBLIC	??_C@_0CG@NMMKCBIB@DongGuan?5LongTao?5Electronic?5Co?4@ ; `string'
PUBLIC	??_C@_0BI@MHBLLANG@Weida?5Hi?9Tech?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CI@CBMJJLAP@Dongguan?5Wisechamp?5Electronic?5C@ ; `string'
PUBLIC	??_C@_0BH@NLMAPGEN@Sequans?5Communications@	; `string'
PUBLIC	??_C@_0P@GGHEMJJH@ALGOLTEK?0?5INC?4@		; `string'
PUBLIC	??_C@_0CC@LNBMPCHG@Top?5Victory?5Investments?5Ltd?4?5?$CIH@ ; `string'
PUBLIC	??_C@_0CF@LHOCOHOF@DongGuan?5Elinke?5Industrial?5Co?4?0@ ; `string'
PUBLIC	??_C@_0BK@DKIKJOEB@Corning?5Cable?5Systems?5LLC@ ; `string'
PUBLIC	??_C@_0CI@EJBKCNKI@Zhe?5Jiang?5Huasheng?5Technology?5C@ ; `string'
PUBLIC	??_C@_0CG@OAMKINAC@Dongguan?5Jinyue?5Electronics?5Co?4@ ; `string'
PUBLIC	??_C@_0BM@BOLFLJP@RICOH?5IMAGING?5COMPANY?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0CC@GLDMKJH@DongGuan?5HYX?5Industrial?5Co?4?0?5Lt@ ; `string'
PUBLIC	??_C@_0BE@HOIKDMEJ@Advanced?5Silicon?5SA@	; `string'
PUBLIC	??_C@_0BJ@FPNGMFON@INTELLIGENT?5ENERGY?0?5LTD?4@ ; `string'
PUBLIC	??_C@_0O@KCHFFECA@EISST?5Limited@		; `string'
PUBLIC	??_C@_0CO@FNFDMCAN@JXT?5Precision?5Electronics?5Techn@ ; `string'
PUBLIC	??_C@_0CA@PHDNLNGC@Inno?5Audio?5?$CG?5Video?5?$CIHK?$CJ?5Limited@ ; `string'
PUBLIC	??_C@_0BO@PHCBCBDD@Electronics?5For?5Imaging?0?5Inc?4@ ; `string'
PUBLIC	??_C@_0DB@HNELJFDJ@Shenzhen?5Yuwenfa?5Electronic?5Tec@ ; `string'
PUBLIC	??_C@_0BB@LEBIHPBN@Innovative?5Logic@		; `string'
PUBLIC	??_C@_09BGJCNJFM@Basler?5AG@			; `string'
PUBLIC	??_C@_0CG@INIEIBBC@BESTMEDIA?5CD?9Recordable?5GmbH?5?$CG?5@ ; `string'
PUBLIC	??_C@_0BD@LIHAOBJB@UNIREX?5CORPORATION@		; `string'
PUBLIC	??_C@_0CF@IPDEOKJG@Zhejiang?5Senda?5Electronics?5Co?4?0@ ; `string'
PUBLIC	??_C@_0BF@BKLIFGG@Integral?5Memory?5Plc?4@	; `string'
PUBLIC	??_C@_0BG@BKPEFBBD@Broadway?5System?0?5Inc?4@	; `string'
PUBLIC	??_C@_0CJ@EHDKCLMM@Morning?5Star?5Digital?5Connector?5@ ; `string'
PUBLIC	??_C@_0BC@EBEJIPHO@MITACHI?5CO?4?0?5LTD?4@	; `string'
PUBLIC	??_C@_0BJ@FPADBEEC@Inhon?5Computer?5Co?4?0?5Ltd?4@ ; `string'
PUBLIC	??_C@_0CA@HMOFPNPP@HGST?0?5a?5Western?5Digital?5Company@ ; `string'
PUBLIC	??_C@_07NFANNNEC@UNKNOWN@			; `string'
PUBLIC	??_C@_0BF@GIOJHHEG@Win32_1394Controller@	; `string'
PUBLIC	??_C@_04FABLJDN@Name@				; `string'
PUBLIC	??_C@_0M@HHJKGII@PNPDeviceID@			; `string'
PUBLIC	??_C@_08JLPEJKOE@DeviceID@			; `string'
PUBLIC	??_C@_0N@BBNLMPJO@Manufacturer@			; `string'
PUBLIC	??_C@_0N@MFGCECDI@Availability@			; `string'
PUBLIC	??_C@_07OJKFJLLK@Caption@			; `string'
PUBLIC	??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@	; `string'
PUBLIC	??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@	; `string'
PUBLIC	??_C@_0M@OHKMKKDH@Description@			; `string'
PUBLIC	??_C@_0N@FJHLDHMG@ErrorCleared@			; `string'
PUBLIC	??_C@_0BB@KIDBLMK@ErrorDescription@		; `string'
PUBLIC	??_C@_0M@NBIJNNJJ@InstallDate@			; `string'
PUBLIC	??_C@_0O@NDKHIJAE@LastErrorCode@		; `string'
PUBLIC	??_C@_0BE@JDLAPHJE@MaxNumberControlled@		; `string'
PUBLIC	??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@	; `string'
PUBLIC	??_C@_0BJ@CFOPGMLH@PowerManagementSupported@	; `string'
PUBLIC	??_C@_0BC@JHPOAJCM@ProtocolSupported@		; `string'
PUBLIC	??_C@_06PGDKHFME@Status@			; `string'
PUBLIC	??_C@_0L@PKEHCAEI@StatusInfo@			; `string'
PUBLIC	??_C@_0BA@HADKHLAI@TimeOfLastReset@		; `string'
PUBLIC	??_C@_0BA@FKIDHCEN@Win32_BaseBoard@		; `string'
PUBLIC	??_C@_03PJHNOEGB@Tag@				; `string'
PUBLIC	??_C@_07HMDPOHHF@Product@			; `string'
PUBLIC	??_C@_05NFIJOKEG@Model@				; `string'
PUBLIC	??_C@_07NGFJPNPN@Version@			; `string'
PUBLIC	??_C@_0O@GLLHAKAI@ConfigOptions@		; `string'
PUBLIC	??_C@_05BOMFGPKE@Depth@				; `string'
PUBLIC	??_C@_06HCAKHJJK@Height@			; `string'
PUBLIC	??_C@_06ODJMJFLN@Weight@			; `string'
PUBLIC	??_C@_05IBAMDCFI@Width@				; `string'
PUBLIC	??_C@_0N@CCJNCHMP@HostingBoard@			; `string'
PUBLIC	??_C@_0N@FCOIALPI@HotSwappable@			; `string'
PUBLIC	??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@	; `string'
PUBLIC	??_C@_0L@MIOPIENN@PartNumber@			; `string'
PUBLIC	??_C@_09HKGEBMAI@PoweredOn@			; `string'
PUBLIC	??_C@_09DADBKOHO@Removable@			; `string'
PUBLIC	??_C@_0M@KLOLJEDG@Replaceable@			; `string'
PUBLIC	??_C@_0BI@NLNEBFOD@RequirementsDescription@	; `string'
PUBLIC	??_C@_0BG@KNNEFNEE@RequiresDaughterBoard@	; `string'
PUBLIC	??_C@_0N@FPJJBBNM@SerialNumber@			; `string'
PUBLIC	??_C@_03LMAAELJP@SKU@				; `string'
PUBLIC	??_C@_0L@NLNCHAIH@SlotLayout@			; `string'
PUBLIC	??_C@_0BE@DAJBDDHL@SpecialRequirements@		; `string'
PUBLIC	??_C@_0O@CLAKILND@Win32_Battery@		; `string'
PUBLIC	??_C@_0O@PKGMNGNM@BatteryStatus@		; `string'
PUBLIC	??_C@_0O@IKADLBCG@TimeOnBattery@		; `string'
PUBLIC	??_C@_0BB@HMDCOCCC@TimeToFullCharge@		; `string'
PUBLIC	??_C@_0BE@HNKJKBND@BatteryRechargeTime@		; `string'
PUBLIC	??_C@_09CAHFAGKL@Chemistry@			; `string'
PUBLIC	??_C@_0P@IFPGNGPN@DesignCapacity@		; `string'
PUBLIC	??_C@_0O@PBABLEFL@DesignVoltage@		; `string'
PUBLIC	??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining@	; `string'
PUBLIC	??_C@_0BB@NPKJIND@EstimatedRunTime@		; `string'
PUBLIC	??_C@_0BE@NEEKJBPN@ExpectedBatteryLife@		; `string'
PUBLIC	??_C@_0N@DDGBNILM@ExpectedLife@			; `string'
PUBLIC	??_C@_0BD@HADPLBCE@FullChargeCapacity@		; `string'
PUBLIC	??_C@_0BA@KENPOHHF@MaxRechargeTime@		; `string'
PUBLIC	??_C@_0BE@IIEJDIAD@SmartBatteryVersion@		; `string'
PUBLIC	??_C@_0L@JLLHHBAL@Win32_BIOS@			; `string'
PUBLIC	??_C@_0BE@DHLHFABD@BiosCharacteristics@		; `string'
PUBLIC	??_C@_0M@JNJNMLGA@BIOSVersion@			; `string'
PUBLIC	??_C@_0M@PIEABBJI@BuildNumber@			; `string'
PUBLIC	??_C@_07FOHBHJJA@CodeSet@			; `string'
PUBLIC	??_C@_0BA@LAFEEKJE@CurrentLanguage@		; `string'
PUBLIC	??_C@_0BD@IAKLNJOL@IdentificationCode@		; `string'
PUBLIC	??_C@_0BF@JGHHIKJK@InstallableLanguages@	; `string'
PUBLIC	??_C@_0BA@OPCNKLIC@ListOfLanguages@		; `string'
PUBLIC	??_C@_0O@LMGDODCH@OtherTargetOS@		; `string'
PUBLIC	??_C@_0M@PLCFCEDN@PrimaryBIOS@			; `string'
PUBLIC	??_C@_0M@FEKFCCJH@ReleaseDate@			; `string'
PUBLIC	??_C@_0BC@GDJFCIN@SMBIOSBIOSVersion@		; `string'
PUBLIC	??_C@_0BD@GHLLPFOK@SMBIOSMajorVersion@		; `string'
PUBLIC	??_C@_0BD@NBGOPAJG@SMBIOSMinorVersion@		; `string'
PUBLIC	??_C@_0O@BHMENNOL@SMBIOSPresent@		; `string'
PUBLIC	??_C@_0BC@MBHIKAHO@SoftwareElementID@		; `string'
PUBLIC	??_C@_0BF@GFDCFGAP@SoftwareElementState@	; `string'
PUBLIC	??_C@_09HPFDNOIF@Win32_Bus@			; `string'
PUBLIC	??_C@_06KNDINCOD@BusNum@			; `string'
PUBLIC	??_C@_07FFFMBEEK@BusType@			; `string'
PUBLIC	??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@		; `string'
PUBLIC	??_C@_05FHDOJGAA@Drive@				; `string'
PUBLIC	??_C@_0L@PEPMOJNO@VolumeName@			; `string'
PUBLIC	??_C@_0BD@KNELKJMD@VolumeSerialNumber@		; `string'
PUBLIC	??_C@_0N@FNJCOOAL@Capabilities@			; `string'
PUBLIC	??_C@_0BH@EPMKAGLN@CapabilityDescriptions@	; `string'
PUBLIC	??_C@_0BC@MBGAHHAB@CompressionMethod@		; `string'
PUBLIC	??_C@_0BB@GHOHONOE@DefaultBlockSize@		; `string'
PUBLIC	??_C@_0P@HKGKOHLF@DriveIntegrity@		; `string'
PUBLIC	??_C@_0BB@PNCBAHDK@ErrorMethodology@		; `string'
PUBLIC	??_C@_0BA@KMBBNBII@FileSystemFlags@		; `string'
PUBLIC	??_C@_0BC@JDDJOAMF@FileSystemFlagsEx@		; `string'
PUBLIC	??_C@_0N@HEPDBKFE@MaxBlockSize@			; `string'
PUBLIC	??_C@_0BH@GKGMNPDK@MaximumComponentLength@	; `string'
PUBLIC	??_C@_0N@HBNKJHPM@MaxMediaSize@			; `string'
PUBLIC	??_C@_0M@BKHKLNGH@MediaLoaded@			; `string'
PUBLIC	??_C@_09HPDNNFFF@MediaType@			; `string'
PUBLIC	??_C@_0BJ@FCFAAAMD@MfrAssignedRevisionLevel@	; `string'
PUBLIC	??_C@_0N@DELMGCCC@MinBlockSize@			; `string'
PUBLIC	??_C@_0O@IIJMNCFJ@NeedsCleaning@		; `string'
PUBLIC	??_C@_0BH@COPKOGMD@NumberOfMediaSupported@	; `string'
PUBLIC	??_C@_0O@MEKHAACN@RevisionLevel@		; `string'
PUBLIC	??_C@_07IMFLOLAO@SCSIBus@			; `string'
PUBLIC	??_C@_0BA@FGFDLPLK@SCSILogicalUnit@		; `string'
PUBLIC	??_C@_08IICBNDDA@SCSIPort@			; `string'
PUBLIC	??_C@_0N@BGGJIJCI@SCSITargetId@			; `string'
PUBLIC	??_C@_04EBKMHHBE@Size@				; `string'
PUBLIC	??_C@_0N@GFEIEMMN@TransferRate@			; `string'
PUBLIC	??_C@_0BB@ILOPCCAP@Win32_DMAChannel@		; `string'
PUBLIC	??_C@_04HOKNCALA@Port@				; `string'
PUBLIC	??_C@_0L@PGAIMACF@DMAChannel@			; `string'
PUBLIC	??_C@_0M@HJPEAMBM@AddressSize@			; `string'
PUBLIC	??_C@_09LDKFCLB@BurstMode@			; `string'
PUBLIC	??_C@_08IOOBKHAJ@ByteMode@			; `string'
PUBLIC	??_C@_0O@BPLPAGKN@ChannelTiming@		; `string'
PUBLIC	??_C@_0BA@HBAKOKJE@MaxTransferSize@		; `string'
PUBLIC	??_C@_0P@HFMGHLOP@TransferWidths@		; `string'
PUBLIC	??_C@_0M@MOIPDDOB@TypeCTiming@			; `string'
PUBLIC	??_C@_08HKOOHOAE@WordMode@			; `string'
PUBLIC	??_C@_0BA@DGOGJGDP@Win32_DriverVXD@		; `string'
PUBLIC	??_C@_07DFGIDBBA@Control@			; `string'
PUBLIC	??_C@_0BG@IOIHNNJK@DeviceDescriptorBlock@	; `string'
PUBLIC	??_C@_0BA@JOJBKDJN@LanguageEdition@		; `string'
PUBLIC	??_C@_06CGGMGNDK@PM_API@			; `string'
PUBLIC	??_C@_0BB@CCKMONLJ@ServiceTableSize@		; `string'
PUBLIC	??_C@_0BG@LEBBIDOP@TargetOperatingSystem@	; `string'
PUBLIC	??_C@_07JENHGIOM@V86_API@			; `string'
PUBLIC	??_C@_0BH@GBOCBJMM@Win32_FloppyController@	; `string'
PUBLIC	??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@		; `string'
PUBLIC	??_C@_0P@MCPBPNON@Win32_HeatPipe@		; `string'
PUBLIC	??_C@_0O@PBOKHICP@ActiveCooling@		; `string'
PUBLIC	??_C@_0BE@FMCMMJCA@Win32_IDEController@		; `string'
PUBLIC	??_C@_0BF@EEIPINHM@Win32_InfraredDevice@	; `string'
PUBLIC	??_C@_0BC@MGLAEOHD@Win32_IRQResource@		; `string'
PUBLIC	??_C@_08PPIOJEA@Hardware@			; `string'
PUBLIC	??_C@_09PKFILKGD@Shareable@			; `string'
PUBLIC	??_C@_0N@NCNNCPPP@TriggerLevel@			; `string'
PUBLIC	??_C@_0M@NKHMGHID@TriggerType@			; `string'
PUBLIC	??_C@_06BOOCMPNK@Vector@			; `string'
PUBLIC	??_C@_0P@IGJIBAJA@Win32_Keyboard@		; `string'
PUBLIC	??_C@_06KMHOJANB@Layout@			; `string'
PUBLIC	??_C@_0BF@DODFNOHG@NumberOfFunctionKeys@	; `string'
PUBLIC	??_C@_08EOCJLAAL@IsLocked@			; `string'
PUBLIC	??_C@_08FJIAHGMM@Password@			; `string'
PUBLIC	??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@	; `string'
PUBLIC	??_C@_0P@GCEIIPJN@PrimaryBusType@		; `string'
PUBLIC	??_C@_0P@EJGNFGBG@RevisionNumber@		; `string'
PUBLIC	??_C@_0BB@MKKJDBAN@SecondaryBusType@		; `string'
PUBLIC	??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@		; `string'
PUBLIC	??_C@_0L@PMICFDLL@DeviceType@			; `string'
PUBLIC	??_C@_07DOAOMMKG@Enabled@			; `string'
PUBLIC	??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@	; `string'
PUBLIC	??_C@_0BA@EHCOOLPP@Win32_PnPEntity@		; `string'
PUBLIC	??_C@_07LMLHFMEG@Service@			; `string'
PUBLIC	??_C@_09GPHNMGJN@ClassGuid@			; `string'
PUBLIC	??_C@_0N@EEHHOFBP@CompatibleID@			; `string'
PUBLIC	??_C@_0L@MCPBCGGP@HardwareID@			; `string'
PUBLIC	??_C@_0BF@MJMHBKMK@Win32_PointingDevice@	; `string'
PUBLIC	??_C@_0N@HMDMLBLH@PointingType@			; `string'
PUBLIC	??_C@_0BA@EHILAMBM@NumberOfButtons@		; `string'
PUBLIC	??_C@_0BA@PLLFIHNG@DeviceInterface@		; `string'
PUBLIC	??_C@_0N@OGCCLEJJ@HardwareType@			; `string'
PUBLIC	??_C@_0L@DEGCDBKP@Handedness@			; `string'
PUBLIC	??_C@_0BF@FLDPHBAC@DoubleSpeedThreshold@	; `string'
PUBLIC	??_C@_0M@LNGELFEC@InfFileName@			; `string'
PUBLIC	??_C@_0L@KHOEHLLF@InfSection@			; `string'
PUBLIC	??_C@_0BD@MJAHKLJJ@QuadSpeedThreshold@		; `string'
PUBLIC	??_C@_0L@KGPBCGJE@Resolution@			; `string'
PUBLIC	??_C@_0L@NEGJIGMA@SampleRate@			; `string'
PUBLIC	??_C@_05MKJLCFN@Synch@				; `string'
PUBLIC	??_C@_0BE@BFHBBNBL@Win32_PortConnector@		; `string'
PUBLIC	??_C@_0BM@OAEDMMAI@ExternalReferenceDesignator@	; `string'
PUBLIC	??_C@_0BM@JBGCGAG@InternalReferenceDesignator@	; `string'
PUBLIC	??_C@_08BOPEOHEK@PortType@			; `string'
PUBLIC	??_C@_0O@CPCPFFAH@ConnectorType@		; `string'
PUBLIC	??_C@_0BA@KNNOFNF@ConnectorPinout@		; `string'
PUBLIC	??_C@_0BD@JJNGNMBL@Win32_PortResource@		; `string'
PUBLIC	??_C@_05NNNCCOHC@Alias@				; `string'
PUBLIC	??_C@_0BE@HLKMDILE@Win32_PrinterDriver@		; `string'
PUBLIC	??_C@_0BA@PFCCEOEE@DefaultDataType@		; `string'
PUBLIC	??_C@_0L@EAJLGPDF@DriverPath@			; `string'
PUBLIC	??_C@_08CKKAOMLK@FilePath@			; `string'
PUBLIC	??_C@_0L@LKBOBDBI@ConfigFile@			; `string'
PUBLIC	??_C@_08JFJMIJHO@DataFile@			; `string'
PUBLIC	??_C@_0M@PJPGFADP@MonitorName@			; `string'
PUBLIC	??_C@_0BC@MLDLGMGB@SupportedPlatform@		; `string'
PUBLIC	??_C@_07JFPHJDHA@InfName@			; `string'
PUBLIC	??_C@_08GLFJHHAH@HelpFile@			; `string'
PUBLIC	??_C@_0P@NBBGILI@DependentFiles@		; `string'
PUBLIC	??_C@_06ENMIEFDD@OEMUrl@			; `string'
PUBLIC	??_C@_07LCDJNPHI@Started@			; `string'
PUBLIC	??_C@_09IAGOJBFI@StartMode@			; `string'
PUBLIC	??_C@_0BA@OJJOBJJP@Win32_Processor@		; `string'
PUBLIC	??_C@_0N@MDJPNJNL@Architecture@			; `string'
PUBLIC	??_C@_0O@FFCOPHIP@NumberOfCores@		; `string'
PUBLIC	??_C@_0O@MJOHKFKO@MaxClockSpeed@		; `string'
PUBLIC	??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors@	; `string'
PUBLIC	??_C@_06BOFMEHLD@Family@			; `string'
PUBLIC	??_C@_0M@DJKFFMLN@L2CacheSize@			; `string'
PUBLIC	??_C@_0N@NBPCHGPE@L2CacheSpeed@			; `string'
PUBLIC	??_C@_0M@PICLIDHN@L3CacheSize@			; `string'
PUBLIC	??_C@_0N@EKFHDKJL@L3CacheSpeed@			; `string'
PUBLIC	??_C@_0N@IPOPOCBB@AddressWidth@			; `string'
PUBLIC	??_C@_09OJECCCEO@CpuStatus@			; `string'
PUBLIC	??_C@_0BC@JFANJPME@CurrentClockSpeed@		; `string'
PUBLIC	??_C@_0P@IHAGOHLC@CurrentVoltage@		; `string'
PUBLIC	??_C@_09KNGBBIL@DataWidth@			; `string'
PUBLIC	??_C@_08JALCBBMK@ExtClock@			; `string'
PUBLIC	??_C@_05KOHFLOFG@Level@				; `string'
PUBLIC	??_C@_0P@HLLBIGKP@LoadPercentage@		; `string'
PUBLIC	??_C@_0BH@LLAHKBOJ@OtherFamilyDescription@	; `string'
PUBLIC	??_C@_0M@DHKOOBFD@ProcessorId@			; `string'
PUBLIC	??_C@_0O@DAODMABE@ProcessorType@		; `string'
PUBLIC	??_C@_08DNLDHPFP@Revision@			; `string'
PUBLIC	??_C@_04EBAMNOLK@Role@				; `string'
PUBLIC	??_C@_0BC@GCIFEBIL@SocketDesignation@		; `string'
PUBLIC	??_C@_08HPJGCEAH@Stepping@			; `string'
PUBLIC	??_C@_08HJBCPKNB@UniqueId@			; `string'
PUBLIC	??_C@_0O@KHACBBMN@UpgradeMethod@		; `string'
PUBLIC	??_C@_0M@DEJHGOJI@VoltageCaps@			; `string'
PUBLIC	??_C@_0BF@OGHHAMBD@Win32_SCSIController@	; `string'
PUBLIC	??_C@_0L@DJBCKAGE@DriverName@			; `string'
PUBLIC	??_C@_0BA@BJODOJJC@HardwareVersion@		; `string'
PUBLIC	??_C@_0BD@LPBNFPJD@ControllerTimeouts@		; `string'
PUBLIC	??_C@_09DJCHLIFB@DeviceMap@			; `string'
PUBLIC	??_C@_05FNNGFGLF@Index@				; `string'
PUBLIC	??_C@_0N@OLJPFNHL@MaxDataWidth@			; `string'
PUBLIC	??_C@_0BA@IDEAMGMB@MaxTransferRate@		; `string'
PUBLIC	??_C@_0BF@OGNJDJGP@ProtectionManagement@	; `string'
PUBLIC	??_C@_0BB@DLHLCIMJ@Win32_SerialPort@		; `string'
PUBLIC	??_C@_0M@BFAJGJNN@MaxBaudRate@			; `string'
PUBLIC	??_C@_0N@KFNBCBNP@ProviderType@			; `string'
PUBLIC	??_C@_06JCOMDNII@Binary@			; `string'
PUBLIC	??_C@_0BH@PKAPBGLB@MaximumInputBufferSize@	; `string'
PUBLIC	??_C@_0BI@EAKFLPF@MaximumOutputBufferSize@	; `string'
PUBLIC	??_C@_0BB@NCMHEECO@OSAutoDiscovered@		; `string'
PUBLIC	??_C@_0BB@CCEBCKAP@SettableBaudRate@		; `string'
PUBLIC	??_C@_0BB@BOCNMDDI@SettableDataBits@		; `string'
PUBLIC	??_C@_0BE@FMKJPGFK@SettableFlowControl@		; `string'
PUBLIC	??_C@_0P@MOHECAJ@SettableParity@		; `string'
PUBLIC	??_C@_0BE@NMPLPPIE@SettableParityCheck@		; `string'
PUBLIC	??_C@_0N@OBGEBGNG@SettableRLSD@			; `string'
PUBLIC	??_C@_0BB@EPIEMKMF@SettableStopBits@		; `string'
PUBLIC	??_C@_0BC@EEEMKCBH@Supports16BitMode@		; `string'
PUBLIC	??_C@_0P@GODDIGIP@SupportsDTRDSR@		; `string'
PUBLIC	??_C@_0BI@LJLLOLPH@SupportsElapsedTimeouts@	; `string'
PUBLIC	??_C@_0BE@JOEIKOLI@SupportsIntTimeouts@		; `string'
PUBLIC	??_C@_0BE@JCPAAGPO@SupportsParityCheck@		; `string'
PUBLIC	??_C@_0N@GBIJPBEE@SupportsRLSD@			; `string'
PUBLIC	??_C@_0P@NGNOBJLG@SupportsRTSCTS@		; `string'
PUBLIC	??_C@_0BK@GGENNCGN@SupportsSpecialCharacters@	; `string'
PUBLIC	??_C@_0BA@OPAGJFHI@SupportsXOnXOff@		; `string'
PUBLIC	??_C@_0BD@GDEAPHBI@SupportsXOnXOffSet@		; `string'
PUBLIC	??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@ ; `string'
PUBLIC	??_C@_08FCNNIBJG@BaudRate@			; `string'
PUBLIC	??_C@_0M@PAFDOFKP@BitsPerByte@			; `string'
PUBLIC	??_C@_06OKNHBMNM@Parity@			; `string'
PUBLIC	??_C@_08DPBIGBFM@StopBits@			; `string'
PUBLIC	??_C@_06OICOCAHF@IsBusy@			; `string'
PUBLIC	??_C@_0BG@DFLLPBBO@AbortReadWriteOnError@	; `string'
PUBLIC	??_C@_0BC@OGEDEEBA@BinaryModeEnabled@		; `string'
PUBLIC	??_C@_0BD@MCBMPIAJ@ContinueXMitOnXOff@		; `string'
PUBLIC	??_C@_0BC@BMKJGEMK@CTSOutflowControl@		; `string'
PUBLIC	??_C@_0BB@LNMOOKGE@DiscardNULLBytes@		; `string'
PUBLIC	??_C@_0BC@HDHNIDHE@DSROutflowControl@		; `string'
PUBLIC	??_C@_0P@FDLAEJMA@DSRSensitivity@		; `string'
PUBLIC	??_C@_0BD@HKACMHPL@DTRFlowControlType@		; `string'
PUBLIC	??_C@_0N@HDNBGKMG@EOFCharacter@			; `string'
PUBLIC	??_C@_0BG@HECEEKCN@ErrorReplaceCharacter@	; `string'
PUBLIC	??_C@_0BI@MDNCEDD@ErrorReplacementEnabled@	; `string'
PUBLIC	??_C@_0P@ELDMBJ@EventCharacter@			; `string'
PUBLIC	??_C@_0BD@KACACAPH@ParityCheckEnabled@		; `string'
PUBLIC	??_C@_0BD@HDDKDMKB@RTSFlowControlType@		; `string'
PUBLIC	??_C@_09CMMJGBDB@SettingID@			; `string'
PUBLIC	??_C@_0O@IABHIILA@XOffCharacter@		; `string'
PUBLIC	??_C@_0BC@PIOKAKHD@XOffXMitThreshold@		; `string'
PUBLIC	??_C@_0N@LMKFMCPA@XOnCharacter@			; `string'
PUBLIC	??_C@_0BB@OHGPOKOF@XOnXMitThreshold@		; `string'
PUBLIC	??_C@_0BF@FMELJHC@XOnXOffInFlowControl@		; `string'
PUBLIC	??_C@_0BG@LCMFOHKE@XOnXOffOutFlowControl@	; `string'
PUBLIC	??_C@_0BC@INJPMPPD@Win32_SoundDevice@		; `string'
PUBLIC	??_C@_0M@MNPNDAHP@ProductName@			; `string'
PUBLIC	??_C@_0O@GILLNKKD@MPU401Address@		; `string'
PUBLIC	??_C@_0O@GHJKPLAG@DMABufferSize@		; `string'
PUBLIC	??_C@_0BE@KNIHCNGM@Win32_USBController@		; `string'
PUBLIC	??_C@_0BG@IOBPPLKC@Win32_VideoController@	; `string'
PUBLIC	??_C@_0BE@FEOPMOOE@CurrentBitsPerPixel@		; `string'
PUBLIC	??_C@_0BM@OFHJCNEB@CurrentHorizontalResolution@	; `string'
PUBLIC	??_C@_0BK@LFIAOAGD@CurrentVerticalResolution@	; `string'
PUBLIC	??_C@_0BG@NCBMILGB@CurrentNumberOfColors@	; `string'
PUBLIC	??_C@_0BD@JKLPINND@CurrentRefreshRate@		; `string'
PUBLIC	??_C@_0BA@CDIHNLEF@CurrentScanMode@		; `string'
PUBLIC	??_C@_0BH@IKBJPLJ@CurrentNumberOfColumns@	; `string'
PUBLIC	??_C@_0BE@BKBIMFEG@CurrentNumberOfRows@		; `string'
PUBLIC	??_C@_0BC@GFHBBCIN@VideoArchitecture@		; `string'
PUBLIC	??_C@_0BA@COFLHODM@VideoMemoryType@		; `string'
PUBLIC	??_C@_09LIEAKBEG@VideoMode@			; `string'
PUBLIC	??_C@_0BF@MAGAOPPB@VideoModeDescription@	; `string'
PUBLIC	??_C@_0P@OMEGAAG@VideoProcessor@		; `string'
PUBLIC	??_C@_0BC@PEHKLIOA@ColorTableEntries@		; `string'
PUBLIC	??_C@_0BF@JCFFEIIM@NumberOfColorPlanes?$DL@	; `string'
PUBLIC	??_C@_0BD@DECAKEGH@NumberOfVideoPages@		; `string'
PUBLIC	??_C@_0BF@FKKNOPFN@SystemPaletteEntries@	; `string'
PUBLIC	??_C@_0BI@DFJMJFBI@AcceleratorCapabilities@	; `string'
PUBLIC	??_C@_0BF@LPCADEJI@AdapterCompatibility@	; `string'
PUBLIC	??_C@_0P@MPKKGADB@AdapterDACType@		; `string'
PUBLIC	??_C@_0L@CKHNOAKJ@AdapterRAM@			; `string'
PUBLIC	??_C@_0M@HMKFJKEG@InfFilename@			; `string'
PUBLIC	??_C@_0O@KKIKAADI@DriverVersion@		; `string'
PUBLIC	??_C@_0BD@HBMCPLLH@DeviceSpecificPens@		; `string'
PUBLIC	??_C@_0L@HJOBJMDE@DitherType@			; `string'
PUBLIC	??_C@_0L@GAFFCADK@DriverDate@			; `string'
PUBLIC	??_C@_09MBIABGHL@ICMIntent@			; `string'
PUBLIC	??_C@_09OGGCGCBA@ICMMethod@			; `string'
PUBLIC	??_C@_0BI@NCJGCGIA@InstalledDisplayDrivers@	; `string'
PUBLIC	??_C@_0BD@KFJBBNPN@MaxMemorySupported@		; `string'
PUBLIC	??_C@_0P@DHIEOPKP@MaxRefreshRate@		; `string'
PUBLIC	??_C@_0P@BADPIIJO@MinRefreshRate@		; `string'
PUBLIC	??_C@_0L@NCAJOFAD@Monochrome@			; `string'
PUBLIC	??_C@_0BN@FJFLBOEO@ReservedSystemPaletteEntries@ ; `string'
PUBLIC	??_C@_0BF@HGGDLIIF@SpecificationVersion@	; `string'
PUBLIC	??_C@_0BA@CJPFNKBD@Win32_DiskDrive@		; `string'
PUBLIC	??_C@_0L@BLANPANH@Partitions@			; `string'
PUBLIC	??_C@_09GDNFOKKF@Signature@			; `string'
PUBLIC	??_C@_0P@MMMIFHLL@BytesPerSector@		; `string'
PUBLIC	??_C@_0BB@HMBACBBL@FirmwareRevision@		; `string'
PUBLIC	??_C@_0O@IHENGMAG@InterfaceType@		; `string'
PUBLIC	??_C@_0BA@CCMKCJPC@SectorsPerTrack@		; `string'
PUBLIC	??_C@_0P@NEMACPGO@TotalCylinders@		; `string'
PUBLIC	??_C@_0L@PLGEACLG@TotalHeads@			; `string'
PUBLIC	??_C@_0N@BJMAPGKO@TotalSectors@			; `string'
PUBLIC	??_C@_0M@BHKEFGGG@TotalTracks@			; `string'
PUBLIC	??_C@_0BC@KOKBEBBE@TracksPerCylinder@		; `string'
PUBLIC	??_C@_0BE@GBMGFCLI@Win32_DiskPartition@		; `string'
PUBLIC	??_C@_04KOACHJEN@Type@				; `string'
PUBLIC	??_C@_08GBCOMNMP@Bootable@			; `string'
PUBLIC	??_C@_0O@GKABHDFN@BootPartition@		; `string'
PUBLIC	??_C@_0BB@GMPNKCND@PrimaryPartition@		; `string'
PUBLIC	??_C@_06IOEANFCI@Access@			; `string'
PUBLIC	??_C@_09JFLKFGKE@BlockSize@			; `string'
PUBLIC	??_C@_0P@PGINBNEO@NumberOfBlocks@		; `string'
PUBLIC	??_C@_0O@NMDEFEE@HiddenSectors@			; `string'
PUBLIC	??_C@_07ODOLMOGH@Purpose@			; `string'
PUBLIC	??_C@_0BB@CLPKNLNO@RewritePartition@		; `string'
PUBLIC	??_C@_0P@HEMAHOJD@StartingOffset@		; `string'
PUBLIC	??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@		; `string'
PUBLIC	??_C@_0BB@GANKFIKA@MediaDescription@		; `string'
PUBLIC	??_C@_0BC@FNAKMFAB@CreationClassName@		; `string'
PUBLIC	??_C@_08PINBMPEF@Capacity@			; `string'
PUBLIC	??_C@_0P@CNPPDDMA@WriteProtectOn@		; `string'
PUBLIC	??_C@_0N@NINPCONM@CleanerMedia@			; `string'
PUBLIC	??_C@_0BA@GLDDIFFN@Win32_TapeDrive@		; `string'
PUBLIC	??_C@_02HOGEDOAB@Id@				; `string'
PUBLIC	??_C@_0M@COKFBABJ@Compression@			; `string'
PUBLIC	??_C@_03NLPJKHLD@ECC@				; `string'
PUBLIC	??_C@_0BD@IDPNAMKG@EOTWarningZoneSize@		; `string'
PUBLIC	??_C@_0N@PNICBLFI@FeaturesHigh@			; `string'
PUBLIC	??_C@_0M@GCKGDCME@FeaturesLow@			; `string'
PUBLIC	??_C@_0BC@NKLHGLCM@MaxPartitionCount@		; `string'
PUBLIC	??_C@_07DDDGKLAD@Padding@			; `string'
PUBLIC	??_C@_0P@OCFCAPCK@ReportSetMarks@		; `string'
PUBLIC	??_C@_0BC@BKKBKJDE@Win32_CacheMemory@		; `string'
PUBLIC	??_C@_0BE@FGEPBFNL@AdditionalErrorData@		; `string'
PUBLIC	??_C@_0O@BJAAJMNJ@Associativity@		; `string'
PUBLIC	??_C@_0L@GKCEABFB@CacheSpeed@			; `string'
PUBLIC	??_C@_09LDLPEFB@CacheType@			; `string'
PUBLIC	??_C@_0N@FNMLGPI@MaxCacheSize@			; `string'
PUBLIC	??_C@_0BB@HJBOPHEK@CorrectableError@		; `string'
PUBLIC	??_C@_0M@JJECGOOK@CurrentSRAM@			; `string'
PUBLIC	??_C@_0O@DMEOEBEF@EndingAddress@		; `string'
PUBLIC	??_C@_0M@PJGEGKNG@ErrorAccess@			; `string'
PUBLIC	??_C@_0N@BEELHEFJ@ErrorAddress@			; `string'
PUBLIC	??_C@_0BB@OEAEPHLK@ErrorCorrectType@		; `string'
PUBLIC	??_C@_09GOCFECJA@ErrorData@			; `string'
PUBLIC	??_C@_0P@LPKOAMHJ@ErrorDataOrder@		; `string'
PUBLIC	??_C@_09EPPHMMOH@ErrorInfo@			; `string'
PUBLIC	??_C@_0BA@DBMDPLBE@ErrorResolution@		; `string'
PUBLIC	??_C@_09LMOKKAAG@ErrorTime@			; `string'
PUBLIC	??_C@_0BC@FEODMBII@ErrorTransferSize@		; `string'
PUBLIC	??_C@_0L@NIIIAJJG@FlushTimer@			; `string'
PUBLIC	??_C@_0O@BJDNNDOA@InstalledSize@		; `string'
PUBLIC	??_C@_08BFDFHGHF@LineSize@			; `string'
PUBLIC	??_C@_08KDOEBHGA@Location@			; `string'
PUBLIC	??_C@_0BG@GMMANAIM@OtherErrorDescription@	; `string'
PUBLIC	??_C@_0L@OICKBPFP@ReadPolicy@			; `string'
PUBLIC	??_C@_0BC@CACAEAGO@ReplacementPolicy@		; `string'
PUBLIC	??_C@_0BA@JKJCLFJA@StartingAddress@		; `string'
PUBLIC	??_C@_0O@LOONNFKJ@SupportedSRAM@		; `string'
PUBLIC	??_C@_0BD@EHELDMNK@SystemLevelAddress@		; `string'
PUBLIC	??_C@_0M@GMGLDKG@WritePolicy@			; `string'
PUBLIC	??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@	; `string'
PUBLIC	??_C@_0L@NKIIONIP@MemoryType@			; `string'
PUBLIC	??_C@_0BC@NBCNDILJ@Win32_MemoryArray@		; `string'
PUBLIC	??_C@_0BB@CCADGENH@ErrorGranularity@		; `string'
PUBLIC	??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@		; `string'
PUBLIC	??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@	; `string'
PUBLIC	??_C@_09ELEBPJGH@BankLabel@			; `string'
PUBLIC	??_C@_0O@DKGGAIKL@DeviceLocator@		; `string'
PUBLIC	??_C@_0L@JPOMKNPI@FormFactor@			; `string'
PUBLIC	??_C@_0BE@GAJMAAIE@InterleaveDataDepth@		; `string'
PUBLIC	??_C@_0BD@OOBFBMPB@InterleavePosition@		; `string'
PUBLIC	??_C@_0O@MJAFBIEI@PositionInRow@		; `string'
PUBLIC	??_C@_05HOIAGEJD@Speed@				; `string'
PUBLIC	??_C@_0L@EONKMHCB@TotalWidth@			; `string'
PUBLIC	??_C@_0L@NHBAOOAD@TypeDetail@			; `string'
PUBLIC	??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@	; `string'
PUBLIC	??_C@_0O@EOCLGIEK@MemoryDevices@		; `string'
PUBLIC	??_C@_0M@LPAFCHAO@MaxCapacity@			; `string'
PUBLIC	??_C@_0BG@BDKPEMKD@MemoryErrorCorrection@	; `string'
PUBLIC	??_C@_03GMFFJGJI@Use@				; `string'
PUBLIC	??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@		; `string'
PUBLIC	??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@	; `string'
PUBLIC	??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@	; `string'
PUBLIC	??_C@_0L@GEHHDFHH@SystemType@			; `string'
PUBLIC	??_C@_0BD@KEFEPCEP@NumberOfProcessors@		; `string'
PUBLIC	??_C@_08KAFEAHEM@UserName@			; `string'
PUBLIC	??_C@_0BE@BPKIAGEB@AdminPasswordStatus@		; `string'
PUBLIC	??_C@_0BJ@GMKDMOMC@AutomaticManagedPagefile@	; `string'
PUBLIC	??_C@_0BJ@CCCKPNOE@AutomaticResetBootOption@	; `string'
PUBLIC	??_C@_0BJ@HFJMLPDD@AutomaticResetCapability@	; `string'
PUBLIC	??_C@_0BC@LOIFGJNH@BootOptionOnLimit@		; `string'
PUBLIC	??_C@_0BF@NHNHHNLM@BootOptionOnWatchDog@	; `string'
PUBLIC	??_C@_0BB@KCAGDBFG@BootROMSupported@		; `string'
PUBLIC	??_C@_0M@FAIFADKE@BootupState@			; `string'
PUBLIC	??_C@_0BD@NPOFELCJ@ChassisBootupState@		; `string'
PUBLIC	??_C@_0BA@KEBGPOLH@CurrentTimeZone@		; `string'
PUBLIC	??_C@_0BB@PNOOHJBN@DaylightInEffect@		; `string'
PUBLIC	??_C@_0M@HMDMJNAL@DNSHostName@			; `string'
PUBLIC	??_C@_06HFDFFJHI@Domain@			; `string'
PUBLIC	??_C@_0L@DHGJAMBB@DomainRole@			; `string'
PUBLIC	??_C@_0BK@DMLHGPE@EnableDaylightSavingsTime@	; `string'
PUBLIC	??_C@_0BG@OFHEPCGG@FrontPanelResetStatus@	; `string'
PUBLIC	??_C@_0BC@MOGIEFCC@InfraredSupported@		; `string'
PUBLIC	??_C@_0BA@FHFMLOBH@InitialLoadInfo@		; `string'
PUBLIC	??_C@_0BH@NPMFKEOG@KeyboardPasswordStatus@	; `string'
PUBLIC	??_C@_0N@FDMFJCLB@LastLoadInfo@			; `string'
PUBLIC	??_C@_0L@INCFKHMA@NameFormat@			; `string'
PUBLIC	??_C@_0BJ@OJMPPEPI@NetworkServerModeEnabled@	; `string'
PUBLIC	??_C@_0O@KFCLFAME@OEMLogoBitmap@		; `string'
PUBLIC	??_C@_0P@DEDOEGFN@OEMStringArray@		; `string'
PUBLIC	??_C@_0N@BDBDHMKI@PartOfDomain@			; `string'
PUBLIC	??_C@_0BA@BAAGJACJ@PauseAfterReset@		; `string'
PUBLIC	??_C@_0N@EOPDJAGI@PCSystemType@			; `string'
PUBLIC	??_C@_0BG@MGBDJIM@PowerOnPasswordStatus@	; `string'
PUBLIC	??_C@_0L@PFLEPOFF@PowerState@			; `string'
PUBLIC	??_C@_0BB@PGEJAGBJ@PowerSupplyState@		; `string'
PUBLIC	??_C@_0BE@GNDJOKHP@PrimaryOwnerContact@		; `string'
PUBLIC	??_C@_0BB@CIHLIHGG@PrimaryOwnerName@		; `string'
PUBLIC	??_C@_0BA@JGMMLHGF@ResetCapability@		; `string'
PUBLIC	??_C@_0L@NDDNCBN@ResetCount@			; `string'
PUBLIC	??_C@_0L@ODMHPMJN@ResetLimit@			; `string'
PUBLIC	??_C@_05CPOHHMHJ@Roles@				; `string'
PUBLIC	??_C@_0BK@GHHBNFKI@SupportContactDescription@	; `string'
PUBLIC	??_C@_0BD@MJBJDOPG@SystemStartupDelay@		; `string'
PUBLIC	??_C@_0BF@HNHDCNN@SystemStartupOptions@		; `string'
PUBLIC	??_C@_0BF@IKJAHOGK@SystemStartupSetting@	; `string'
PUBLIC	??_C@_0N@HHACICKK@ThermalState@			; `string'
PUBLIC	??_C@_0BE@LPDNMOEG@TotalPhysicalMemory@		; `string'
PUBLIC	??_C@_0L@FAPFOCCC@WakeUpType@			; `string'
PUBLIC	??_C@_09CLAAHCGK@Workgroup@			; `string'
PUBLIC	??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@	; `string'
PUBLIC	??_C@_06LGGLFMPE@Vendor@			; `string'
PUBLIC	??_C@_04NOKDILIH@UUID@				; `string'
PUBLIC	??_C@_0BC@IBEJLMDM@IdentifyingNumber@		; `string'
PUBLIC	??_C@_09ODBEMGCH@SKUNumber@			; `string'
PUBLIC	??_C@_0O@LCAALOJJ@Win32_Product@		; `string'
PUBLIC	??_C@_09IHHILKBJ@ProductID@			; `string'
PUBLIC	??_C@_0P@CAOEPKFE@AssignmentType@		; `string'
PUBLIC	??_C@_0BA@DLLPKNMD@InstallLocation@		; `string'
PUBLIC	??_C@_0N@FNHIHJOE@InstallState@			; `string'
PUBLIC	??_C@_08LMOOJGEG@HelpLink@			; `string'
PUBLIC	??_C@_0O@PPCFOOHH@HelpTelephone@		; `string'
PUBLIC	??_C@_0O@GCCHCBIO@InstallSource@		; `string'
PUBLIC	??_C@_08BENDAOKD@Language@			; `string'
PUBLIC	??_C@_0N@ONDNCIN@LocalPackage@			; `string'
PUBLIC	??_C@_0N@LIDMIFHK@PackageCache@			; `string'
PUBLIC	??_C@_0M@OMMGPPBL@PackageCode@			; `string'
PUBLIC	??_C@_0M@PLFIHHBG@PackageName@			; `string'
PUBLIC	??_C@_08KOFIEIPM@RegOwner@			; `string'
PUBLIC	??_C@_0L@BDBMLIBF@RegCompany@			; `string'
PUBLIC	??_C@_0L@LNLOEOEC@Transforms@			; `string'
PUBLIC	??_C@_0N@CIJCJNDA@URLInfoAbout@			; `string'
PUBLIC	??_C@_0O@FDAGMPND@URLUpdateInfo@		; `string'
PUBLIC	??_C@_09JCLOCIPO@WordCount@			; `string'
PUBLIC	??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@	; `string'
PUBLIC	??_C@_08GFKGEEBB@HotFixID@			; `string'
PUBLIC	??_C@_0M@NMGHOPGA@InstalledBy@			; `string'
PUBLIC	??_C@_0M@NBDMPIKF@InstalledOn@			; `string'
PUBLIC	??_C@_0M@PIGNGIJB@FixComments@			; `string'
PUBLIC	??_C@_0BE@FBEKBLIJ@ServicePackInEffect@		; `string'
PUBLIC	??_C@_0BE@DKANKDCG@Win32_Refrigeration@		; `string'
PUBLIC	??_C@_0P@OGGGECNI@Win32_Registry@		; `string'
PUBLIC	??_C@_0M@MLALLFJB@CurrentSize@			; `string'
PUBLIC	??_C@_0M@JHEHBNHB@MaximumSize@			; `string'
PUBLIC	??_C@_0N@JHIKPPPP@ProposedSize@			; `string'
PUBLIC	??_C@_0BE@DHOOODEL@Win32_SystemAccount@		; `string'
PUBLIC	??_C@_03OMFNLMOB@SID@				; `string'
PUBLIC	??_C@_0N@FPKOIMIG@LocalAccount@			; `string'
PUBLIC	??_C@_07JDPBNNMM@SIDType@			; `string'
PUBLIC	??_C@_0BD@GGPCAOMO@Win32_SystemDriver@		; `string'
PUBLIC	??_C@_0M@MLHPPPJP@DisplayName@			; `string'
PUBLIC	??_C@_08LHLJMCNC@PathName@			; `string'
PUBLIC	??_C@_0M@MEIJGDEJ@AcceptPause@			; `string'
PUBLIC	??_C@_0L@MPAKMMDG@AcceptStop@			; `string'
PUBLIC	??_C@_0BA@DKLNMHH@DesktopInteract@		; `string'
PUBLIC	??_C@_0N@GPBKMKLE@ErrorControl@			; `string'
PUBLIC	??_C@_08FHJJFIAP@ExitCode@			; `string'
PUBLIC	??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode@	; `string'
PUBLIC	??_C@_0M@CFFFGGEC@ServiceType@			; `string'
PUBLIC	??_C@_09CIMAKHDE@StartName@			; `string'
PUBLIC	??_C@_05JNKNAC@State@				; `string'
PUBLIC	??_C@_05KFFLJNBG@TagId@				; `string'
PUBLIC	??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@	; `string'
PUBLIC	??_C@_0N@MLFAOMIG@ChassisTypes@			; `string'
PUBLIC	??_C@_0N@FBKDMIBE@AudibleAlarm@			; `string'
PUBLIC	??_C@_0BC@OICCILBJ@BreachDescription@		; `string'
PUBLIC	??_C@_0BI@OIOFCGCN@CableManagementStrategy@	; `string'
PUBLIC	??_C@_0BK@DMAHAAAM@CurrentRequiredOrProduced@	; `string'
PUBLIC	??_C@_0P@FPMIANAI@HeatGeneration@		; `string'
PUBLIC	??_C@_0M@FLPBGKMO@LockPresent@			; `string'
PUBLIC	??_C@_0BD@BOLIJOBH@NumberOfPowerCords@		; `string'
PUBLIC	??_C@_0P@IFAJDLJO@SecurityBreach@		; `string'
PUBLIC	??_C@_0P@LBCDFKMM@SecurityStatus@		; `string'
PUBLIC	??_C@_0BE@CDEDGENH@ServiceDescriptions@		; `string'
PUBLIC	??_C@_0BC@MJACHPAA@ServicePhilosophy@		; `string'
PUBLIC	??_C@_0P@GDBINLPP@SMBIOSAssetTag@		; `string'
PUBLIC	??_C@_0BB@EPPDMJMG@TypeDescriptions@		; `string'
PUBLIC	??_C@_0N@BGAIBJKD@VisibleAlarm@			; `string'
PUBLIC	??_C@_0BB@IINEGLLN@Win32_SystemSlot@		; `string'
PUBLIC	??_C@_0BA@JKMEMADA@SlotDesignation@		; `string'
PUBLIC	??_C@_0N@OHNMFPEL@CurrentUsage@			; `string'
PUBLIC	??_C@_0O@JIADPBNP@HeightAllowed@		; `string'
PUBLIC	??_C@_0O@ICFBEHEI@LengthAllowed@		; `string'
PUBLIC	??_C@_09KGLBDKHB@PMESignal@			; `string'
PUBLIC	??_C@_0BD@MJCDBDLK@PurposeDescription@		; `string'
PUBLIC	??_C@_06LOOAMPBO@Shared@			; `string'
PUBLIC	??_C@_0P@MHGKENBB@SpecialPurpose@		; `string'
PUBLIC	??_C@_0BA@HLMBNLEL@SupportsHotPlug@		; `string'
PUBLIC	??_C@_0O@OPICFFNJ@ThermalRating@		; `string'
PUBLIC	??_C@_0BH@BMAHGALK@VccMixedVoltageSupport@	; `string'
PUBLIC	??_C@_0BH@LMHCBHLE@VppMixedVoltageSupport@	; `string'
PUBLIC	??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@	; `string'
PUBLIC	??_C@_0L@MLCHOGMM@MACAddress@			; `string'
PUBLIC	??_C@_0BA@PKOOKBHK@PhysicalAdapter@		; `string'
PUBLIC	??_C@_0M@IOFGKGDC@ServiceName@			; `string'
PUBLIC	??_C@_0BA@FMEGGBNH@NetConnectionID@		; `string'
PUBLIC	??_C@_0BE@OHJLPIPO@NetConnectionStatus@		; `string'
PUBLIC	??_C@_08MFFAALKH@MaxSpeed@			; `string'
PUBLIC	??_C@_04MEIDEPGF@GUID@				; `string'
PUBLIC	??_C@_0BB@HCIBJPII@NetworkAddresses@		; `string'
PUBLIC	??_C@_0BB@CPOCLJND@PermanentAddress@		; `string'
PUBLIC	??_C@_0M@CBMGKKGD@AdapterType@			; `string'
PUBLIC	??_C@_0O@JDINGPBK@AdapterTypeID@		; `string'
PUBLIC	??_C@_09MMNBJFFE@AutoSense@			; `string'
PUBLIC	??_C@_09HBJECKPO@Installed@			; `string'
PUBLIC	??_C@_0P@LMPBIBLI@InterfaceIndex@		; `string'
PUBLIC	??_C@_0L@COBEMNCH@NetEnabled@			; `string'
PUBLIC	??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@ ; `string'
PUBLIC	??_C@_09NIGMFFPO@IPAddress@			; `string'
PUBLIC	??_C@_0L@BJOKJMLN@DHCPServer@			; `string'
PUBLIC	??_C@_0BB@HACNIBBH@DefaultIPGateway@		; `string'
PUBLIC	??_C@_09FBHLGFBK@DNSDomain@			; `string'
PUBLIC	??_C@_08EKHHNDLH@IPSubnet@			; `string'
PUBLIC	??_C@_0BF@NNMMFFI@ArpAlwaysSourceRoute@		; `string'
PUBLIC	??_C@_0BA@DHDIOMKI@ArpUseEtherSNAP@		; `string'
PUBLIC	??_C@_0N@OAKOAPMO@DatabasePath@			; `string'
PUBLIC	??_C@_0BE@GOBIIDKA@DeadGWDetectEnabled@		; `string'
PUBLIC	??_C@_0L@JFBEJJHM@DefaultTOS@			; `string'
PUBLIC	??_C@_0L@EIDNNLHD@DefaultTTL@			; `string'
PUBLIC	??_C@_0M@HIMIFMFA@DHCPEnabled@			; `string'
PUBLIC	??_C@_0BB@BOGKHOEE@DHCPLeaseExpires@		; `string'
PUBLIC	??_C@_0BC@MIONLOAH@DHCPLeaseObtained@		; `string'
PUBLIC	??_C@_0BL@NEHFNDKH@DNSDomainSuffixSearchOrder@	; `string'
PUBLIC	??_C@_0BM@LEBEBEIJ@DNSEnabledForWINSResolution@	; `string'
PUBLIC	??_C@_0BF@CIMMNJEP@DNSServerSearchOrder@	; `string'
PUBLIC	??_C@_0BN@OACMHJBD@DomainDNSRegistrationEnabled@ ; `string'
PUBLIC	??_C@_0BE@GGFBGHJP@ForwardBufferMemory@		; `string'
PUBLIC	??_C@_0BL@EIIPDLGE@FullDNSRegistrationEnabled@	; `string'
PUBLIC	??_C@_0BC@JPOLFPNM@GatewayCostMetric@		; `string'
PUBLIC	??_C@_09LFCMALKM@IGMPLevel@			; `string'
PUBLIC	??_C@_0BD@KDBLHBOO@IPConnectionMetric@		; `string'
PUBLIC	??_C@_09KIFLBGKF@IPEnabled@			; `string'
PUBLIC	??_C@_0BI@LBDHONDJ@IPFilterSecurityEnabled@	; `string'
PUBLIC	??_C@_0BG@IJANIIKC@IPPortSecurityEnabled@	; `string'
PUBLIC	??_C@_0BH@HHIPIHMF@IPSecPermitIPProtocols@	; `string'
PUBLIC	??_C@_0BE@JOIOPHFJ@IPSecPermitTCPPorts@		; `string'
PUBLIC	??_C@_0BE@IDDAOKAD@IPSecPermitUDPPorts@		; `string'
PUBLIC	??_C@_0BD@EFBIPBIB@IPUseZeroBroadcast@		; `string'
PUBLIC	??_C@_0L@JNAHKDDE@IPXAddress@			; `string'
PUBLIC	??_C@_0L@ONDAOAGP@IPXEnabled@			; `string'
PUBLIC	??_C@_0N@EAKCLKKB@IPXFrameType@			; `string'
PUBLIC	??_C@_0N@FHNNAGIP@IPXMediaType@			; `string'
PUBLIC	??_C@_0BB@HFHJDNKD@IPXNetworkNumber@		; `string'
PUBLIC	??_C@_0BE@KIGHGIHN@IPXVirtualNetNumber@		; `string'
PUBLIC	??_C@_0BC@HLLJNCGL@KeepAliveInterval@		; `string'
PUBLIC	??_C@_0O@HNPIKCNH@KeepAliveTime@		; `string'
PUBLIC	??_C@_03BLLMIPHO@MTU@				; `string'
PUBLIC	??_C@_0BC@CHJCENM@NumForwardPackets@		; `string'
PUBLIC	??_C@_0BF@DPKIODPI@PMTUBHDetectEnabled?$DL@	; `string'
PUBLIC	??_C@_0BF@KBFAFCNG@PMTUDiscoveryEnabled@	; `string'
PUBLIC	??_C@_0BE@MJKNHDFN@TcpipNetbiosOptions@		; `string'
PUBLIC	??_C@_0BN@NBAJINBE@TcpMaxConnectRetransmissions@ ; `string'
PUBLIC	??_C@_0BK@ICGANMDC@TcpMaxDataRetransmissions@	; `string'
PUBLIC	??_C@_0BC@CEGEJAFC@TcpNumConnections@		; `string'
PUBLIC	??_C@_0BL@JOFENPLC@TcpUseRFC1122UrgentPointer@	; `string'
PUBLIC	??_C@_0O@CIEPJIDD@TcpWindowSize@		; `string'
PUBLIC	??_C@_0BI@MIGGLKDO@WINSEnableLMHostsLookup@	; `string'
PUBLIC	??_C@_0BD@POPKKJKC@WINSHostLookupFile@		; `string'
PUBLIC	??_C@_0BC@BECMMLFM@WINSPrimaryServer@		; `string'
PUBLIC	??_C@_0M@CMEBCDLL@WINSScopeID@			; `string'
PUBLIC	??_C@_0BE@CHHDIDN@WINSSecondaryServer@		; `string'
PUBLIC	??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@	; `string'
PUBLIC	??_C@_08FPDCFGEH@FullName@			; `string'
PUBLIC	??_C@_0O@PKMMPAKN@HomeDirectory@		; `string'
PUBLIC	??_C@_0BD@GBDEODMP@HomeDirectoryDrive@		; `string'
PUBLIC	??_C@_0M@NDLIHBHJ@LogonServer@			; `string'
PUBLIC	??_C@_06HAPGBBDI@UserId@			; `string'
PUBLIC	??_C@_08LFHMHDM@UserType@			; `string'
PUBLIC	??_C@_0M@KEGPAPIK@UserComment@			; `string'
PUBLIC	??_C@_0P@FLJOKOM@AccountExpires@		; `string'
PUBLIC	??_C@_0BD@JGGENGAP@AuthorizationFlags@		; `string'
PUBLIC	??_C@_0BB@OBONNEPA@BadPasswordCount@		; `string'
PUBLIC	??_C@_08BHOPBADB@Caption?$DL@			; `string'
PUBLIC	??_C@_08DOHJINHB@CodePage@			; `string'
PUBLIC	??_C@_07JABLCLAF@Comment@			; `string'
PUBLIC	??_C@_0M@NALIBBDH@CountryCode@			; `string'
PUBLIC	??_C@_05BOOEKJH@Flags@				; `string'
PUBLIC	??_C@_0L@NKJIFPDG@LastLogoff@			; `string'
PUBLIC	??_C@_09JEOPKIAO@LastLogon@			; `string'
PUBLIC	??_C@_0L@HFGJFNDM@LogonHours@			; `string'
PUBLIC	??_C@_0P@BDLNENEK@MaximumStorage@		; `string'
PUBLIC	??_C@_0P@FMELCCCP@NumberOfLogons@		; `string'
PUBLIC	??_C@_0L@PBGCNDPG@Parameters@			; `string'
PUBLIC	??_C@_0M@HKNCEPDC@PasswordAge@			; `string'
PUBLIC	??_C@_0BA@HLOHOKEI@PasswordExpires@		; `string'
PUBLIC	??_C@_0P@CIBDNLPH@PrimaryGroupId@		; `string'
PUBLIC	??_C@_0L@FILALLBE@Privileges@			; `string'
PUBLIC	??_C@_07EELFDIBP@Profile@			; `string'
PUBLIC	??_C@_0L@GHILPLPE@ScriptPath@			; `string'
PUBLIC	??_C@_0N@LMMEGDEF@UnitsPerWeek@			; `string'
PUBLIC	??_C@_0N@LMIHDJBC@Workstations@			; `string'
PUBLIC	??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@	; `string'
PUBLIC	??_C@_0BG@IODJFDPJ@ConnectionlessService@	; `string'
PUBLIC	??_C@_0BD@ECGOALCK@GuaranteesDelivery@		; `string'
PUBLIC	??_C@_0BF@FAHCIDLD@GuaranteesSequencing@	; `string'
PUBLIC	??_C@_0BD@FFCOFDOJ@MaximumAddressSize@		; `string'
PUBLIC	??_C@_0BD@IBPHBINL@MaximumMessageSize@		; `string'
PUBLIC	??_C@_0BA@NLEIFDG@MessageOriented@		; `string'
PUBLIC	??_C@_0BD@PCBKNDJA@MinimumAddressSize@		; `string'
PUBLIC	??_C@_0BF@DJOBDJFP@PseudoStreamOriented@	; `string'
PUBLIC	??_C@_0BF@ONDNBOBK@SupportsBroadcasting@	; `string'
PUBLIC	??_C@_0BE@OAOGNDFG@SupportsConnectData@		; `string'
PUBLIC	??_C@_0BH@KMFDMCNH@SupportsDisconnectData@	; `string'
PUBLIC	??_C@_0BD@BJHEFNDH@SupportsEncryption@		; `string'
PUBLIC	??_C@_0BG@MJFBKLBP@SupportsExpeditedData@	; `string'
PUBLIC	??_C@_0BH@PFGLDBHN@SupportsFragmentation?$DL@	; `string'
PUBLIC	??_C@_0BI@FGBPBAKA@SupportsGracefulClosing@	; `string'
PUBLIC	??_C@_0BM@MDHHIPIM@SupportsGuaranteedBandwidth@	; `string'
PUBLIC	??_C@_0BF@BHPPOJFK@SupportsMulticasting@	; `string'
PUBLIC	??_C@_0BJ@MNHPDIFA@SupportsQualityofService@	; `string'
PUBLIC	??_C@_0BA@MBMLPGOB@Win32_CodecFile@		; `string'
PUBLIC	??_C@_08BHIEONMC@FileSize@			; `string'
PUBLIC	??_C@_08PICKODJL@FileType@			; `string'
PUBLIC	??_C@_0L@OHPKPJND@AccessMask@			; `string'
PUBLIC	??_C@_07CNOHFBBG@Archive@			; `string'
PUBLIC	??_C@_0L@FBPJPEIN@Compressed@			; `string'
PUBLIC	??_C@_0N@GPGLEEKJ@CreationDate@			; `string'
PUBLIC	??_C@_09KLPLELGE@Encrypted@			; `string'
PUBLIC	??_C@_0BB@CPNPJAMG@EncryptionMethod@		; `string'
PUBLIC	??_C@_06PDIOKLEE@FSName@			; `string'
PUBLIC	??_C@_05MBDCODDP@Group@				; `string'
PUBLIC	??_C@_06FHBILLDG@Hidden@			; `string'
PUBLIC	??_C@_0L@PCJCDOJK@InUseCount@			; `string'
PUBLIC	??_C@_0N@BLGOKNC@LastAccessed@			; `string'
PUBLIC	??_C@_0N@JFOMFNHF@LastModified@			; `string'
PUBLIC	??_C@_08PMHOKLA@Readable@			; `string'
PUBLIC	??_C@_06JIODDOFH@System@			; `string'
PUBLIC	??_C@_09HKGIPMHJ@Writeable@			; `string'
PUBLIC	??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@	; `string'
PUBLIC	??_C@_08OBOKCFEP@Accesses@			; `string'
PUBLIC	??_C@_0L@PLFFHFAH@Attributes@			; `string'
PUBLIC	??_C@_07PKCEDPHO@LastUse@			; `string'
PUBLIC	??_C@_0BC@DPAOPBJD@Win32_BaseService@		; `string'
PUBLIC	??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@	; `string'
PUBLIC	??_C@_0O@KLLIKPKC@BootDirectory@		; `string'
PUBLIC	??_C@_0BC@BJLIMIEA@ConfigurationPath@		; `string'
PUBLIC	??_C@_09PABAEPFH@LastDrive@			; `string'
PUBLIC	??_C@_0BB@FHBPINGK@ScratchDirectory@		; `string'
PUBLIC	??_C@_0O@FDHFFDED@TempDirectory@		; `string'
PUBLIC	??_C@_0O@MLAGCNDM@Win32_Desktop@		; `string'
PUBLIC	??_C@_0M@EEKAPENF@BorderWidth@			; `string'
PUBLIC	??_C@_0L@GMHAONPD@CoolSwitch@			; `string'
PUBLIC	??_C@_0BA@NKDGIFD@CursorBlinkRate@		; `string'
PUBLIC	??_C@_0BA@CNEMFCKH@DragFullWindows@		; `string'
PUBLIC	??_C@_0BA@MJNOPNAD@GridGranularity@		; `string'
PUBLIC	??_C@_0M@FALLBHKM@IconSpacing@			; `string'
PUBLIC	??_C@_0BC@HAAMKFAI@IconTitleFaceName@		; `string'
PUBLIC	??_C@_0O@COINDPHH@IconTitleSize@		; `string'
PUBLIC	??_C@_0O@HLNDODKM@IconTitleWrap@		; `string'
PUBLIC	??_C@_07NOCIGAPP@Pattern@			; `string'
PUBLIC	??_C@_0BC@KENIIHPI@ScreenSaverActive@		; `string'
PUBLIC	??_C@_0BG@OPEGFPLM@ScreenSaverExecutable@	; `string'
PUBLIC	??_C@_0BC@ENMGOCGL@ScreenSaverSecure@		; `string'
PUBLIC	??_C@_0BD@LIKEHLGN@ScreenSaverTimeout@		; `string'
PUBLIC	??_C@_09FAKNONCF@Wallpaper@			; `string'
PUBLIC	??_C@_0BD@MNOICNPG@WallpaperStretched@		; `string'
PUBLIC	??_C@_0P@HLGPBKPI@WallpaperTiled@		; `string'
PUBLIC	??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@	; `string'
PUBLIC	??_C@_0N@EJILFHEF@ScreenHeight@			; `string'
PUBLIC	??_C@_0M@GOACCFHI@ScreenWidth@			; `string'
PUBLIC	??_C@_0BG@JHIHGKIO@PixelsPerXLogicalInch@	; `string'
PUBLIC	??_C@_0BG@EKBBLDAL@PixelsPerYLogicalInch@	; `string'
PUBLIC	??_C@_0BE@EAJFLPNK@MonitorManufacturer@		; `string'
PUBLIC	??_C@_0M@FCPFJAEP@MonitorType@			; `string'
PUBLIC	??_C@_09LPCHGGLO@Bandwidth@			; `string'
PUBLIC	??_C@_0M@GAHMDPOP@DisplayType@			; `string'
PUBLIC	??_C@_09BEHCCOGC@Win32_Fan@			; `string'
PUBLIC	??_C@_0N@HOGGFFKF@DesiredSpeed@			; `string'
PUBLIC	??_C@_0O@ODMHJIAL@VariableSpeed@		; `string'
PUBLIC	??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@	; `string'
PUBLIC	??_C@_0P@NOCBMKBI@OSArchitecture@		; `string'
PUBLIC	??_C@_09LLAGGHGM@BuildType@			; `string'
PUBLIC	??_C@_0L@EGALIDNG@CSDVersion@			; `string'
PUBLIC	??_C@_0BI@MCMKKPJH@ServicePackMajorVersion@	; `string'
PUBLIC	??_C@_0BI@HEBPKKOL@ServicePackMinorVersion@	; `string'
PUBLIC	??_C@_0P@HNONGDKL@OSProductSuite@		; `string'
PUBLIC	??_C@_06MNBFCOOH@OSType@			; `string'
PUBLIC	??_C@_0N@MHPBIIPD@Organization@			; `string'
PUBLIC	??_C@_0P@DAFCPCAO@RegisteredUser@		; `string'
PUBLIC	??_C@_0M@GGPOPAAP@ProductType@			; `string'
PUBLIC	??_C@_0L@BLKKOICB@BootDevice@			; `string'
PUBLIC	??_C@_0N@LCIKLBMI@SystemDevice@			; `string'
PUBLIC	??_C@_0M@JBPIDKPO@SystemDrive@			; `string'
PUBLIC	??_C@_0BA@FNJMICPB@SystemDirectory@		; `string'
PUBLIC	??_C@_0BB@IEJHMEDK@WindowsDirectory@		; `string'
PUBLIC	??_C@_0L@IOMOHLID@OSLanguage@			; `string'
PUBLIC	??_C@_0CC@LDMHMPMB@DataExecutionPrevention_Availab@ ; `string'
PUBLIC	??_C@_0CK@PHHDEHCB@DataExecutionPrevention_32BitAp@ ; `string'
PUBLIC	??_C@_0CA@KCIFHCEN@DataExecutionPrevention_Drivers@ ; `string'
PUBLIC	??_C@_0CG@FOLHLACL@DataExecutionPrevention_Support@ ; `string'
PUBLIC	??_C@_05GCIPIGEI@Debug@				; `string'
PUBLIC	??_C@_0M@DGCHPHG@Distributed@			; `string'
PUBLIC	??_C@_0BA@LIJDDPMD@EncryptionLevel@		; `string'
PUBLIC	??_C@_0BL@LKLGBOHP@ForegroundApplicationBoost@	; `string'
PUBLIC	??_C@_0BD@KJPLACJD@FreePhysicalMemory@		; `string'
PUBLIC	??_C@_0BH@GDCHGEBO@FreeSpaceInPagingFiles@	; `string'
PUBLIC	??_C@_0BC@HEKPKJCK@FreeVirtualMemory@		; `string'
PUBLIC	??_C@_0BB@GLODIIPC@LargeSystemCache@		; `string'
PUBLIC	??_C@_0P@DKHNBJBB@LastBootUpTime@		; `string'
PUBLIC	??_C@_0O@GFNPHCJN@LocalDateTime@		; `string'
PUBLIC	??_C@_06BMNFLCFO@Locale@			; `string'
PUBLIC	??_C@_0BF@BJJFAIPL@MaxNumberOfProcesses@	; `string'
PUBLIC	??_C@_0BF@OEEDDGBK@MaxProcessMemorySize@	; `string'
PUBLIC	??_C@_0N@FEFLNODO@MUILanguages@			; `string'
PUBLIC	??_C@_0BG@MGHJNMGE@NumberOfLicensedUsers@	; `string'
PUBLIC	??_C@_0BC@FILGLGHH@NumberOfProcesses@		; `string'
PUBLIC	??_C@_0O@PBBGLGFJ@NumberOfUsers@		; `string'
PUBLIC	??_C@_0BD@GLJCNHGP@OperatingSystemSKU@		; `string'
PUBLIC	??_C@_0BF@KAMHDIPP@OtherTypeDescription@	; `string'
PUBLIC	??_C@_0L@KNGIFFNB@PAEEnabled@			; `string'
PUBLIC	??_C@_0O@NNCCMBIG@PlusProductID@		; `string'
PUBLIC	??_C@_0BC@LMIHOAGL@PlusVersionNumber@		; `string'
PUBLIC	??_C@_07NAEHBBNL@Primary@			; `string'
PUBLIC	??_C@_0BI@BKJHEEOL@SizeStoredInPagingFiles@	; `string'
PUBLIC	??_C@_09IIJPJFOC@SuiteMask@			; `string'
PUBLIC	??_C@_0BD@PBNAJGBH@TotalSwapSpaceSize@		; `string'
PUBLIC	??_C@_0BH@IBKKELEK@TotalVirtualMemorySize@	; `string'
PUBLIC	??_C@_0BH@EOFEPLNL@TotalVisibleMemorySize@	; `string'
PUBLIC	??_C@_0P@GFMPEM@Win32_PageFile@			; `string'
PUBLIC	??_C@_09LCEICGML@FreeSpace@			; `string'
PUBLIC	??_C@_0M@EONNPILK@InitialSize@			; `string'
PUBLIC	??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@		; `string'
PUBLIC	??_C@_0L@LICOLOBE@DMASupport@			; `string'
PUBLIC	??_C@_0M@GFHBIAHO@Win32_Proxy@			; `string'
PUBLIC	??_C@_0BA@LEMEMCNN@ProxyPortNumber@		; `string'
PUBLIC	??_C@_0M@BCMAAPLG@ProxyServer@			; `string'
PUBLIC	??_C@_0L@FFDIDHBB@ServerName@			; `string'
PUBLIC	??_C@_0M@MCIKNCEL@Win32_Share@			; `string'
PUBLIC	??_C@_04HMIIHGGM@Path@				; `string'
PUBLIC	??_C@_0P@IBLGFEE@MaximumAllowed@		; `string'
PUBLIC	??_C@_0N@PEAHLPLG@AllowMaximum@			; `string'
PUBLIC	??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@ ; `string'
PUBLIC	??_C@_0BD@HINAAJAB@ActivationRequired@		; `string'
PUBLIC	??_C@_0BB@FFPKNIIL@IsNotificationOn@		; `string'
PUBLIC	??_C@_0BK@MHMKFBPN@RemainingEvaluationPeriod@	; `string'
PUBLIC	??_C@_0BF@GDCPFLAD@RemainingGracePeriod@	; `string'
PUBLIC	??_C@_0BB@BBHCGAKO@Win32_WMISetting@		; `string'
PUBLIC	??_C@_0BK@HACJICBD@ASPScriptDefaultNamespace@	; `string'
PUBLIC	??_C@_0BB@HHJGCMCA@ASPScriptEnabled@		; `string'
PUBLIC	??_C@_0BA@FCAEOBFB@AutorecoverMofs@		; `string'
PUBLIC	??_C@_0P@LBFHKJDL@AutoStartWin9X@		; `string'
PUBLIC	??_C@_0P@HCBDPJED@BackupInterval@		; `string'
PUBLIC	??_C@_0P@HCKKJOFA@BackupLastTime@		; `string'
PUBLIC	??_C@_0N@DMPKCKPJ@BuildVersion@			; `string'
PUBLIC	??_C@_0BC@PJAEIMII@DatabaseDirectory@		; `string'
PUBLIC	??_C@_0BA@GMIIIOHB@DatabaseMaxSize@		; `string'
PUBLIC	??_C@_0BL@FLALGEND@EnableAnonWin9xConnections@	; `string'
PUBLIC	??_C@_0N@OBNHEDLP@EnableEvents@			; `string'
PUBLIC	??_C@_0BP@DHLDKHJI@EnableStartupHeapPreallocation@ ; `string'
PUBLIC	??_C@_0BN@FBHHPGGC@HighThresholdOnClientObjects@ ; `string'
PUBLIC	??_C@_0BG@LKICGCBK@HighThresholdOnEvents@	; `string'
PUBLIC	??_C@_0BG@MDEOBFAH@InstallationDirectory@	; `string'
PUBLIC	??_C@_0BN@GKEEMEKI@LastStartupHeapPreallocation@ ; `string'
PUBLIC	??_C@_0BB@FALFKNPE@LoggingDirectory@		; `string'
PUBLIC	??_C@_0N@FMFGOJPB@LoggingLevel@			; `string'
PUBLIC	??_C@_0BM@NGNJMOHJ@LowThresholdOnClientObjects@	; `string'
PUBLIC	??_C@_0BF@PHEPMKDN@LowThresholdOnEvents@	; `string'
PUBLIC	??_C@_0P@CEPALFMK@MaxLogFileSize@		; `string'
PUBLIC	??_C@_0BH@PBKELOKA@MaxWaitOnClientObjects@	; `string'
PUBLIC	??_C@_0BA@NHHFPHIJ@MaxWaitOnEvents@		; `string'
PUBLIC	??_C@_0BI@NOBDNJPM@MofSelfInstallDirectory@	; `string'
PUBLIC	??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@	; `string'
PUBLIC	??_C@_0L@MJJCDBO@BitsPerPel@			; `string'
PUBLIC	??_C@_07KLCNEDPB@Collate@			; `string'
PUBLIC	??_C@_05PDOBBJNA@Color@				; `string'
PUBLIC	??_C@_06BLCAIJFC@Copies@			; `string'
PUBLIC	??_C@_0L@FHIBJDML@DeviceName@			; `string'
PUBLIC	??_C@_0N@DJPIPGBF@DisplayFlags@			; `string'
PUBLIC	??_C@_0BB@FJLGFJEJ@DisplayFrequency@		; `string'
PUBLIC	??_C@_06KIOALPNI@Duplex@			; `string'
PUBLIC	??_C@_08EOPEEPJC@FormName@			; `string'
PUBLIC	??_C@_0BF@FOMIFJDP@HorizontalResolution@	; `string'
PUBLIC	??_C@_09ENKMJEBL@LogPixels@			; `string'
PUBLIC	??_C@_0M@LHPCLPIO@Orientation@			; `string'
PUBLIC	??_C@_0M@ICHOFLKL@PaperLength@			; `string'
PUBLIC	??_C@_09KFDMKFMI@PaperSize@			; `string'
PUBLIC	??_C@_0L@OINDMHF@PaperWidth@			; `string'
PUBLIC	??_C@_0L@FDBJOBNL@PelsHeight@			; `string'
PUBLIC	??_C@_09CGGAMGGM@PelsWidth@			; `string'
PUBLIC	??_C@_0N@CLBFGPBN@PrintQuality@			; `string'
PUBLIC	??_C@_05MAGIBEFI@Scale@				; `string'
PUBLIC	??_C@_08KMMMDKPE@TTOption@			; `string'
PUBLIC	??_C@_0BD@FGMLFAJH@VerticalResolution@		; `string'
PUBLIC	??_C@_0M@IMNEHNOF@XResolution@			; `string'
PUBLIC	??_C@_0M@BHHBDBIK@YResolution@			; `string'
PUBLIC	??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@	; `string'
PUBLIC	??_C@_0BA@FLFAPDFG@ConnectionState@		; `string'
PUBLIC	??_C@_0P@LNPCDAPC@ConnectionType@		; `string'
PUBLIC	??_C@_0L@CCMICFHJ@RemotePath@			; `string'
PUBLIC	??_C@_09CLGGKACF@LocalName@			; `string'
PUBLIC	??_C@_0L@FLEBOKCI@RemoteName@			; `string'
PUBLIC	??_C@_0L@LNKKEMJM@Persistent@			; `string'
PUBLIC	??_C@_0N@ONCOBKP@ProviderName@			; `string'
PUBLIC	??_C@_0N@EPHJOCBJ@ResourceType@			; `string'
PUBLIC	??_C@_0N@NNCPDPIH@Win32_Volume@			; `string'
PUBLIC	??_C@_05IEIONIFO@Label@				; `string'
PUBLIC	??_C@_0M@EHMJIHII@DriveLetter@			; `string'
PUBLIC	??_C@_09NKILGKMH@DriveType@			; `string'
PUBLIC	??_C@_0L@FPFLHALM@FileSystem@			; `string'
PUBLIC	??_C@_09HICOCIIF@Automount@			; `string'
PUBLIC	??_C@_0M@FMPADJNN@DirtyBitSet@			; `string'
PUBLIC	??_C@_0BA@JDIBBDEO@IndexingEnabled@		; `string'
PUBLIC	??_C@_0BG@ELFKDNP@MaximumFileNameLength@	; `string'
PUBLIC	??_C@_0O@HEHOMNCC@QuotasEnabled@		; `string'
PUBLIC	??_C@_0BB@MPFPEDFA@QuotasIncomplete@		; `string'
PUBLIC	??_C@_0BB@JJBCJECG@QuotasRebuilding@		; `string'
PUBLIC	??_C@_0BD@BJDMHPHA@SupportsDiskQuotas@		; `string'
PUBLIC	??_C@_0BN@DMMADKEM@SupportsFileBasedCompression@ ; `string'
PUBLIC	??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@ ; `string'
PUBLIC	??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead@		; `string'
PUBLIC	??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base@	; `string'
PUBLIC	??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer@	; `string'
PUBLIC	??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base@ ; `string'
PUBLIC	??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite@	; `string'
PUBLIC	??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base@	; `string'
PUBLIC	??_C@_0BD@CKOOLAI@AvgDiskQueueLength@		; `string'
PUBLIC	??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength@	; `string'
PUBLIC	??_C@_0BD@LLDDCMMH@AvgDiskSecPerRead?$DL@	; `string'
PUBLIC	??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base@	; `string'
PUBLIC	??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer@	; `string'
PUBLIC	??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base@	; `string'
PUBLIC	??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite@		; `string'
PUBLIC	??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base@	; `string'
PUBLIC	??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength@	; `string'
PUBLIC	??_C@_0BH@CFGDHLM@CurrentDiskQueueLength@	; `string'
PUBLIC	??_C@_0BA@BBEHMIEJ@DiskBytesPerSec@		; `string'
PUBLIC	??_C@_0BE@IJJNINGL@DiskReadBytesPerSec@		; `string'
PUBLIC	??_C@_0BA@GPEPCNFG@DiskReadsPerSec@		; `string'
PUBLIC	??_C@_0BE@INHPJNPE@DiskTransfersPerSec@		; `string'
PUBLIC	??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec@	; `string'
PUBLIC	??_C@_0BB@FFLCGPKG@DiskWritesPerSec@		; `string'
PUBLIC	??_C@_0BB@EEOEKLCO@Frequency_Object@		; `string'
PUBLIC	??_C@_0BD@IONDPFD@Frequency_PerfTime@		; `string'
PUBLIC	??_C@_0BD@MECIOMGA@Frequency_Sys100NS@		; `string'
PUBLIC	??_C@_0BE@KMHMAHCP@PercentDiskReadTime@		; `string'
PUBLIC	??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base@	; `string'
PUBLIC	??_C@_0BA@HPDMAPLN@PercentDiskTime@		; `string'
PUBLIC	??_C@_0BF@CHKOMNLI@PercentDiskTime_Base@	; `string'
PUBLIC	??_C@_0BF@DOKCNDOL@PercentDiskWriteTime@	; `string'
PUBLIC	??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base@	; `string'
PUBLIC	??_C@_0BA@LOOKHAGM@PercentIdleTime@		; `string'
PUBLIC	??_C@_0BF@PLICIEBG@PercentIdleTime_Base@	; `string'
PUBLIC	??_C@_0O@JFLPIICD@SplitIOPerSec@		; `string'
PUBLIC	??_C@_0BB@JNCIMECH@Timestamp_Object@		; `string'
PUBLIC	??_C@_0BD@ECCCBBP@Timestamp_PerfTime@		; `string'
PUBLIC	??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@		; `string'
PUBLIC	??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@ ; `string'
PUBLIC	??_C@_0O@EJBHEMAA@FreeMegabytes@		; `string'
PUBLIC	??_C@_0BC@IJGACNJB@AvgDiskSecPerRead@		; `string'
PUBLIC	??_C@_0BB@FDAACFPN@PercentFreeSpace@		; `string'
PUBLIC	??_C@_0BG@KEJCKNPB@PercentFreeSpace_Base@	; `string'
PUBLIC	??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@ ; `string'
PUBLIC	??_C@_0BE@IEAMAKJB@BytesReceivedPerSec@		; `string'
PUBLIC	??_C@_0BH@GKKKHEEC@BytesTransmittedPerSec@	; `string'
PUBLIC	??_C@_0BB@NADCFLBJ@BytesTotalPerSec@		; `string'
PUBLIC	??_C@_0O@GPMHHPHG@PacketsPerSec@		; `string'
PUBLIC	??_C@_0BG@PFNBEMLM@PacketsReceivedPerSec@	; `string'
PUBLIC	??_C@_0BJ@EHOOHGK@PacketsTransmittedPerSec@	; `string'
PUBLIC	??_C@_0N@IJGODAGI@ConnectsCore@			; `string'
PUBLIC	??_C@_0BF@MNEGHJGM@ConnectsLanManager20@	; `string'
PUBLIC	??_C@_0BF@NEFNEICN@ConnectsLanManager21@	; `string'
PUBLIC	??_C@_0BC@EOFEMAHF@ConnectsWindowsNT@		; `string'
PUBLIC	??_C@_0BA@DJMJIEBG@CurrentCommands@		; `string'
PUBLIC	??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec@	; `string'
PUBLIC	??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec@	; `string'
PUBLIC	??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec@	; `string'
PUBLIC	??_C@_0BE@OGCPPNJJ@NetworkErrorsPerSec@		; `string'
PUBLIC	??_C@_0BF@LPDAMOL@ReadBytesCachePerSec@		; `string'
PUBLIC	??_C@_0BH@IAHICFAL@ReadBytesNetworkPerSec@	; `string'
PUBLIC	??_C@_0BJ@ILOCGCLG@ReadBytesNonPagingPerSec@	; `string'
PUBLIC	??_C@_0BG@OLGMIDCE@ReadBytesPagingPerSec@	; `string'
PUBLIC	??_C@_0BL@CFIGOGID@ReadOperationsRandomPerSec@	; `string'
PUBLIC	??_C@_0BC@JALNAJBD@ReadPacketsPerSec@		; `string'
PUBLIC	??_C@_0BH@JCFIFLJN@ReadPacketsSmallPerSec@	; `string'
PUBLIC	??_C@_0BC@MGHKCLNK@ReadsDeniedPerSec@		; `string'
PUBLIC	??_C@_0BB@FFKFENGC@ReadsLargePerSec@		; `string'
PUBLIC	??_C@_0BC@GAMKMMKB@ServerDisconnects@		; `string'
PUBLIC	??_C@_0BB@LGLKKLGK@ServerReconnects@		; `string'
PUBLIC	??_C@_0P@EPIIEJNA@ServerSessions@		; `string'
PUBLIC	??_C@_0BD@BALBBJPI@ServerSessionsHung@		; `string'
PUBLIC	??_C@_0BG@GCNKDHCE@WriteBytesCachePerSec@	; `string'
PUBLIC	??_C@_0BI@HNBBGOIH@WriteBytesNetworkPerSec@	; `string'
PUBLIC	??_C@_0BK@PNNKNAIA@WriteBytesNonPagingPerSec@	; `string'
PUBLIC	??_C@_0BH@OANOHFDO@WriteBytesPagingPerSec@	; `string'
PUBLIC	??_C@_0BM@IJPFNDGO@WriteOperationsRandomPerSec@	; `string'
PUBLIC	??_C@_0BD@NEABLLFJ@WritePacketsPerSec@		; `string'
PUBLIC	??_C@_0BI@GPDBBABB@WritePacketsSmallPerSec@	; `string'
PUBLIC	??_C@_0BC@LMECNINB@WriteDeniedPerSec@		; `string'
PUBLIC	??_C@_0BB@HAMOOOJ@WriteLargePerSec@		; `string'
PUBLIC	??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@ ; `string'
PUBLIC	??_C@_0BF@MGINILGA@AsyncCopyReadsPerSec@	; `string'
PUBLIC	??_C@_0BE@CAOOLPND@AsyncDataMapsPerSec@		; `string'
PUBLIC	??_C@_0BF@GKOKALKG@AsyncFastReadsPerSec@	; `string'
PUBLIC	??_C@_0BE@OMOFBJFA@AsyncMDLReadsPerSec@		; `string'
PUBLIC	??_C@_0BE@PNDFACCO@AsyncPinReadsPerSec@		; `string'
PUBLIC	??_C@_0BE@FFJCEMDJ@CopyReadHitsPercent@		; `string'
PUBLIC	??_C@_0BJ@FGOEJAHL@CopyReadHitsPercent_Base@	; `string'
PUBLIC	??_C@_0BA@BIHGDHJL@CopyReadsPerSec@		; `string'
PUBLIC	??_C@_0BC@MJKDEPG@DataFlushesPerSec@		; `string'
PUBLIC	??_C@_0BF@JDDABGEO@DataFlushPagesPerSec@	; `string'
PUBLIC	??_C@_0BD@KOAAJIJA@DataMapHitsPercent@		; `string'
PUBLIC	??_C@_0BI@ILDKBHLK@DataMapHitsPercent_Base@	; `string'
PUBLIC	??_C@_0BC@OOMEAEEA@DataMapPinsPerSec@		; `string'
PUBLIC	??_C@_0BH@JDIGEHGG@DataMapPinsPerSec_Base@	; `string'
PUBLIC	??_C@_0P@GAMMIBDO@DataMapsPerSec@		; `string'
PUBLIC	??_C@_0BL@HBAEFMGM@FastReadNotPossiblesPerSec@	; `string'
PUBLIC	??_C@_0BN@JGPDPBED@FastReadResourceMissesPerSec@ ; `string'
PUBLIC	??_C@_0BA@LEBBLHFN@FastReadsPerSec@		; `string'
PUBLIC	??_C@_0BH@JCPDBLIF@LazyWriteFlushesPerSec@	; `string'
PUBLIC	??_C@_0BF@GOGJJNKE@LazyWritePagesPerSec@	; `string'
PUBLIC	??_C@_0BD@PNDPPHMH@MDLReadHitsPercent@		; `string'
PUBLIC	??_C@_0BI@NMONEPAO@MDLReadHitsPercent_Base@	; `string'
PUBLIC	??_C@_0P@KMMHCHLN@MDLReadsPerSec@		; `string'
PUBLIC	??_C@_0BD@INCEIJBE@PinReadHitsPercent@		; `string'
PUBLIC	??_C@_0BI@KGBEKIEP@PinReadHitsPercent_Base@	; `string'
PUBLIC	??_C@_0P@LNBHDMMD@PinReadsPerSec@		; `string'
PUBLIC	??_C@_0BB@NGKOLIIB@ReadAheadsPerSec@		; `string'
PUBLIC	??_C@_0BE@PJJLELAC@SyncCopyReadsPerSec@		; `string'
PUBLIC	??_C@_0BD@IDCIAAHF@SyncDataMapsPerSec@		; `string'
PUBLIC	??_C@_0BE@FFPMMLME@SyncFastReadsPerSec@		; `string'
PUBLIC	??_C@_0BD@EPCDKGPG@SyncMDLReadsPerSec@		; `string'
PUBLIC	??_C@_0BD@FOPDLNII@SyncPinReadsPerSec@		; `string'
PUBLIC	??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@ ; `string'
PUBLIC	??_C@_0P@HPKKNIPF@AvailableBytes@		; `string'
PUBLIC	??_C@_0BA@DKABBPEK@AvailableKBytes@		; `string'
PUBLIC	??_C@_0BA@FJNBCKHA@AvailableMBytes@		; `string'
PUBLIC	??_C@_0L@ECJIAGHC@CacheBytes@			; `string'
PUBLIC	??_C@_0P@BPAGOPIK@CacheBytesPeak@		; `string'
PUBLIC	??_C@_0BC@ONMHHFEO@CacheFaultsPerSec@		; `string'
PUBLIC	??_C@_0M@HHOMCEFN@CommitLimit@			; `string'
PUBLIC	??_C@_0P@FAEGOFEG@CommittedBytes@		; `string'
PUBLIC	??_C@_0BH@BIADJNEE@DemandZeroFaultsPerSec@	; `string'
PUBLIC	??_C@_0BL@MIKHIOLC@FreeSystemPageTableEntries@	; `string'
PUBLIC	??_C@_0BB@HOEEGAIG@PageFaultsPerSec@		; `string'
PUBLIC	??_C@_0BA@BHCICMAP@PageReadsPerSec@		; `string'
PUBLIC	??_C@_0BB@NHNEKMAP@PagesInputPerSec@		; `string'
PUBLIC	??_C@_0BC@PGIEMCPC@PagesOutputPerSec@		; `string'
PUBLIC	??_C@_0M@PJBDCOH@PagesPerSec@			; `string'
PUBLIC	??_C@_0BB@EHHNOBPH@PageWritesPerSec@		; `string'
PUBLIC	??_C@_0BL@EHMKCOHH@PercentCommittedBytesInUse@	; `string'
PUBLIC	??_C@_0CA@DKFDEGAA@PercentCommittedBytesInUse_Base@ ; `string'
PUBLIC	??_C@_0BD@GAOJBHDB@PoolNonpagedAllocs@		; `string'
PUBLIC	??_C@_0BC@GMPJEGLC@PoolNonpagedBytes@		; `string'
PUBLIC	??_C@_0BA@LDKKFHCE@PoolPagedAllocs@		; `string'
PUBLIC	??_C@_0P@PJENKINF@PoolPagedBytes@		; `string'
PUBLIC	??_C@_0BH@OMBHLDMN@PoolPagedResidentBytes@	; `string'
PUBLIC	??_C@_0BJ@NPNGHFJN@SystemCacheResidentBytes@	; `string'
PUBLIC	??_C@_0BI@KPKNFENK@SystemCodeResidentBytes@	; `string'
PUBLIC	??_C@_0BF@JBGABIBK@SystemCodeTotalBytes@	; `string'
PUBLIC	??_C@_0BK@MNCINJBF@SystemDriverResidentBytes@	; `string'
PUBLIC	??_C@_0BH@KPIDEMMH@SystemDriverTotalBytes@	; `string'
PUBLIC	??_C@_0BH@KEMPGDKK@TransitionFaultsPerSec@	; `string'
PUBLIC	??_C@_0BC@KBPIOBBH@WriteCopiesPerSec@		; `string'
PUBLIC	??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@ ; `string'
PUBLIC	??_C@_09BNGODGIH@Processes@			; `string'
PUBLIC	??_C@_07CMIGFCHA@Threads@			; `string'
PUBLIC	??_C@_07LDPBBEEB@Mutexes@			; `string'
PUBLIC	??_C@_06HEBKAGDH@Events@			; `string'
PUBLIC	??_C@_0L@GLBCAKLN@Semaphores@			; `string'
PUBLIC	??_C@_08FBPDBPOE@Sections@			; `string'
PUBLIC	??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@ ; `string'
PUBLIC	??_C@_0N@CKGFJCHF@PercentUsage@			; `string'
PUBLIC	??_C@_0BB@JKLALBIF@PercentUsagePeak@		; `string'
PUBLIC	??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@ ; `string'
PUBLIC	??_C@_0BF@EMKPKJGP@PercentProcessorTime@	; `string'
PUBLIC	??_C@_0BA@JCLIOML@PercentUserTime@		; `string'
PUBLIC	??_C@_0BE@DLJADCBG@C1TransitionsPerSec@		; `string'
PUBLIC	??_C@_0BE@JIMGLELP@C2TransitionsPerSec@		; `string'
PUBLIC	??_C@_0BE@EPCEDEOH@C3TransitionsPerSec@		; `string'
PUBLIC	??_C@_07BHCICOFH@DPCRate@			; `string'
PUBLIC	??_C@_0BB@KHEGFAIJ@DPCsQueuedPerSec@		; `string'
PUBLIC	??_C@_0BB@FCICDGPJ@InterruptsPerSec@		; `string'
PUBLIC	??_C@_0O@PJFMGMCN@PercentC1Time@		; `string'
PUBLIC	??_C@_0O@HPMIBOID@PercentC2Time@		; `string'
PUBLIC	??_C@_0O@LEJEMNCG@PercentC3Time@		; `string'
PUBLIC	??_C@_0P@LMLLFJEI@PercentDPCTime@		; `string'
PUBLIC	??_C@_0BF@GMGAHOLM@PercentInterruptTime@	; `string'
PUBLIC	??_C@_0BG@FPNGHOGK@PercentPrivilegedTime@	; `string'
PUBLIC	??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@ ; `string'
PUBLIC	??_C@_0BG@KHFHJKMP@AlignmentFixupsPerSec@	; `string'
PUBLIC	??_C@_0BG@GIPKJDB@ContextSwitchesPerSec@	; `string'
PUBLIC	??_C@_0BK@DHKAACDP@ExceptionDispatchesPerSec@	; `string'
PUBLIC	??_C@_0BH@EMNLAEFK@FileControlBytesPerSec@	; `string'
PUBLIC	??_C@_0BM@PIKKJCOI@FileControlOperationsPerSec@	; `string'
PUBLIC	??_C@_0BE@NKKLPLAB@FileReadBytesPerSec@		; `string'
PUBLIC	??_C@_0BF@LGMPDKBA@FileWriteBytesPerSec@	; `string'
PUBLIC	??_C@_0BJ@PHDBHNCO@FloatingEmulationsPerSec@	; `string'
PUBLIC	??_C@_0BK@NGGOKLMO@PercentRegistryQuotaInUse@	; `string'
PUBLIC	??_C@_0BF@NPGOAGED@ProcessorQueueLength@	; `string'
PUBLIC	??_C@_0BC@HMBPBBJB@SystemCallsPerSec@		; `string'
PUBLIC	??_C@_0N@JBKHOEPE@SystemUpTime@			; `string'
PUBLIC	??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@		; `string'
PUBLIC	??_C@_0P@IDBBEDLI@CurrentReading@		; `string'
PUBLIC	??_C@_08NLCOAFEI@Accuracy@			; `string'
PUBLIC	??_C@_09BKMALBOE@Tolerance@			; `string'
PUBLIC	??_C@_0P@OAFFNBPO@NominalReading@		; `string'
PUBLIC	??_C@_09EDCPMBJN@NormalMax@			; `string'
PUBLIC	??_C@_09FBKECFPC@NormalMin@			; `string'
PUBLIC	??_C@_0BH@NMAIJHFM@LowerThresholdCritical@	; `string'
PUBLIC	??_C@_0BE@NPMAGCMK@LowerThresholdFatal@		; `string'
PUBLIC	??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical@	; `string'
PUBLIC	??_C@_0BH@FKDKGMLL@UpperThresholdCritical@	; `string'
PUBLIC	??_C@_0BE@HGEJIDLL@UpperThresholdFatal@		; `string'
PUBLIC	??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical@	; `string'
PUBLIC	??_C@_0M@EIBDACPL@MaxReadable@			; `string'
PUBLIC	??_C@_0M@NIGABCBB@MinReadable@			; `string'
PUBLIC	??_C@_08JLKOPNJP@IsLinear@			; `string'
PUBLIC	??_C@_0BG@GEFEDJOA@Win32_PortableBattery@	; `string'
PUBLIC	??_C@_0BA@EMGHNHBI@ManufactureDate@		; `string'
PUBLIC	??_C@_0BD@EBMPMBCC@CapacityMultiplier@		; `string'
PUBLIC	??_C@_0BA@LLOCDJF@MaxBatteryError@		; `string'
PUBLIC	??_C@_0BI@LFKNNEKA@SystemCreationClassName@	; `string'
PUBLIC	??_C@_0L@MPHEPFAH@SystemName@			; `string'
PUBLIC	??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@	; `string'
PUBLIC	??_C@_0BD@HAJJDCII@Win32_VoltageProbe@		; `string'
PUBLIC	??_C@_09BAECPDM@?$DO?$DO?5MonIPs@		; `string'
PUBLIC	??_C@_09CLAHNHIH@?$DM?$DM?5MonIPs@		; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_0BA@GBPLBEEL@SysStatus_Trace@		; `string'
PUBLIC	??_C@_03LBAKCJJ@dbg@				; `string'
PUBLIC	??_C@_03GLILPAEP@wnd@				; `string'
PUBLIC	??_C@_03NMGDDAFL@wmi@				; `string'
PUBLIC	??_C@_0CP@CLGPPHLF@?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d?4?$CF@ ; `string'
PUBLIC	??_C@_09OGNGBBJO@?$CFs?4?$CFs?4log@		; `string'
PUBLIC	??_C@_09BJLKJKJF@?$CFs?4?$CFs_old@		; `string'
PUBLIC	??_C@_0O@FHDHJHFN@SysStatus_Log@		; `string'
PUBLIC	??_C@_0EH@MFNKNCE@?$AN?6?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d@ ; `string'
PUBLIC	??_C@_05OLKONLEL@?7?$CFs?$AN?6@			; `string'
PUBLIC	??_C@_06BEJGOBHG@?$CFs?4log@			; `string'
PUBLIC	??_C@_0BH@NMAKEFMG@TID?5?$CF?45lu?5ID?5?$CF?45i?5?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_0BE@GIEOINGB@?$DO?$DO?5ChkLogFileSz?0?5?$CFu@ ; `string'
PUBLIC	??_C@_0BJ@LGJHGBPF@?9?9?5ChkLogFileSz?0?5Opng?5?$CFs@ ; `string'
PUBLIC	??_C@_0BK@HOHICOFN@?9?9?5ChkLogFileSz?0?5?$CFs?5Sz?5?$CFu@ ; `string'
PUBLIC	??_C@_0M@HKKOHPEB@?$CFs?4?$CF?43d?4log@		; `string'
PUBLIC	??_C@_0CA@MGCLJDML@?9?9?5ChkLogFileSz?0?5Trying?5opng?5?$CFs@ ; `string'
PUBLIC	??_C@_0CD@DNFINAJK@?9?9?5ChkLogFileSz?0?5Last?5file?5fnd?3@ ; `string'
PUBLIC	??_C@_0CL@JDMPMEKE@?9?9?5ChkLogFileSz?0?5Removing?5?$CFs?5?9?5@ ; `string'
PUBLIC	??_C@_0CD@KIGAJNDH@?9?9?5ChkLogFileSz?0?5Renaming?5?$CFs?5?9?$DO@ ; `string'
PUBLIC	??_C@_0L@HLBMFDAN@?$CFs?4000?4log@		; `string'
PUBLIC	??_C@_0CE@EHOHNGJO@?9?9?5ChkLogFileSz?0?5Remaining?5?$CFs?5?9@ ; `string'
PUBLIC	??_C@_0BA@GCOGCGED@?$DM?$DM?5ChkLogFileSz@	; `string'
PUBLIC	??_C@_0L@MNPEAJCA@netmsg?4dll@			; `string'
PUBLIC	??_C@_04KKAJCPFA@Err?5@				; `string'
PUBLIC	??_C@_05EIGEDBOH@?5Msg?5@			; `string'
PUBLIC	??_C@_0BM@GCCDOOIB@?$CFs?5?$FLVID?3?$CFs?5PID?3?$CFs?5SN?3?$CFs?$FN?5?$CFs@ ; `string'
PUBLIC	??_C@_0BK@LNKKODAK@?9?9?5New?5DeviceName?5nullptr@ ; `string'
PUBLIC	??_C@_04CFJMJGDJ@?$CF?42X@			; `string'
PUBLIC	??_C@_0FI@PPGABHKA@?9?9?5Prevented?5attempt?5to?5set?5unh@ ; `string'
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll@		; `string'
PUBLIC	??_C@_0BM@EBDAABIF@SetUnhandledExceptionFilter@	; `string'
PUBLIC	??_C@_0CF@MLLEOGPJ@?$CFs_?$CF?44d?9?$CF?42d?9?$CF?42d_?$CF?42d?9?$CF?42d?9?$CF?42@ ; `string'
PUBLIC	??_C@_0DE@KOKEPHBJ@CreateMiniDump?0?5Created?5MiniDum@ ; `string'
PUBLIC	??_C@_0DD@IPHAABKL@CreateMiniDump?0?5Failed?5to?5creat@ ; `string'
PUBLIC	??_C@_0GA@GFOAHNCA@AppUnhndldExcptFltr?0?5Attempt?5to@ ; `string'
PUBLIC	??_C@_0CB@KLGENLFB@?$CFs?0?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5@ ; `string'
PUBLIC	??_C@_0BN@GOPGHHGJ@?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@ ; `string'
PUBLIC	??_C@_0DA@DAMKDCLP@?9?9?5SetThrdName?0?5Tp?5?$CFp?0?5Name?5?$CFs?0@ ; `string'
PUBLIC	??_C@_0DN@OLKMHNED@?$DO?$DO?5StartThrd?0?5Name?5?$CFs?0?5Func?5?$CFp?0@ ; `string'
PUBLIC	??_C@_0BP@FDECIAPH@?9?9?5StartThrd?0?5?$CFs?5Id?5?$CFu?0?5Hnd?5?$CFp@ ; `string'
PUBLIC	??_C@_0CB@LFOPNEOO@?9?9?5StartThrd?0?5No?5?$CFs?5thrd?5create@ ; `string'
PUBLIC	??_C@_0BB@POKBMEDO@?$DM?$DM?5StartThrd?0?5?$CFp@ ; `string'
PUBLIC	??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@ ; `string'
PUBLIC	??_C@_0BI@EBHNNPDK@?$DM?$DM?5StartThrd?0?5ret?5False@ ; `string'
PUBLIC	??_C@_0BJ@JJOKMIHG@?$DO?$DO?5EndPendgThrd?0?5Hndl?5?$CFp@ ; `string'
PUBLIC	??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@ ; `string'
PUBLIC	??_C@_0BH@FCCILLCE@RtlFreeUserThreadStack@	; `string'
PUBLIC	??_C@_0BA@OFOICJDM@?$DM?$DM?5EndPendgThrd@	; `string'
PUBLIC	??_C@_0GE@BJAJHKCK@?9?9?5WndProcMsg?0?5Wnd?5?$CFp?0?5Msg?50x?$CF?4@ ; `string'
PUBLIC	??_C@_0BK@GJJBBOEE@Session?5Closure?5Requested@	; `string'
PUBLIC	??_C@_0M@LLINGCEN@End?5Session@			; `string'
PUBLIC	??_C@_09KECABMHK@SysStatus@			; `string'
PUBLIC	??_C@_0CF@OJAKBKAK@User?5Defined?5?$CFs?0?5Size?5?$CFu?0?5DevTy@ ; `string'
PUBLIC	??_C@_03BBKEAIF@?$DP?$DP?$DP@			; `string'
PUBLIC	??_C@_09LGELGNNP@?$CCArrived?$CC@		; `string'
PUBLIC	??_C@_0BC@MMAEKGNO@?$CCRemoval?5Request?$CC@	; `string'
PUBLIC	??_C@_0BC@ENLMBDFJ@?$CCRemoval?5Aborted?$CC@	; `string'
PUBLIC	??_C@_0BC@MCANMMCL@?$CCRemoval?5Pending?$CC@	; `string'
PUBLIC	??_C@_09BCLHCEGD@?$CCRemoved?$CC@		; `string'
PUBLIC	??_C@_0BP@PNOLPDFB@Device?5?$CFs?0?5Size?5?$CFu?0?5DevType?5?$CFu@ ; `string'
PUBLIC	??_C@_0BM@HKOFJDPP@Usb?5CHANGE?5Dev?5?$DM?$CFs?5GUID?5?$CFs?$DO@ ; `string'
PUBLIC	??_C@_0M@FPDKOEDO@USB?5ARRIVAL@			; `string'
PUBLIC	??_C@_0M@ENJCMGFB@USB?5?5REMOVE@		; `string'
PUBLIC	??_C@_0CG@OJJDNJOH@Volume?5CHANGE?5?$DMFlags?5?$CFp?0?5UnitMa@ ; `string'
PUBLIC	??_C@_0CA@FNGBCCOE@Oem?5CHANGE?5?$DMId?5?$CFp?0?5SuppFunc?5?$CFp?$DO@ ; `string'
PUBLIC	??_C@_0BE@FJDGCJID@DevNode?5CHANGE?5?$DM?$CFp?$DO@ ; `string'
PUBLIC	??_C@_0BB@LPBNHOKC@Port?5CHANGE?5?$DM?$CFs?$DO@	; `string'
PUBLIC	??_C@_0CD@BNLENJBO@Net?5CHANGE?5?$DMResource?5?$CFp?0?5Flags?5@ ; `string'
PUBLIC	??_C@_0EN@GBOFOCLM@Handle?5CHANGE?5?$DMHandle?5?$CFp?0?5NameO@ ; `string'
PUBLIC	??_C@_0CK@KDAHPGC@Would?5you?5like?5to?5close?5this?5ap@ ; `string'
PUBLIC	??_C@_0P@BIPEBJDO@Exit?5Requested@		; `string'
PUBLIC	??_C@_0DC@MBHJGPCP@Would?5you?5like?5to?5quickly?5close@ ; `string'
PUBLIC	??_C@_0BF@CDGGKCEM@Quick?5Exit?5Requested@	; `string'
PUBLIC	??_C@_0L@EMLHDHFB@?$DO?$DO?5ThrdMsg@		; `string'
PUBLIC	??_C@_0BA@JDKJFHEL@SysStatusWClass@		; `string'
PUBLIC	??_C@_0BG@GPCBDAOG@?$DM?$DM?5ThrdMsg?0?5RegCls?5?$CFs@ ; `string'
PUBLIC	??_C@_0BJ@JFGPBNIN@?$DM?$DM?5ThrdMsg?0?5CreateWnd?5?$CFs@ ; `string'
PUBLIC	??_C@_0L@BACOFOKN@?$DM?$DM?5ThrdMsg@		; `string'
PUBLIC	??_C@_0BA@PGPPJDLP@?$DO?$DO?5ThrdUSB?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BP@GBFCDAOJ@?$DM?$DM?5ThrdUSB?0?5New?5USB?5class?5null@ ; `string'
PUBLIC	??_C@_0L@FFDNLHNK@?$DM?$DM?5ThrdUSB@		; `string'
PUBLIC	??_C@_0BB@JFPIPLLP@?$DO?$DO?5ProcInfo?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0CP@FFOKNKOI@Processes?5Information?0?5Number?5o@ ; `string'
PUBLIC	??_C@_0OJ@OBBIANJK@?$DO?5?5?5?5?5?5ProcessID?0?5Process?5Name?0@ ; `string'
PUBLIC	??_C@_09EEKGDCPH@?$DMunknown?$DO@		; `string'
PUBLIC	??_C@_0EJ@NBLNGMHL@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$CFs?0?5?$CFu?0?5?$CF02d?3?$CF02d@ ; `string'
PUBLIC	??_C@_0CF@LGHCMJEF@ProcessInfo?0?5OpenProcess?$CIPID?5?$CFl@ ; `string'
PUBLIC	??_C@_0EA@JFLIEPEA@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$DMunknown?$DO?0?5?$DP?0?5?$DP?$DP?3@ ; `string'
PUBLIC	??_C@_0BO@MOIJAHHG@ProcessInfo?0?5EnumProcesses?5?$CFs@ ; `string'
PUBLIC	??_C@_0M@LHLIHEIP@?$DM?$DM?5ProcInfo@		; `string'
PUBLIC	??_C@_0BC@BGHHFGNO@?$DO?$DO?5HwProfile?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0DA@OIKPBLGF@Hardware?5Profile?0?5DockInfo?5?$CFp?0?5@ ; `string'
PUBLIC	??_C@_0CC@OJDBEDNI@HwProfile?0?5GetCurrentHwProfile?5@ ; `string'
PUBLIC	??_C@_0N@DNDAOIDK@?$DM?$DM?5HwProfile@		; `string'
PUBLIC	??_C@_0BK@DFNBACLA@GetCurrentProcessorNumber@	; `string'
PUBLIC	??_C@_08PNLNEKOB@kernel32@			; `string'
PUBLIC	??_C@_0EH@HJFNKFOJ@?9?9?5CurrentProcessorNumber?0?5GetC@ ; `string'
PUBLIC	??_C@_0BA@KIDPDIJO@?$DO?$DO?5SysInfo?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BD@EBOFFHEB@x64?5?$CIAMD?5or?5Intel?$CJ@	; `string'
PUBLIC	??_C@_0BE@BAGOKCHN@Intel?5Itanium?9based@	; `string'
PUBLIC	??_C@_03NDFEINMN@x86@				; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_0FN@KGKHOIOF@Computer?3?5?$CFs?0?5Processor?$CIs?$CJ?5?$CFu?5?$CF@ ; `string'
PUBLIC	??_C@_0L@EJPMBDJN@?$DM?$DM?5SysInfo@		; `string'
PUBLIC	??_C@_0P@JFFCKGPB@?$DO?$DO?5OSInfo?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BC@LGEIIGCP@Domain?5Controller@		; `string'
PUBLIC	??_C@_06LGMEBDBC@Server@			; `string'
PUBLIC	??_C@_0M@CILGCIDH@Workstation@			; `string'
PUBLIC	??_C@_0EG@OPOFGEHK@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@ ; `string'
PUBLIC	??_C@_0BN@NMBMIHHC@OSInfo?0?5VerifyVersionInfo?5?$CFs@ ; `string'
PUBLIC	??_C@_0CK@HOFAFFOO@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@ ; `string'
PUBLIC	??_C@_09EHLFKBJE@?$DM?$DM?5OSInfo@		; `string'
PUBLIC	??_C@_0P@CFMOGLIC@?$DO?$DO?5SysMem?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0O@OAHOAHIO@System?5Memory@		; `string'
PUBLIC	??_C@_0BB@DIEGGMCF@Usage?3?5?$CFu?$CF?$CF?5used@ ; `string'
PUBLIC	??_C@_0CC@JHNBDNDC@Physical?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@ ; `string'
PUBLIC	??_C@_0CC@PBKOHCPF@Pagefile?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@ ; `string'
PUBLIC	??_C@_0DB@BKHHAKDB@Virtual?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5avai@ ; `string'
PUBLIC	??_C@_09CIJKANFC@?$DM?$DM?5SysMem@		; `string'
PUBLIC	??_C@_0BB@FODCFBGJ@?$DO?$DO?5SysTimes?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0N@HHJCFDFH@System?5Times@		; `string'
PUBLIC	??_C@_0CE@PJKLEAEE@Kernel?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu@ ; `string'
PUBLIC	??_C@_0CC@JKEHGGOG@User?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s@ ; `string'
PUBLIC	??_C@_0BN@JFNEHINJ@Idle?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s?$CJ?4@ ; `string'
PUBLIC	??_C@_0DP@OCMJGDEB@Processor?3?5?$CFI64u?5counts?0?5?$CFI64u?5@ ; `string'
PUBLIC	??_C@_0M@FNBLPGFN@?$DM?$DM?5SysTimes@		; `string'
PUBLIC	??_C@_09MOKIPJGJ@NoRootDir@			; `string'
PUBLIC	??_C@_05OCBIINAK@Fixed@				; `string'
PUBLIC	??_C@_06MHHFENDB@Remote@			; `string'
PUBLIC	??_C@_05JIFOIGMJ@CDRom@				; `string'
PUBLIC	??_C@_07CPJGKNJN@RamDisk@			; `string'
PUBLIC	??_C@_0BA@KFINEJGA@?$DO?$DO?5LogDrvs?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0CA@BGDEGNDO@Logical?5Drivers?5?$CFu?$CI?$CFu?$CJ?5?$CI0x?$CF?48X?$CJ@ ; `string'
PUBLIC	??_C@_0BJ@BENIJAPK@?$DO?$DO?5?$CF?43d?0?5?$CFs?3?5Type?5?$CFs?$CI?$CFu?$CJ@ ; `string'
PUBLIC	??_C@_0GE@JMDLMJNN@?5?5?5VolumeInfo?0?5Name?5?$CFs?0?5SerialN@ ; `string'
PUBLIC	??_C@_0GJ@NOKMBBI@?5?5?5FreeSpace?0?5SectorsPerCluster@ ; `string'
PUBLIC	??_C@_0L@GICAALNI@?$DM?$DM?5LogDrvs@		; `string'
PUBLIC	??_C@_0BA@GBCPBHIM@?$DO?$DO?5SysDirs?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BD@OAHOLNHD@System?5Directories@		; `string'
PUBLIC	??_C@_09LGICPEGI@SysDir?5?$CFs@			; `string'
PUBLIC	??_C@_0M@JFNOOIEA@TempPath?5?$CFs@		; `string'
PUBLIC	??_C@_09PEBHDCJJ@WinDir?5?$CFs@			; `string'
PUBLIC	??_C@_0N@JJNMAABC@WinSysDir?5?$CFs@		; `string'
PUBLIC	??_C@_0L@NBODLJGE@?$DM?$DM?5SysDirs@		; `string'
PUBLIC	??_C@_0BH@MFPGFEAK@?$DO?$DO?5SysLogProcInfo?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BP@KHGALBC@GetLogicalProcessorInformation@ ; `string'
PUBLIC	??_C@_0DO@CNICBAHJ@?$DM?$DM?5SysLogProcInfo?0?5Out?0?5Unsupp?5@ ; `string'
PUBLIC	??_C@_0CG@LHEIAGGO@?9?9?5SysLogProcInfo?0?5Allocation?5f@ ; `string'
PUBLIC	??_C@_0BL@KHIEGLFN@?9?9?5SysLogProcInfo?0?5GLPI?5?$CFs@ ; `string'
PUBLIC	??_C@_0EC@BGADHKMF@?9?9?5SysLogProcInfo?0?5Unsupp?5LOGIC@ ; `string'
PUBLIC	??_C@_0CB@ECHENMHH@Logical?5Processor?$CIs?$CJ?5Informatio@ ; `string'
PUBLIC	??_C@_0BJ@CBGNJNLO@Number?5of?5NUMA?5nodes?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CK@CIFFOGGE@Number?5of?5physical?5processor?5pa@ ; `string'
PUBLIC	??_C@_0BO@JLJNFPPO@Number?5of?5processor?5cores?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CB@NEBFNBCF@Number?5of?5logical?5processors?3?5?$CF@ ; `string'
PUBLIC	??_C@_0CO@JLHKKOJE@Number?5of?5processor?5L1?1L2?1L3?5ca@ ; `string'
PUBLIC	??_C@_0BC@BKCMKMCI@?$DM?$DM?5SysLogProcInfo@	; `string'
PUBLIC	??_C@_0BA@HKMBGJGH@?$DO?$DO?5DevDrvs?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BO@PHKHDLGJ@Device?5Drivers?0?5Number?5of?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0BA@DGAJHBGD@?$DO?5?$CF?43zu?0?5?$CFs?0?5?$CFs@ ; `string'
PUBLIC	??_C@_0DF@CJPNLIJE@DevDrvs?0?5EnumDeviceDrivers?5?$CFs?5?$CI@ ; `string'
PUBLIC	??_C@_0L@NHDPJOBN@?$DM?$DM?5DevDrvs@		; `string'
PUBLIC	??_C@_0BB@LPGMBLGN@?$DO?$DO?5PerfInfo?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BI@ECNHKKAA@Performance?5Information@	; `string'
PUBLIC	??_C@_0CE@ONMEHFLA@Commit?3?5Total?5?$CFu?0?5Limit?5?$CFu?0?5Pea@ ; `string'
PUBLIC	??_C@_0CB@KFDPCIGB@Physical?3?5Total?5?$CFu?0?5Available?5?$CF@ ; `string'
PUBLIC	??_C@_0BA@DCNNFMJH@System?5Cache?5?$CFu@	; `string'
PUBLIC	??_C@_0CI@POMBEGEK@Kernel?3?5Total?5?$CFu?0?5Paged?5?$CFu?0?5Non@ ; `string'
PUBLIC	??_C@_0N@HEDGONEI@Page?5Size?5?$CFu@		; `string'
PUBLIC	??_C@_0CD@DBCKLHBG@Process?5?$CFu?0?5Handles?5?$CFu?0?5Threads@ ; `string'
PUBLIC	??_C@_0CA@JENOJKFE@PerfInfo?0?5GetPerformanceInfo?5?$CFs@ ; `string'
PUBLIC	??_C@_0M@JHACCAAA@?$DM?$DM?5PerfInfo@		; `string'
PUBLIC	??_C@_0P@CKNBFJNB@?$DO?$DO?5GetPtrsList@	; `string'
PUBLIC	??_C@_0BL@CMACENMK@?$DM?$DM?5GetPtrsList?0?5No?5Printer@ ; `string'
PUBLIC	??_C@_0CB@CEENFMON@?$DM?$DM?5GetPtrsList?0?5new?5PtrInfo?5nul@ ; `string'
PUBLIC	??_C@_0CA@CCAKGGPA@?$DM?$DM?5GetPtrsList?0?5EnumPrinters?5?$CFs@ ; `string'
PUBLIC	??_C@_0CF@POBEDBNN@?$DM?$DM?5GetPtrsList?0?5new?5PrtInfoList@ ; `string'
PUBLIC	??_C@_0BL@DODNOLI@Printers?5Information?5?$CI?$CFd?$CJ?3@ ; `string'
PUBLIC	??_C@_0FD@LPLLHANM@?$DO?5?5?5?5?5Printer?0?5Port?0?5Driver?0?5Pr@ ; `string'
PUBLIC	??_C@_0P@EABBNIJO@?$DMLocalPrinter?$DO@		; `string'
PUBLIC	??_C@_0DB@OBDCAEAF@?$DO?5?$CF?42d?3?5?2?2?$CFs?2?$CFs?0?5?5?$CFs?0?5?$CFs?0?5?$CFs?0?5?$CF@ ; `string'
PUBLIC	??_C@_0P@GDDJCMON@?$DM?$DM?5GetPtrsList@	; `string'
PUBLIC	??_C@_0CA@MEDOMPCD@?$DO?$DO?5GetBinList?0?5Name?5?$CFs?0?5Port?5?$CFs@ ; `string'
PUBLIC	??_C@_0DE@FGDAMBLB@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@ ; `string'
PUBLIC	??_C@_0CJ@MFGEJMEH@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINS@ ; `string'
PUBLIC	??_C@_0DD@GBLOLICC@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5PTRDATA@ ; `string'
PUBLIC	??_C@_0DC@FCIPFBFM@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@ ; `string'
PUBLIC	??_C@_0CN@HGGHLGCE@?9?9?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINN@ ; `string'
PUBLIC	??_C@_0DG@HABDBBMM@?9?9?5GetBinList?0?5DeviceCapabiliti@ ; `string'
PUBLIC	??_C@_0BH@CEPOJCOE@?$DM?$DM?5GetBinList?0?5List?5?$CFp@ ; `string'
PUBLIC	??_C@_0CC@ONAFHJDF@?$DO?$DO?5GetPaperList?0?5Name?5?$CFs?0?5Port?5@ ; `string'
PUBLIC	??_C@_0DI@CDPGKELL@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@ ; `string'
PUBLIC	??_C@_0CN@BIOGLDPF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@ ; `string'
PUBLIC	??_C@_0DF@MINJLAHF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5PTRDA@ ; `string'
PUBLIC	??_C@_0DG@CIOANDHH@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@ ; `string'
PUBLIC	??_C@_0DA@NJCIHNJI@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@ ; `string'
PUBLIC	??_C@_0DJ@BNKOAMAF@?9?9?5GetPaperList?0?5DeviceCapabili@ ; `string'
PUBLIC	??_C@_0DB@DLBCIEDL@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@ ; `string'
PUBLIC	??_C@_0DK@CGKLJHJE@?9?9?5GetPaperList?0?5DeviceCapabili@ ; `string'
PUBLIC	??_C@_0BJ@HGBNGAMD@?$DM?$DM?5GetPaperList?0?5List?5?$CFp@ ; `string'
PUBLIC	??_C@_0CG@PBHDOEPC@?$DO?$DO?5GetMediaTypeList?0?5Name?5?$CFs?0?5P@ ; `string'
PUBLIC	??_C@_0EA@NNAOKLFO@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@ ; `string'
PUBLIC	??_C@_0DF@EKPICGIC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@ ; `string'
PUBLIC	??_C@_0DJ@IAEPPFOH@?$DM?$DM?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5P@ ; `string'
PUBLIC	??_C@_0DO@OFONMAMJ@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@ ; `string'
PUBLIC	??_C@_0DJ@CAKMLHPC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@ ; `string'
PUBLIC	??_C@_0EC@ONNFKLG@?9?9?5GetMediaTypeList?0?5DeviceCapa@ ; `string'
PUBLIC	??_C@_0BN@IBLEBHCE@?$DM?$DM?5GetMediaTypeList?0?5List?5?$CFp@ ; `string'
PUBLIC	??_C@_0BA@EKNEIKHO@?$DO?$DO?5PtrInfo?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BH@ENEDNFCI@?$DM?$DM?5PtrInfo?0?5No?5Printer@ ; `string'
PUBLIC	??_C@_0BN@HOILGMMA@?$DM?$DM?5PtrInfo?0?5PtrInfoList?5null@ ; `string'
PUBLIC	??_C@_0CG@GNJLFBNH@Info?5from?5?$CFs?0?5Port?5?$CFs?0?5Driver?5?$CF@ ; `string'
PUBLIC	??_C@_0DM@DLHDGDPE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0DB@OINKGGOI@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_ENUMRES@ ; `string'
PUBLIC	??_C@_0DK@HALEOHFL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0BJ@PLJPAGFI@DC_ENUMRESOLUTIONS?5?$CI?$CFd?$CJ?3@ ; `string'
PUBLIC	??_C@_0P@OBKMFCDP@?$DO?$CF?42d?3?5?$CFu?5x?5?$CFu@ ; `string'
PUBLIC	??_C@_0BL@IBIADDJ@DC_BINS?0?5DC_BINNAMES?5?$CI?$CFd?$CJ?3@ ; `string'
PUBLIC	??_C@_0O@KDMGFAIN@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs@ ; `string'
PUBLIC	??_C@_0CP@BNOBPGPC@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@ ; `string'
PUBLIC	??_C@_0CN@GKNAEPGN@DC_PAPERS?0?5DC_PAPERNAMES?0?5DC_PA@ ; `string'
PUBLIC	??_C@_0BJ@ENBLCNAO@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs?0?5?$CF?45d?5?$CF?45d@ ; `string'
PUBLIC	??_C@_0DB@CMDEFNNK@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@ ; `string'
PUBLIC	??_C@_0BC@NAFPPPIH@DC_ORIENTATION?5?$CFd@	; `string'
PUBLIC	??_C@_0N@GOBEBGOJ@DC_COPIES?5?$CFd@		; `string'
PUBLIC	??_C@_0O@CECDKEDL@DC_COLLATE?5?$CFd@		; `string'
PUBLIC	??_C@_0BC@CPGDDBNJ@DC_COLORDEVICE?5?$CFd@	; `string'
PUBLIC	??_C@_0N@JAMONLMJ@DC_DUPLEX?5?$CFd@		; `string'
PUBLIC	??_C@_0N@BOEFEHCB@DC_DRIVER?5?$CFd@		; `string'
PUBLIC	??_C@_0O@BHGLDB@DC_VERSION?5?$CFd@		; `string'
PUBLIC	??_C@_0N@FMBEEHK@DC_FIELDS?5?$CFu@		; `string'
PUBLIC	??_C@_0CC@HHEJCDLL@DC_MAXEXTENT?3?5Length?5?$CFu?0?5Width?5@ ; `string'
PUBLIC	??_C@_0CC@FIJGGACG@DC_MINEXTENT?3?5Length?5?$CFu?0?5Width?5@ ; `string'
PUBLIC	??_C@_0L@ICJGKLML@DC_SIZE?5?$CFd@		; `string'
PUBLIC	??_C@_0N@ONNHJAOP@DC_STAPLE?5?$CFd@		; `string'
PUBLIC	??_C@_0P@MLIHNHLK@DC_TRUETYPE?5?$CFd@		; `string'
PUBLIC	??_C@_0DA@BHONBGKL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0CF@DGNIMKMD@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_NUP?5mem@ ; `string'
PUBLIC	??_C@_0CO@CJKPCGLF@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0N@EHIGBDLP@DC_NUP?5?$CI?$CFd?$CJ?3@	; `string'
PUBLIC	??_C@_09MFCBGNBM@?$DO?$CF?42d?3?5?$CFu@		; `string'
PUBLIC	??_C@_0DN@GGKKNNDH@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0DC@MCOOCAIH@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_FILEDEP@ ; `string'
PUBLIC	??_C@_0DL@NOJMDJGA@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0BK@NAHDGPCH@DC_FILEDEPENDENCIES?5?$CI?$CFd?$CJ?3@ ; `string'
PUBLIC	??_C@_09JDHLMKJK@?$DO?$CF?42d?3?5?$CFs@		; `string'
PUBLIC	??_C@_0DH@GEGMAAP@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0CM@KMOLCCC@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_MEDIARE@ ; `string'
PUBLIC	??_C@_0DF@POBLKCNL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0BE@JHLOAEJA@DC_MEDIAREADY?5?$CI?$CFd?$CJ?3@ ; `string'
PUBLIC	??_C@_0CH@OFCLBKDH@DC_MEDIATYPES?0?5DC_MEDIATYPENAME@ ; `string'
PUBLIC	??_C@_0DF@CIBLFONP@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@ ; `string'
PUBLIC	??_C@_0DI@PACCMPGC@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0CN@FDCGHEM@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_PERSONA@ ; `string'
PUBLIC	??_C@_0DG@NKFBLOLE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ ; `string'
PUBLIC	??_C@_0BF@JJAELOOF@DC_PERSONALITY?5?$CI?$CFd?$CJ?3@ ; `string'
PUBLIC	??_C@_08JFBLCBEM@DEVMODE?3@			; `string'
PUBLIC	??_C@_0BA@KDNAKNNN@?$DO?5DeviceName?5?$CFs@	; `string'
PUBLIC	??_C@_0BB@GFIGJBOF@?$DO?5SpecVersion?5?$CFd@	; `string'
PUBLIC	??_C@_0BD@FHCKIAEA@?$DO?5DriverVersion?5?$CFd@	; `string'
PUBLIC	??_C@_09EJHHAJLO@?$DO?5Size?5?$CFd@		; `string'
PUBLIC	??_C@_0BB@NFLJLFB@?$DO?5DriverExtra?5?$CFd@	; `string'
PUBLIC	??_C@_0BG@JDMKIO@?$DO?5DriverFields?50x?$CF?48X@ ; `string'
PUBLIC	??_C@_0M@PJOJJBEC@?$DO?5Orient?5?$CFd@		; `string'
PUBLIC	??_C@_0P@MIJBPCPJ@?$DO?5PaperSize?5?$CFd@	; `string'
PUBLIC	??_C@_0BB@NFCPDFAH@?$DO?5PaperLength?5?$CFd@	; `string'
PUBLIC	??_C@_0BA@EJLKBGAF@?$DO?5PaperWidth?5?$CFd@	; `string'
PUBLIC	??_C@_0L@CIICACOJ@?$DO?5Scale?5?$CFd@		; `string'
PUBLIC	??_C@_0M@MCOJLIEN@?$DO?5Copies?5?$CFd@		; `string'
PUBLIC	??_C@_0BD@PBLNKDE@?$DO?5DefaultSource?5?$CFd@	; `string'
PUBLIC	??_C@_0BB@FEEDGEPE@?$DO?5PrintQulity?5?$CFd@	; `string'
PUBLIC	??_C@_0L@OGGOANCL@?$DO?5Color?5?$CFd@		; `string'
PUBLIC	??_C@_0M@DMDDHFGN@?$DO?5Duplex?5?$CFd@		; `string'
PUBLIC	??_C@_0BB@ODANIHPJ@?$DO?5YResolution?5?$CFd@	; `string'
PUBLIC	??_C@_0O@ODMOOLLN@?$DO?5TTOption?5?$CFd@	; `string'
PUBLIC	??_C@_0N@DEPFBBGA@?$DO?5Collate?5?$CFd@		; `string'
PUBLIC	??_C@_0O@NAFNONHG@?$DO?5FormName?5?$CFs@	; `string'
PUBLIC	??_C@_0P@HBAMONIO@?$DO?5LogPixels?5?$CFd@	; `string'
PUBLIC	??_C@_0BA@IJGBMLDF@?$DO?5BitsPerPel?5?$CFu@	; `string'
PUBLIC	??_C@_0P@GJDEABGN@?$DO?5PelsWidth?5?$CFu@	; `string'
PUBLIC	??_C@_0BA@FJKIIKDN@?$DO?5PelsHeight?5?$CFd@	; `string'
PUBLIC	??_C@_0P@BALKIIFI@?$DO?5ICMMethod?5?$CFu@	; `string'
PUBLIC	??_C@_0P@FBGPJDBI@?$DO?5ICMIntent?5?$CFu@	; `string'
PUBLIC	??_C@_0P@DGLLLDPA@?$DO?5MediaType?5?$CFu@	; `string'
PUBLIC	??_C@_0BA@IBDIEDAP@?$DO?5DitherType?5?$CFu@	; `string'
PUBLIC	??_C@_0P@ODIJDFHK@?$DO?5Reserved1?5?$CFu@	; `string'
PUBLIC	??_C@_0P@KECJEPKK@?$DO?5Reserved2?5?$CFu@	; `string'
PUBLIC	??_C@_0BC@ILEBHAGL@?$DO?5PanningWidth?5?$CFu@	; `string'
PUBLIC	??_C@_0BD@ODPAHJGJ@?$DO?5PanningHeight?5?$CFu@	; `string'
PUBLIC	??_C@_0BL@NKEHJDBP@?9?9?5PtrInfo?0?5OpenPrinter?5?$CFs@ ; `string'
PUBLIC	??_C@_0M@CPAOAHIM@DeviceCaps?3@			; `string'
PUBLIC	??_C@_0BD@JDPBNNPN@?$DO?5DRIVERVERSION?5?$CFd@	; `string'
PUBLIC	??_C@_0BA@KDKPJOH@?$DO?5TECHNOLOGY?5?$CFd@	; `string'
PUBLIC	??_C@_0O@HMCMNAPC@?$DO?5HORZSIZE?5?$CFd@	; `string'
PUBLIC	??_C@_0O@LDGIGNAG@?$DO?5VERTSIZE?5?$CFd@	; `string'
PUBLIC	??_C@_0N@IFBEPCKP@?$DO?5HORZRES?5?$CFd@		; `string'
PUBLIC	??_C@_0N@HLDMJPJJ@?$DO?5VERTRES?5?$CFd@		; `string'
PUBLIC	??_C@_0P@CHMKJDGJ@?$DO?5BITSPIXEL?5?$CFd@	; `string'
PUBLIC	??_C@_0M@DABMECAD@?$DO?5PLANES?5?$CFd@		; `string'
PUBLIC	??_C@_0BA@GCBODPHK@?$DO?5NUMBRUSHES?5?$CFd@	; `string'
PUBLIC	??_C@_0N@HHCKOKCG@?$DO?5NUMPENS?5?$CFd@		; `string'
PUBLIC	??_C@_0BA@IJEEOFOD@?$DO?5NUMMARKERS?5?$CFd@	; `string'
PUBLIC	??_C@_0O@HIAAJLOF@?$DO?5NUMFONTS?5?$CFd@	; `string'
PUBLIC	??_C@_0P@CDPEOCLN@?$DO?5NUMCOLORS?5?$CFd@	; `string'
PUBLIC	??_C@_0BB@BIAFAHJC@?$DO?5PDEVICESIZE?5?$CFd@	; `string'
PUBLIC	??_C@_0P@MJKILKAG@?$DO?5CURVECAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0O@NIBLPDAA@?$DO?5LINECAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0BD@NDEFMMIK@?$DO?5POLYGONALCAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0O@EJBOFNFI@?$DO?5TEXTCAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0O@NPFDNMHE@?$DO?5CLIPCAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0BA@OCKGHOJF@?$DO?5RASTERCAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0N@DGFFNBBI@?$DO?5ASPECTX?5?$CFd@		; `string'
PUBLIC	??_C@_0N@LDFPIKI@?$DO?5ASPECTY?5?$CFd@		; `string'
PUBLIC	??_C@_0O@KAIPPGFP@?$DO?5ASPECTXY?5?$CFd@	; `string'
PUBLIC	??_C@_0BA@NDEAPPCA@?$DO?5LOGPIXELSX?5?$CFd@	; `string'
PUBLIC	??_C@_0BA@OOCANGJA@?$DO?5LOGPIXELSY?5?$CFd@	; `string'
PUBLIC	??_C@_0BB@KNEJGJKJ@?$DO?5SIZEPALETTE?5?$CFd@	; `string'
PUBLIC	??_C@_0BB@KMMENDMI@?$DO?5NUMRESERVED?5?$CFd@	; `string'
PUBLIC	??_C@_0O@GGNNNIFP@?$DO?5COLORRES?5?$CFd@	; `string'
PUBLIC	??_C@_0BD@HDEIPKKB@?$DO?5PHYSICALWIDTH?5?$CFd@	; `string'
PUBLIC	??_C@_0BE@BHEFJOBO@?$DO?5PHYSICALHEIGHT?5?$CFd@	; `string'
PUBLIC	??_C@_0BF@PADOFFNF@?$DO?5PHYSICALOFFSETX?5?$CFd@ ; `string'
PUBLIC	??_C@_0BF@MNFOHMGF@?$DO?5PHYSICALOFFSETY?5?$CFd@ ; `string'
PUBLIC	??_C@_0BE@LLMKMDFO@?$DO?5SCALINGFACTORX?5?$CFd@	; `string'
PUBLIC	??_C@_0BE@IGKKOKOO@?$DO?5SCALINGFACTORY?5?$CFd@	; `string'
PUBLIC	??_C@_0O@KHHELDLL@?$DO?5VREFRESH?5?$CFd@	; `string'
PUBLIC	??_C@_0BE@COAHGLLD@?$DO?5DESKTOPVERTRES?5?$CFd@	; `string'
PUBLIC	??_C@_0BE@NACPAGIF@?$DO?5DESKTOPHORZRES?5?$CFd@	; `string'
PUBLIC	??_C@_0BC@JFPGOKHF@?$DO?5BLTALIGNMENT?5?$CFd@	; `string'
PUBLIC	??_C@_0BE@BAMFBECL@?$DO?5SHADEBLENDCAPS?5?$CFd@	; `string'
PUBLIC	??_C@_0BD@DKIEMMJN@?$DO?5COLORMGMTCAPS?5?$CFd@	; `string'
PUBLIC	??_C@_09IGELCPAM@Layout?5?$CFu@			; `string'
PUBLIC	??_C@_0O@FBFECABI@DEFAULT?5FONT?3@		; `string'
PUBLIC	??_C@_0M@JCFCFHLH@?$DO?5Height?5?$CFd@		; `string'
PUBLIC	??_C@_0L@KBIDCEMN@?$DO?5Width?5?$CFd@		; `string'
PUBLIC	??_C@_0P@DLDGLOB@?$DO?5Escapment?5?$CFd@	; `string'
PUBLIC	??_C@_0BB@DFLFEINK@?$DO?5Orientation?5?$CFd@	; `string'
PUBLIC	??_C@_0M@EEPHINNC@?$DO?5Weight?5?$CFd@		; `string'
PUBLIC	??_C@_0P@FOGJLDPM@?$DO?5Italic?5?$CF?42Xh@	; `string'
PUBLIC	??_C@_0BC@IHAMIHEE@?$DO?5Underline?5?$CF?42Xh@	; `string'
PUBLIC	??_C@_0BC@MFABLFLO@?$DO?5StrikeOut?5?$CF?42Xh@	; `string'
PUBLIC	??_C@_0BA@CJMDNNAL@?$DO?5CharSet?5?$CF?42Xh@	; `string'
PUBLIC	??_C@_0BF@IIGPOAFP@?$DO?5OutPrecision?5?$CF?42Xh@ ; `string'
PUBLIC	??_C@_0BG@FHJOGBNN@?$DO?5ClipPrecision?5?$CF?42Xh@ ; `string'
PUBLIC	??_C@_0BA@PONLFNLB@?$DO?5Quality?5?$CF?42Xh@	; `string'
PUBLIC	??_C@_0BH@FCEMNLND@?$DO?5PitchAndFamily?5?$CF?42Xh@ ; `string'
PUBLIC	??_C@_0O@PBJPIOLO@?$DO?5FaceName?5?$CFs@	; `string'
PUBLIC	??_C@_0BN@PNGCEDEF@?9?9?5PtrInfo?0?5new?5LOGFONT?5null@ ; `string'
PUBLIC	??_C@_0BI@CCOPIFBO@?9?9?5PtrInfo?0?5CreateIC?5?$CFs@ ; `string'
PUBLIC	??_C@_0L@GNPIKGBL@?$DM?$DM?5PtrInfo@		; `string'
PUBLIC	??_C@_04HPMIDMKH@True@				; `string'
PUBLIC	??_C@_05MKDOIIA@False@				; `string'
PUBLIC	??_C@_0BJ@JNNHNEI@?$DO?$DO?5GetSysIPAddrs?0?5?$CFp?0?5?$CFs@ ; `string'
PUBLIC	??_C@_0BD@JGGPHJBD@IP?5Addresses?5?$CI?$CFu?$CJ?3@ ; `string'
PUBLIC	??_C@_09BDGNKGNI@?$DO?5?$CF02u?5?$CFs@		; `string'
PUBLIC	??_C@_0BB@CMFNMPNL@?$DM?$DM?5GetSysIPAddrs@	; `string'
PUBLIC	??_C@_0O@BHNLPBFJ@?$DO?$DO?5GetSysDets@		; `string'
PUBLIC	??_C@_09NLLCGGEI@HwProfile@			; `string'
PUBLIC	??_C@_07JFBHEENG@SysInfo@			; `string'
PUBLIC	??_C@_06HKOPCFLK@OSInfo@			; `string'
PUBLIC	??_C@_0BA@JCIBBNDO@SysLogPrcsrInfo@		; `string'
PUBLIC	??_C@_07NAIOOCP@SysDirs@			; `string'
PUBLIC	??_C@_0O@JGOJIALP@?$DM?$DM?5GetSysDets@		; `string'
PUBLIC	??_C@_0N@DKCIAKLO@?$DO?$DO?5GetSysSts@		; `string'
PUBLIC	??_C@_08LMMJIFBC@SysTimes@			; `string'
PUBLIC	??_C@_06BFMAIJHM@SysMem@			; `string'
PUBLIC	??_C@_08HGNAFDEP@PerfInfo@			; `string'
PUBLIC	??_C@_08FGGKAHMA@ProcInfo@			; `string'
PUBLIC	??_C@_0N@LGEPCBGK@?$DM?$DM?5GetSysSts@		; `string'
PUBLIC	??_C@_07LEMLFMJD@LogDrvs@			; `string'
PUBLIC	??_C@_03IONNGCBN@USB@				; `string'
PUBLIC	??_C@_08IHNDGAAK@DevDrvrs@			; `string'
PUBLIC	??_C@_07LBBDPBFA@PtrInfo@			; `string'
PUBLIC	??_C@_0BH@HFGKIIBM@?$DO?$DO?5ThrdWMISysPerf?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BC@DBJGMMHB@?$DM?$DM?5ThrdWMISysPerf@	; `string'
PUBLIC	??_C@_0BG@GEAKCKEN@?$DO?$DO?5ThrdWMIHwSnsr?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BB@MKNOIMND@?$DM?$DM?5ThrdWMIHwSnsr@	; `string'
PUBLIC	??_C@_0BH@LBINOCLF@?$DO?$DO?5ThrdWMISysVols?5?$CI?$CFp?$CJ@ ; `string'
PUBLIC	??_C@_0BC@PAGGLBNL@?$DM?$DM?5ThrdWMISysVols@	; `string'
PUBLIC	??_C@_0N@LKBNMLDB@?$DO?$DO?5GetWMISts@		; `string'
PUBLIC	??_C@_0L@KDFOBJKP@WMISysPerf@			; `string'
PUBLIC	??_C@_09NAIFMJBP@WMIHwSnsr@			; `string'
PUBLIC	??_C@_0L@GCKOGEAF@WMISysVols@			; `string'
PUBLIC	??_C@_0N@DGHKOAOF@?$DM?$DM?5GetWMISts@		; `string'
PUBLIC	??_C@_06CKGENIKG@Enable@			; `string'
PUBLIC	??_C@_07MIKIFGAL@Disable@			; `string'
PUBLIC	??_C@_0BM@PMAFNLMJ@?$DO?$DO?5ModifyPrivilege?3?5?$CFs?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_0CI@FBLPGCLK@?$DM?$DM?5ModifyPrivilege?0?5OpenProcess@ ; `string'
PUBLIC	??_C@_0CN@CCHLMIMA@?$DM?$DM?5ModifyPrivilege?0?5AdjustToken@ ; `string'
PUBLIC	??_C@_0BD@NDFMDBME@?$DM?$DM?5ModifyPrivilege@	; `string'
PUBLIC	??_C@_0BC@CGDDBBID@?$DO?$DO?5AdjtProcRights@	; `string'
PUBLIC	??_C@_0BE@COMAOBFG@SeSecurityPrivilege@		; `string'
PUBLIC	??_C@_0DN@CNCGHAJP@?9?9?5AdjtProcRights?0?5Successfully@ ; `string'
PUBLIC	??_C@_0BG@PKIMIEFE@?9?9?5AdjtProcRights?0?5?$CFs@ ; `string'
PUBLIC	??_C@_0BC@PHNLOKMH@?$DM?$DM?5AdjtProcRights@	; `string'
PUBLIC	??_C@_07GKIGKNOK@runonce@			; `string'
PUBLIC	??_C@_07KNKAAJIE@sysinfo@			; `string'
PUBLIC	??_C@_08DDBLHJBD@nowindow@			; `string'
PUBLIC	??_C@_05NAPFDJNG@timer@				; `string'
PUBLIC	??_C@_07MMCGMGHO@logsize@			; `string'
PUBLIC	??_C@_09OBKGEPKB@appendlog@			; `string'
PUBLIC	??_C@_06BCHOJLEN@logdir@			; `string'
PUBLIC	??_C@_0N@MHPPNGIP@?$CFs?2SysStatus@		; `string'
PUBLIC	??_C@_0M@NLCNCKHJ@?$CFsSysStatus@		; `string'
PUBLIC	??_C@_0L@PGBNDJPK@?$DO?$DO?5WinMain@		; `string'
PUBLIC	??_C@_0BG@FONLKPFK@SysStatus?0?5CmdLine?5?$CFs@	; `string'
PUBLIC	??_C@_07MMMFAJOG@ThrdMsg@			; `string'
PUBLIC	??_C@_06NNJPAOHJ@ThrWMI@			; `string'
PUBLIC	??_C@_03CCLAEDDF@Yes@				; `string'
PUBLIC	??_C@_02JINPPBEP@No@				; `string'
PUBLIC	??_C@_0BH@ICNNMNOE@Net?5Alive?$DP?5?$CFs?0?5Type?5?$CFu@ ; `string'
PUBLIC	??_C@_0M@MNGEFCAN@Net?5Chkg?5?$CFs@		; `string'
PUBLIC	??_C@_0CA@IBENHIJM@?9?9?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@ ; `string'
PUBLIC	??_C@_0CG@DLNNNFPM@SysStatus?5?9?5Running?5for?5?$CF02llu?3@ ; `string'
PUBLIC	??_C@_0BM@DDANBCKI@?9?9?5WinMain?0?5Wait?5ThrdMsg?5?$CFu@ ; `string'
PUBLIC	??_C@_06EMJDEMAB@?$CF?49f?5s@			; `string'
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@ ; `string'
PUBLIC	?ghWnd@@3PAUHWND__@@A				; ghWnd
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	?gbShutdown@@3HA				; gbShutdown
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?gbForceChecking@@3HA				; gbForceChecking
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?gszLogFilePrefix@@3PADA			; gszLogFilePrefix
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	?gbTerminate@@3HA				; gbTerminate
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	?gpPrinterInfoList@@3PAU_printer_info_list_@@A	; gpPrinterInfoList
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	?gTickStart@@3_KA				; gTickStart
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	?ghInstance@@3PAUHINSTANCE__@@A			; ghInstance
EXTRN	__imp__SetUnhandledExceptionFilter@4:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__GetComputerNameA@8:PROC
EXTRN	__imp__DocumentPropertiesA@24:PROC
EXTRN	__imp__GetProcessTimes@20:PROC
EXTRN	__imp__GetProcessHandleCount@8:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__SetEntriesInAclA@16:PROC
EXTRN	__imp__AdjustTokenPrivileges@24:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	_isdigit:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__Query_perf_counter:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__K32EnumProcessModules@16:PROC
EXTRN	_strchr:PROC
EXTRN	__imp__K32GetPerformanceInfo@8:PROC
EXTRN	_strstr:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__GetLayout@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GlobalMemoryStatusEx@4:PROC
EXTRN	__imp__GetCurrentHwProfileA@4:PROC
EXTRN	__imp__OpenPrinterA@12:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	_atoi:PROC
EXTRN	_free:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__UnregisterWaitEx@8:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp__GetLogicalDriveStringsA@8:PROC
EXTRN	__strlwr:PROC
EXTRN	__imp__K32EnumProcesses@12:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp__IsNetworkAlive@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__GetWindowsDirectoryA@8:PROC
EXTRN	__imp__LookupPrivilegeValueA@12:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__K32GetModuleBaseNameA@16:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__FileTimeToSystemTime@8:PROC
EXTRN	__imp__PathRemoveExtensionA@4:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__CreateWellKnownSid@16:PROC
EXTRN	__imp__RegisterDeviceNotificationA@12:PROC
EXTRN	__imp__K32GetProcessMemoryInfo@12:PROC
EXTRN	_rename:PROC
EXTRN	__imp__CreateICA@16:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__GetDiskFreeSpaceA@20:PROC
EXTRN	__imp__GetTempPathA@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetExitCodeThread@8:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	_atexit:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	__imp__GetSystemWindowsDirectoryA@8:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	__imp__OpenProcessToken@12:PROC
EXTRN	__imp__K32GetDeviceDriverBaseNameA@12:PROC
EXTRN	__beginthreadex:PROC
EXTRN	_remove:PROC
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__imp__ClosePrinter@4:PROC
EXTRN	__imp__BuildTrusteeWithSidA@8:PROC
EXTRN	__Query_perf_frequency:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__SetSecurityInfo@28:PROC
EXTRN	__imp__GetSystemTimes@12:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__GetDriveTypeA@4:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__endthreadex:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__K32GetDeviceDriverFileNameA@12:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__DeviceCapabilitiesA@20:PROC
EXTRN	__imp__VerifyVersionInfoA@16:PROC
EXTRN	__imp__GetCurrentObject@8:PROC
EXTRN	__imp__MiniDumpWriteDump@28:PROC
EXTRN	__imp__WriteProcessMemory@20:PROC
EXTRN	__imp__UnregisterDeviceNotification@4:PROC
EXTRN	__imp__GetObjectA@12:PROC
EXTRN	__imp__GetLogicalDrives@0:PROC
EXTRN	__imp__GetSecurityInfo@32:PROC
EXTRN	__imp__EnumPrintersA@28:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_exception_destroy:PROC
EXTRN	_exit:PROC
EXTRN	__imp__K32EnumDeviceDrivers@12:PROC
EXTRN	__except_handler4:PROC
?ghWnd@@3PAUHWND__@@A DD 01H DUP (?)			; ghWnd
?gbShutdown@@3HA DD 01H DUP (?)				; gbShutdown
?gbForceChecking@@3HA DD 01H DUP (?)			; gbForceChecking
?gszLogFilePrefix@@3PADA DB 0400H DUP (?)		; gszLogFilePrefix
?gbTerminate@@3HA DD 01H DUP (?)			; gbTerminate
?gpPrinterInfoList@@3PAU_printer_info_list_@@A DD 01H DUP (?) ; gpPrinterInfoList
	ALIGN	8

?gTickStart@@3_KA DQ 01H DUP (?)			; gTickStart
?ghInstance@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; ghInstance
_BSS	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
CONST	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@ DB 'invalid vecto'
	DB	'r<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EMJDEMAB@?$CF?49f?5s@
CONST	SEGMENT
??_C@_06EMJDEMAB@?$CF?49f?5s@ DB '%.9f s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DDANBCKI@?9?9?5WinMain?0?5Wait?5ThrdMsg?5?$CFu@
CONST	SEGMENT
??_C@_0BM@DDANBCKI@?9?9?5WinMain?0?5Wait?5ThrdMsg?5?$CFu@ DB '-- WinMain,'
	DB	' Wait ThrdMsg %u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DLNNNFPM@SysStatus?5?9?5Running?5for?5?$CF02llu?3@
CONST	SEGMENT
??_C@_0CG@DLNNNFPM@SysStatus?5?9?5Running?5for?5?$CF02llu?3@ DB 'SysStatu'
	DB	's - Running for %02llu:%02llu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IBENHIJM@?9?9?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@
CONST	SEGMENT
??_C@_0CA@IBENHIJM@?9?9?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@ DB '-'
	DB	'- %02llu:%02llu:%02llu, %.3f s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MNGEFCAN@Net?5Chkg?5?$CFs@
CONST	SEGMENT
??_C@_0M@MNGEFCAN@Net?5Chkg?5?$CFs@ DB 'Net Chkg %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ICNNMNOE@Net?5Alive?$DP?5?$CFs?0?5Type?5?$CFu@
CONST	SEGMENT
??_C@_0BH@ICNNMNOE@Net?5Alive?$DP?5?$CFs?0?5Type?5?$CFu@ DB 'Net Alive? %'
	DB	's, Type %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No@
CONST	SEGMENT
??_C@_02JINPPBEP@No@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNJPAOHJ@ThrWMI@
CONST	SEGMENT
??_C@_06NNJPAOHJ@ThrWMI@ DB 'ThrWMI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMMFAJOG@ThrdMsg@
CONST	SEGMENT
??_C@_07MMMFAJOG@ThrdMsg@ DB 'ThrdMsg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FONLKPFK@SysStatus?0?5CmdLine?5?$CFs@
CONST	SEGMENT
??_C@_0BG@FONLKPFK@SysStatus?0?5CmdLine?5?$CFs@ DB 'SysStatus, CmdLine %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGBNDJPK@?$DO?$DO?5WinMain@
CONST	SEGMENT
??_C@_0L@PGBNDJPK@?$DO?$DO?5WinMain@ DB '>> WinMain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NLCNCKHJ@?$CFsSysStatus@
CONST	SEGMENT
??_C@_0M@NLCNCKHJ@?$CFsSysStatus@ DB '%sSysStatus', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MHPPNGIP@?$CFs?2SysStatus@
CONST	SEGMENT
??_C@_0N@MHPPNGIP@?$CFs?2SysStatus@ DB '%s\SysStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BCHOJLEN@logdir@
CONST	SEGMENT
??_C@_06BCHOJLEN@logdir@ DB 'logdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OBKGEPKB@appendlog@
CONST	SEGMENT
??_C@_09OBKGEPKB@appendlog@ DB 'appendlog', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMCGMGHO@logsize@
CONST	SEGMENT
??_C@_07MMCGMGHO@logsize@ DB 'logsize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAPFDJNG@timer@
CONST	SEGMENT
??_C@_05NAPFDJNG@timer@ DB 'timer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DDBLHJBD@nowindow@
CONST	SEGMENT
??_C@_08DDBLHJBD@nowindow@ DB 'nowindow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNKAAJIE@sysinfo@
CONST	SEGMENT
??_C@_07KNKAAJIE@sysinfo@ DB 'sysinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GKIGKNOK@runonce@
CONST	SEGMENT
??_C@_07GKIGKNOK@runonce@ DB 'runonce', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PHNLOKMH@?$DM?$DM?5AdjtProcRights@
CONST	SEGMENT
??_C@_0BC@PHNLOKMH@?$DM?$DM?5AdjtProcRights@ DB '<< AdjtProcRights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PKIMIEFE@?9?9?5AdjtProcRights?0?5?$CFs@
CONST	SEGMENT
??_C@_0BG@PKIMIEFE@?9?9?5AdjtProcRights?0?5?$CFs@ DB '-- AdjtProcRights, '
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@CNCGHAJP@?9?9?5AdjtProcRights?0?5Successfully@
CONST	SEGMENT
??_C@_0DN@CNCGHAJP@?9?9?5AdjtProcRights?0?5Successfully@ DB '-- AdjtProcR'
	DB	'ights, Successfully adjusted the process rights.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@COMAOBFG@SeSecurityPrivilege@
CONST	SEGMENT
??_C@_0BE@COMAOBFG@SeSecurityPrivilege@ DB 'SeSecurityPrivilege', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CGDDBBID@?$DO?$DO?5AdjtProcRights@
CONST	SEGMENT
??_C@_0BC@CGDDBBID@?$DO?$DO?5AdjtProcRights@ DB '>> AdjtProcRights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDFMDBME@?$DM?$DM?5ModifyPrivilege@
CONST	SEGMENT
??_C@_0BD@NDFMDBME@?$DM?$DM?5ModifyPrivilege@ DB '<< ModifyPrivilege', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CCHLMIMA@?$DM?$DM?5ModifyPrivilege?0?5AdjustToken@
CONST	SEGMENT
??_C@_0CN@CCHLMIMA@?$DM?$DM?5ModifyPrivilege?0?5AdjustToken@ DB '<< Modif'
	DB	'yPrivilege, AdjustTokenPrivileges %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FBLPGCLK@?$DM?$DM?5ModifyPrivilege?0?5OpenProcess@
CONST	SEGMENT
??_C@_0CI@FBLPGCLK@?$DM?$DM?5ModifyPrivilege?0?5OpenProcess@ DB '<< Modif'
	DB	'yPrivilege, OpenProcessToken %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PMAFNLMJ@?$DO?$DO?5ModifyPrivilege?3?5?$CFs?5?8?$CFs?8@
CONST	SEGMENT
??_C@_0BM@PMAFNLMJ@?$DO?$DO?5ModifyPrivilege?3?5?$CFs?5?8?$CFs?8@ DB '>> '
	DB	'ModifyPrivilege: %s ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIKIFGAL@Disable@
CONST	SEGMENT
??_C@_07MIKIFGAL@Disable@ DB 'Disable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CKGENIKG@Enable@
CONST	SEGMENT
??_C@_06CKGENIKG@Enable@ DB 'Enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGHKOAOF@?$DM?$DM?5GetWMISts@
CONST	SEGMENT
??_C@_0N@DGHKOAOF@?$DM?$DM?5GetWMISts@ DB '<< GetWMISts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GCKOGEAF@WMISysVols@
CONST	SEGMENT
??_C@_0L@GCKOGEAF@WMISysVols@ DB 'WMISysVols', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NAIFMJBP@WMIHwSnsr@
CONST	SEGMENT
??_C@_09NAIFMJBP@WMIHwSnsr@ DB 'WMIHwSnsr', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDFOBJKP@WMISysPerf@
CONST	SEGMENT
??_C@_0L@KDFOBJKP@WMISysPerf@ DB 'WMISysPerf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKBNMLDB@?$DO?$DO?5GetWMISts@
CONST	SEGMENT
??_C@_0N@LKBNMLDB@?$DO?$DO?5GetWMISts@ DB '>> GetWMISts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PAGGLBNL@?$DM?$DM?5ThrdWMISysVols@
CONST	SEGMENT
??_C@_0BC@PAGGLBNL@?$DM?$DM?5ThrdWMISysVols@ DB '<< ThrdWMISysVols', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LBINOCLF@?$DO?$DO?5ThrdWMISysVols?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BH@LBINOCLF@?$DO?$DO?5ThrdWMISysVols?5?$CI?$CFp?$CJ@ DB '>> ThrdWM'
	DB	'ISysVols (%p)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MKNOIMND@?$DM?$DM?5ThrdWMIHwSnsr@
CONST	SEGMENT
??_C@_0BB@MKNOIMND@?$DM?$DM?5ThrdWMIHwSnsr@ DB '<< ThrdWMIHwSnsr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GEAKCKEN@?$DO?$DO?5ThrdWMIHwSnsr?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BG@GEAKCKEN@?$DO?$DO?5ThrdWMIHwSnsr?5?$CI?$CFp?$CJ@ DB '>> ThrdWMI'
	DB	'HwSnsr (%p)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DBJGMMHB@?$DM?$DM?5ThrdWMISysPerf@
CONST	SEGMENT
??_C@_0BC@DBJGMMHB@?$DM?$DM?5ThrdWMISysPerf@ DB '<< ThrdWMISysPerf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HFGKIIBM@?$DO?$DO?5ThrdWMISysPerf?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BH@HFGKIIBM@?$DO?$DO?5ThrdWMISysPerf?5?$CI?$CFp?$CJ@ DB '>> ThrdWM'
	DB	'ISysPerf (%p)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBBDPBFA@PtrInfo@
CONST	SEGMENT
??_C@_07LBBDPBFA@PtrInfo@ DB 'PtrInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IHNDGAAK@DevDrvrs@
CONST	SEGMENT
??_C@_08IHNDGAAK@DevDrvrs@ DB 'DevDrvrs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IONNGCBN@USB@
CONST	SEGMENT
??_C@_03IONNGCBN@USB@ DB 'USB', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LEMLFMJD@LogDrvs@
CONST	SEGMENT
??_C@_07LEMLFMJD@LogDrvs@ DB 'LogDrvs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LGEPCBGK@?$DM?$DM?5GetSysSts@
CONST	SEGMENT
??_C@_0N@LGEPCBGK@?$DM?$DM?5GetSysSts@ DB '<< GetSysSts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FGGKAHMA@ProcInfo@
CONST	SEGMENT
??_C@_08FGGKAHMA@ProcInfo@ DB 'ProcInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HGNAFDEP@PerfInfo@
CONST	SEGMENT
??_C@_08HGNAFDEP@PerfInfo@ DB 'PerfInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFMAIJHM@SysMem@
CONST	SEGMENT
??_C@_06BFMAIJHM@SysMem@ DB 'SysMem', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMMJIFBC@SysTimes@
CONST	SEGMENT
??_C@_08LMMJIFBC@SysTimes@ DB 'SysTimes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKCIAKLO@?$DO?$DO?5GetSysSts@
CONST	SEGMENT
??_C@_0N@DKCIAKLO@?$DO?$DO?5GetSysSts@ DB '>> GetSysSts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JGOJIALP@?$DM?$DM?5GetSysDets@
CONST	SEGMENT
??_C@_0O@JGOJIALP@?$DM?$DM?5GetSysDets@ DB '<< GetSysDets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAIOOCP@SysDirs@
CONST	SEGMENT
??_C@_07NAIOOCP@SysDirs@ DB 'SysDirs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCIBBNDO@SysLogPrcsrInfo@
CONST	SEGMENT
??_C@_0BA@JCIBBNDO@SysLogPrcsrInfo@ DB 'SysLogPrcsrInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKOPCFLK@OSInfo@
CONST	SEGMENT
??_C@_06HKOPCFLK@OSInfo@ DB 'OSInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JFBHEENG@SysInfo@
CONST	SEGMENT
??_C@_07JFBHEENG@SysInfo@ DB 'SysInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLLCGGEI@HwProfile@
CONST	SEGMENT
??_C@_09NLLCGGEI@HwProfile@ DB 'HwProfile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BHNLPBFJ@?$DO?$DO?5GetSysDets@
CONST	SEGMENT
??_C@_0O@BHNLPBFJ@?$DO?$DO?5GetSysDets@ DB '>> GetSysDets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CMFNMPNL@?$DM?$DM?5GetSysIPAddrs@
CONST	SEGMENT
??_C@_0BB@CMFNMPNL@?$DM?$DM?5GetSysIPAddrs@ DB '<< GetSysIPAddrs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDGNKGNI@?$DO?5?$CF02u?5?$CFs@
CONST	SEGMENT
??_C@_09BDGNKGNI@?$DO?5?$CF02u?5?$CFs@ DB '> %02u %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGGPHJBD@IP?5Addresses?5?$CI?$CFu?$CJ?3@
CONST	SEGMENT
??_C@_0BD@JGGPHJBD@IP?5Addresses?5?$CI?$CFu?$CJ?3@ DB 'IP Addresses (%u):'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JNNHNEI@?$DO?$DO?5GetSysIPAddrs?0?5?$CFp?0?5?$CFs@
CONST	SEGMENT
??_C@_0BJ@JNNHNEI@?$DO?$DO?5GetSysIPAddrs?0?5?$CFp?0?5?$CFs@ DB '>> GetSy'
	DB	'sIPAddrs, %p, %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKDOIIA@False@
CONST	SEGMENT
??_C@_05MKDOIIA@False@ DB 'False', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True@
CONST	SEGMENT
??_C@_04HPMIDMKH@True@ DB 'True', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GNPIKGBL@?$DM?$DM?5PtrInfo@
CONST	SEGMENT
??_C@_0L@GNPIKGBL@?$DM?$DM?5PtrInfo@ DB '<< PtrInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CCOPIFBO@?9?9?5PtrInfo?0?5CreateIC?5?$CFs@
CONST	SEGMENT
??_C@_0BI@CCOPIFBO@?9?9?5PtrInfo?0?5CreateIC?5?$CFs@ DB '-- PtrInfo, Crea'
	DB	'teIC %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PNGCEDEF@?9?9?5PtrInfo?0?5new?5LOGFONT?5null@
CONST	SEGMENT
??_C@_0BN@PNGCEDEF@?9?9?5PtrInfo?0?5new?5LOGFONT?5null@ DB '-- PtrInfo, n'
	DB	'ew LOGFONT null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBJPIOLO@?$DO?5FaceName?5?$CFs@
CONST	SEGMENT
??_C@_0O@PBJPIOLO@?$DO?5FaceName?5?$CFs@ DB '> FaceName %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FCEMNLND@?$DO?5PitchAndFamily?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BH@FCEMNLND@?$DO?5PitchAndFamily?5?$CF?42Xh@ DB '> PitchAndFamily '
	DB	'%.2Xh', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PONLFNLB@?$DO?5Quality?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BA@PONLFNLB@?$DO?5Quality?5?$CF?42Xh@ DB '> Quality %.2Xh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FHJOGBNN@?$DO?5ClipPrecision?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BG@FHJOGBNN@?$DO?5ClipPrecision?5?$CF?42Xh@ DB '> ClipPrecision %.'
	DB	'2Xh', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IIGPOAFP@?$DO?5OutPrecision?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BF@IIGPOAFP@?$DO?5OutPrecision?5?$CF?42Xh@ DB '> OutPrecision %.2X'
	DB	'h', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJMDNNAL@?$DO?5CharSet?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BA@CJMDNNAL@?$DO?5CharSet?5?$CF?42Xh@ DB '> CharSet %.2Xh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MFABLFLO@?$DO?5StrikeOut?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BC@MFABLFLO@?$DO?5StrikeOut?5?$CF?42Xh@ DB '> StrikeOut %.2Xh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IHAMIHEE@?$DO?5Underline?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0BC@IHAMIHEE@?$DO?5Underline?5?$CF?42Xh@ DB '> Underline %.2Xh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FOGJLDPM@?$DO?5Italic?5?$CF?42Xh@
CONST	SEGMENT
??_C@_0P@FOGJLDPM@?$DO?5Italic?5?$CF?42Xh@ DB '> Italic %.2Xh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEPHINNC@?$DO?5Weight?5?$CFd@
CONST	SEGMENT
??_C@_0M@EEPHINNC@?$DO?5Weight?5?$CFd@ DB '> Weight %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DFLFEINK@?$DO?5Orientation?5?$CFd@
CONST	SEGMENT
??_C@_0BB@DFLFEINK@?$DO?5Orientation?5?$CFd@ DB '> Orientation %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLDGLOB@?$DO?5Escapment?5?$CFd@
CONST	SEGMENT
??_C@_0P@DLDGLOB@?$DO?5Escapment?5?$CFd@ DB '> Escapment %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KBIDCEMN@?$DO?5Width?5?$CFd@
CONST	SEGMENT
??_C@_0L@KBIDCEMN@?$DO?5Width?5?$CFd@ DB '> Width %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCFCFHLH@?$DO?5Height?5?$CFd@
CONST	SEGMENT
??_C@_0M@JCFCFHLH@?$DO?5Height?5?$CFd@ DB '> Height %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FBFECABI@DEFAULT?5FONT?3@
CONST	SEGMENT
??_C@_0O@FBFECABI@DEFAULT?5FONT?3@ DB 'DEFAULT FONT:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IGELCPAM@Layout?5?$CFu@
CONST	SEGMENT
??_C@_09IGELCPAM@Layout?5?$CFu@ DB 'Layout %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DKIEMMJN@?$DO?5COLORMGMTCAPS?5?$CFd@
CONST	SEGMENT
??_C@_0BD@DKIEMMJN@?$DO?5COLORMGMTCAPS?5?$CFd@ DB '> COLORMGMTCAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAMFBECL@?$DO?5SHADEBLENDCAPS?5?$CFd@
CONST	SEGMENT
??_C@_0BE@BAMFBECL@?$DO?5SHADEBLENDCAPS?5?$CFd@ DB '> SHADEBLENDCAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JFPGOKHF@?$DO?5BLTALIGNMENT?5?$CFd@
CONST	SEGMENT
??_C@_0BC@JFPGOKHF@?$DO?5BLTALIGNMENT?5?$CFd@ DB '> BLTALIGNMENT %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NACPAGIF@?$DO?5DESKTOPHORZRES?5?$CFd@
CONST	SEGMENT
??_C@_0BE@NACPAGIF@?$DO?5DESKTOPHORZRES?5?$CFd@ DB '> DESKTOPHORZRES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@COAHGLLD@?$DO?5DESKTOPVERTRES?5?$CFd@
CONST	SEGMENT
??_C@_0BE@COAHGLLD@?$DO?5DESKTOPVERTRES?5?$CFd@ DB '> DESKTOPVERTRES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KHHELDLL@?$DO?5VREFRESH?5?$CFd@
CONST	SEGMENT
??_C@_0O@KHHELDLL@?$DO?5VREFRESH?5?$CFd@ DB '> VREFRESH %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGKKOKOO@?$DO?5SCALINGFACTORY?5?$CFd@
CONST	SEGMENT
??_C@_0BE@IGKKOKOO@?$DO?5SCALINGFACTORY?5?$CFd@ DB '> SCALINGFACTORY %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LLMKMDFO@?$DO?5SCALINGFACTORX?5?$CFd@
CONST	SEGMENT
??_C@_0BE@LLMKMDFO@?$DO?5SCALINGFACTORX?5?$CFd@ DB '> SCALINGFACTORX %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MNFOHMGF@?$DO?5PHYSICALOFFSETY?5?$CFd@
CONST	SEGMENT
??_C@_0BF@MNFOHMGF@?$DO?5PHYSICALOFFSETY?5?$CFd@ DB '> PHYSICALOFFSETY %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PADOFFNF@?$DO?5PHYSICALOFFSETX?5?$CFd@
CONST	SEGMENT
??_C@_0BF@PADOFFNF@?$DO?5PHYSICALOFFSETX?5?$CFd@ DB '> PHYSICALOFFSETX %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHEFJOBO@?$DO?5PHYSICALHEIGHT?5?$CFd@
CONST	SEGMENT
??_C@_0BE@BHEFJOBO@?$DO?5PHYSICALHEIGHT?5?$CFd@ DB '> PHYSICALHEIGHT %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HDEIPKKB@?$DO?5PHYSICALWIDTH?5?$CFd@
CONST	SEGMENT
??_C@_0BD@HDEIPKKB@?$DO?5PHYSICALWIDTH?5?$CFd@ DB '> PHYSICALWIDTH %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GGNNNIFP@?$DO?5COLORRES?5?$CFd@
CONST	SEGMENT
??_C@_0O@GGNNNIFP@?$DO?5COLORRES?5?$CFd@ DB '> COLORRES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KMMENDMI@?$DO?5NUMRESERVED?5?$CFd@
CONST	SEGMENT
??_C@_0BB@KMMENDMI@?$DO?5NUMRESERVED?5?$CFd@ DB '> NUMRESERVED %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KNEJGJKJ@?$DO?5SIZEPALETTE?5?$CFd@
CONST	SEGMENT
??_C@_0BB@KNEJGJKJ@?$DO?5SIZEPALETTE?5?$CFd@ DB '> SIZEPALETTE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OOCANGJA@?$DO?5LOGPIXELSY?5?$CFd@
CONST	SEGMENT
??_C@_0BA@OOCANGJA@?$DO?5LOGPIXELSY?5?$CFd@ DB '> LOGPIXELSY %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDEAPPCA@?$DO?5LOGPIXELSX?5?$CFd@
CONST	SEGMENT
??_C@_0BA@NDEAPPCA@?$DO?5LOGPIXELSX?5?$CFd@ DB '> LOGPIXELSX %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KAIPPGFP@?$DO?5ASPECTXY?5?$CFd@
CONST	SEGMENT
??_C@_0O@KAIPPGFP@?$DO?5ASPECTXY?5?$CFd@ DB '> ASPECTXY %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDFPIKI@?$DO?5ASPECTY?5?$CFd@
CONST	SEGMENT
??_C@_0N@LDFPIKI@?$DO?5ASPECTY?5?$CFd@ DB '> ASPECTY %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DGFFNBBI@?$DO?5ASPECTX?5?$CFd@
CONST	SEGMENT
??_C@_0N@DGFFNBBI@?$DO?5ASPECTX?5?$CFd@ DB '> ASPECTX %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OCKGHOJF@?$DO?5RASTERCAPS?5?$CFd@
CONST	SEGMENT
??_C@_0BA@OCKGHOJF@?$DO?5RASTERCAPS?5?$CFd@ DB '> RASTERCAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NPFDNMHE@?$DO?5CLIPCAPS?5?$CFd@
CONST	SEGMENT
??_C@_0O@NPFDNMHE@?$DO?5CLIPCAPS?5?$CFd@ DB '> CLIPCAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJBOFNFI@?$DO?5TEXTCAPS?5?$CFd@
CONST	SEGMENT
??_C@_0O@EJBOFNFI@?$DO?5TEXTCAPS?5?$CFd@ DB '> TEXTCAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NDEFMMIK@?$DO?5POLYGONALCAPS?5?$CFd@
CONST	SEGMENT
??_C@_0BD@NDEFMMIK@?$DO?5POLYGONALCAPS?5?$CFd@ DB '> POLYGONALCAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NIBLPDAA@?$DO?5LINECAPS?5?$CFd@
CONST	SEGMENT
??_C@_0O@NIBLPDAA@?$DO?5LINECAPS?5?$CFd@ DB '> LINECAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJKILKAG@?$DO?5CURVECAPS?5?$CFd@
CONST	SEGMENT
??_C@_0P@MJKILKAG@?$DO?5CURVECAPS?5?$CFd@ DB '> CURVECAPS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIAFAHJC@?$DO?5PDEVICESIZE?5?$CFd@
CONST	SEGMENT
??_C@_0BB@BIAFAHJC@?$DO?5PDEVICESIZE?5?$CFd@ DB '> PDEVICESIZE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CDPEOCLN@?$DO?5NUMCOLORS?5?$CFd@
CONST	SEGMENT
??_C@_0P@CDPEOCLN@?$DO?5NUMCOLORS?5?$CFd@ DB '> NUMCOLORS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HIAAJLOF@?$DO?5NUMFONTS?5?$CFd@
CONST	SEGMENT
??_C@_0O@HIAAJLOF@?$DO?5NUMFONTS?5?$CFd@ DB '> NUMFONTS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IJEEOFOD@?$DO?5NUMMARKERS?5?$CFd@
CONST	SEGMENT
??_C@_0BA@IJEEOFOD@?$DO?5NUMMARKERS?5?$CFd@ DB '> NUMMARKERS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HHCKOKCG@?$DO?5NUMPENS?5?$CFd@
CONST	SEGMENT
??_C@_0N@HHCKOKCG@?$DO?5NUMPENS?5?$CFd@ DB '> NUMPENS %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GCBODPHK@?$DO?5NUMBRUSHES?5?$CFd@
CONST	SEGMENT
??_C@_0BA@GCBODPHK@?$DO?5NUMBRUSHES?5?$CFd@ DB '> NUMBRUSHES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DABMECAD@?$DO?5PLANES?5?$CFd@
CONST	SEGMENT
??_C@_0M@DABMECAD@?$DO?5PLANES?5?$CFd@ DB '> PLANES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CHMKJDGJ@?$DO?5BITSPIXEL?5?$CFd@
CONST	SEGMENT
??_C@_0P@CHMKJDGJ@?$DO?5BITSPIXEL?5?$CFd@ DB '> BITSPIXEL %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HLDMJPJJ@?$DO?5VERTRES?5?$CFd@
CONST	SEGMENT
??_C@_0N@HLDMJPJJ@?$DO?5VERTRES?5?$CFd@ DB '> VERTRES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFBEPCKP@?$DO?5HORZRES?5?$CFd@
CONST	SEGMENT
??_C@_0N@IFBEPCKP@?$DO?5HORZRES?5?$CFd@ DB '> HORZRES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDGIGNAG@?$DO?5VERTSIZE?5?$CFd@
CONST	SEGMENT
??_C@_0O@LDGIGNAG@?$DO?5VERTSIZE?5?$CFd@ DB '> VERTSIZE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HMCMNAPC@?$DO?5HORZSIZE?5?$CFd@
CONST	SEGMENT
??_C@_0O@HMCMNAPC@?$DO?5HORZSIZE?5?$CFd@ DB '> HORZSIZE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDKPJOH@?$DO?5TECHNOLOGY?5?$CFd@
CONST	SEGMENT
??_C@_0BA@KDKPJOH@?$DO?5TECHNOLOGY?5?$CFd@ DB '> TECHNOLOGY %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JDPBNNPN@?$DO?5DRIVERVERSION?5?$CFd@
CONST	SEGMENT
??_C@_0BD@JDPBNNPN@?$DO?5DRIVERVERSION?5?$CFd@ DB '> DRIVERVERSION %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CPAOAHIM@DeviceCaps?3@
CONST	SEGMENT
??_C@_0M@CPAOAHIM@DeviceCaps?3@ DB 'DeviceCaps:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NKEHJDBP@?9?9?5PtrInfo?0?5OpenPrinter?5?$CFs@
CONST	SEGMENT
??_C@_0BL@NKEHJDBP@?9?9?5PtrInfo?0?5OpenPrinter?5?$CFs@ DB '-- PtrInfo, O'
	DB	'penPrinter %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ODPAHJGJ@?$DO?5PanningHeight?5?$CFu@
CONST	SEGMENT
??_C@_0BD@ODPAHJGJ@?$DO?5PanningHeight?5?$CFu@ DB '> PanningHeight %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ILEBHAGL@?$DO?5PanningWidth?5?$CFu@
CONST	SEGMENT
??_C@_0BC@ILEBHAGL@?$DO?5PanningWidth?5?$CFu@ DB '> PanningWidth %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KECJEPKK@?$DO?5Reserved2?5?$CFu@
CONST	SEGMENT
??_C@_0P@KECJEPKK@?$DO?5Reserved2?5?$CFu@ DB '> Reserved2 %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ODIJDFHK@?$DO?5Reserved1?5?$CFu@
CONST	SEGMENT
??_C@_0P@ODIJDFHK@?$DO?5Reserved1?5?$CFu@ DB '> Reserved1 %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IBDIEDAP@?$DO?5DitherType?5?$CFu@
CONST	SEGMENT
??_C@_0BA@IBDIEDAP@?$DO?5DitherType?5?$CFu@ DB '> DitherType %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGLLLDPA@?$DO?5MediaType?5?$CFu@
CONST	SEGMENT
??_C@_0P@DGLLLDPA@?$DO?5MediaType?5?$CFu@ DB '> MediaType %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FBGPJDBI@?$DO?5ICMIntent?5?$CFu@
CONST	SEGMENT
??_C@_0P@FBGPJDBI@?$DO?5ICMIntent?5?$CFu@ DB '> ICMIntent %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BALKIIFI@?$DO?5ICMMethod?5?$CFu@
CONST	SEGMENT
??_C@_0P@BALKIIFI@?$DO?5ICMMethod?5?$CFu@ DB '> ICMMethod %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJKIIKDN@?$DO?5PelsHeight?5?$CFd@
CONST	SEGMENT
??_C@_0BA@FJKIIKDN@?$DO?5PelsHeight?5?$CFd@ DB '> PelsHeight %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJDEABGN@?$DO?5PelsWidth?5?$CFu@
CONST	SEGMENT
??_C@_0P@GJDEABGN@?$DO?5PelsWidth?5?$CFu@ DB '> PelsWidth %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IJGBMLDF@?$DO?5BitsPerPel?5?$CFu@
CONST	SEGMENT
??_C@_0BA@IJGBMLDF@?$DO?5BitsPerPel?5?$CFu@ DB '> BitsPerPel %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HBAMONIO@?$DO?5LogPixels?5?$CFd@
CONST	SEGMENT
??_C@_0P@HBAMONIO@?$DO?5LogPixels?5?$CFd@ DB '> LogPixels %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAFNONHG@?$DO?5FormName?5?$CFs@
CONST	SEGMENT
??_C@_0O@NAFNONHG@?$DO?5FormName?5?$CFs@ DB '> FormName %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DEPFBBGA@?$DO?5Collate?5?$CFd@
CONST	SEGMENT
??_C@_0N@DEPFBBGA@?$DO?5Collate?5?$CFd@ DB '> Collate %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ODMOOLLN@?$DO?5TTOption?5?$CFd@
CONST	SEGMENT
??_C@_0O@ODMOOLLN@?$DO?5TTOption?5?$CFd@ DB '> TTOption %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ODANIHPJ@?$DO?5YResolution?5?$CFd@
CONST	SEGMENT
??_C@_0BB@ODANIHPJ@?$DO?5YResolution?5?$CFd@ DB '> YResolution %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMDDHFGN@?$DO?5Duplex?5?$CFd@
CONST	SEGMENT
??_C@_0M@DMDDHFGN@?$DO?5Duplex?5?$CFd@ DB '> Duplex %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGGOANCL@?$DO?5Color?5?$CFd@
CONST	SEGMENT
??_C@_0L@OGGOANCL@?$DO?5Color?5?$CFd@ DB '> Color %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FEEDGEPE@?$DO?5PrintQulity?5?$CFd@
CONST	SEGMENT
??_C@_0BB@FEEDGEPE@?$DO?5PrintQulity?5?$CFd@ DB '> PrintQulity %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PBLNKDE@?$DO?5DefaultSource?5?$CFd@
CONST	SEGMENT
??_C@_0BD@PBLNKDE@?$DO?5DefaultSource?5?$CFd@ DB '> DefaultSource %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCOJLIEN@?$DO?5Copies?5?$CFd@
CONST	SEGMENT
??_C@_0M@MCOJLIEN@?$DO?5Copies?5?$CFd@ DB '> Copies %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CIICACOJ@?$DO?5Scale?5?$CFd@
CONST	SEGMENT
??_C@_0L@CIICACOJ@?$DO?5Scale?5?$CFd@ DB '> Scale %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EJLKBGAF@?$DO?5PaperWidth?5?$CFd@
CONST	SEGMENT
??_C@_0BA@EJLKBGAF@?$DO?5PaperWidth?5?$CFd@ DB '> PaperWidth %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFCPDFAH@?$DO?5PaperLength?5?$CFd@
CONST	SEGMENT
??_C@_0BB@NFCPDFAH@?$DO?5PaperLength?5?$CFd@ DB '> PaperLength %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIJBPCPJ@?$DO?5PaperSize?5?$CFd@
CONST	SEGMENT
??_C@_0P@MIJBPCPJ@?$DO?5PaperSize?5?$CFd@ DB '> PaperSize %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJOJJBEC@?$DO?5Orient?5?$CFd@
CONST	SEGMENT
??_C@_0M@PJOJJBEC@?$DO?5Orient?5?$CFd@ DB '> Orient %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JDMKIO@?$DO?5DriverFields?50x?$CF?48X@
CONST	SEGMENT
??_C@_0BG@JDMKIO@?$DO?5DriverFields?50x?$CF?48X@ DB '> DriverFields 0x%.8'
	DB	'X', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NFLJLFB@?$DO?5DriverExtra?5?$CFd@
CONST	SEGMENT
??_C@_0BB@NFLJLFB@?$DO?5DriverExtra?5?$CFd@ DB '> DriverExtra %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EJHHAJLO@?$DO?5Size?5?$CFd@
CONST	SEGMENT
??_C@_09EJHHAJLO@?$DO?5Size?5?$CFd@ DB '> Size %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FHCKIAEA@?$DO?5DriverVersion?5?$CFd@
CONST	SEGMENT
??_C@_0BD@FHCKIAEA@?$DO?5DriverVersion?5?$CFd@ DB '> DriverVersion %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFIGJBOF@?$DO?5SpecVersion?5?$CFd@
CONST	SEGMENT
??_C@_0BB@GFIGJBOF@?$DO?5SpecVersion?5?$CFd@ DB '> SpecVersion %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KDNAKNNN@?$DO?5DeviceName?5?$CFs@
CONST	SEGMENT
??_C@_0BA@KDNAKNNN@?$DO?5DeviceName?5?$CFs@ DB '> DeviceName %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JFBLCBEM@DEVMODE?3@
CONST	SEGMENT
??_C@_08JFBLCBEM@DEVMODE?3@ DB 'DEVMODE:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JJAELOOF@DC_PERSONALITY?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0BF@JJAELOOF@DC_PERSONALITY?5?$CI?$CFd?$CJ?3@ DB 'DC_PERSONALITY (%'
	DB	'd):', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NKFBLOLE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DG@NKFBLOLE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_PERSONALITY, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FDCGHEM@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_PERSONA@
CONST	SEGMENT
??_C@_0CN@FDCGHEM@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_PERSONA@ DB '--'
	DB	' PtrInfo, <%s> new DC_PERSONALITY mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PACCMPGC@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DI@PACCMPGC@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_PERSONALITY, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CIBLFONP@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@
CONST	SEGMENT
??_C@_0DF@CIBLFONP@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@ DB '-- PtrInfo'
	DB	', Catch unhndld excpetion on MediaTypeList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OFCLBKDH@DC_MEDIATYPES?0?5DC_MEDIATYPENAME@
CONST	SEGMENT
??_C@_0CH@OFCLBKDH@DC_MEDIATYPES?0?5DC_MEDIATYPENAME@ DB 'DC_MEDIATYPES, '
	DB	'DC_MEDIATYPENAMES (%d):', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JHLOAEJA@DC_MEDIAREADY?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0BE@JHLOAEJA@DC_MEDIAREADY?5?$CI?$CFd?$CJ?3@ DB 'DC_MEDIAREADY (%d)'
	DB	':', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@POBLKCNL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DF@POBLKCNL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_MEDIAREADY, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KMOLCCC@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_MEDIARE@
CONST	SEGMENT
??_C@_0CM@KMOLCCC@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_MEDIARE@ DB '--'
	DB	' PtrInfo, <%s> new DC_MEDIAREADY mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GEGMAAP@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DH@GEGMAAP@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInfo'
	DB	', DeviceCapabilities(DC_MEDIAREADY, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDHLMKJK@?$DO?$CF?42d?3?5?$CFs@
CONST	SEGMENT
??_C@_09JDHLMKJK@?$DO?$CF?42d?3?5?$CFs@ DB '>%.2d: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NAHDGPCH@DC_FILEDEPENDENCIES?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0BK@NAHDGPCH@DC_FILEDEPENDENCIES?5?$CI?$CFd?$CJ?3@ DB 'DC_FILEDEPEN'
	DB	'DENCIES (%d):', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NOJMDJGA@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DL@NOJMDJGA@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_FILEDEPENDENCIES, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MCOOCAIH@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_FILEDEP@
CONST	SEGMENT
??_C@_0DC@MCOOCAIH@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_FILEDEP@ DB '-'
	DB	'- PtrInfo, <%s> new DC_FILEDEPENDENCIES mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GGKKNNDH@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DN@GGKKNNDH@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_FILEDEPENDENCIES, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MFCBGNBM@?$DO?$CF?42d?3?5?$CFu@
CONST	SEGMENT
??_C@_09MFCBGNBM@?$DO?$CF?42d?3?5?$CFu@ DB '>%.2d: %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHIGBDLP@DC_NUP?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0N@EHIGBDLP@DC_NUP?5?$CI?$CFd?$CJ?3@ DB 'DC_NUP (%d):', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CJKPCGLF@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0CO@CJKPCGLF@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_NUP, %p) %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGNIMKMD@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_NUP?5mem@
CONST	SEGMENT
??_C@_0CF@DGNIMKMD@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_NUP?5mem@ DB '-'
	DB	'- PtrInfo, <%s> new DC_NUP mem null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BHONBGKL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DA@BHONBGKL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_NUP, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MLIHNHLK@DC_TRUETYPE?5?$CFd@
CONST	SEGMENT
??_C@_0P@MLIHNHLK@DC_TRUETYPE?5?$CFd@ DB 'DC_TRUETYPE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONNHJAOP@DC_STAPLE?5?$CFd@
CONST	SEGMENT
??_C@_0N@ONNHJAOP@DC_STAPLE?5?$CFd@ DB 'DC_STAPLE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICJGKLML@DC_SIZE?5?$CFd@
CONST	SEGMENT
??_C@_0L@ICJGKLML@DC_SIZE?5?$CFd@ DB 'DC_SIZE %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FIJGGACG@DC_MINEXTENT?3?5Length?5?$CFu?0?5Width?5@
CONST	SEGMENT
??_C@_0CC@FIJGGACG@DC_MINEXTENT?3?5Length?5?$CFu?0?5Width?5@ DB 'DC_MINEX'
	DB	'TENT: Length %u, Width %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HHEJCDLL@DC_MAXEXTENT?3?5Length?5?$CFu?0?5Width?5@
CONST	SEGMENT
??_C@_0CC@HHEJCDLL@DC_MAXEXTENT?3?5Length?5?$CFu?0?5Width?5@ DB 'DC_MAXEX'
	DB	'TENT: Length %u, Width %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMBEEHK@DC_FIELDS?5?$CFu@
CONST	SEGMENT
??_C@_0N@FMBEEHK@DC_FIELDS?5?$CFu@ DB 'DC_FIELDS %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BHGLDB@DC_VERSION?5?$CFd@
CONST	SEGMENT
??_C@_0O@BHGLDB@DC_VERSION?5?$CFd@ DB 'DC_VERSION %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOEFEHCB@DC_DRIVER?5?$CFd@
CONST	SEGMENT
??_C@_0N@BOEFEHCB@DC_DRIVER?5?$CFd@ DB 'DC_DRIVER %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JAMONLMJ@DC_DUPLEX?5?$CFd@
CONST	SEGMENT
??_C@_0N@JAMONLMJ@DC_DUPLEX?5?$CFd@ DB 'DC_DUPLEX %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CPGDDBNJ@DC_COLORDEVICE?5?$CFd@
CONST	SEGMENT
??_C@_0BC@CPGDDBNJ@DC_COLORDEVICE?5?$CFd@ DB 'DC_COLORDEVICE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CECDKEDL@DC_COLLATE?5?$CFd@
CONST	SEGMENT
??_C@_0O@CECDKEDL@DC_COLLATE?5?$CFd@ DB 'DC_COLLATE %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOBEBGOJ@DC_COPIES?5?$CFd@
CONST	SEGMENT
??_C@_0N@GOBEBGOJ@DC_COPIES?5?$CFd@ DB 'DC_COPIES %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NAFPPPIH@DC_ORIENTATION?5?$CFd@
CONST	SEGMENT
??_C@_0BC@NAFPPPIH@DC_ORIENTATION?5?$CFd@ DB 'DC_ORIENTATION %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CMDEFNNK@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@
CONST	SEGMENT
??_C@_0DB@CMDEFNNK@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@ DB '-- PtrInfo'
	DB	', Catch unhndld excpetion on PaperList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ENBLCNAO@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs?0?5?$CF?45d?5?$CF?45d@
CONST	SEGMENT
??_C@_0BJ@ENBLCNAO@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs?0?5?$CF?45d?5?$CF?45d@ DB '>'
	DB	'%.2d: %u, %s, %.5d %.5d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GKNAEPGN@DC_PAPERS?0?5DC_PAPERNAMES?0?5DC_PA@
CONST	SEGMENT
??_C@_0CN@GKNAEPGN@DC_PAPERS?0?5DC_PAPERNAMES?0?5DC_PA@ DB 'DC_PAPERS, DC'
	DB	'_PAPERNAMES, DC_PAPERSIZE (%d):', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BNOBPGPC@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@
CONST	SEGMENT
??_C@_0CP@BNOBPGPC@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@ DB '-- PtrInfo'
	DB	', Catch unhndld excpetion on BinList', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KDMGFAIN@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs@
CONST	SEGMENT
??_C@_0O@KDMGFAIN@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs@ DB '>%.2d: %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IBIADDJ@DC_BINS?0?5DC_BINNAMES?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0BL@IBIADDJ@DC_BINS?0?5DC_BINNAMES?5?$CI?$CFd?$CJ?3@ DB 'DC_BINS, D'
	DB	'C_BINNAMES (%d):', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OBKMFCDP@?$DO?$CF?42d?3?5?$CFu?5x?5?$CFu@
CONST	SEGMENT
??_C@_0P@OBKMFCDP@?$DO?$CF?42d?3?5?$CFu?5x?5?$CFu@ DB '>%.2d: %u x %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PLJPAGFI@DC_ENUMRESOLUTIONS?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0BJ@PLJPAGFI@DC_ENUMRESOLUTIONS?5?$CI?$CFd?$CJ?3@ DB 'DC_ENUMRESOLU'
	DB	'TIONS (%d):', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HALEOHFL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DK@HALEOHFL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_ENUMRESOLUTIONS, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OINKGGOI@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_ENUMRES@
CONST	SEGMENT
??_C@_0DB@OINKGGOI@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_ENUMRES@ DB '-'
	DB	'- PtrInfo, <%s> new DC_ENUMRESOLUTIONS mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@DLHDGDPE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
CONST	SEGMENT
??_C@_0DM@DLHDGDPE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@ DB '-- PtrInf'
	DB	'o, DeviceCapabilities(DC_ENUMRESOLUTIONS, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GNJLFBNH@Info?5from?5?$CFs?0?5Port?5?$CFs?0?5Driver?5?$CF@
CONST	SEGMENT
??_C@_0CG@GNJLFBNH@Info?5from?5?$CFs?0?5Port?5?$CFs?0?5Driver?5?$CF@ DB 'I'
	DB	'nfo from %s, Port %s, Driver %s (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HOILGMMA@?$DM?$DM?5PtrInfo?0?5PtrInfoList?5null@
CONST	SEGMENT
??_C@_0BN@HOILGMMA@?$DM?$DM?5PtrInfo?0?5PtrInfoList?5null@ DB '<< PtrInfo'
	DB	', PtrInfoList null', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENEDNFCI@?$DM?$DM?5PtrInfo?0?5No?5Printer@
CONST	SEGMENT
??_C@_0BH@ENEDNFCI@?$DM?$DM?5PtrInfo?0?5No?5Printer@ DB '<< PtrInfo, No P'
	DB	'rinter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EKNEIKHO@?$DO?$DO?5PtrInfo?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BA@EKNEIKHO@?$DO?$DO?5PtrInfo?5?$CI?$CFp?$CJ@ DB '>> PtrInfo (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IBLEBHCE@?$DM?$DM?5GetMediaTypeList?0?5List?5?$CFp@
CONST	SEGMENT
??_C@_0BN@IBLEBHCE@?$DM?$DM?5GetMediaTypeList?0?5List?5?$CFp@ DB '<< GetM'
	DB	'ediaTypeList, List %p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@ONNFKLG@?9?9?5GetMediaTypeList?0?5DeviceCapa@
CONST	SEGMENT
??_C@_0EC@ONNFKLG@?9?9?5GetMediaTypeList?0?5DeviceCapa@ DB '-- GetMediaTy'
	DB	'peList, DeviceCapabilities(DC_MEDIATYPENAMES, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CAKMLHPC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@
CONST	SEGMENT
??_C@_0DJ@CAKMLHPC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@ DB '-'
	DB	'- GetMediaTypeList, <%s> new DC_MEDIATYPENAMES mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@OFONMAMJ@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@
CONST	SEGMENT
??_C@_0DO@OFONMAMJ@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@ DB '<< GetMe'
	DB	'diaTypeList, DeviceCapabilities(DC_MEDIATYPES, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IAEPPFOH@?$DM?$DM?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5P@
CONST	SEGMENT
??_C@_0DJ@IAEPPFOH@?$DM?$DM?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5P@ DB '<'
	DB	'< GetMediaTypeList, <%s> new PTRDATA_INFO_LIST mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EKPICGIC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@
CONST	SEGMENT
??_C@_0DF@EKPICGIC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@ DB '-'
	DB	'- GetMediaTypeList, <%s> new DC_MEDIATYPES mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NNAOKLFO@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@
CONST	SEGMENT
??_C@_0EA@NNAOKLFO@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@ DB '<< GetMe'
	DB	'diaTypeList, DeviceCapabilities(DC_MEDIATYPES, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PBHDOEPC@?$DO?$DO?5GetMediaTypeList?0?5Name?5?$CFs?0?5P@
CONST	SEGMENT
??_C@_0CG@PBHDOEPC@?$DO?$DO?5GetMediaTypeList?0?5Name?5?$CFs?0?5P@ DB '>>'
	DB	' GetMediaTypeList, Name %s, Port %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HGBNGAMD@?$DM?$DM?5GetPaperList?0?5List?5?$CFp@
CONST	SEGMENT
??_C@_0BJ@HGBNGAMD@?$DM?$DM?5GetPaperList?0?5List?5?$CFp@ DB '<< GetPaper'
	DB	'List, List %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CGKLJHJE@?9?9?5GetPaperList?0?5DeviceCapabili@
CONST	SEGMENT
??_C@_0DK@CGKLJHJE@?9?9?5GetPaperList?0?5DeviceCapabili@ DB '-- GetPaperL'
	DB	'ist, DeviceCapabilities(DC_PAPERNAMES, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DLBCIEDL@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@
CONST	SEGMENT
??_C@_0DB@DLBCIEDL@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@ DB '-'
	DB	'- GetPaperList, <%s> new DC_PAPERNAMES mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BNKOAMAF@?9?9?5GetPaperList?0?5DeviceCapabili@
CONST	SEGMENT
??_C@_0DJ@BNKOAMAF@?9?9?5GetPaperList?0?5DeviceCapabili@ DB '-- GetPaperL'
	DB	'ist, DeviceCapabilities(DC_PAPERSIZE, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NJCIHNJI@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@
CONST	SEGMENT
??_C@_0DA@NJCIHNJI@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@ DB '-'
	DB	'- GetPaperList, <%s> new DC_PAPERSIZE mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CIOANDHH@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@
CONST	SEGMENT
??_C@_0DG@CIOANDHH@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@ DB '<< GetPa'
	DB	'perList, DeviceCapabilities(DC_PAPERS, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MINJLAHF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5PTRDA@
CONST	SEGMENT
??_C@_0DF@MINJLAHF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5PTRDA@ DB '<'
	DB	'< GetPaperList, <%s> new PTRDATA_INFO_LIST mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BIOGLDPF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@
CONST	SEGMENT
??_C@_0CN@BIOGLDPF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@ DB '<'
	DB	'< GetPaperList, <%s> new DC_PAPERS mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CDPGKELL@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@
CONST	SEGMENT
??_C@_0DI@CDPGKELL@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@ DB '<< GetPa'
	DB	'perList, DeviceCapabilities(DC_PAPERS, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ONAFHJDF@?$DO?$DO?5GetPaperList?0?5Name?5?$CFs?0?5Port?5@
CONST	SEGMENT
??_C@_0CC@ONAFHJDF@?$DO?$DO?5GetPaperList?0?5Name?5?$CFs?0?5Port?5@ DB '>'
	DB	'> GetPaperList, Name %s, Port %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CEPOJCOE@?$DM?$DM?5GetBinList?0?5List?5?$CFp@
CONST	SEGMENT
??_C@_0BH@CEPOJCOE@?$DM?$DM?5GetBinList?0?5List?5?$CFp@ DB '<< GetBinList'
	DB	', List %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HABDBBMM@?9?9?5GetBinList?0?5DeviceCapabiliti@
CONST	SEGMENT
??_C@_0DG@HABDBBMM@?9?9?5GetBinList?0?5DeviceCapabiliti@ DB '-- GetBinLis'
	DB	't, DeviceCapabilities(DC_BINNAMES, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HGGHLGCE@?9?9?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINN@
CONST	SEGMENT
??_C@_0CN@HGGHLGCE@?9?9?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINN@ DB '-'
	DB	'- GetBinList, <%s> new DC_BINNAMES mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FCIPFBFM@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@
CONST	SEGMENT
??_C@_0DC@FCIPFBFM@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@ DB '<< GetBi'
	DB	'nList, DeviceCapabilities(DC_BINS, %p) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GBLOLICC@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5PTRDATA@
CONST	SEGMENT
??_C@_0DD@GBLOLICC@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5PTRDATA@ DB '<'
	DB	'< GetBinList, <%s> new PTRDATA_INFO_LIST mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MFGEJMEH@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINS@
CONST	SEGMENT
??_C@_0CJ@MFGEJMEH@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINS@ DB '<'
	DB	'< GetBinList, <%s> new DC_BINS mem null', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FGDAMBLB@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@
CONST	SEGMENT
??_C@_0DE@FGDAMBLB@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@ DB '<< GetBi'
	DB	'nList, DeviceCapabilities(DC_BINS, null) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MEDOMPCD@?$DO?$DO?5GetBinList?0?5Name?5?$CFs?0?5Port?5?$CFs@
CONST	SEGMENT
??_C@_0CA@MEDOMPCD@?$DO?$DO?5GetBinList?0?5Name?5?$CFs?0?5Port?5?$CFs@ DB '>'
	DB	'> GetBinList, Name %s, Port %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDDJCMON@?$DM?$DM?5GetPtrsList@
CONST	SEGMENT
??_C@_0P@GDDJCMON@?$DM?$DM?5GetPtrsList@ DB '<< GetPtrsList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OBDCAEAF@?$DO?5?$CF?42d?3?5?2?2?$CFs?2?$CFs?0?5?5?$CFs?0?5?$CFs?0?5?$CFs?0?5?$CF@
CONST	SEGMENT
??_C@_0DB@OBDCAEAF@?$DO?5?$CF?42d?3?5?2?2?$CFs?2?$CFs?0?5?5?$CFs?0?5?$CFs?0?5?$CFs?0?5?$CF@ DB '>'
	DB	' %.2d: \\%s\%s,  %s, %s, %s, %u, %u, %s, %s, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EABBNIJO@?$DMLocalPrinter?$DO@
CONST	SEGMENT
??_C@_0P@EABBNIJO@?$DMLocalPrinter?$DO@ DB '<LocalPrinter>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@LPLLHANM@?$DO?5?5?5?5?5Printer?0?5Port?0?5Driver?0?5Pr@
CONST	SEGMENT
??_C@_0FD@LPLLHANM@?$DO?5?5?5?5?5Printer?0?5Port?0?5Driver?0?5Pr@ DB '>  '
	DB	'   Printer, Port, Driver, Processor, Status, Priority, Locati'
	DB	'on, Share, Comment', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DODNOLI@Printers?5Information?5?$CI?$CFd?$CJ?3@
CONST	SEGMENT
??_C@_0BL@DODNOLI@Printers?5Information?5?$CI?$CFd?$CJ?3@ DB 'Printers In'
	DB	'formation (%d):', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@POBEDBNN@?$DM?$DM?5GetPtrsList?0?5new?5PrtInfoList@
CONST	SEGMENT
??_C@_0CF@POBEDBNN@?$DM?$DM?5GetPtrsList?0?5new?5PrtInfoList@ DB '<< GetP'
	DB	'trsList, new PrtInfoList null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCAKGGPA@?$DM?$DM?5GetPtrsList?0?5EnumPrinters?5?$CFs@
CONST	SEGMENT
??_C@_0CA@CCAKGGPA@?$DM?$DM?5GetPtrsList?0?5EnumPrinters?5?$CFs@ DB '<< G'
	DB	'etPtrsList, EnumPrinters %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CEENFMON@?$DM?$DM?5GetPtrsList?0?5new?5PtrInfo?5nul@
CONST	SEGMENT
??_C@_0CB@CEENFMON@?$DM?$DM?5GetPtrsList?0?5new?5PtrInfo?5nul@ DB '<< Get'
	DB	'PtrsList, new PtrInfo null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CMACENMK@?$DM?$DM?5GetPtrsList?0?5No?5Printer@
CONST	SEGMENT
??_C@_0BL@CMACENMK@?$DM?$DM?5GetPtrsList?0?5No?5Printer@ DB '<< GetPtrsLi'
	DB	'st, No Printer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CKNBFJNB@?$DO?$DO?5GetPtrsList@
CONST	SEGMENT
??_C@_0P@CKNBFJNB@?$DO?$DO?5GetPtrsList@ DB '>> GetPtrsList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JHACCAAA@?$DM?$DM?5PerfInfo@
CONST	SEGMENT
??_C@_0M@JHACCAAA@?$DM?$DM?5PerfInfo@ DB '<< PerfInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JENOJKFE@PerfInfo?0?5GetPerformanceInfo?5?$CFs@
CONST	SEGMENT
??_C@_0CA@JENOJKFE@PerfInfo?0?5GetPerformanceInfo?5?$CFs@ DB 'PerfInfo, G'
	DB	'etPerformanceInfo %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DBCKLHBG@Process?5?$CFu?0?5Handles?5?$CFu?0?5Threads@
CONST	SEGMENT
??_C@_0CD@DBCKLHBG@Process?5?$CFu?0?5Handles?5?$CFu?0?5Threads@ DB 'Proce'
	DB	'ss %u, Handles %u, Threads %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HEDGONEI@Page?5Size?5?$CFu@
CONST	SEGMENT
??_C@_0N@HEDGONEI@Page?5Size?5?$CFu@ DB 'Page Size %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@POMBEGEK@Kernel?3?5Total?5?$CFu?0?5Paged?5?$CFu?0?5Non@
CONST	SEGMENT
??_C@_0CI@POMBEGEK@Kernel?3?5Total?5?$CFu?0?5Paged?5?$CFu?0?5Non@ DB 'Ker'
	DB	'nel: Total %u, Paged %u, Nonpaged %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DCNNFMJH@System?5Cache?5?$CFu@
CONST	SEGMENT
??_C@_0BA@DCNNFMJH@System?5Cache?5?$CFu@ DB 'System Cache %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KFDPCIGB@Physical?3?5Total?5?$CFu?0?5Available?5?$CF@
CONST	SEGMENT
??_C@_0CB@KFDPCIGB@Physical?3?5Total?5?$CFu?0?5Available?5?$CF@ DB 'Physi'
	DB	'cal: Total %u, Available %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ONMEHFLA@Commit?3?5Total?5?$CFu?0?5Limit?5?$CFu?0?5Pea@
CONST	SEGMENT
??_C@_0CE@ONMEHFLA@Commit?3?5Total?5?$CFu?0?5Limit?5?$CFu?0?5Pea@ DB 'Com'
	DB	'mit: Total %u, Limit %u, Peak %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECNHKKAA@Performance?5Information@
CONST	SEGMENT
??_C@_0BI@ECNHKKAA@Performance?5Information@ DB 'Performance Information', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LPGMBLGN@?$DO?$DO?5PerfInfo?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BB@LPGMBLGN@?$DO?$DO?5PerfInfo?5?$CI?$CFp?$CJ@ DB '>> PerfInfo (%p'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NHDPJOBN@?$DM?$DM?5DevDrvs@
CONST	SEGMENT
??_C@_0L@NHDPJOBN@?$DM?$DM?5DevDrvs@ DB '<< DevDrvs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CJPNLIJE@DevDrvs?0?5EnumDeviceDrivers?5?$CFs?5?$CI@
CONST	SEGMENT
??_C@_0DF@CJPNLIJE@DevDrvs?0?5EnumDeviceDrivers?5?$CFs?5?$CI@ DB 'DevDrvs'
	DB	', EnumDeviceDrivers %s (array size needed %u)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DGAJHBGD@?$DO?5?$CF?43zu?0?5?$CFs?0?5?$CFs@
CONST	SEGMENT
??_C@_0BA@DGAJHBGD@?$DO?5?$CF?43zu?0?5?$CFs?0?5?$CFs@ DB '> %.3zu, %s, %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PHKHDLGJ@Device?5Drivers?0?5Number?5of?3?5?$CFd@
CONST	SEGMENT
??_C@_0BO@PHKHDLGJ@Device?5Drivers?0?5Number?5of?3?5?$CFd@ DB 'Device Dri'
	DB	'vers, Number of: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HKMBGJGH@?$DO?$DO?5DevDrvs?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BA@HKMBGJGH@?$DO?$DO?5DevDrvs?5?$CI?$CFp?$CJ@ DB '>> DevDrvs (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BKCMKMCI@?$DM?$DM?5SysLogProcInfo@
CONST	SEGMENT
??_C@_0BC@BKCMKMCI@?$DM?$DM?5SysLogProcInfo@ DB '<< SysLogProcInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JLHKKOJE@Number?5of?5processor?5L1?1L2?1L3?5ca@
CONST	SEGMENT
??_C@_0CO@JLHKKOJE@Number?5of?5processor?5L1?1L2?1L3?5ca@ DB 'Number of p'
	DB	'rocessor L1/L2/L3 caches: %d/%d/%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NEBFNBCF@Number?5of?5logical?5processors?3?5?$CF@
CONST	SEGMENT
??_C@_0CB@NEBFNBCF@Number?5of?5logical?5processors?3?5?$CF@ DB 'Number of'
	DB	' logical processors: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JLJNFPPO@Number?5of?5processor?5cores?3?5?$CFd@
CONST	SEGMENT
??_C@_0BO@JLJNFPPO@Number?5of?5processor?5cores?3?5?$CFd@ DB 'Number of p'
	DB	'rocessor cores: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CIFFOGGE@Number?5of?5physical?5processor?5pa@
CONST	SEGMENT
??_C@_0CK@CIFFOGGE@Number?5of?5physical?5processor?5pa@ DB 'Number of phy'
	DB	'sical processor packages: %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CBGNJNLO@Number?5of?5NUMA?5nodes?3?5?$CFd@
CONST	SEGMENT
??_C@_0BJ@CBGNJNLO@Number?5of?5NUMA?5nodes?3?5?$CFd@ DB 'Number of NUMA n'
	DB	'odes: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ECHENMHH@Logical?5Processor?$CIs?$CJ?5Informatio@
CONST	SEGMENT
??_C@_0CB@ECHENMHH@Logical?5Processor?$CIs?$CJ?5Informatio@ DB 'Logical P'
	DB	'rocessor(s) Information', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@BGADHKMF@?9?9?5SysLogProcInfo?0?5Unsupp?5LOGIC@
CONST	SEGMENT
??_C@_0EC@BGADHKMF@?9?9?5SysLogProcInfo?0?5Unsupp?5LOGIC@ DB '-- SysLogPr'
	DB	'ocInfo, Unsupp LOGICAL_PROCESSOR_RELATIONSHIP value %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KHIEGLFN@?9?9?5SysLogProcInfo?0?5GLPI?5?$CFs@
CONST	SEGMENT
??_C@_0BL@KHIEGLFN@?9?9?5SysLogProcInfo?0?5GLPI?5?$CFs@ DB '-- SysLogProc'
	DB	'Info, GLPI %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LHEIAGGO@?9?9?5SysLogProcInfo?0?5Allocation?5f@
CONST	SEGMENT
??_C@_0CG@LHEIAGGO@?9?9?5SysLogProcInfo?0?5Allocation?5f@ DB '-- SysLogPr'
	DB	'ocInfo, Allocation failure', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@CNICBAHJ@?$DM?$DM?5SysLogProcInfo?0?5Out?0?5Unsupp?5@
CONST	SEGMENT
??_C@_0DO@CNICBAHJ@?$DM?$DM?5SysLogProcInfo?0?5Out?0?5Unsupp?5@ DB '<< Sy'
	DB	'sLogProcInfo, Out, Unsupp GetLogicalProcessorInformation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KHGALBC@GetLogicalProcessorInformation@
CONST	SEGMENT
??_C@_0BP@KHGALBC@GetLogicalProcessorInformation@ DB 'GetLogicalProcessor'
	DB	'Information', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MFPGFEAK@?$DO?$DO?5SysLogProcInfo?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BH@MFPGFEAK@?$DO?$DO?5SysLogProcInfo?5?$CI?$CFp?$CJ@ DB '>> SysLog'
	DB	'ProcInfo (%p)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBODLJGE@?$DM?$DM?5SysDirs@
CONST	SEGMENT
??_C@_0L@NBODLJGE@?$DM?$DM?5SysDirs@ DB '<< SysDirs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJNMAABC@WinSysDir?5?$CFs@
CONST	SEGMENT
??_C@_0N@JJNMAABC@WinSysDir?5?$CFs@ DB 'WinSysDir %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PEBHDCJJ@WinDir?5?$CFs@
CONST	SEGMENT
??_C@_09PEBHDCJJ@WinDir?5?$CFs@ DB 'WinDir %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JFNOOIEA@TempPath?5?$CFs@
CONST	SEGMENT
??_C@_0M@JFNOOIEA@TempPath?5?$CFs@ DB 'TempPath %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGICPEGI@SysDir?5?$CFs@
CONST	SEGMENT
??_C@_09LGICPEGI@SysDir?5?$CFs@ DB 'SysDir %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OAHOLNHD@System?5Directories@
CONST	SEGMENT
??_C@_0BD@OAHOLNHD@System?5Directories@ DB 'System Directories', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBCPBHIM@?$DO?$DO?5SysDirs?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BA@GBCPBHIM@?$DO?$DO?5SysDirs?5?$CI?$CFp?$CJ@ DB '>> SysDirs (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GICAALNI@?$DM?$DM?5LogDrvs@
CONST	SEGMENT
??_C@_0L@GICAALNI@?$DM?$DM?5LogDrvs@ DB '<< LogDrvs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@NOKMBBI@?5?5?5FreeSpace?0?5SectorsPerCluster@
CONST	SEGMENT
??_C@_0GJ@NOKMBBI@?5?5?5FreeSpace?0?5SectorsPerCluster@ DB '   FreeSpace,'
	DB	' SectorsPerCluster %u, BytesPerSector %u, NumberOfFreeCluster'
	DB	's %u, TotalNumberOfClusters %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@JMDLMJNN@?5?5?5VolumeInfo?0?5Name?5?$CFs?0?5SerialN@
CONST	SEGMENT
??_C@_0GE@JMDLMJNN@?5?5?5VolumeInfo?0?5Name?5?$CFs?0?5SerialN@ DB '   Vol'
	DB	'umeInfo, Name %s, SerialNumber %u, MaxComponentLength %u, Fil'
	DB	'eSysflags 0x%08X, FileSysName %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BENIJAPK@?$DO?$DO?5?$CF?43d?0?5?$CFs?3?5Type?5?$CFs?$CI?$CFu?$CJ@
CONST	SEGMENT
??_C@_0BJ@BENIJAPK@?$DO?$DO?5?$CF?43d?0?5?$CFs?3?5Type?5?$CFs?$CI?$CFu?$CJ@ DB '>'
	DB	'> %.3d, %s: Type %s(%u)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BGDEGNDO@Logical?5Drivers?5?$CFu?$CI?$CFu?$CJ?5?$CI0x?$CF?48X?$CJ@
CONST	SEGMENT
??_C@_0CA@BGDEGNDO@Logical?5Drivers?5?$CFu?$CI?$CFu?$CJ?5?$CI0x?$CF?48X?$CJ@ DB 'L'
	DB	'ogical Drivers %u(%u) (0x%.8X)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KFINEJGA@?$DO?$DO?5LogDrvs?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BA@KFINEJGA@?$DO?$DO?5LogDrvs?5?$CI?$CFp?$CJ@ DB '>> LogDrvs (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPJGKNJN@RamDisk@
CONST	SEGMENT
??_C@_07CPJGKNJN@RamDisk@ DB 'RamDisk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JIFOIGMJ@CDRom@
CONST	SEGMENT
??_C@_05JIFOIGMJ@CDRom@ DB 'CDRom', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06MHHFENDB@Remote@
CONST	SEGMENT
??_C@_06MHHFENDB@Remote@ DB 'Remote', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCBIINAK@Fixed@
CONST	SEGMENT
??_C@_05OCBIINAK@Fixed@ DB 'Fixed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOKIPJGJ@NoRootDir@
CONST	SEGMENT
??_C@_09MOKIPJGJ@NoRootDir@ DB 'NoRootDir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNBLPGFN@?$DM?$DM?5SysTimes@
CONST	SEGMENT
??_C@_0M@FNBLPGFN@?$DM?$DM?5SysTimes@ DB '<< SysTimes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@OCMJGDEB@Processor?3?5?$CFI64u?5counts?0?5?$CFI64u?5@
CONST	SEGMENT
??_C@_0DP@OCMJGDEB@Processor?3?5?$CFI64u?5counts?0?5?$CFI64u?5@ DB 'Proce'
	DB	'ssor: %I64u counts, %I64u counts/sec, %02d:%02d:%02d %f s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JFNEHINJ@Idle?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s?$CJ?4@
CONST	SEGMENT
??_C@_0BN@JFNEHINJ@Idle?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s?$CJ?4@ DB 'I'
	DB	'dle: %02d:%02d:%02d (%u s).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JKEHGGOG@User?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s@
CONST	SEGMENT
??_C@_0CC@JKEHGGOG@User?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s@ DB 'U'
	DB	'ser time: %02d:%02d:%02d (%u s).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PJKLEAEE@Kernel?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu@
CONST	SEGMENT
??_C@_0CE@PJKLEAEE@Kernel?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu@ DB 'K'
	DB	'ernel time: %02d:%02d:%02d (%u s).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HHJCFDFH@System?5Times@
CONST	SEGMENT
??_C@_0N@HHJCFDFH@System?5Times@ DB 'System Times', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FODCFBGJ@?$DO?$DO?5SysTimes?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BB@FODCFBGJ@?$DO?$DO?5SysTimes?5?$CI?$CFp?$CJ@ DB '>> SysTimes (%p'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09CIJKANFC@?$DM?$DM?5SysMem@
CONST	SEGMENT
??_C@_09CIJKANFC@?$DM?$DM?5SysMem@ DB '<< SysMem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BKHHAKDB@Virtual?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5avai@
CONST	SEGMENT
??_C@_0DB@BKHHAKDB@Virtual?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5avai@ DB 'Vir'
	DB	'tual: %u MB used, %u MB avail, %u MB extended', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PBKOHCPF@Pagefile?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@
CONST	SEGMENT
??_C@_0CC@PBKOHCPF@Pagefile?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@ DB 'Pag'
	DB	'efile: %u MB used, %u MB avail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JHNBDNDC@Physical?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@
CONST	SEGMENT
??_C@_0CC@JHNBDNDC@Physical?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@ DB 'Phy'
	DB	'sical: %u MB used, %u MB avail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DIEGGMCF@Usage?3?5?$CFu?$CF?$CF?5used@
CONST	SEGMENT
??_C@_0BB@DIEGGMCF@Usage?3?5?$CFu?$CF?$CF?5used@ DB 'Usage: %u%% used', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OAHOAHIO@System?5Memory@
CONST	SEGMENT
??_C@_0O@OAHOAHIO@System?5Memory@ DB 'System Memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CFMOGLIC@?$DO?$DO?5SysMem?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0P@CFMOGLIC@?$DO?$DO?5SysMem?5?$CI?$CFp?$CJ@ DB '>> SysMem (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHLFKBJE@?$DM?$DM?5OSInfo@
CONST	SEGMENT
??_C@_09EHLFKBJE@?$DM?$DM?5OSInfo@ DB '<< OSInfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HOFAFFOO@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@
CONST	SEGMENT
??_C@_0CK@HOFAFFOO@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@ DB 'O'
	DB	'SInfo, Version %u.%u.%u, Platform %u, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NMBMIHHC@OSInfo?0?5VerifyVersionInfo?5?$CFs@
CONST	SEGMENT
??_C@_0BN@NMBMIHHC@OSInfo?0?5VerifyVersionInfo?5?$CFs@ DB 'OSInfo, Verify'
	DB	'VersionInfo %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OPOFGEHK@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@
CONST	SEGMENT
??_C@_0EG@OPOFGEHK@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@ DB 'O'
	DB	'SInfo, Version %u.%u.%u, Platform %u, SP %s(%u.%u), Suite 0x%'
	DB	'08X, %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CILGCIDH@Workstation@
CONST	SEGMENT
??_C@_0M@CILGCIDH@Workstation@ DB 'Workstation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGMEBDBC@Server@
CONST	SEGMENT
??_C@_06LGMEBDBC@Server@ DB 'Server', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LGEIIGCP@Domain?5Controller@
CONST	SEGMENT
??_C@_0BC@LGEIIGCP@Domain?5Controller@ DB 'Domain Controller', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JFFCKGPB@?$DO?$DO?5OSInfo?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0P@JFFCKGPB@?$DO?$DO?5OSInfo?5?$CI?$CFp?$CJ@ DB '>> OSInfo (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EJPMBDJN@?$DM?$DM?5SysInfo@
CONST	SEGMENT
??_C@_0L@EJPMBDJN@?$DM?$DM?5SysInfo@ DB '<< SysInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@KGKHOIOF@Computer?3?5?$CFs?0?5Processor?$CIs?$CJ?5?$CFu?5?$CF@
CONST	SEGMENT
??_C@_0FN@KGKHOIOF@Computer?3?5?$CFs?0?5Processor?$CIs?$CJ?5?$CFu?5?$CF@ DB 'C'
	DB	'omputer: %s, Processor(s) %u %f Mhz Current %u, %s, Level %u,'
	DB	' Rev %u, Type %u; Page Size %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDFEINMN@x86@
CONST	SEGMENT
??_C@_03NDFEINMN@x86@ DB 'x86', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAGOKCHN@Intel?5Itanium?9based@
CONST	SEGMENT
??_C@_0BE@BAGOKCHN@Intel?5Itanium?9based@ DB 'Intel Itanium-based', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EBOFFHEB@x64?5?$CIAMD?5or?5Intel?$CJ@
CONST	SEGMENT
??_C@_0BD@EBOFFHEB@x64?5?$CIAMD?5or?5Intel?$CJ@ DB 'x64 (AMD or Intel)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KIDPDIJO@?$DO?$DO?5SysInfo?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BA@KIDPDIJO@?$DO?$DO?5SysInfo?5?$CI?$CFp?$CJ@ DB '>> SysInfo (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@HJFNKFOJ@?9?9?5CurrentProcessorNumber?0?5GetC@
CONST	SEGMENT
??_C@_0EH@HJFNKFOJ@?9?9?5CurrentProcessorNumber?0?5GetC@ DB '-- CurrentPr'
	DB	'ocessorNumber, GetCurrentProcessorNumber is not supported.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PNLNEKOB@kernel32@
CONST	SEGMENT
??_C@_08PNLNEKOB@kernel32@ DB 'kernel32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFNBACLA@GetCurrentProcessorNumber@
CONST	SEGMENT
??_C@_0BK@DFNBACLA@GetCurrentProcessorNumber@ DB 'GetCurrentProcessorNumb'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DNDAOIDK@?$DM?$DM?5HwProfile@
CONST	SEGMENT
??_C@_0N@DNDAOIDK@?$DM?$DM?5HwProfile@ DB '<< HwProfile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OJDBEDNI@HwProfile?0?5GetCurrentHwProfile?5@
CONST	SEGMENT
??_C@_0CC@OJDBEDNI@HwProfile?0?5GetCurrentHwProfile?5@ DB 'HwProfile, Get'
	DB	'CurrentHwProfile %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OIKPBLGF@Hardware?5Profile?0?5DockInfo?5?$CFp?0?5@
CONST	SEGMENT
??_C@_0DA@OIKPBLGF@Hardware?5Profile?0?5DockInfo?5?$CFp?0?5@ DB 'Hardware'
	DB	' Profile, DockInfo %p, GUID %s, Name %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BGHHFGNO@?$DO?$DO?5HwProfile?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BC@BGHHFGNO@?$DO?$DO?5HwProfile?5?$CI?$CFp?$CJ@ DB '>> HwProfile ('
	DB	'%p)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHLIHEIP@?$DM?$DM?5ProcInfo@
CONST	SEGMENT
??_C@_0M@LHLIHEIP@?$DM?$DM?5ProcInfo@ DB '<< ProcInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MOIJAHHG@ProcessInfo?0?5EnumProcesses?5?$CFs@
CONST	SEGMENT
??_C@_0BO@MOIJAHHG@ProcessInfo?0?5EnumProcesses?5?$CFs@ DB 'ProcessInfo, '
	DB	'EnumProcesses %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JFLIEPEA@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$DMunknown?$DO?0?5?$DP?0?5?$DP?$DP?3@
CONST	SEGMENT
??_C@_0EA@JFLIEPEA@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$DMunknown?$DO?0?5?$DP?0?5?$DP?$DP?3@ DB '>'
	DB	' %.3d, %05u, <unknown>, ?, ??:??:??, ?, ?, ?, ?, ?, ?, ?, ?, '
	DB	'?', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LGHCMJEF@ProcessInfo?0?5OpenProcess?$CIPID?5?$CFl@
CONST	SEGMENT
??_C@_0CF@LGHCMJEF@ProcessInfo?0?5OpenProcess?$CIPID?5?$CFl@ DB 'ProcessI'
	DB	'nfo, OpenProcess(PID %lu) %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NBLNGMHL@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$CFs?0?5?$CFu?0?5?$CF02d?3?$CF02d@
CONST	SEGMENT
??_C@_0EJ@NBLNGMHL@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$CFs?0?5?$CFu?0?5?$CF02d?3?$CF02d@ DB '>'
	DB	' %.3d, %05u, %s, %u, %02d:%02d:%02d, %u, %u, %u, %u, %u, %u, '
	DB	'%u, %u, %u', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09EEKGDCPH@?$DMunknown?$DO@
CONST	SEGMENT
??_C@_09EEKGDCPH@?$DMunknown?$DO@ DB '<unknown>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OJ@OBBIANJK@?$DO?5?5?5?5?5?5ProcessID?0?5Process?5Name?0@
CONST	SEGMENT
??_C@_0OJ@OBBIANJK@?$DO?5?5?5?5?5?5ProcessID?0?5Process?5Name?0@ DB '>   '
	DB	'   ProcessID, Process Name, Handles, CPUTime, PagefileUsage, '
	DB	'PeakPagefileUsage, PageFaultCount, PeakWorkingSetSize, Workin'
	DB	'gSetSize, QuotaPeakPagedPoolUsage, QuotaPagedPoolUsage, Quota'
	DB	'PeakNonPagedPoolUsage, QuotaNonPagedPoolUsage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FFOKNKOI@Processes?5Information?0?5Number?5o@
CONST	SEGMENT
??_C@_0CP@FFOKNKOI@Processes?5Information?0?5Number?5o@ DB 'Processes Inf'
	DB	'ormation, Number of processes: %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFPIPLLP@?$DO?$DO?5ProcInfo?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BB@JFPIPLLP@?$DO?$DO?5ProcInfo?5?$CI?$CFp?$CJ@ DB '>> ProcInfo (%p'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FFDNLHNK@?$DM?$DM?5ThrdUSB@
CONST	SEGMENT
??_C@_0L@FFDNLHNK@?$DM?$DM?5ThrdUSB@ DB '<< ThrdUSB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GBFCDAOJ@?$DM?$DM?5ThrdUSB?0?5New?5USB?5class?5null@
CONST	SEGMENT
??_C@_0BP@GBFCDAOJ@?$DM?$DM?5ThrdUSB?0?5New?5USB?5class?5null@ DB '<< Thr'
	DB	'dUSB, New USB class null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PGPPJDLP@?$DO?$DO?5ThrdUSB?5?$CI?$CFp?$CJ@
CONST	SEGMENT
??_C@_0BA@PGPPJDLP@?$DO?$DO?5ThrdUSB?5?$CI?$CFp?$CJ@ DB '>> ThrdUSB (%p)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BACOFOKN@?$DM?$DM?5ThrdMsg@
CONST	SEGMENT
??_C@_0L@BACOFOKN@?$DM?$DM?5ThrdMsg@ DB '<< ThrdMsg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JFGPBNIN@?$DM?$DM?5ThrdMsg?0?5CreateWnd?5?$CFs@
CONST	SEGMENT
??_C@_0BJ@JFGPBNIN@?$DM?$DM?5ThrdMsg?0?5CreateWnd?5?$CFs@ DB '<< ThrdMsg,'
	DB	' CreateWnd %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GPCBDAOG@?$DM?$DM?5ThrdMsg?0?5RegCls?5?$CFs@
CONST	SEGMENT
??_C@_0BG@GPCBDAOG@?$DM?$DM?5ThrdMsg?0?5RegCls?5?$CFs@ DB '<< ThrdMsg, Re'
	DB	'gCls %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDKJFHEL@SysStatusWClass@
CONST	SEGMENT
??_C@_0BA@JDKJFHEL@SysStatusWClass@ DB 'SysStatusWClass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMLHDHFB@?$DO?$DO?5ThrdMsg@
CONST	SEGMENT
??_C@_0L@EMLHDHFB@?$DO?$DO?5ThrdMsg@ DB '>> ThrdMsg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDGGKCEM@Quick?5Exit?5Requested@
CONST	SEGMENT
??_C@_0BF@CDGGKCEM@Quick?5Exit?5Requested@ DB 'Quick Exit Requested', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MBHJGPCP@Would?5you?5like?5to?5quickly?5close@
CONST	SEGMENT
??_C@_0DC@MBHJGPCP@Would?5you?5like?5to?5quickly?5close@ DB 'Would you li'
	DB	'ke to quickly close this application?', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BIPEBJDO@Exit?5Requested@
CONST	SEGMENT
??_C@_0P@BIPEBJDO@Exit?5Requested@ DB 'Exit Requested', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KDAHPGC@Would?5you?5like?5to?5close?5this?5ap@
CONST	SEGMENT
??_C@_0CK@KDAHPGC@Would?5you?5like?5to?5close?5this?5ap@ DB 'Would you li'
	DB	'ke to close this application?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@GBOFOCLM@Handle?5CHANGE?5?$DMHandle?5?$CFp?0?5NameO@
CONST	SEGMENT
??_C@_0EN@GBOFOCLM@Handle?5CHANGE?5?$DMHandle?5?$CFp?0?5NameO@ DB 'Handle'
	DB	' CHANGE <Handle %p, NameOffset %d, Name %s, DevNotify %p, Evn'
	DB	'tGUID %s>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BNLENJBO@Net?5CHANGE?5?$DMResource?5?$CFp?0?5Flags?5@
CONST	SEGMENT
??_C@_0CD@BNLENJBO@Net?5CHANGE?5?$DMResource?5?$CFp?0?5Flags?5@ DB 'Net C'
	DB	'HANGE <Resource %p, Flags %p>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LPBNHOKC@Port?5CHANGE?5?$DM?$CFs?$DO@
CONST	SEGMENT
??_C@_0BB@LPBNHOKC@Port?5CHANGE?5?$DM?$CFs?$DO@ DB 'Port CHANGE <%s>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FJDGCJID@DevNode?5CHANGE?5?$DM?$CFp?$DO@
CONST	SEGMENT
??_C@_0BE@FJDGCJID@DevNode?5CHANGE?5?$DM?$CFp?$DO@ DB 'DevNode CHANGE <%p'
	DB	'>', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FNGBCCOE@Oem?5CHANGE?5?$DMId?5?$CFp?0?5SuppFunc?5?$CFp?$DO@
CONST	SEGMENT
??_C@_0CA@FNGBCCOE@Oem?5CHANGE?5?$DMId?5?$CFp?0?5SuppFunc?5?$CFp?$DO@ DB 'O'
	DB	'em CHANGE <Id %p, SuppFunc %p>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OJJDNJOH@Volume?5CHANGE?5?$DMFlags?5?$CFp?0?5UnitMa@
CONST	SEGMENT
??_C@_0CG@OJJDNJOH@Volume?5CHANGE?5?$DMFlags?5?$CFp?0?5UnitMa@ DB 'Volume'
	DB	' CHANGE <Flags %p, UnitMask %p>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENJCMGFB@USB?5?5REMOVE@
CONST	SEGMENT
??_C@_0M@ENJCMGFB@USB?5?5REMOVE@ DB 'USB  REMOVE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPDKOEDO@USB?5ARRIVAL@
CONST	SEGMENT
??_C@_0M@FPDKOEDO@USB?5ARRIVAL@ DB 'USB ARRIVAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HKOFJDPP@Usb?5CHANGE?5Dev?5?$DM?$CFs?5GUID?5?$CFs?$DO@
CONST	SEGMENT
??_C@_0BM@HKOFJDPP@Usb?5CHANGE?5Dev?5?$DM?$CFs?5GUID?5?$CFs?$DO@ DB 'Usb '
	DB	'CHANGE Dev <%s GUID %s>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNOLPDFB@Device?5?$CFs?0?5Size?5?$CFu?0?5DevType?5?$CFu@
CONST	SEGMENT
??_C@_0BP@PNOLPDFB@Device?5?$CFs?0?5Size?5?$CFu?0?5DevType?5?$CFu@ DB 'De'
	DB	'vice %s, Size %u, DevType %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCLHCEGD@?$CCRemoved?$CC@
CONST	SEGMENT
??_C@_09BCLHCEGD@?$CCRemoved?$CC@ DB '"Removed"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MCANMMCL@?$CCRemoval?5Pending?$CC@
CONST	SEGMENT
??_C@_0BC@MCANMMCL@?$CCRemoval?5Pending?$CC@ DB '"Removal Pending"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ENLMBDFJ@?$CCRemoval?5Aborted?$CC@
CONST	SEGMENT
??_C@_0BC@ENLMBDFJ@?$CCRemoval?5Aborted?$CC@ DB '"Removal Aborted"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MMAEKGNO@?$CCRemoval?5Request?$CC@
CONST	SEGMENT
??_C@_0BC@MMAEKGNO@?$CCRemoval?5Request?$CC@ DB '"Removal Request"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGELGNNP@?$CCArrived?$CC@
CONST	SEGMENT
??_C@_09LGELGNNP@?$CCArrived?$CC@ DB '"Arrived"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBKEAIF@?$DP?$DP?$DP@
CONST	SEGMENT
??_C@_03BBKEAIF@?$DP?$DP?$DP@ DB '???', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OJAKBKAK@User?5Defined?5?$CFs?0?5Size?5?$CFu?0?5DevTy@
CONST	SEGMENT
??_C@_0CF@OJAKBKAK@User?5Defined?5?$CFs?0?5Size?5?$CFu?0?5DevTy@ DB 'User'
	DB	' Defined %s, Size %u, DevType %u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KECABMHK@SysStatus@
CONST	SEGMENT
??_C@_09KECABMHK@SysStatus@ DB 'SysStatus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLINGCEN@End?5Session@
CONST	SEGMENT
??_C@_0M@LLINGCEN@End?5Session@ DB 'End Session', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GJJBBOEE@Session?5Closure?5Requested@
CONST	SEGMENT
??_C@_0BK@GJJBBOEE@Session?5Closure?5Requested@ DB 'Session Closure Reque'
	DB	'sted', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@BJAJHKCK@?9?9?5WndProcMsg?0?5Wnd?5?$CFp?0?5Msg?50x?$CF?4@
CONST	SEGMENT
??_C@_0GE@BJAJHKCK@?9?9?5WndProcMsg?0?5Wnd?5?$CFp?0?5Msg?50x?$CF?4@ DB '-'
	DB	'- WndProcMsg, Wnd %p, Msg 0x%.4X, WPrm 0x%.8X HI 0x%.4X LO 0x'
	DB	'%.4X, LPrm 0x%.8X HI 0x%.4X LO 0x%.4X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OFOICJDM@?$DM?$DM?5EndPendgThrd@
CONST	SEGMENT
??_C@_0BA@OFOICJDM@?$DM?$DM?5EndPendgThrd@ DB '<< EndPendgThrd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FCCILLCE@RtlFreeUserThreadStack@
CONST	SEGMENT
??_C@_0BH@FCCILLCE@RtlFreeUserThreadStack@ DB 'RtlFreeUserThreadStack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@
CONST	SEGMENT
??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@ DB 'n', 00H
	DB	't', 00H, 'd', 00H, 'l', 00H, 'l', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JJOKMIHG@?$DO?$DO?5EndPendgThrd?0?5Hndl?5?$CFp@
CONST	SEGMENT
??_C@_0BJ@JJOKMIHG@?$DO?$DO?5EndPendgThrd?0?5Hndl?5?$CFp@ DB '>> EndPendg'
	DB	'Thrd, Hndl %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EBHNNPDK@?$DM?$DM?5StartThrd?0?5ret?5False@
CONST	SEGMENT
??_C@_0BI@EBHNNPDK@?$DM?$DM?5StartThrd?0?5ret?5False@ DB '<< StartThrd, r'
	DB	'et False', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@
CONST	SEGMENT
??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@ DB '<< StartThrd, re'
	DB	't True', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@POKBMEDO@?$DM?$DM?5StartThrd?0?5?$CFp@
CONST	SEGMENT
??_C@_0BB@POKBMEDO@?$DM?$DM?5StartThrd?0?5?$CFp@ DB '<< StartThrd, %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LFOPNEOO@?9?9?5StartThrd?0?5No?5?$CFs?5thrd?5create@
CONST	SEGMENT
??_C@_0CB@LFOPNEOO@?9?9?5StartThrd?0?5No?5?$CFs?5thrd?5create@ DB '-- Sta'
	DB	'rtThrd, No %s thrd created', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FDECIAPH@?9?9?5StartThrd?0?5?$CFs?5Id?5?$CFu?0?5Hnd?5?$CFp@
CONST	SEGMENT
??_C@_0BP@FDECIAPH@?9?9?5StartThrd?0?5?$CFs?5Id?5?$CFu?0?5Hnd?5?$CFp@ DB '-'
	DB	'- StartThrd, %s Id %u, Hnd %p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OLKMHNED@?$DO?$DO?5StartThrd?0?5Name?5?$CFs?0?5Func?5?$CFp?0@
CONST	SEGMENT
??_C@_0DN@OLKMHNED@?$DO?$DO?5StartThrd?0?5Name?5?$CFs?0?5Func?5?$CFp?0@ DB '>'
	DB	'> StartThrd, Name %s, Func %p, Dat %p, Timeout %u, pHndl %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DAMKDCLP@?9?9?5SetThrdName?0?5Tp?5?$CFp?0?5Name?5?$CFs?0@
CONST	SEGMENT
??_C@_0DA@DAMKDCLP@?9?9?5SetThrdName?0?5Tp?5?$CFp?0?5Name?5?$CFs?0@ DB '-'
	DB	'- SetThrdName, Tp %p, Name %s, Id %u, Flags %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GOPGHHGJ@?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@
CONST	SEGMENT
??_C@_0BN@GOPGHHGJ@?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@ DB '%0'
	DB	'2llu:%02llu:%02llu, %.3f s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KLGENLFB@?$CFs?0?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5@
CONST	SEGMENT
??_C@_0CB@KLGENLFB@?$CFs?0?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5@ DB '%'
	DB	's, %02llu:%02llu:%02llu, %.3f s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@GFOAHNCA@AppUnhndldExcptFltr?0?5Attempt?5to@
CONST	SEGMENT
??_C@_0GA@GFOAHNCA@AppUnhndldExcptFltr?0?5Attempt?5to@ DB 'AppUnhndldExcp'
	DB	'tFltr, Attempt to create MiniDump file before exit proc due t'
	DB	'o unhndld exception.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IPHAABKL@CreateMiniDump?0?5Failed?5to?5creat@
CONST	SEGMENT
??_C@_0DD@IPHAABKL@CreateMiniDump?0?5Failed?5to?5creat@ DB 'CreateMiniDum'
	DB	'p, Failed to create MiniDump file. %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KOKEPHBJ@CreateMiniDump?0?5Created?5MiniDum@
CONST	SEGMENT
??_C@_0DE@KOKEPHBJ@CreateMiniDump?0?5Created?5MiniDum@ DB 'CreateMiniDump'
	DB	', Created MiniDump file located at %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLLEOGPJ@?$CFs_?$CF?44d?9?$CF?42d?9?$CF?42d_?$CF?42d?9?$CF?42d?9?$CF?42@
CONST	SEGMENT
??_C@_0CF@MLLEOGPJ@?$CFs_?$CF?44d?9?$CF?42d?9?$CF?42d_?$CF?42d?9?$CF?42d?9?$CF?42@ DB '%'
	DB	's_%.4d-%.2d-%.2d_%.2d-%.2d-%.2d.dmp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EBDAABIF@SetUnhandledExceptionFilter@
CONST	SEGMENT
??_C@_0BM@EBDAABIF@SetUnhandledExceptionFilter@ DB 'SetUnhandledException'
	DB	'Filter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll@
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll@ DB 'kernel32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@PPGABHKA@?9?9?5Prevented?5attempt?5to?5set?5unh@
CONST	SEGMENT
??_C@_0FI@PPGABHKA@?9?9?5Prevented?5attempt?5to?5set?5unh@ DB '-- Prevent'
	DB	'ed attempt to set unhandled exception filter. lpTopLevelExcep'
	DB	'tionFilter: 0x%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CFJMJGDJ@?$CF?42X@
CONST	SEGMENT
??_C@_04CFJMJGDJ@?$CF?42X@ DB '%.2X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LNKKODAK@?9?9?5New?5DeviceName?5nullptr@
CONST	SEGMENT
??_C@_0BK@LNKKODAK@?9?9?5New?5DeviceName?5nullptr@ DB '-- New DeviceName '
	DB	'nullptr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GCCDOOIB@?$CFs?5?$FLVID?3?$CFs?5PID?3?$CFs?5SN?3?$CFs?$FN?5?$CFs@
CONST	SEGMENT
??_C@_0BM@GCCDOOIB@?$CFs?5?$FLVID?3?$CFs?5PID?3?$CFs?5SN?3?$CFs?$FN?5?$CFs@ DB '%'
	DB	's [VID:%s PID:%s SN:%s] %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EIGEDBOH@?5Msg?5@
CONST	SEGMENT
??_C@_05EIGEDBOH@?5Msg?5@ DB ' Msg ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KKAJCPFA@Err?5@
CONST	SEGMENT
??_C@_04KKAJCPFA@Err?5@ DB 'Err ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MNPEAJCA@netmsg?4dll@
CONST	SEGMENT
??_C@_0L@MNPEAJCA@netmsg?4dll@ DB 'netmsg.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GCOGCGED@?$DM?$DM?5ChkLogFileSz@
CONST	SEGMENT
??_C@_0BA@GCOGCGED@?$DM?$DM?5ChkLogFileSz@ DB '<< ChkLogFileSz', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EHOHNGJO@?9?9?5ChkLogFileSz?0?5Remaining?5?$CFs?5?9@
CONST	SEGMENT
??_C@_0CE@EHOHNGJO@?9?9?5ChkLogFileSz?0?5Remaining?5?$CFs?5?9@ DB '-- Chk'
	DB	'LogFileSz, Remaining %s -> %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HLBMFDAN@?$CFs?4000?4log@
CONST	SEGMENT
??_C@_0L@HLBMFDAN@?$CFs?4000?4log@ DB '%s.000.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KIGAJNDH@?9?9?5ChkLogFileSz?0?5Renaming?5?$CFs?5?9?$DO@
CONST	SEGMENT
??_C@_0CD@KIGAJNDH@?9?9?5ChkLogFileSz?0?5Renaming?5?$CFs?5?9?$DO@ DB '-- '
	DB	'ChkLogFileSz, Renaming %s -> %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JDMPMEKE@?9?9?5ChkLogFileSz?0?5Removing?5?$CFs?5?9?5@
CONST	SEGMENT
??_C@_0CL@JDMPMEKE@?9?9?5ChkLogFileSz?0?5Removing?5?$CFs?5?9?5@ DB '-- Ch'
	DB	'kLogFileSz, Removing %s - oldest file', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DNFINAJK@?9?9?5ChkLogFileSz?0?5Last?5file?5fnd?3@
CONST	SEGMENT
??_C@_0CD@DNFINAJK@?9?9?5ChkLogFileSz?0?5Last?5file?5fnd?3@ DB '-- ChkLog'
	DB	'FileSz, Last file fnd: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MGCLJDML@?9?9?5ChkLogFileSz?0?5Trying?5opng?5?$CFs@
CONST	SEGMENT
??_C@_0CA@MGCLJDML@?9?9?5ChkLogFileSz?0?5Trying?5opng?5?$CFs@ DB '-- ChkL'
	DB	'ogFileSz, Trying opng %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKKOHPEB@?$CFs?4?$CF?43d?4log@
CONST	SEGMENT
??_C@_0M@HKKOHPEB@?$CFs?4?$CF?43d?4log@ DB '%s.%.3d.log', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HOHICOFN@?9?9?5ChkLogFileSz?0?5?$CFs?5Sz?5?$CFu@
CONST	SEGMENT
??_C@_0BK@HOHICOFN@?9?9?5ChkLogFileSz?0?5?$CFs?5Sz?5?$CFu@ DB '-- ChkLogF'
	DB	'ileSz, %s Sz %u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LGJHGBPF@?9?9?5ChkLogFileSz?0?5Opng?5?$CFs@
CONST	SEGMENT
??_C@_0BJ@LGJHGBPF@?9?9?5ChkLogFileSz?0?5Opng?5?$CFs@ DB '-- ChkLogFileSz'
	DB	', Opng %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GIEOINGB@?$DO?$DO?5ChkLogFileSz?0?5?$CFu@
CONST	SEGMENT
??_C@_0BE@GIEOINGB@?$DO?$DO?5ChkLogFileSz?0?5?$CFu@ DB '>> ChkLogFileSz, '
	DB	'%u', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NMAKEFMG@TID?5?$CF?45lu?5ID?5?$CF?45i?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BH@NMAKEFMG@TID?5?$CF?45lu?5ID?5?$CF?45i?5?$CFs?$AN?6@ DB 'TID %.5'
	DB	'lu ID %.5i %s', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BEJGOBHG@?$CFs?4log@
CONST	SEGMENT
??_C@_06BEJGOBHG@?$CFs?4log@ DB '%s.log', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OLKONLEL@?7?$CFs?$AN?6@
CONST	SEGMENT
??_C@_05OLKONLEL@?7?$CFs?$AN?6@ DB 09H, '%s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MFNKNCE@?$AN?6?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d@
CONST	SEGMENT
??_C@_0EH@MFNKNCE@?$AN?6?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d@ DB 0dH
	DB	0aH, '%.4d-%.2d-%.2d %.2d:%.2d:%.2d.%.3d PID %.5lu TID %.5lu I'
	DB	'D %.5i', 0dH, 0aH, '%s', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHDHJHFN@SysStatus_Log@
CONST	SEGMENT
??_C@_0O@FHDHJHFN@SysStatus_Log@ DB 'SysStatus_Log', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BJLKJKJF@?$CFs?4?$CFs_old@
CONST	SEGMENT
??_C@_09BJLKJKJF@?$CFs?4?$CFs_old@ DB '%s.%s_old', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGNGBBJO@?$CFs?4?$CFs?4log@
CONST	SEGMENT
??_C@_09OGNGBBJO@?$CFs?4?$CFs?4log@ DB '%s.%s.log', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CLGPPHLF@?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d?4?$CF@
CONST	SEGMENT
??_C@_0CP@CLGPPHLF@?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d?4?$CF@ DB '%'
	DB	'.4d-%.2d-%.2d %.2d:%.2d:%.2d.%.3d PID %.5u %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NMGDDAFL@wmi@
CONST	SEGMENT
??_C@_03NMGDDAFL@wmi@ DB 'wmi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GLILPAEP@wnd@
CONST	SEGMENT
??_C@_03GLILPAEP@wnd@ DB 'wnd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBAKCJJ@dbg@
CONST	SEGMENT
??_C@_03LBAKCJJ@dbg@ DB 'dbg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBPLBEEL@SysStatus_Trace@
CONST	SEGMENT
??_C@_0BA@GBPLBEEL@SysStatus_Trace@ DB 'SysStatus_Trace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CLAHNHIH@?$DM?$DM?5MonIPs@
CONST	SEGMENT
??_C@_09CLAHNHIH@?$DM?$DM?5MonIPs@ DB '<< MonIPs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BAECPDM@?$DO?$DO?5MonIPs@
CONST	SEGMENT
??_C@_09BAECPDM@?$DO?$DO?5MonIPs@ DB '>> MonIPs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
CONST	SEGMENT
??_C@_0BD@HAJJDCII@Win32_VoltageProbe@ DB 'Win32_VoltageProbe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
CONST	SEGMENT
??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@ DB 'Win32_TemperatureProbe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPHEPFAH@SystemName@
CONST	SEGMENT
??_C@_0L@MPHEPFAH@SystemName@ DB 'SystemName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LFKNNEKA@SystemCreationClassName@
CONST	SEGMENT
??_C@_0BI@LFKNNEKA@SystemCreationClassName@ DB 'SystemCreationClassName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLOCDJF@MaxBatteryError@
CONST	SEGMENT
??_C@_0BA@LLOCDJF@MaxBatteryError@ DB 'MaxBatteryError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EBMPMBCC@CapacityMultiplier@
CONST	SEGMENT
??_C@_0BD@EBMPMBCC@CapacityMultiplier@ DB 'CapacityMultiplier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EMGHNHBI@ManufactureDate@
CONST	SEGMENT
??_C@_0BA@EMGHNHBI@ManufactureDate@ DB 'ManufactureDate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
CONST	SEGMENT
??_C@_0BG@GEFEDJOA@Win32_PortableBattery@ DB 'Win32_PortableBattery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLKOPNJP@IsLinear@
CONST	SEGMENT
??_C@_08JLKOPNJP@IsLinear@ DB 'IsLinear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NIGABCBB@MinReadable@
CONST	SEGMENT
??_C@_0M@NIGABCBB@MinReadable@ DB 'MinReadable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIBDACPL@MaxReadable@
CONST	SEGMENT
??_C@_0M@EIBDACPL@MaxReadable@ DB 'MaxReadable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical@
CONST	SEGMENT
??_C@_0BK@CCJKGBMI@UpperThresholdNonCritical@ DB 'UpperThresholdNonCritic'
	DB	'al', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HGEJIDLL@UpperThresholdFatal@
CONST	SEGMENT
??_C@_0BE@HGEJIDLL@UpperThresholdFatal@ DB 'UpperThresholdFatal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FKDKGMLL@UpperThresholdCritical@
CONST	SEGMENT
??_C@_0BH@FKDKGMLL@UpperThresholdCritical@ DB 'UpperThresholdCritical', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical@
CONST	SEGMENT
??_C@_0BK@LBKIMOJN@LowerThresholdNonCritical@ DB 'LowerThresholdNonCritic'
	DB	'al', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NPMAGCMK@LowerThresholdFatal@
CONST	SEGMENT
??_C@_0BE@NPMAGCMK@LowerThresholdFatal@ DB 'LowerThresholdFatal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NMAIJHFM@LowerThresholdCritical@
CONST	SEGMENT
??_C@_0BH@NMAIJHFM@LowerThresholdCritical@ DB 'LowerThresholdCritical', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FBKECFPC@NormalMin@
CONST	SEGMENT
??_C@_09FBKECFPC@NormalMin@ DB 'NormalMin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EDCPMBJN@NormalMax@
CONST	SEGMENT
??_C@_09EDCPMBJN@NormalMax@ DB 'NormalMax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OAFFNBPO@NominalReading@
CONST	SEGMENT
??_C@_0P@OAFFNBPO@NominalReading@ DB 'NominalReading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BKMALBOE@Tolerance@
CONST	SEGMENT
??_C@_09BKMALBOE@Tolerance@ DB 'Tolerance', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLCOAFEI@Accuracy@
CONST	SEGMENT
??_C@_08NLCOAFEI@Accuracy@ DB 'Accuracy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDBBEDLI@CurrentReading@
CONST	SEGMENT
??_C@_0P@IDBBEDLI@CurrentReading@ DB 'CurrentReading', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
CONST	SEGMENT
??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@ DB 'Win32_CurrentProbe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JBKHOEPE@SystemUpTime@
CONST	SEGMENT
??_C@_0N@JBKHOEPE@SystemUpTime@ DB 'SystemUpTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HMBPBBJB@SystemCallsPerSec@
CONST	SEGMENT
??_C@_0BC@HMBPBBJB@SystemCallsPerSec@ DB 'SystemCallsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPGOAGED@ProcessorQueueLength@
CONST	SEGMENT
??_C@_0BF@NPGOAGED@ProcessorQueueLength@ DB 'ProcessorQueueLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NGGOKLMO@PercentRegistryQuotaInUse@
CONST	SEGMENT
??_C@_0BK@NGGOKLMO@PercentRegistryQuotaInUse@ DB 'PercentRegistryQuotaInU'
	DB	'se', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PHDBHNCO@FloatingEmulationsPerSec@
CONST	SEGMENT
??_C@_0BJ@PHDBHNCO@FloatingEmulationsPerSec@ DB 'FloatingEmulationsPerSec'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LGMPDKBA@FileWriteBytesPerSec@
CONST	SEGMENT
??_C@_0BF@LGMPDKBA@FileWriteBytesPerSec@ DB 'FileWriteBytesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NKKLPLAB@FileReadBytesPerSec@
CONST	SEGMENT
??_C@_0BE@NKKLPLAB@FileReadBytesPerSec@ DB 'FileReadBytesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PIKKJCOI@FileControlOperationsPerSec@
CONST	SEGMENT
??_C@_0BM@PIKKJCOI@FileControlOperationsPerSec@ DB 'FileControlOperations'
	DB	'PerSec', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EMNLAEFK@FileControlBytesPerSec@
CONST	SEGMENT
??_C@_0BH@EMNLAEFK@FileControlBytesPerSec@ DB 'FileControlBytesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DHKAACDP@ExceptionDispatchesPerSec@
CONST	SEGMENT
??_C@_0BK@DHKAACDP@ExceptionDispatchesPerSec@ DB 'ExceptionDispatchesPerS'
	DB	'ec', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GIPKJDB@ContextSwitchesPerSec@
CONST	SEGMENT
??_C@_0BG@GIPKJDB@ContextSwitchesPerSec@ DB 'ContextSwitchesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KHFHJKMP@AlignmentFixupsPerSec@
CONST	SEGMENT
??_C@_0BG@KHFHJKMP@AlignmentFixupsPerSec@ DB 'AlignmentFixupsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
CONST	SEGMENT
??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@ DB 'Win32_PerfRawData'
	DB	'_PerfOS_System', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FPNGHOGK@PercentPrivilegedTime@
CONST	SEGMENT
??_C@_0BG@FPNGHOGK@PercentPrivilegedTime@ DB 'PercentPrivilegedTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GMGAHOLM@PercentInterruptTime@
CONST	SEGMENT
??_C@_0BF@GMGAHOLM@PercentInterruptTime@ DB 'PercentInterruptTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMLLFJEI@PercentDPCTime@
CONST	SEGMENT
??_C@_0P@LMLLFJEI@PercentDPCTime@ DB 'PercentDPCTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEJEMNCG@PercentC3Time@
CONST	SEGMENT
??_C@_0O@LEJEMNCG@PercentC3Time@ DB 'PercentC3Time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HPMIBOID@PercentC2Time@
CONST	SEGMENT
??_C@_0O@HPMIBOID@PercentC2Time@ DB 'PercentC2Time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PJFMGMCN@PercentC1Time@
CONST	SEGMENT
??_C@_0O@PJFMGMCN@PercentC1Time@ DB 'PercentC1Time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCICDGPJ@InterruptsPerSec@
CONST	SEGMENT
??_C@_0BB@FCICDGPJ@InterruptsPerSec@ DB 'InterruptsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KHEGFAIJ@DPCsQueuedPerSec@
CONST	SEGMENT
??_C@_0BB@KHEGFAIJ@DPCsQueuedPerSec@ DB 'DPCsQueuedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHCICOFH@DPCRate@
CONST	SEGMENT
??_C@_07BHCICOFH@DPCRate@ DB 'DPCRate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EPCEDEOH@C3TransitionsPerSec@
CONST	SEGMENT
??_C@_0BE@EPCEDEOH@C3TransitionsPerSec@ DB 'C3TransitionsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JIMGLELP@C2TransitionsPerSec@
CONST	SEGMENT
??_C@_0BE@JIMGLELP@C2TransitionsPerSec@ DB 'C2TransitionsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DLJADCBG@C1TransitionsPerSec@
CONST	SEGMENT
??_C@_0BE@DLJADCBG@C1TransitionsPerSec@ DB 'C1TransitionsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCLIOML@PercentUserTime@
CONST	SEGMENT
??_C@_0BA@JCLIOML@PercentUserTime@ DB 'PercentUserTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EMKPKJGP@PercentProcessorTime@
CONST	SEGMENT
??_C@_0BF@EMKPKJGP@PercentProcessorTime@ DB 'PercentProcessorTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
CONST	SEGMENT
??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@ DB 'Win32_PerfRawData'
	DB	'_PerfOS_Processor', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JKLALBIF@PercentUsagePeak@
CONST	SEGMENT
??_C@_0BB@JKLALBIF@PercentUsagePeak@ DB 'PercentUsagePeak', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKGFJCHF@PercentUsage@
CONST	SEGMENT
??_C@_0N@CKGFJCHF@PercentUsage@ DB 'PercentUsage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
CONST	SEGMENT
??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@ DB 'Win32_PerfRawData'
	DB	'_PerfOS_PagingFile', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBPDBPOE@Sections@
CONST	SEGMENT
??_C@_08FBPDBPOE@Sections@ DB 'Sections', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLBCAKLN@Semaphores@
CONST	SEGMENT
??_C@_0L@GLBCAKLN@Semaphores@ DB 'Semaphores', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HEBKAGDH@Events@
CONST	SEGMENT
??_C@_06HEBKAGDH@Events@ DB 'Events', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDPBBEEB@Mutexes@
CONST	SEGMENT
??_C@_07LDPBBEEB@Mutexes@ DB 'Mutexes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMIGFCHA@Threads@
CONST	SEGMENT
??_C@_07CMIGFCHA@Threads@ DB 'Threads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNGODGIH@Processes@
CONST	SEGMENT
??_C@_09BNGODGIH@Processes@ DB 'Processes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
CONST	SEGMENT
??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@ DB 'Win32_PerfRawData'
	DB	'_PerfOS_Objects', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBPIOBBH@WriteCopiesPerSec@
CONST	SEGMENT
??_C@_0BC@KBPIOBBH@WriteCopiesPerSec@ DB 'WriteCopiesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KEMPGDKK@TransitionFaultsPerSec@
CONST	SEGMENT
??_C@_0BH@KEMPGDKK@TransitionFaultsPerSec@ DB 'TransitionFaultsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KPIDEMMH@SystemDriverTotalBytes@
CONST	SEGMENT
??_C@_0BH@KPIDEMMH@SystemDriverTotalBytes@ DB 'SystemDriverTotalBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MNCINJBF@SystemDriverResidentBytes@
CONST	SEGMENT
??_C@_0BK@MNCINJBF@SystemDriverResidentBytes@ DB 'SystemDriverResidentByt'
	DB	'es', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JBGABIBK@SystemCodeTotalBytes@
CONST	SEGMENT
??_C@_0BF@JBGABIBK@SystemCodeTotalBytes@ DB 'SystemCodeTotalBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KPKNFENK@SystemCodeResidentBytes@
CONST	SEGMENT
??_C@_0BI@KPKNFENK@SystemCodeResidentBytes@ DB 'SystemCodeResidentBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NPNGHFJN@SystemCacheResidentBytes@
CONST	SEGMENT
??_C@_0BJ@NPNGHFJN@SystemCacheResidentBytes@ DB 'SystemCacheResidentBytes'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OMBHLDMN@PoolPagedResidentBytes@
CONST	SEGMENT
??_C@_0BH@OMBHLDMN@PoolPagedResidentBytes@ DB 'PoolPagedResidentBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PJENKINF@PoolPagedBytes@
CONST	SEGMENT
??_C@_0P@PJENKINF@PoolPagedBytes@ DB 'PoolPagedBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LDKKFHCE@PoolPagedAllocs@
CONST	SEGMENT
??_C@_0BA@LDKKFHCE@PoolPagedAllocs@ DB 'PoolPagedAllocs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMPJEGLC@PoolNonpagedBytes@
CONST	SEGMENT
??_C@_0BC@GMPJEGLC@PoolNonpagedBytes@ DB 'PoolNonpagedBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GAOJBHDB@PoolNonpagedAllocs@
CONST	SEGMENT
??_C@_0BD@GAOJBHDB@PoolNonpagedAllocs@ DB 'PoolNonpagedAllocs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DKFDEGAA@PercentCommittedBytesInUse_Base@
CONST	SEGMENT
??_C@_0CA@DKFDEGAA@PercentCommittedBytesInUse_Base@ DB 'PercentCommittedB'
	DB	'ytesInUse_Base', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EHMKCOHH@PercentCommittedBytesInUse@
CONST	SEGMENT
??_C@_0BL@EHMKCOHH@PercentCommittedBytesInUse@ DB 'PercentCommittedBytesI'
	DB	'nUse', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHHNOBPH@PageWritesPerSec@
CONST	SEGMENT
??_C@_0BB@EHHNOBPH@PageWritesPerSec@ DB 'PageWritesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJBDCOH@PagesPerSec@
CONST	SEGMENT
??_C@_0M@PJBDCOH@PagesPerSec@ DB 'PagesPerSec', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGIEMCPC@PagesOutputPerSec@
CONST	SEGMENT
??_C@_0BC@PGIEMCPC@PagesOutputPerSec@ DB 'PagesOutputPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NHNEKMAP@PagesInputPerSec@
CONST	SEGMENT
??_C@_0BB@NHNEKMAP@PagesInputPerSec@ DB 'PagesInputPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BHCICMAP@PageReadsPerSec@
CONST	SEGMENT
??_C@_0BA@BHCICMAP@PageReadsPerSec@ DB 'PageReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HOEEGAIG@PageFaultsPerSec@
CONST	SEGMENT
??_C@_0BB@HOEEGAIG@PageFaultsPerSec@ DB 'PageFaultsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MIKHIOLC@FreeSystemPageTableEntries@
CONST	SEGMENT
??_C@_0BL@MIKHIOLC@FreeSystemPageTableEntries@ DB 'FreeSystemPageTableEnt'
	DB	'ries', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BIADJNEE@DemandZeroFaultsPerSec@
CONST	SEGMENT
??_C@_0BH@BIADJNEE@DemandZeroFaultsPerSec@ DB 'DemandZeroFaultsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FAEGOFEG@CommittedBytes@
CONST	SEGMENT
??_C@_0P@FAEGOFEG@CommittedBytes@ DB 'CommittedBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHOMCEFN@CommitLimit@
CONST	SEGMENT
??_C@_0M@HHOMCEFN@CommitLimit@ DB 'CommitLimit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ONMHHFEO@CacheFaultsPerSec@
CONST	SEGMENT
??_C@_0BC@ONMHHFEO@CacheFaultsPerSec@ DB 'CacheFaultsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BPAGOPIK@CacheBytesPeak@
CONST	SEGMENT
??_C@_0P@BPAGOPIK@CacheBytesPeak@ DB 'CacheBytesPeak', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECJIAGHC@CacheBytes@
CONST	SEGMENT
??_C@_0L@ECJIAGHC@CacheBytes@ DB 'CacheBytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FJNBCKHA@AvailableMBytes@
CONST	SEGMENT
??_C@_0BA@FJNBCKHA@AvailableMBytes@ DB 'AvailableMBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKABBPEK@AvailableKBytes@
CONST	SEGMENT
??_C@_0BA@DKABBPEK@AvailableKBytes@ DB 'AvailableKBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HPKKNIPF@AvailableBytes@
CONST	SEGMENT
??_C@_0P@HPKKNIPF@AvailableBytes@ DB 'AvailableBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
CONST	SEGMENT
??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@ DB 'Win32_PerfRawData'
	DB	'_PerfOS_Memory', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FOPDLNII@SyncPinReadsPerSec@
CONST	SEGMENT
??_C@_0BD@FOPDLNII@SyncPinReadsPerSec@ DB 'SyncPinReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EPCDKGPG@SyncMDLReadsPerSec@
CONST	SEGMENT
??_C@_0BD@EPCDKGPG@SyncMDLReadsPerSec@ DB 'SyncMDLReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FFPMMLME@SyncFastReadsPerSec@
CONST	SEGMENT
??_C@_0BE@FFPMMLME@SyncFastReadsPerSec@ DB 'SyncFastReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IDCIAAHF@SyncDataMapsPerSec@
CONST	SEGMENT
??_C@_0BD@IDCIAAHF@SyncDataMapsPerSec@ DB 'SyncDataMapsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJJLELAC@SyncCopyReadsPerSec@
CONST	SEGMENT
??_C@_0BE@PJJLELAC@SyncCopyReadsPerSec@ DB 'SyncCopyReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NGKOLIIB@ReadAheadsPerSec@
CONST	SEGMENT
??_C@_0BB@NGKOLIIB@ReadAheadsPerSec@ DB 'ReadAheadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNBHDMMD@PinReadsPerSec@
CONST	SEGMENT
??_C@_0P@LNBHDMMD@PinReadsPerSec@ DB 'PinReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KGBEKIEP@PinReadHitsPercent_Base@
CONST	SEGMENT
??_C@_0BI@KGBEKIEP@PinReadHitsPercent_Base@ DB 'PinReadHitsPercent_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INCEIJBE@PinReadHitsPercent@
CONST	SEGMENT
??_C@_0BD@INCEIJBE@PinReadHitsPercent@ DB 'PinReadHitsPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMMHCHLN@MDLReadsPerSec@
CONST	SEGMENT
??_C@_0P@KMMHCHLN@MDLReadsPerSec@ DB 'MDLReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMONEPAO@MDLReadHitsPercent_Base@
CONST	SEGMENT
??_C@_0BI@NMONEPAO@MDLReadHitsPercent_Base@ DB 'MDLReadHitsPercent_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNDPPHMH@MDLReadHitsPercent@
CONST	SEGMENT
??_C@_0BD@PNDPPHMH@MDLReadHitsPercent@ DB 'MDLReadHitsPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOGJJNKE@LazyWritePagesPerSec@
CONST	SEGMENT
??_C@_0BF@GOGJJNKE@LazyWritePagesPerSec@ DB 'LazyWritePagesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JCPDBLIF@LazyWriteFlushesPerSec@
CONST	SEGMENT
??_C@_0BH@JCPDBLIF@LazyWriteFlushesPerSec@ DB 'LazyWriteFlushesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LEBBLHFN@FastReadsPerSec@
CONST	SEGMENT
??_C@_0BA@LEBBLHFN@FastReadsPerSec@ DB 'FastReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JGPDPBED@FastReadResourceMissesPerSec@
CONST	SEGMENT
??_C@_0BN@JGPDPBED@FastReadResourceMissesPerSec@ DB 'FastReadResourceMiss'
	DB	'esPerSec', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HBAEFMGM@FastReadNotPossiblesPerSec@
CONST	SEGMENT
??_C@_0BL@HBAEFMGM@FastReadNotPossiblesPerSec@ DB 'FastReadNotPossiblesPe'
	DB	'rSec', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAMMIBDO@DataMapsPerSec@
CONST	SEGMENT
??_C@_0P@GAMMIBDO@DataMapsPerSec@ DB 'DataMapsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDIGEHGG@DataMapPinsPerSec_Base@
CONST	SEGMENT
??_C@_0BH@JDIGEHGG@DataMapPinsPerSec_Base@ DB 'DataMapPinsPerSec_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OOMEAEEA@DataMapPinsPerSec@
CONST	SEGMENT
??_C@_0BC@OOMEAEEA@DataMapPinsPerSec@ DB 'DataMapPinsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ILDKBHLK@DataMapHitsPercent_Base@
CONST	SEGMENT
??_C@_0BI@ILDKBHLK@DataMapHitsPercent_Base@ DB 'DataMapHitsPercent_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOAAJIJA@DataMapHitsPercent@
CONST	SEGMENT
??_C@_0BD@KOAAJIJA@DataMapHitsPercent@ DB 'DataMapHitsPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JDDABGEO@DataFlushPagesPerSec@
CONST	SEGMENT
??_C@_0BF@JDDABGEO@DataFlushPagesPerSec@ DB 'DataFlushPagesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MJKDEPG@DataFlushesPerSec@
CONST	SEGMENT
??_C@_0BC@MJKDEPG@DataFlushesPerSec@ DB 'DataFlushesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIHGDHJL@CopyReadsPerSec@
CONST	SEGMENT
??_C@_0BA@BIHGDHJL@CopyReadsPerSec@ DB 'CopyReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FGOEJAHL@CopyReadHitsPercent_Base@
CONST	SEGMENT
??_C@_0BJ@FGOEJAHL@CopyReadHitsPercent_Base@ DB 'CopyReadHitsPercent_Base'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FFJCEMDJ@CopyReadHitsPercent@
CONST	SEGMENT
??_C@_0BE@FFJCEMDJ@CopyReadHitsPercent@ DB 'CopyReadHitsPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PNDFACCO@AsyncPinReadsPerSec@
CONST	SEGMENT
??_C@_0BE@PNDFACCO@AsyncPinReadsPerSec@ DB 'AsyncPinReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OMOFBJFA@AsyncMDLReadsPerSec@
CONST	SEGMENT
??_C@_0BE@OMOFBJFA@AsyncMDLReadsPerSec@ DB 'AsyncMDLReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKOKALKG@AsyncFastReadsPerSec@
CONST	SEGMENT
??_C@_0BF@GKOKALKG@AsyncFastReadsPerSec@ DB 'AsyncFastReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CAOOLPND@AsyncDataMapsPerSec@
CONST	SEGMENT
??_C@_0BE@CAOOLPND@AsyncDataMapsPerSec@ DB 'AsyncDataMapsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MGINILGA@AsyncCopyReadsPerSec@
CONST	SEGMENT
??_C@_0BF@MGINILGA@AsyncCopyReadsPerSec@ DB 'AsyncCopyReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
CONST	SEGMENT
??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@ DB 'Win32_PerfRawData_'
	DB	'PerfOS_Cache', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HAMOOOJ@WriteLargePerSec@
CONST	SEGMENT
??_C@_0BB@HAMOOOJ@WriteLargePerSec@ DB 'WriteLargePerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMECNINB@WriteDeniedPerSec@
CONST	SEGMENT
??_C@_0BC@LMECNINB@WriteDeniedPerSec@ DB 'WriteDeniedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPDBBABB@WritePacketsSmallPerSec@
CONST	SEGMENT
??_C@_0BI@GPDBBABB@WritePacketsSmallPerSec@ DB 'WritePacketsSmallPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NEABLLFJ@WritePacketsPerSec@
CONST	SEGMENT
??_C@_0BD@NEABLLFJ@WritePacketsPerSec@ DB 'WritePacketsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IJPFNDGO@WriteOperationsRandomPerSec@
CONST	SEGMENT
??_C@_0BM@IJPFNDGO@WriteOperationsRandomPerSec@ DB 'WriteOperationsRandom'
	DB	'PerSec', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OANOHFDO@WriteBytesPagingPerSec@
CONST	SEGMENT
??_C@_0BH@OANOHFDO@WriteBytesPagingPerSec@ DB 'WriteBytesPagingPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PNNKNAIA@WriteBytesNonPagingPerSec@
CONST	SEGMENT
??_C@_0BK@PNNKNAIA@WriteBytesNonPagingPerSec@ DB 'WriteBytesNonPagingPerS'
	DB	'ec', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HNBBGOIH@WriteBytesNetworkPerSec@
CONST	SEGMENT
??_C@_0BI@HNBBGOIH@WriteBytesNetworkPerSec@ DB 'WriteBytesNetworkPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GCNKDHCE@WriteBytesCachePerSec@
CONST	SEGMENT
??_C@_0BG@GCNKDHCE@WriteBytesCachePerSec@ DB 'WriteBytesCachePerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BALBBJPI@ServerSessionsHung@
CONST	SEGMENT
??_C@_0BD@BALBBJPI@ServerSessionsHung@ DB 'ServerSessionsHung', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EPIIEJNA@ServerSessions@
CONST	SEGMENT
??_C@_0P@EPIIEJNA@ServerSessions@ DB 'ServerSessions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LGLKKLGK@ServerReconnects@
CONST	SEGMENT
??_C@_0BB@LGLKKLGK@ServerReconnects@ DB 'ServerReconnects', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GAMKMMKB@ServerDisconnects@
CONST	SEGMENT
??_C@_0BC@GAMKMMKB@ServerDisconnects@ DB 'ServerDisconnects', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFKFENGC@ReadsLargePerSec@
CONST	SEGMENT
??_C@_0BB@FFKFENGC@ReadsLargePerSec@ DB 'ReadsLargePerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MGHKCLNK@ReadsDeniedPerSec@
CONST	SEGMENT
??_C@_0BC@MGHKCLNK@ReadsDeniedPerSec@ DB 'ReadsDeniedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JCFIFLJN@ReadPacketsSmallPerSec@
CONST	SEGMENT
??_C@_0BH@JCFIFLJN@ReadPacketsSmallPerSec@ DB 'ReadPacketsSmallPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JALNAJBD@ReadPacketsPerSec@
CONST	SEGMENT
??_C@_0BC@JALNAJBD@ReadPacketsPerSec@ DB 'ReadPacketsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CFIGOGID@ReadOperationsRandomPerSec@
CONST	SEGMENT
??_C@_0BL@CFIGOGID@ReadOperationsRandomPerSec@ DB 'ReadOperationsRandomPe'
	DB	'rSec', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OLGMIDCE@ReadBytesPagingPerSec@
CONST	SEGMENT
??_C@_0BG@OLGMIDCE@ReadBytesPagingPerSec@ DB 'ReadBytesPagingPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ILOCGCLG@ReadBytesNonPagingPerSec@
CONST	SEGMENT
??_C@_0BJ@ILOCGCLG@ReadBytesNonPagingPerSec@ DB 'ReadBytesNonPagingPerSec'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IAHICFAL@ReadBytesNetworkPerSec@
CONST	SEGMENT
??_C@_0BH@IAHICFAL@ReadBytesNetworkPerSec@ DB 'ReadBytesNetworkPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPDAMOL@ReadBytesCachePerSec@
CONST	SEGMENT
??_C@_0BF@LPDAMOL@ReadBytesCachePerSec@ DB 'ReadBytesCachePerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGCPPNJJ@NetworkErrorsPerSec@
CONST	SEGMENT
??_C@_0BE@OGCPPNJJ@NetworkErrorsPerSec@ DB 'NetworkErrorsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec@
CONST	SEGMENT
??_C@_0BK@PGBFPAJ@FileWriteOperationsPerSec@ DB 'FileWriteOperationsPerSe'
	DB	'c', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec@
CONST	SEGMENT
??_C@_0BJ@BKIGCPAP@FileReadOperationsPerSec@ DB 'FileReadOperationsPerSec'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec@
CONST	SEGMENT
??_C@_0BJ@CAIAAECL@FileDataOperationsPerSec@ DB 'FileDataOperationsPerSec'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DJMJIEBG@CurrentCommands@
CONST	SEGMENT
??_C@_0BA@DJMJIEBG@CurrentCommands@ DB 'CurrentCommands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOFEMAHF@ConnectsWindowsNT@
CONST	SEGMENT
??_C@_0BC@EOFEMAHF@ConnectsWindowsNT@ DB 'ConnectsWindowsNT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NEFNEICN@ConnectsLanManager21@
CONST	SEGMENT
??_C@_0BF@NEFNEICN@ConnectsLanManager21@ DB 'ConnectsLanManager21', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MNEGHJGM@ConnectsLanManager20@
CONST	SEGMENT
??_C@_0BF@MNEGHJGM@ConnectsLanManager20@ DB 'ConnectsLanManager20', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IJGODAGI@ConnectsCore@
CONST	SEGMENT
??_C@_0N@IJGODAGI@ConnectsCore@ DB 'ConnectsCore', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EHOOHGK@PacketsTransmittedPerSec@
CONST	SEGMENT
??_C@_0BJ@EHOOHGK@PacketsTransmittedPerSec@ DB 'PacketsTransmittedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PFNBEMLM@PacketsReceivedPerSec@
CONST	SEGMENT
??_C@_0BG@PFNBEMLM@PacketsReceivedPerSec@ DB 'PacketsReceivedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GPMHHPHG@PacketsPerSec@
CONST	SEGMENT
??_C@_0O@GPMHHPHG@PacketsPerSec@ DB 'PacketsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NADCFLBJ@BytesTotalPerSec@
CONST	SEGMENT
??_C@_0BB@NADCFLBJ@BytesTotalPerSec@ DB 'BytesTotalPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GKKKHEEC@BytesTransmittedPerSec@
CONST	SEGMENT
??_C@_0BH@GKKKHEEC@BytesTransmittedPerSec@ DB 'BytesTransmittedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IEAMAKJB@BytesReceivedPerSec@
CONST	SEGMENT
??_C@_0BE@IEAMAKJB@BytesReceivedPerSec@ DB 'BytesReceivedPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
CONST	SEGMENT
??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@ DB 'Win32_PerfRawData'
	DB	'_PerfNet_Redirector', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KEJCKNPB@PercentFreeSpace_Base@
CONST	SEGMENT
??_C@_0BG@KEJCKNPB@PercentFreeSpace_Base@ DB 'PercentFreeSpace_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FDAACFPN@PercentFreeSpace@
CONST	SEGMENT
??_C@_0BB@FDAACFPN@PercentFreeSpace@ DB 'PercentFreeSpace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IJGACNJB@AvgDiskSecPerRead@
CONST	SEGMENT
??_C@_0BC@IJGACNJB@AvgDiskSecPerRead@ DB 'AvgDiskSecPerRead', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJBHEMAA@FreeMegabytes@
CONST	SEGMENT
??_C@_0O@EJBHEMAA@FreeMegabytes@ DB 'FreeMegabytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@
CONST	SEGMENT
??_C@_0CH@LGANEOML@Win32_PerfRawData_PerfDisk_Logi@ DB 'Win32_PerfRawData'
	DB	'_PerfDisk_LogicalDisk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@
CONST	SEGMENT
??_C@_0BD@MIOHPCCM@Timestamp_Sys100NS@ DB 'Timestamp_Sys100NS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ECCCBBP@Timestamp_PerfTime@
CONST	SEGMENT
??_C@_0BD@ECCCBBP@Timestamp_PerfTime@ DB 'Timestamp_PerfTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNCIMECH@Timestamp_Object@
CONST	SEGMENT
??_C@_0BB@JNCIMECH@Timestamp_Object@ DB 'Timestamp_Object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JFLPIICD@SplitIOPerSec@
CONST	SEGMENT
??_C@_0O@JFLPIICD@SplitIOPerSec@ DB 'SplitIOPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PLICIEBG@PercentIdleTime_Base@
CONST	SEGMENT
??_C@_0BF@PLICIEBG@PercentIdleTime_Base@ DB 'PercentIdleTime_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LOOKHAGM@PercentIdleTime@
CONST	SEGMENT
??_C@_0BA@LOOKHAGM@PercentIdleTime@ DB 'PercentIdleTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base@
CONST	SEGMENT
??_C@_0BK@OCJABKEM@PercentDiskWriteTime_Base@ DB 'PercentDiskWriteTime_Ba'
	DB	'se', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DOKCNDOL@PercentDiskWriteTime@
CONST	SEGMENT
??_C@_0BF@DOKCNDOL@PercentDiskWriteTime@ DB 'PercentDiskWriteTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHKOMNLI@PercentDiskTime_Base@
CONST	SEGMENT
??_C@_0BF@CHKOMNLI@PercentDiskTime_Base@ DB 'PercentDiskTime_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPDMAPLN@PercentDiskTime@
CONST	SEGMENT
??_C@_0BA@HPDMAPLN@PercentDiskTime@ DB 'PercentDiskTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base@
CONST	SEGMENT
??_C@_0BJ@JDFDIKDL@PercentDiskReadTime_Base@ DB 'PercentDiskReadTime_Base'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMHMAHCP@PercentDiskReadTime@
CONST	SEGMENT
??_C@_0BE@KMHMAHCP@PercentDiskReadTime@ DB 'PercentDiskReadTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MECIOMGA@Frequency_Sys100NS@
CONST	SEGMENT
??_C@_0BD@MECIOMGA@Frequency_Sys100NS@ DB 'Frequency_Sys100NS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IONDPFD@Frequency_PerfTime@
CONST	SEGMENT
??_C@_0BD@IONDPFD@Frequency_PerfTime@ DB 'Frequency_PerfTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEOEKLCO@Frequency_Object@
CONST	SEGMENT
??_C@_0BB@EEOEKLCO@Frequency_Object@ DB 'Frequency_Object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFLCGPKG@DiskWritesPerSec@
CONST	SEGMENT
??_C@_0BB@FFLCGPKG@DiskWritesPerSec@ DB 'DiskWritesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec@
CONST	SEGMENT
??_C@_0BF@BLPLIECA@DiskWriteBytesPerSec@ DB 'DiskWriteBytesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@INHPJNPE@DiskTransfersPerSec@
CONST	SEGMENT
??_C@_0BE@INHPJNPE@DiskTransfersPerSec@ DB 'DiskTransfersPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GPEPCNFG@DiskReadsPerSec@
CONST	SEGMENT
??_C@_0BA@GPEPCNFG@DiskReadsPerSec@ DB 'DiskReadsPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IJJNINGL@DiskReadBytesPerSec@
CONST	SEGMENT
??_C@_0BE@IJJNINGL@DiskReadBytesPerSec@ DB 'DiskReadBytesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BBEHMIEJ@DiskBytesPerSec@
CONST	SEGMENT
??_C@_0BA@BBEHMIEJ@DiskBytesPerSec@ DB 'DiskBytesPerSec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFGDHLM@CurrentDiskQueueLength@
CONST	SEGMENT
??_C@_0BH@CFGDHLM@CurrentDiskQueueLength@ DB 'CurrentDiskQueueLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength@
CONST	SEGMENT
??_C@_0BI@LJILLEEA@AvgDiskWriteQueueLength@ DB 'AvgDiskWriteQueueLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base@
CONST	SEGMENT
??_C@_0BI@ICCNFHHL@AvgDiskSecPerWrite_Base@ DB 'AvgDiskSecPerWrite_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite@
CONST	SEGMENT
??_C@_0BD@MEJEANKD@AvgDiskSecPerWrite@ DB 'AvgDiskSecPerWrite', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base@
CONST	SEGMENT
??_C@_0BL@BNDKFKFB@AvgDiskSecPerTransfer_Base@ DB 'AvgDiskSecPerTransfer_'
	DB	'Base', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer@
CONST	SEGMENT
??_C@_0BG@JDCFEBPA@AvgDiskSecPerTransfer@ DB 'AvgDiskSecPerTransfer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base@
CONST	SEGMENT
??_C@_0BH@OOEPJOH@AvgDiskSecPerRead_Base@ DB 'AvgDiskSecPerRead_Base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LLDDCMMH@AvgDiskSecPerRead?$DL@
CONST	SEGMENT
??_C@_0BD@LLDDCMMH@AvgDiskSecPerRead?$DL@ DB 'AvgDiskSecPerRead;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength@
CONST	SEGMENT
??_C@_0BH@NCJLEAHB@AvgDiskReadQueueLength@ DB 'AvgDiskReadQueueLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKOOLAI@AvgDiskQueueLength@
CONST	SEGMENT
??_C@_0BD@CKOOLAI@AvgDiskQueueLength@ DB 'AvgDiskQueueLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base@
CONST	SEGMENT
??_C@_0BK@CFFBJGE@AvgDiskBytesPerWrite_Base@ DB 'AvgDiskBytesPerWrite_Bas'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite@
CONST	SEGMENT
??_C@_0BF@POONAKDE@AvgDiskBytesPerWrite@ DB 'AvgDiskBytesPerWrite', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base@
CONST	SEGMENT
??_C@_0BN@DKGECFBJ@AvgDiskBytesPerTransfer_Base@ DB 'AvgDiskBytesPerTrans'
	DB	'fer_Base', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer@
CONST	SEGMENT
??_C@_0BI@NOBLAOA@AvgDiskBytesPerTransfer@ DB 'AvgDiskBytesPerTransfer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base@
CONST	SEGMENT
??_C@_0BJ@BDMNCNHC@AvgDiskBytesPerRead_Base@ DB 'AvgDiskBytesPerRead_Base'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead@
CONST	SEGMENT
??_C@_0BE@EFDGHEPA@AvgDiskBytesPerRead@ DB 'AvgDiskBytesPerRead', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
CONST	SEGMENT
??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@ DB 'Win32_PerfRawData'
	DB	'_PerfDisk_PhysicalDisk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DMMADKEM@SupportsFileBasedCompression@
CONST	SEGMENT
??_C@_0BN@DMMADKEM@SupportsFileBasedCompression@ DB 'SupportsFileBasedCom'
	DB	'pression', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJDMHPHA@SupportsDiskQuotas@
CONST	SEGMENT
??_C@_0BD@BJDMHPHA@SupportsDiskQuotas@ DB 'SupportsDiskQuotas', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JJBCJECG@QuotasRebuilding@
CONST	SEGMENT
??_C@_0BB@JJBCJECG@QuotasRebuilding@ DB 'QuotasRebuilding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MPFPEDFA@QuotasIncomplete@
CONST	SEGMENT
??_C@_0BB@MPFPEDFA@QuotasIncomplete@ DB 'QuotasIncomplete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HEHOMNCC@QuotasEnabled@
CONST	SEGMENT
??_C@_0O@HEHOMNCC@QuotasEnabled@ DB 'QuotasEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ELFKDNP@MaximumFileNameLength@
CONST	SEGMENT
??_C@_0BG@ELFKDNP@MaximumFileNameLength@ DB 'MaximumFileNameLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDIBBDEO@IndexingEnabled@
CONST	SEGMENT
??_C@_0BA@JDIBBDEO@IndexingEnabled@ DB 'IndexingEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMPADJNN@DirtyBitSet@
CONST	SEGMENT
??_C@_0M@FMPADJNN@DirtyBitSet@ DB 'DirtyBitSet', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HICOCIIF@Automount@
CONST	SEGMENT
??_C@_09HICOCIIF@Automount@ DB 'Automount', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FPFLHALM@FileSystem@
CONST	SEGMENT
??_C@_0L@FPFLHALM@FileSystem@ DB 'FileSystem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKILGKMH@DriveType@
CONST	SEGMENT
??_C@_09NKILGKMH@DriveType@ DB 'DriveType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHMJIHII@DriveLetter@
CONST	SEGMENT
??_C@_0M@EHMJIHII@DriveLetter@ DB 'DriveLetter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEIONIFO@Label@
CONST	SEGMENT
??_C@_05IEIONIFO@Label@ DB 'Label', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NNCPDPIH@Win32_Volume@
CONST	SEGMENT
??_C@_0N@NNCPDPIH@Win32_Volume@ DB 'Win32_Volume', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPHJOCBJ@ResourceType@
CONST	SEGMENT
??_C@_0N@EPHJOCBJ@ResourceType@ DB 'ResourceType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONCOBKP@ProviderName@
CONST	SEGMENT
??_C@_0N@ONCOBKP@ProviderName@ DB 'ProviderName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNKKEMJM@Persistent@
CONST	SEGMENT
??_C@_0L@LNKKEMJM@Persistent@ DB 'Persistent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLEBOKCI@RemoteName@
CONST	SEGMENT
??_C@_0L@FLEBOKCI@RemoteName@ DB 'RemoteName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CLGGKACF@LocalName@
CONST	SEGMENT
??_C@_09CLGGKACF@LocalName@ DB 'LocalName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCMICFHJ@RemotePath@
CONST	SEGMENT
??_C@_0L@CCMICFHJ@RemotePath@ DB 'RemotePath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LNPCDAPC@ConnectionType@
CONST	SEGMENT
??_C@_0P@LNPCDAPC@ConnectionType@ DB 'ConnectionType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FLFAPDFG@ConnectionState@
CONST	SEGMENT
??_C@_0BA@FLFAPDFG@ConnectionState@ DB 'ConnectionState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
CONST	SEGMENT
??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@ DB 'Win32_NetworkConnection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BHHBDBIK@YResolution@
CONST	SEGMENT
??_C@_0M@BHHBDBIK@YResolution@ DB 'YResolution', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMNEHNOF@XResolution@
CONST	SEGMENT
??_C@_0M@IMNEHNOF@XResolution@ DB 'XResolution', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FGMLFAJH@VerticalResolution@
CONST	SEGMENT
??_C@_0BD@FGMLFAJH@VerticalResolution@ DB 'VerticalResolution', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KMMMDKPE@TTOption@
CONST	SEGMENT
??_C@_08KMMMDKPE@TTOption@ DB 'TTOption', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAGIBEFI@Scale@
CONST	SEGMENT
??_C@_05MAGIBEFI@Scale@ DB 'Scale', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CLBFGPBN@PrintQuality@
CONST	SEGMENT
??_C@_0N@CLBFGPBN@PrintQuality@ DB 'PrintQuality', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CGGAMGGM@PelsWidth@
CONST	SEGMENT
??_C@_09CGGAMGGM@PelsWidth@ DB 'PelsWidth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FDBJOBNL@PelsHeight@
CONST	SEGMENT
??_C@_0L@FDBJOBNL@PelsHeight@ DB 'PelsHeight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OINDMHF@PaperWidth@
CONST	SEGMENT
??_C@_0L@OINDMHF@PaperWidth@ DB 'PaperWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KFDMKFMI@PaperSize@
CONST	SEGMENT
??_C@_09KFDMKFMI@PaperSize@ DB 'PaperSize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICHOFLKL@PaperLength@
CONST	SEGMENT
??_C@_0M@ICHOFLKL@PaperLength@ DB 'PaperLength', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LHPCLPIO@Orientation@
CONST	SEGMENT
??_C@_0M@LHPCLPIO@Orientation@ DB 'Orientation', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ENKMJEBL@LogPixels@
CONST	SEGMENT
??_C@_09ENKMJEBL@LogPixels@ DB 'LogPixels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FOMIFJDP@HorizontalResolution@
CONST	SEGMENT
??_C@_0BF@FOMIFJDP@HorizontalResolution@ DB 'HorizontalResolution', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOPEEPJC@FormName@
CONST	SEGMENT
??_C@_08EOPEEPJC@FormName@ DB 'FormName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KIOALPNI@Duplex@
CONST	SEGMENT
??_C@_06KIOALPNI@Duplex@ DB 'Duplex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJLGFJEJ@DisplayFrequency@
CONST	SEGMENT
??_C@_0BB@FJLGFJEJ@DisplayFrequency@ DB 'DisplayFrequency', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJPIPGBF@DisplayFlags@
CONST	SEGMENT
??_C@_0N@DJPIPGBF@DisplayFlags@ DB 'DisplayFlags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FHIBJDML@DeviceName@
CONST	SEGMENT
??_C@_0L@FHIBJDML@DeviceName@ DB 'DeviceName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BLCAIJFC@Copies@
CONST	SEGMENT
??_C@_06BLCAIJFC@Copies@ DB 'Copies', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDOBBJNA@Color@
CONST	SEGMENT
??_C@_05PDOBBJNA@Color@ DB 'Color', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLCNEDPB@Collate@
CONST	SEGMENT
??_C@_07KLCNEDPB@Collate@ DB 'Collate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MJJCDBO@BitsPerPel@
CONST	SEGMENT
??_C@_0L@MJJCDBO@BitsPerPel@ DB 'BitsPerPel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@
CONST	SEGMENT
??_C@_0BL@CLHPKLFC@Win32_PrinterConfiguration@ DB 'Win32_PrinterConfigura'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NOBDNJPM@MofSelfInstallDirectory@
CONST	SEGMENT
??_C@_0BI@NOBDNJPM@MofSelfInstallDirectory@ DB 'MofSelfInstallDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHHFPHIJ@MaxWaitOnEvents@
CONST	SEGMENT
??_C@_0BA@NHHFPHIJ@MaxWaitOnEvents@ DB 'MaxWaitOnEvents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PBKELOKA@MaxWaitOnClientObjects@
CONST	SEGMENT
??_C@_0BH@PBKELOKA@MaxWaitOnClientObjects@ DB 'MaxWaitOnClientObjects', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CEPALFMK@MaxLogFileSize@
CONST	SEGMENT
??_C@_0P@CEPALFMK@MaxLogFileSize@ DB 'MaxLogFileSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHEPMKDN@LowThresholdOnEvents@
CONST	SEGMENT
??_C@_0BF@PHEPMKDN@LowThresholdOnEvents@ DB 'LowThresholdOnEvents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NGNJMOHJ@LowThresholdOnClientObjects@
CONST	SEGMENT
??_C@_0BM@NGNJMOHJ@LowThresholdOnClientObjects@ DB 'LowThresholdOnClientO'
	DB	'bjects', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMFGOJPB@LoggingLevel@
CONST	SEGMENT
??_C@_0N@FMFGOJPB@LoggingLevel@ DB 'LoggingLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FALFKNPE@LoggingDirectory@
CONST	SEGMENT
??_C@_0BB@FALFKNPE@LoggingDirectory@ DB 'LoggingDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GKEEMEKI@LastStartupHeapPreallocation@
CONST	SEGMENT
??_C@_0BN@GKEEMEKI@LastStartupHeapPreallocation@ DB 'LastStartupHeapPreal'
	DB	'location', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MDEOBFAH@InstallationDirectory@
CONST	SEGMENT
??_C@_0BG@MDEOBFAH@InstallationDirectory@ DB 'InstallationDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LKICGCBK@HighThresholdOnEvents@
CONST	SEGMENT
??_C@_0BG@LKICGCBK@HighThresholdOnEvents@ DB 'HighThresholdOnEvents', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FBHHPGGC@HighThresholdOnClientObjects@
CONST	SEGMENT
??_C@_0BN@FBHHPGGC@HighThresholdOnClientObjects@ DB 'HighThresholdOnClien'
	DB	'tObjects', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DHLDKHJI@EnableStartupHeapPreallocation@
CONST	SEGMENT
??_C@_0BP@DHLDKHJI@EnableStartupHeapPreallocation@ DB 'EnableStartupHeapP'
	DB	'reallocation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBNHEDLP@EnableEvents@
CONST	SEGMENT
??_C@_0N@OBNHEDLP@EnableEvents@ DB 'EnableEvents', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FLALGEND@EnableAnonWin9xConnections@
CONST	SEGMENT
??_C@_0BL@FLALGEND@EnableAnonWin9xConnections@ DB 'EnableAnonWin9xConnect'
	DB	'ions', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMIIIOHB@DatabaseMaxSize@
CONST	SEGMENT
??_C@_0BA@GMIIIOHB@DatabaseMaxSize@ DB 'DatabaseMaxSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PJAEIMII@DatabaseDirectory@
CONST	SEGMENT
??_C@_0BC@PJAEIMII@DatabaseDirectory@ DB 'DatabaseDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DMPKCKPJ@BuildVersion@
CONST	SEGMENT
??_C@_0N@DMPKCKPJ@BuildVersion@ DB 'BuildVersion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HCKKJOFA@BackupLastTime@
CONST	SEGMENT
??_C@_0P@HCKKJOFA@BackupLastTime@ DB 'BackupLastTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HCBDPJED@BackupInterval@
CONST	SEGMENT
??_C@_0P@HCBDPJED@BackupInterval@ DB 'BackupInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LBFHKJDL@AutoStartWin9X@
CONST	SEGMENT
??_C@_0P@LBFHKJDL@AutoStartWin9X@ DB 'AutoStartWin9X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FCAEOBFB@AutorecoverMofs@
CONST	SEGMENT
??_C@_0BA@FCAEOBFB@AutorecoverMofs@ DB 'AutorecoverMofs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HHJGCMCA@ASPScriptEnabled@
CONST	SEGMENT
??_C@_0BB@HHJGCMCA@ASPScriptEnabled@ DB 'ASPScriptEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HACJICBD@ASPScriptDefaultNamespace@
CONST	SEGMENT
??_C@_0BK@HACJICBD@ASPScriptDefaultNamespace@ DB 'ASPScriptDefaultNamespa'
	DB	'ce', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BBHCGAKO@Win32_WMISetting@
CONST	SEGMENT
??_C@_0BB@BBHCGAKO@Win32_WMISetting@ DB 'Win32_WMISetting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GDCPFLAD@RemainingGracePeriod@
CONST	SEGMENT
??_C@_0BF@GDCPFLAD@RemainingGracePeriod@ DB 'RemainingGracePeriod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MHMKFBPN@RemainingEvaluationPeriod@
CONST	SEGMENT
??_C@_0BK@MHMKFBPN@RemainingEvaluationPeriod@ DB 'RemainingEvaluationPeri'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFPKNIIL@IsNotificationOn@
CONST	SEGMENT
??_C@_0BB@FFPKNIIL@IsNotificationOn@ DB 'IsNotificationOn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HINAAJAB@ActivationRequired@
CONST	SEGMENT
??_C@_0BD@HINAAJAB@ActivationRequired@ DB 'ActivationRequired', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@
CONST	SEGMENT
??_C@_0BP@BGMJPOID@Win32_WindowsProductActivation@ DB 'Win32_WindowsProdu'
	DB	'ctActivation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEAHLPLG@AllowMaximum@
CONST	SEGMENT
??_C@_0N@PEAHLPLG@AllowMaximum@ DB 'AllowMaximum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IBLGFEE@MaximumAllowed@
CONST	SEGMENT
??_C@_0P@IBLGFEE@MaximumAllowed@ DB 'MaximumAllowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HMIIHGGM@Path@
CONST	SEGMENT
??_C@_04HMIIHGGM@Path@ DB 'Path', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCIKNCEL@Win32_Share@
CONST	SEGMENT
??_C@_0M@MCIKNCEL@Win32_Share@ DB 'Win32_Share', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FFDIDHBB@ServerName@
CONST	SEGMENT
??_C@_0L@FFDIDHBB@ServerName@ DB 'ServerName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCMAAPLG@ProxyServer@
CONST	SEGMENT
??_C@_0M@BCMAAPLG@ProxyServer@ DB 'ProxyServer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LEMEMCNN@ProxyPortNumber@
CONST	SEGMENT
??_C@_0BA@LEMEMCNN@ProxyPortNumber@ DB 'ProxyPortNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GFHBIAHO@Win32_Proxy@
CONST	SEGMENT
??_C@_0M@GFHBIAHO@Win32_Proxy@ DB 'Win32_Proxy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LICOLOBE@DMASupport@
CONST	SEGMENT
??_C@_0L@LICOLOBE@DMASupport@ DB 'DMASupport', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@
CONST	SEGMENT
??_C@_0BD@CPCJFLPJ@Win32_ParallelPort@ DB 'Win32_ParallelPort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EONNPILK@InitialSize@
CONST	SEGMENT
??_C@_0M@EONNPILK@InitialSize@ DB 'InitialSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LCEICGML@FreeSpace@
CONST	SEGMENT
??_C@_09LCEICGML@FreeSpace@ DB 'FreeSpace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GFMPEM@Win32_PageFile@
CONST	SEGMENT
??_C@_0P@GFMPEM@Win32_PageFile@ DB 'Win32_PageFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EOFEPLNL@TotalVisibleMemorySize@
CONST	SEGMENT
??_C@_0BH@EOFEPLNL@TotalVisibleMemorySize@ DB 'TotalVisibleMemorySize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IBKKELEK@TotalVirtualMemorySize@
CONST	SEGMENT
??_C@_0BH@IBKKELEK@TotalVirtualMemorySize@ DB 'TotalVirtualMemorySize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PBNAJGBH@TotalSwapSpaceSize@
CONST	SEGMENT
??_C@_0BD@PBNAJGBH@TotalSwapSpaceSize@ DB 'TotalSwapSpaceSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IIJPJFOC@SuiteMask@
CONST	SEGMENT
??_C@_09IIJPJFOC@SuiteMask@ DB 'SuiteMask', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BKJHEEOL@SizeStoredInPagingFiles@
CONST	SEGMENT
??_C@_0BI@BKJHEEOL@SizeStoredInPagingFiles@ DB 'SizeStoredInPagingFiles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAEHBBNL@Primary@
CONST	SEGMENT
??_C@_07NAEHBBNL@Primary@ DB 'Primary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMIHOAGL@PlusVersionNumber@
CONST	SEGMENT
??_C@_0BC@LMIHOAGL@PlusVersionNumber@ DB 'PlusVersionNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NNCCMBIG@PlusProductID@
CONST	SEGMENT
??_C@_0O@NNCCMBIG@PlusProductID@ DB 'PlusProductID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNGIFFNB@PAEEnabled@
CONST	SEGMENT
??_C@_0L@KNGIFFNB@PAEEnabled@ DB 'PAEEnabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KAMHDIPP@OtherTypeDescription@
CONST	SEGMENT
??_C@_0BF@KAMHDIPP@OtherTypeDescription@ DB 'OtherTypeDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GLJCNHGP@OperatingSystemSKU@
CONST	SEGMENT
??_C@_0BD@GLJCNHGP@OperatingSystemSKU@ DB 'OperatingSystemSKU', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBBGLGFJ@NumberOfUsers@
CONST	SEGMENT
??_C@_0O@PBBGLGFJ@NumberOfUsers@ DB 'NumberOfUsers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FILGLGHH@NumberOfProcesses@
CONST	SEGMENT
??_C@_0BC@FILGLGHH@NumberOfProcesses@ DB 'NumberOfProcesses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MGHJNMGE@NumberOfLicensedUsers@
CONST	SEGMENT
??_C@_0BG@MGHJNMGE@NumberOfLicensedUsers@ DB 'NumberOfLicensedUsers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEFLNODO@MUILanguages@
CONST	SEGMENT
??_C@_0N@FEFLNODO@MUILanguages@ DB 'MUILanguages', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OEEDDGBK@MaxProcessMemorySize@
CONST	SEGMENT
??_C@_0BF@OEEDDGBK@MaxProcessMemorySize@ DB 'MaxProcessMemorySize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BJJFAIPL@MaxNumberOfProcesses@
CONST	SEGMENT
??_C@_0BF@BJJFAIPL@MaxNumberOfProcesses@ DB 'MaxNumberOfProcesses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMNFLCFO@Locale@
CONST	SEGMENT
??_C@_06BMNFLCFO@Locale@ DB 'Locale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GFNPHCJN@LocalDateTime@
CONST	SEGMENT
??_C@_0O@GFNPHCJN@LocalDateTime@ DB 'LocalDateTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DKHNBJBB@LastBootUpTime@
CONST	SEGMENT
??_C@_0P@DKHNBJBB@LastBootUpTime@ DB 'LastBootUpTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GLODIIPC@LargeSystemCache@
CONST	SEGMENT
??_C@_0BB@GLODIIPC@LargeSystemCache@ DB 'LargeSystemCache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HEKPKJCK@FreeVirtualMemory@
CONST	SEGMENT
??_C@_0BC@HEKPKJCK@FreeVirtualMemory@ DB 'FreeVirtualMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDCHGEBO@FreeSpaceInPagingFiles@
CONST	SEGMENT
??_C@_0BH@GDCHGEBO@FreeSpaceInPagingFiles@ DB 'FreeSpaceInPagingFiles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KJPLACJD@FreePhysicalMemory@
CONST	SEGMENT
??_C@_0BD@KJPLACJD@FreePhysicalMemory@ DB 'FreePhysicalMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LKLGBOHP@ForegroundApplicationBoost@
CONST	SEGMENT
??_C@_0BL@LKLGBOHP@ForegroundApplicationBoost@ DB 'ForegroundApplicationB'
	DB	'oost', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LIJDDPMD@EncryptionLevel@
CONST	SEGMENT
??_C@_0BA@LIJDDPMD@EncryptionLevel@ DB 'EncryptionLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGCHPHG@Distributed@
CONST	SEGMENT
??_C@_0M@DGCHPHG@Distributed@ DB 'Distributed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCIPIGEI@Debug@
CONST	SEGMENT
??_C@_05GCIPIGEI@Debug@ DB 'Debug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FOLHLACL@DataExecutionPrevention_Support@
CONST	SEGMENT
??_C@_0CG@FOLHLACL@DataExecutionPrevention_Support@ DB 'DataExecutionPrev'
	DB	'ention_SupportPolicy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KCIFHCEN@DataExecutionPrevention_Drivers@
CONST	SEGMENT
??_C@_0CA@KCIFHCEN@DataExecutionPrevention_Drivers@ DB 'DataExecutionPrev'
	DB	'ention_Drivers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PHHDEHCB@DataExecutionPrevention_32BitAp@
CONST	SEGMENT
??_C@_0CK@PHHDEHCB@DataExecutionPrevention_32BitAp@ DB 'DataExecutionPrev'
	DB	'ention_32BitApplications', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LDMHMPMB@DataExecutionPrevention_Availab@
CONST	SEGMENT
??_C@_0CC@LDMHMPMB@DataExecutionPrevention_Availab@ DB 'DataExecutionPrev'
	DB	'ention_Available', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IOMOHLID@OSLanguage@
CONST	SEGMENT
??_C@_0L@IOMOHLID@OSLanguage@ DB 'OSLanguage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IEJHMEDK@WindowsDirectory@
CONST	SEGMENT
??_C@_0BB@IEJHMEDK@WindowsDirectory@ DB 'WindowsDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FNJMICPB@SystemDirectory@
CONST	SEGMENT
??_C@_0BA@FNJMICPB@SystemDirectory@ DB 'SystemDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBPIDKPO@SystemDrive@
CONST	SEGMENT
??_C@_0M@JBPIDKPO@SystemDrive@ DB 'SystemDrive', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCIKLBMI@SystemDevice@
CONST	SEGMENT
??_C@_0N@LCIKLBMI@SystemDevice@ DB 'SystemDevice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLKKOICB@BootDevice@
CONST	SEGMENT
??_C@_0L@BLKKOICB@BootDevice@ DB 'BootDevice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGPOPAAP@ProductType@
CONST	SEGMENT
??_C@_0M@GGPOPAAP@ProductType@ DB 'ProductType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAFCPCAO@RegisteredUser@
CONST	SEGMENT
??_C@_0P@DAFCPCAO@RegisteredUser@ DB 'RegisteredUser', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MHPBIIPD@Organization@
CONST	SEGMENT
??_C@_0N@MHPBIIPD@Organization@ DB 'Organization', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNBFCOOH@OSType@
CONST	SEGMENT
??_C@_06MNBFCOOH@OSType@ DB 'OSType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HNONGDKL@OSProductSuite@
CONST	SEGMENT
??_C@_0P@HNONGDKL@OSProductSuite@ DB 'OSProductSuite', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HEBPKKOL@ServicePackMinorVersion@
CONST	SEGMENT
??_C@_0BI@HEBPKKOL@ServicePackMinorVersion@ DB 'ServicePackMinorVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCMKKPJH@ServicePackMajorVersion@
CONST	SEGMENT
??_C@_0BI@MCMKKPJH@ServicePackMajorVersion@ DB 'ServicePackMajorVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGALIDNG@CSDVersion@
CONST	SEGMENT
??_C@_0L@EGALIDNG@CSDVersion@ DB 'CSDVersion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLAGGHGM@BuildType@
CONST	SEGMENT
??_C@_09LLAGGHGM@BuildType@ DB 'BuildType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NOCBMKBI@OSArchitecture@
CONST	SEGMENT
??_C@_0P@NOCBMKBI@OSArchitecture@ DB 'OSArchitecture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@
CONST	SEGMENT
??_C@_0BG@MCGAGLCL@Win32_OperatingSystem@ DB 'Win32_OperatingSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ODMHJIAL@VariableSpeed@
CONST	SEGMENT
??_C@_0O@ODMHJIAL@VariableSpeed@ DB 'VariableSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HOGGFFKF@DesiredSpeed@
CONST	SEGMENT
??_C@_0N@HOGGFFKF@DesiredSpeed@ DB 'DesiredSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BEHCCOGC@Win32_Fan@
CONST	SEGMENT
??_C@_09BEHCCOGC@Win32_Fan@ DB 'Win32_Fan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAHMDPOP@DisplayType@
CONST	SEGMENT
??_C@_0M@GAHMDPOP@DisplayType@ DB 'DisplayType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LPCHGGLO@Bandwidth@
CONST	SEGMENT
??_C@_09LPCHGGLO@Bandwidth@ DB 'Bandwidth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCPFJAEP@MonitorType@
CONST	SEGMENT
??_C@_0M@FCPFJAEP@MonitorType@ DB 'MonitorType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EAJFLPNK@MonitorManufacturer@
CONST	SEGMENT
??_C@_0BE@EAJFLPNK@MonitorManufacturer@ DB 'MonitorManufacturer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EKBBLDAL@PixelsPerYLogicalInch@
CONST	SEGMENT
??_C@_0BG@EKBBLDAL@PixelsPerYLogicalInch@ DB 'PixelsPerYLogicalInch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JHIHGKIO@PixelsPerXLogicalInch@
CONST	SEGMENT
??_C@_0BG@JHIHGKIO@PixelsPerXLogicalInch@ DB 'PixelsPerXLogicalInch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOACCFHI@ScreenWidth@
CONST	SEGMENT
??_C@_0M@GOACCFHI@ScreenWidth@ DB 'ScreenWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EJILFHEF@ScreenHeight@
CONST	SEGMENT
??_C@_0N@EJILFHEF@ScreenHeight@ DB 'ScreenHeight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@
CONST	SEGMENT
??_C@_0BF@CJJIHFON@Win32_DesktopMonitor@ DB 'Win32_DesktopMonitor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLGPBKPI@WallpaperTiled@
CONST	SEGMENT
??_C@_0P@HLGPBKPI@WallpaperTiled@ DB 'WallpaperTiled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MNOICNPG@WallpaperStretched@
CONST	SEGMENT
??_C@_0BD@MNOICNPG@WallpaperStretched@ DB 'WallpaperStretched', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FAKNONCF@Wallpaper@
CONST	SEGMENT
??_C@_09FAKNONCF@Wallpaper@ DB 'Wallpaper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIKEHLGN@ScreenSaverTimeout@
CONST	SEGMENT
??_C@_0BD@LIKEHLGN@ScreenSaverTimeout@ DB 'ScreenSaverTimeout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ENMGOCGL@ScreenSaverSecure@
CONST	SEGMENT
??_C@_0BC@ENMGOCGL@ScreenSaverSecure@ DB 'ScreenSaverSecure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OPEGFPLM@ScreenSaverExecutable@
CONST	SEGMENT
??_C@_0BG@OPEGFPLM@ScreenSaverExecutable@ DB 'ScreenSaverExecutable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KENIIHPI@ScreenSaverActive@
CONST	SEGMENT
??_C@_0BC@KENIIHPI@ScreenSaverActive@ DB 'ScreenSaverActive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NOCIGAPP@Pattern@
CONST	SEGMENT
??_C@_07NOCIGAPP@Pattern@ DB 'Pattern', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLNDODKM@IconTitleWrap@
CONST	SEGMENT
??_C@_0O@HLNDODKM@IconTitleWrap@ DB 'IconTitleWrap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COINDPHH@IconTitleSize@
CONST	SEGMENT
??_C@_0O@COINDPHH@IconTitleSize@ DB 'IconTitleSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HAAMKFAI@IconTitleFaceName@
CONST	SEGMENT
??_C@_0BC@HAAMKFAI@IconTitleFaceName@ DB 'IconTitleFaceName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FALLBHKM@IconSpacing@
CONST	SEGMENT
??_C@_0M@FALLBHKM@IconSpacing@ DB 'IconSpacing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJNOPNAD@GridGranularity@
CONST	SEGMENT
??_C@_0BA@MJNOPNAD@GridGranularity@ DB 'GridGranularity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CNEMFCKH@DragFullWindows@
CONST	SEGMENT
??_C@_0BA@CNEMFCKH@DragFullWindows@ DB 'DragFullWindows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NKDGIFD@CursorBlinkRate@
CONST	SEGMENT
??_C@_0BA@NKDGIFD@CursorBlinkRate@ DB 'CursorBlinkRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GMHAONPD@CoolSwitch@
CONST	SEGMENT
??_C@_0L@GMHAONPD@CoolSwitch@ DB 'CoolSwitch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEKAPENF@BorderWidth@
CONST	SEGMENT
??_C@_0M@EEKAPENF@BorderWidth@ DB 'BorderWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLAGCNDM@Win32_Desktop@
CONST	SEGMENT
??_C@_0O@MLAGCNDM@Win32_Desktop@ DB 'Win32_Desktop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDHFFDED@TempDirectory@
CONST	SEGMENT
??_C@_0O@FDHFFDED@TempDirectory@ DB 'TempDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FHBPINGK@ScratchDirectory@
CONST	SEGMENT
??_C@_0BB@FHBPINGK@ScratchDirectory@ DB 'ScratchDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PABAEPFH@LastDrive@
CONST	SEGMENT
??_C@_09PABAEPFH@LastDrive@ DB 'LastDrive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BJLIMIEA@ConfigurationPath@
CONST	SEGMENT
??_C@_0BC@BJLIMIEA@ConfigurationPath@ DB 'ConfigurationPath', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KLLIKPKC@BootDirectory@
CONST	SEGMENT
??_C@_0O@KLLIKPKC@BootDirectory@ DB 'BootDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@
CONST	SEGMENT
??_C@_0BI@EMHOOOGN@Win32_BootConfiguration@ DB 'Win32_BootConfiguration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DPAOPBJD@Win32_BaseService@
CONST	SEGMENT
??_C@_0BC@DPAOPBJD@Win32_BaseService@ DB 'Win32_BaseService', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PKCEDPHO@LastUse@
CONST	SEGMENT
??_C@_07PKCEDPHO@LastUse@ DB 'LastUse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PLFFHFAH@Attributes@
CONST	SEGMENT
??_C@_0L@PLFFHFAH@Attributes@ DB 'Attributes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBOKCFEP@Accesses@
CONST	SEGMENT
??_C@_08OBOKCFEP@Accesses@ DB 'Accesses', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@
CONST	SEGMENT
??_C@_0BG@OEFCBCCA@Win32_SoftwareFeature@ DB 'Win32_SoftwareFeature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKGIPMHJ@Writeable@
CONST	SEGMENT
??_C@_09HKGIPMHJ@Writeable@ DB 'Writeable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JIODDOFH@System@
CONST	SEGMENT
??_C@_06JIODDOFH@System@ DB 'System', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMHOKLA@Readable@
CONST	SEGMENT
??_C@_08PMHOKLA@Readable@ DB 'Readable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFOMFNHF@LastModified@
CONST	SEGMENT
??_C@_0N@JFOMFNHF@LastModified@ DB 'LastModified', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BLGOKNC@LastAccessed@
CONST	SEGMENT
??_C@_0N@BLGOKNC@LastAccessed@ DB 'LastAccessed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCJCDOJK@InUseCount@
CONST	SEGMENT
??_C@_0L@PCJCDOJK@InUseCount@ DB 'InUseCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHBILLDG@Hidden@
CONST	SEGMENT
??_C@_06FHBILLDG@Hidden@ DB 'Hidden', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MBDCODDP@Group@
CONST	SEGMENT
??_C@_05MBDCODDP@Group@ DB 'Group', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDIOKLEE@FSName@
CONST	SEGMENT
??_C@_06PDIOKLEE@FSName@ DB 'FSName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPNPJAMG@EncryptionMethod@
CONST	SEGMENT
??_C@_0BB@CPNPJAMG@EncryptionMethod@ DB 'EncryptionMethod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KLPLELGE@Encrypted@
CONST	SEGMENT
??_C@_09KLPLELGE@Encrypted@ DB 'Encrypted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GPGLEEKJ@CreationDate@
CONST	SEGMENT
??_C@_0N@GPGLEEKJ@CreationDate@ DB 'CreationDate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBPJPEIN@Compressed@
CONST	SEGMENT
??_C@_0L@FBPJPEIN@Compressed@ DB 'Compressed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNOHFBBG@Archive@
CONST	SEGMENT
??_C@_07CNOHFBBG@Archive@ DB 'Archive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OHPKPJND@AccessMask@
CONST	SEGMENT
??_C@_0L@OHPKPJND@AccessMask@ DB 'AccessMask', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PICKODJL@FileType@
CONST	SEGMENT
??_C@_08PICKODJL@FileType@ DB 'FileType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHIEONMC@FileSize@
CONST	SEGMENT
??_C@_08BHIEONMC@FileSize@ DB 'FileSize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MBMLPGOB@Win32_CodecFile@
CONST	SEGMENT
??_C@_0BA@MBMLPGOB@Win32_CodecFile@ DB 'Win32_CodecFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MNHPDIFA@SupportsQualityofService@
CONST	SEGMENT
??_C@_0BJ@MNHPDIFA@SupportsQualityofService@ DB 'SupportsQualityofService'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BHPPOJFK@SupportsMulticasting@
CONST	SEGMENT
??_C@_0BF@BHPPOJFK@SupportsMulticasting@ DB 'SupportsMulticasting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MDHHIPIM@SupportsGuaranteedBandwidth@
CONST	SEGMENT
??_C@_0BM@MDHHIPIM@SupportsGuaranteedBandwidth@ DB 'SupportsGuaranteedBan'
	DB	'dwidth', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FGBPBAKA@SupportsGracefulClosing@
CONST	SEGMENT
??_C@_0BI@FGBPBAKA@SupportsGracefulClosing@ DB 'SupportsGracefulClosing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PFGLDBHN@SupportsFragmentation?$DL@
CONST	SEGMENT
??_C@_0BH@PFGLDBHN@SupportsFragmentation?$DL@ DB 'SupportsFragmentation;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MJFBKLBP@SupportsExpeditedData@
CONST	SEGMENT
??_C@_0BG@MJFBKLBP@SupportsExpeditedData@ DB 'SupportsExpeditedData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJHEFNDH@SupportsEncryption@
CONST	SEGMENT
??_C@_0BD@BJHEFNDH@SupportsEncryption@ DB 'SupportsEncryption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KMFDMCNH@SupportsDisconnectData@
CONST	SEGMENT
??_C@_0BH@KMFDMCNH@SupportsDisconnectData@ DB 'SupportsDisconnectData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OAOGNDFG@SupportsConnectData@
CONST	SEGMENT
??_C@_0BE@OAOGNDFG@SupportsConnectData@ DB 'SupportsConnectData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ONDNBOBK@SupportsBroadcasting@
CONST	SEGMENT
??_C@_0BF@ONDNBOBK@SupportsBroadcasting@ DB 'SupportsBroadcasting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DJOBDJFP@PseudoStreamOriented@
CONST	SEGMENT
??_C@_0BF@DJOBDJFP@PseudoStreamOriented@ DB 'PseudoStreamOriented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCBKNDJA@MinimumAddressSize@
CONST	SEGMENT
??_C@_0BD@PCBKNDJA@MinimumAddressSize@ DB 'MinimumAddressSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NLEIFDG@MessageOriented@
CONST	SEGMENT
??_C@_0BA@NLEIFDG@MessageOriented@ DB 'MessageOriented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IBPHBINL@MaximumMessageSize@
CONST	SEGMENT
??_C@_0BD@IBPHBINL@MaximumMessageSize@ DB 'MaximumMessageSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFCOFDOJ@MaximumAddressSize@
CONST	SEGMENT
??_C@_0BD@FFCOFDOJ@MaximumAddressSize@ DB 'MaximumAddressSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAHCIDLD@GuaranteesSequencing@
CONST	SEGMENT
??_C@_0BF@FAHCIDLD@GuaranteesSequencing@ DB 'GuaranteesSequencing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ECGOALCK@GuaranteesDelivery@
CONST	SEGMENT
??_C@_0BD@ECGOALCK@GuaranteesDelivery@ DB 'GuaranteesDelivery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IODJFDPJ@ConnectionlessService@
CONST	SEGMENT
??_C@_0BG@IODJFDPJ@ConnectionlessService@ DB 'ConnectionlessService', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@
CONST	SEGMENT
??_C@_0BG@IFKJCFNC@Win32_NetworkProtocol@ DB 'Win32_NetworkProtocol', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMIHDJBC@Workstations@
CONST	SEGMENT
??_C@_0N@LMIHDJBC@Workstations@ DB 'Workstations', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMMEGDEF@UnitsPerWeek@
CONST	SEGMENT
??_C@_0N@LMMEGDEF@UnitsPerWeek@ DB 'UnitsPerWeek', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GHILPLPE@ScriptPath@
CONST	SEGMENT
??_C@_0L@GHILPLPE@ScriptPath@ DB 'ScriptPath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EELFDIBP@Profile@
CONST	SEGMENT
??_C@_07EELFDIBP@Profile@ DB 'Profile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FILALLBE@Privileges@
CONST	SEGMENT
??_C@_0L@FILALLBE@Privileges@ DB 'Privileges', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CIBDNLPH@PrimaryGroupId@
CONST	SEGMENT
??_C@_0P@CIBDNLPH@PrimaryGroupId@ DB 'PrimaryGroupId', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLOHOKEI@PasswordExpires@
CONST	SEGMENT
??_C@_0BA@HLOHOKEI@PasswordExpires@ DB 'PasswordExpires', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKNCEPDC@PasswordAge@
CONST	SEGMENT
??_C@_0M@HKNCEPDC@PasswordAge@ DB 'PasswordAge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PBGCNDPG@Parameters@
CONST	SEGMENT
??_C@_0L@PBGCNDPG@Parameters@ DB 'Parameters', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FMELCCCP@NumberOfLogons@
CONST	SEGMENT
??_C@_0P@FMELCCCP@NumberOfLogons@ DB 'NumberOfLogons', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BDLNENEK@MaximumStorage@
CONST	SEGMENT
??_C@_0P@BDLNENEK@MaximumStorage@ DB 'MaximumStorage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HFGJFNDM@LogonHours@
CONST	SEGMENT
??_C@_0L@HFGJFNDM@LogonHours@ DB 'LogonHours', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JEOPKIAO@LastLogon@
CONST	SEGMENT
??_C@_09JEOPKIAO@LastLogon@ DB 'LastLogon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NKJIFPDG@LastLogoff@
CONST	SEGMENT
??_C@_0L@NKJIFPDG@LastLogoff@ DB 'LastLogoff', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BOOEKJH@Flags@
CONST	SEGMENT
??_C@_05BOOEKJH@Flags@ DB 'Flags', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NALIBBDH@CountryCode@
CONST	SEGMENT
??_C@_0M@NALIBBDH@CountryCode@ DB 'CountryCode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JABLCLAF@Comment@
CONST	SEGMENT
??_C@_07JABLCLAF@Comment@ DB 'Comment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DOHJINHB@CodePage@
CONST	SEGMENT
??_C@_08DOHJINHB@CodePage@ DB 'CodePage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHOPBADB@Caption?$DL@
CONST	SEGMENT
??_C@_08BHOPBADB@Caption?$DL@ DB 'Caption;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OBONNEPA@BadPasswordCount@
CONST	SEGMENT
??_C@_0BB@OBONNEPA@BadPasswordCount@ DB 'BadPasswordCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGGENGAP@AuthorizationFlags@
CONST	SEGMENT
??_C@_0BD@JGGENGAP@AuthorizationFlags@ DB 'AuthorizationFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FLJOKOM@AccountExpires@
CONST	SEGMENT
??_C@_0P@FLJOKOM@AccountExpires@ DB 'AccountExpires', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEGPAPIK@UserComment@
CONST	SEGMENT
??_C@_0M@KEGPAPIK@UserComment@ DB 'UserComment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LFHMHDM@UserType@
CONST	SEGMENT
??_C@_08LFHMHDM@UserType@ DB 'UserType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HAPGBBDI@UserId@
CONST	SEGMENT
??_C@_06HAPGBBDI@UserId@ DB 'UserId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDLIHBHJ@LogonServer@
CONST	SEGMENT
??_C@_0M@NDLIHBHJ@LogonServer@ DB 'LogonServer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBDEODMP@HomeDirectoryDrive@
CONST	SEGMENT
??_C@_0BD@GBDEODMP@HomeDirectoryDrive@ DB 'HomeDirectoryDrive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKMMPAKN@HomeDirectory@
CONST	SEGMENT
??_C@_0O@PKMMPAKN@HomeDirectory@ DB 'HomeDirectory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FPDCFGEH@FullName@
CONST	SEGMENT
??_C@_08FPDCFGEH@FullName@ DB 'FullName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@
CONST	SEGMENT
??_C@_0BK@BBOKMFIH@Win32_NetworkLoginProfile@ DB 'Win32_NetworkLoginProfi'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CHHDIDN@WINSSecondaryServer@
CONST	SEGMENT
??_C@_0BE@CHHDIDN@WINSSecondaryServer@ DB 'WINSSecondaryServer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMEBCDLL@WINSScopeID@
CONST	SEGMENT
??_C@_0M@CMEBCDLL@WINSScopeID@ DB 'WINSScopeID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BECMMLFM@WINSPrimaryServer@
CONST	SEGMENT
??_C@_0BC@BECMMLFM@WINSPrimaryServer@ DB 'WINSPrimaryServer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@POPKKJKC@WINSHostLookupFile@
CONST	SEGMENT
??_C@_0BD@POPKKJKC@WINSHostLookupFile@ DB 'WINSHostLookupFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MIGGLKDO@WINSEnableLMHostsLookup@
CONST	SEGMENT
??_C@_0BI@MIGGLKDO@WINSEnableLMHostsLookup@ DB 'WINSEnableLMHostsLookup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIEPJIDD@TcpWindowSize@
CONST	SEGMENT
??_C@_0O@CIEPJIDD@TcpWindowSize@ DB 'TcpWindowSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JOFENPLC@TcpUseRFC1122UrgentPointer@
CONST	SEGMENT
??_C@_0BL@JOFENPLC@TcpUseRFC1122UrgentPointer@ DB 'TcpUseRFC1122UrgentPoi'
	DB	'nter', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CEGEJAFC@TcpNumConnections@
CONST	SEGMENT
??_C@_0BC@CEGEJAFC@TcpNumConnections@ DB 'TcpNumConnections', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ICGANMDC@TcpMaxDataRetransmissions@
CONST	SEGMENT
??_C@_0BK@ICGANMDC@TcpMaxDataRetransmissions@ DB 'TcpMaxDataRetransmissio'
	DB	'ns', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NBAJINBE@TcpMaxConnectRetransmissions@
CONST	SEGMENT
??_C@_0BN@NBAJINBE@TcpMaxConnectRetransmissions@ DB 'TcpMaxConnectRetrans'
	DB	'missions', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MJKNHDFN@TcpipNetbiosOptions@
CONST	SEGMENT
??_C@_0BE@MJKNHDFN@TcpipNetbiosOptions@ DB 'TcpipNetbiosOptions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KBFAFCNG@PMTUDiscoveryEnabled@
CONST	SEGMENT
??_C@_0BF@KBFAFCNG@PMTUDiscoveryEnabled@ DB 'PMTUDiscoveryEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DPKIODPI@PMTUBHDetectEnabled?$DL@
CONST	SEGMENT
??_C@_0BF@DPKIODPI@PMTUBHDetectEnabled?$DL@ DB 'PMTUBHDetectEnabled;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHJCENM@NumForwardPackets@
CONST	SEGMENT
??_C@_0BC@CHJCENM@NumForwardPackets@ DB 'NumForwardPackets', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLLMIPHO@MTU@
CONST	SEGMENT
??_C@_03BLLMIPHO@MTU@ DB 'MTU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HNPIKCNH@KeepAliveTime@
CONST	SEGMENT
??_C@_0O@HNPIKCNH@KeepAliveTime@ DB 'KeepAliveTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HLLJNCGL@KeepAliveInterval@
CONST	SEGMENT
??_C@_0BC@HLLJNCGL@KeepAliveInterval@ DB 'KeepAliveInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KIGHGIHN@IPXVirtualNetNumber@
CONST	SEGMENT
??_C@_0BE@KIGHGIHN@IPXVirtualNetNumber@ DB 'IPXVirtualNetNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFHJDNKD@IPXNetworkNumber@
CONST	SEGMENT
??_C@_0BB@HFHJDNKD@IPXNetworkNumber@ DB 'IPXNetworkNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHNNAGIP@IPXMediaType@
CONST	SEGMENT
??_C@_0N@FHNNAGIP@IPXMediaType@ DB 'IPXMediaType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EAKCLKKB@IPXFrameType@
CONST	SEGMENT
??_C@_0N@EAKCLKKB@IPXFrameType@ DB 'IPXFrameType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ONDAOAGP@IPXEnabled@
CONST	SEGMENT
??_C@_0L@ONDAOAGP@IPXEnabled@ DB 'IPXEnabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNAHKDDE@IPXAddress@
CONST	SEGMENT
??_C@_0L@JNAHKDDE@IPXAddress@ DB 'IPXAddress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EFBIPBIB@IPUseZeroBroadcast@
CONST	SEGMENT
??_C@_0BD@EFBIPBIB@IPUseZeroBroadcast@ DB 'IPUseZeroBroadcast', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IDDAOKAD@IPSecPermitUDPPorts@
CONST	SEGMENT
??_C@_0BE@IDDAOKAD@IPSecPermitUDPPorts@ DB 'IPSecPermitUDPPorts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JOIOPHFJ@IPSecPermitTCPPorts@
CONST	SEGMENT
??_C@_0BE@JOIOPHFJ@IPSecPermitTCPPorts@ DB 'IPSecPermitTCPPorts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHIPIHMF@IPSecPermitIPProtocols@
CONST	SEGMENT
??_C@_0BH@HHIPIHMF@IPSecPermitIPProtocols@ DB 'IPSecPermitIPProtocols', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IJANIIKC@IPPortSecurityEnabled@
CONST	SEGMENT
??_C@_0BG@IJANIIKC@IPPortSecurityEnabled@ DB 'IPPortSecurityEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBDHONDJ@IPFilterSecurityEnabled@
CONST	SEGMENT
??_C@_0BI@LBDHONDJ@IPFilterSecurityEnabled@ DB 'IPFilterSecurityEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KIFLBGKF@IPEnabled@
CONST	SEGMENT
??_C@_09KIFLBGKF@IPEnabled@ DB 'IPEnabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDBLHBOO@IPConnectionMetric@
CONST	SEGMENT
??_C@_0BD@KDBLHBOO@IPConnectionMetric@ DB 'IPConnectionMetric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFCMALKM@IGMPLevel@
CONST	SEGMENT
??_C@_09LFCMALKM@IGMPLevel@ DB 'IGMPLevel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JPOLFPNM@GatewayCostMetric@
CONST	SEGMENT
??_C@_0BC@JPOLFPNM@GatewayCostMetric@ DB 'GatewayCostMetric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EIIPDLGE@FullDNSRegistrationEnabled@
CONST	SEGMENT
??_C@_0BL@EIIPDLGE@FullDNSRegistrationEnabled@ DB 'FullDNSRegistrationEna'
	DB	'bled', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGFBGHJP@ForwardBufferMemory@
CONST	SEGMENT
??_C@_0BE@GGFBGHJP@ForwardBufferMemory@ DB 'ForwardBufferMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OACMHJBD@DomainDNSRegistrationEnabled@
CONST	SEGMENT
??_C@_0BN@OACMHJBD@DomainDNSRegistrationEnabled@ DB 'DomainDNSRegistratio'
	DB	'nEnabled', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CIMMNJEP@DNSServerSearchOrder@
CONST	SEGMENT
??_C@_0BF@CIMMNJEP@DNSServerSearchOrder@ DB 'DNSServerSearchOrder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LEBEBEIJ@DNSEnabledForWINSResolution@
CONST	SEGMENT
??_C@_0BM@LEBEBEIJ@DNSEnabledForWINSResolution@ DB 'DNSEnabledForWINSReso'
	DB	'lution', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NEHFNDKH@DNSDomainSuffixSearchOrder@
CONST	SEGMENT
??_C@_0BL@NEHFNDKH@DNSDomainSuffixSearchOrder@ DB 'DNSDomainSuffixSearchO'
	DB	'rder', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MIONLOAH@DHCPLeaseObtained@
CONST	SEGMENT
??_C@_0BC@MIONLOAH@DHCPLeaseObtained@ DB 'DHCPLeaseObtained', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOGKHOEE@DHCPLeaseExpires@
CONST	SEGMENT
??_C@_0BB@BOGKHOEE@DHCPLeaseExpires@ DB 'DHCPLeaseExpires', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIMIFMFA@DHCPEnabled@
CONST	SEGMENT
??_C@_0M@HIMIFMFA@DHCPEnabled@ DB 'DHCPEnabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EIDNNLHD@DefaultTTL@
CONST	SEGMENT
??_C@_0L@EIDNNLHD@DefaultTTL@ DB 'DefaultTTL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFBEJJHM@DefaultTOS@
CONST	SEGMENT
??_C@_0L@JFBEJJHM@DefaultTOS@ DB 'DefaultTOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOBIIDKA@DeadGWDetectEnabled@
CONST	SEGMENT
??_C@_0BE@GOBIIDKA@DeadGWDetectEnabled@ DB 'DeadGWDetectEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OAKOAPMO@DatabasePath@
CONST	SEGMENT
??_C@_0N@OAKOAPMO@DatabasePath@ DB 'DatabasePath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DHDIOMKI@ArpUseEtherSNAP@
CONST	SEGMENT
??_C@_0BA@DHDIOMKI@ArpUseEtherSNAP@ DB 'ArpUseEtherSNAP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NNMMFFI@ArpAlwaysSourceRoute@
CONST	SEGMENT
??_C@_0BF@NNMMFFI@ArpAlwaysSourceRoute@ DB 'ArpAlwaysSourceRoute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EKHHNDLH@IPSubnet@
CONST	SEGMENT
??_C@_08EKHHNDLH@IPSubnet@ DB 'IPSubnet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FBHLGFBK@DNSDomain@
CONST	SEGMENT
??_C@_09FBHLGFBK@DNSDomain@ DB 'DNSDomain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HACNIBBH@DefaultIPGateway@
CONST	SEGMENT
??_C@_0BB@HACNIBBH@DefaultIPGateway@ DB 'DefaultIPGateway', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJOKJMLN@DHCPServer@
CONST	SEGMENT
??_C@_0L@BJOKJMLN@DHCPServer@ DB 'DHCPServer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NIGMFFPO@IPAddress@
CONST	SEGMENT
??_C@_09NIGMFFPO@IPAddress@ DB 'IPAddress', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@
CONST	SEGMENT
??_C@_0CC@CIAMNGGL@Win32_NetworkAdapterConfigurati@ DB 'Win32_NetworkAdap'
	DB	'terConfiguration', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@COBEMNCH@NetEnabled@
CONST	SEGMENT
??_C@_0L@COBEMNCH@NetEnabled@ DB 'NetEnabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMPBIBLI@InterfaceIndex@
CONST	SEGMENT
??_C@_0P@LMPBIBLI@InterfaceIndex@ DB 'InterfaceIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBJECKPO@Installed@
CONST	SEGMENT
??_C@_09HBJECKPO@Installed@ DB 'Installed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMNBJFFE@AutoSense@
CONST	SEGMENT
??_C@_09MMNBJFFE@AutoSense@ DB 'AutoSense', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDINGPBK@AdapterTypeID@
CONST	SEGMENT
??_C@_0O@JDINGPBK@AdapterTypeID@ DB 'AdapterTypeID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBMGKKGD@AdapterType@
CONST	SEGMENT
??_C@_0M@CBMGKKGD@AdapterType@ DB 'AdapterType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPOCLJND@PermanentAddress@
CONST	SEGMENT
??_C@_0BB@CPOCLJND@PermanentAddress@ DB 'PermanentAddress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HCIBJPII@NetworkAddresses@
CONST	SEGMENT
??_C@_0BB@HCIBJPII@NetworkAddresses@ DB 'NetworkAddresses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEIDEPGF@GUID@
CONST	SEGMENT
??_C@_04MEIDEPGF@GUID@ DB 'GUID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08MFFAALKH@MaxSpeed@
CONST	SEGMENT
??_C@_08MFFAALKH@MaxSpeed@ DB 'MaxSpeed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OHJLPIPO@NetConnectionStatus@
CONST	SEGMENT
??_C@_0BE@OHJLPIPO@NetConnectionStatus@ DB 'NetConnectionStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FMEGGBNH@NetConnectionID@
CONST	SEGMENT
??_C@_0BA@FMEGGBNH@NetConnectionID@ DB 'NetConnectionID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOFGKGDC@ServiceName@
CONST	SEGMENT
??_C@_0M@IOFGKGDC@ServiceName@ DB 'ServiceName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PKOOKBHK@PhysicalAdapter@
CONST	SEGMENT
??_C@_0BA@PKOOKBHK@PhysicalAdapter@ DB 'PhysicalAdapter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MLCHOGMM@MACAddress@
CONST	SEGMENT
??_C@_0L@MLCHOGMM@MACAddress@ DB 'MACAddress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@
CONST	SEGMENT
??_C@_0BF@IPHNLIOA@Win32_NetworkAdapter@ DB 'Win32_NetworkAdapter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LMHCBHLE@VppMixedVoltageSupport@
CONST	SEGMENT
??_C@_0BH@LMHCBHLE@VppMixedVoltageSupport@ DB 'VppMixedVoltageSupport', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BMAHGALK@VccMixedVoltageSupport@
CONST	SEGMENT
??_C@_0BH@BMAHGALK@VccMixedVoltageSupport@ DB 'VccMixedVoltageSupport', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPICFFNJ@ThermalRating@
CONST	SEGMENT
??_C@_0O@OPICFFNJ@ThermalRating@ DB 'ThermalRating', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HLMBNLEL@SupportsHotPlug@
CONST	SEGMENT
??_C@_0BA@HLMBNLEL@SupportsHotPlug@ DB 'SupportsHotPlug', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHGKENBB@SpecialPurpose@
CONST	SEGMENT
??_C@_0P@MHGKENBB@SpecialPurpose@ DB 'SpecialPurpose', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LOOAMPBO@Shared@
CONST	SEGMENT
??_C@_06LOOAMPBO@Shared@ DB 'Shared', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MJCDBDLK@PurposeDescription@
CONST	SEGMENT
??_C@_0BD@MJCDBDLK@PurposeDescription@ DB 'PurposeDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KGLBDKHB@PMESignal@
CONST	SEGMENT
??_C@_09KGLBDKHB@PMESignal@ DB 'PMESignal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICFBEHEI@LengthAllowed@
CONST	SEGMENT
??_C@_0O@ICFBEHEI@LengthAllowed@ DB 'LengthAllowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIADPBNP@HeightAllowed@
CONST	SEGMENT
??_C@_0O@JIADPBNP@HeightAllowed@ DB 'HeightAllowed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OHNMFPEL@CurrentUsage@
CONST	SEGMENT
??_C@_0N@OHNMFPEL@CurrentUsage@ DB 'CurrentUsage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JKMEMADA@SlotDesignation@
CONST	SEGMENT
??_C@_0BA@JKMEMADA@SlotDesignation@ DB 'SlotDesignation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IINEGLLN@Win32_SystemSlot@
CONST	SEGMENT
??_C@_0BB@IINEGLLN@Win32_SystemSlot@ DB 'Win32_SystemSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGAIBJKD@VisibleAlarm@
CONST	SEGMENT
??_C@_0N@BGAIBJKD@VisibleAlarm@ DB 'VisibleAlarm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPPDMJMG@TypeDescriptions@
CONST	SEGMENT
??_C@_0BB@EPPDMJMG@TypeDescriptions@ DB 'TypeDescriptions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GDBINLPP@SMBIOSAssetTag@
CONST	SEGMENT
??_C@_0P@GDBINLPP@SMBIOSAssetTag@ DB 'SMBIOSAssetTag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MJACHPAA@ServicePhilosophy@
CONST	SEGMENT
??_C@_0BC@MJACHPAA@ServicePhilosophy@ DB 'ServicePhilosophy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CDEDGENH@ServiceDescriptions@
CONST	SEGMENT
??_C@_0BE@CDEDGENH@ServiceDescriptions@ DB 'ServiceDescriptions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LBCDFKMM@SecurityStatus@
CONST	SEGMENT
??_C@_0P@LBCDFKMM@SecurityStatus@ DB 'SecurityStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IFAJDLJO@SecurityBreach@
CONST	SEGMENT
??_C@_0P@IFAJDLJO@SecurityBreach@ DB 'SecurityBreach', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BOLIJOBH@NumberOfPowerCords@
CONST	SEGMENT
??_C@_0BD@BOLIJOBH@NumberOfPowerCords@ DB 'NumberOfPowerCords', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FLPBGKMO@LockPresent@
CONST	SEGMENT
??_C@_0M@FLPBGKMO@LockPresent@ DB 'LockPresent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FPMIANAI@HeatGeneration@
CONST	SEGMENT
??_C@_0P@FPMIANAI@HeatGeneration@ DB 'HeatGeneration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DMAHAAAM@CurrentRequiredOrProduced@
CONST	SEGMENT
??_C@_0BK@DMAHAAAM@CurrentRequiredOrProduced@ DB 'CurrentRequiredOrProduc'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OIOFCGCN@CableManagementStrategy@
CONST	SEGMENT
??_C@_0BI@OIOFCGCN@CableManagementStrategy@ DB 'CableManagementStrategy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OICCILBJ@BreachDescription@
CONST	SEGMENT
??_C@_0BC@OICCILBJ@BreachDescription@ DB 'BreachDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBKDMIBE@AudibleAlarm@
CONST	SEGMENT
??_C@_0N@FBKDMIBE@AudibleAlarm@ DB 'AudibleAlarm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MLFAOMIG@ChassisTypes@
CONST	SEGMENT
??_C@_0N@MLFAOMIG@ChassisTypes@ DB 'ChassisTypes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@
CONST	SEGMENT
??_C@_0BG@COLMHJCF@Win32_SystemEnclosure@ DB 'Win32_SystemEnclosure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFFLJNBG@TagId@
CONST	SEGMENT
??_C@_05KFFLJNBG@TagId@ DB 'TagId', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05JNKNAC@State@
CONST	SEGMENT
??_C@_05JNKNAC@State@ DB 'State', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CIMAKHDE@StartName@
CONST	SEGMENT
??_C@_09CIMAKHDE@StartName@ DB 'StartName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFFFGGEC@ServiceType@
CONST	SEGMENT
??_C@_0M@CFFFGGEC@ServiceType@ DB 'ServiceType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode@
CONST	SEGMENT
??_C@_0BI@JAIDFKNN@ServiceSpecificExitCode@ DB 'ServiceSpecificExitCode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHJJFIAP@ExitCode@
CONST	SEGMENT
??_C@_08FHJJFIAP@ExitCode@ DB 'ExitCode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GPBKMKLE@ErrorControl@
CONST	SEGMENT
??_C@_0N@GPBKMKLE@ErrorControl@ DB 'ErrorControl', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKLNMHH@DesktopInteract@
CONST	SEGMENT
??_C@_0BA@DKLNMHH@DesktopInteract@ DB 'DesktopInteract', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPAKMMDG@AcceptStop@
CONST	SEGMENT
??_C@_0L@MPAKMMDG@AcceptStop@ DB 'AcceptStop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MEIJGDEJ@AcceptPause@
CONST	SEGMENT
??_C@_0M@MEIJGDEJ@AcceptPause@ DB 'AcceptPause', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHLJMCNC@PathName@
CONST	SEGMENT
??_C@_08LHLJMCNC@PathName@ DB 'PathName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLHPPPJP@DisplayName@
CONST	SEGMENT
??_C@_0M@MLHPPPJP@DisplayName@ DB 'DisplayName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GGPCAOMO@Win32_SystemDriver@
CONST	SEGMENT
??_C@_0BD@GGPCAOMO@Win32_SystemDriver@ DB 'Win32_SystemDriver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDPBNNMM@SIDType@
CONST	SEGMENT
??_C@_07JDPBNNMM@SIDType@ DB 'SIDType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPKOIMIG@LocalAccount@
CONST	SEGMENT
??_C@_0N@FPKOIMIG@LocalAccount@ DB 'LocalAccount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OMFNLMOB@SID@
CONST	SEGMENT
??_C@_03OMFNLMOB@SID@ DB 'SID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHOOODEL@Win32_SystemAccount@
CONST	SEGMENT
??_C@_0BE@DHOOODEL@Win32_SystemAccount@ DB 'Win32_SystemAccount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JHIKPPPP@ProposedSize@
CONST	SEGMENT
??_C@_0N@JHIKPPPP@ProposedSize@ DB 'ProposedSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JHEHBNHB@MaximumSize@
CONST	SEGMENT
??_C@_0M@JHEHBNHB@MaximumSize@ DB 'MaximumSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLALLFJB@CurrentSize@
CONST	SEGMENT
??_C@_0M@MLALLFJB@CurrentSize@ DB 'CurrentSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OGGGECNI@Win32_Registry@
CONST	SEGMENT
??_C@_0P@OGGGECNI@Win32_Registry@ DB 'Win32_Registry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DKANKDCG@Win32_Refrigeration@
CONST	SEGMENT
??_C@_0BE@DKANKDCG@Win32_Refrigeration@ DB 'Win32_Refrigeration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FBEKBLIJ@ServicePackInEffect@
CONST	SEGMENT
??_C@_0BE@FBEKBLIJ@ServicePackInEffect@ DB 'ServicePackInEffect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIGNGIJB@FixComments@
CONST	SEGMENT
??_C@_0M@PIGNGIJB@FixComments@ DB 'FixComments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NBDMPIKF@InstalledOn@
CONST	SEGMENT
??_C@_0M@NBDMPIKF@InstalledOn@ DB 'InstalledOn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMGHOPGA@InstalledBy@
CONST	SEGMENT
??_C@_0M@NMGHOPGA@InstalledBy@ DB 'InstalledBy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFKGEEBB@HotFixID@
CONST	SEGMENT
??_C@_08GFKGEEBB@HotFixID@ DB 'HotFixID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@
CONST	SEGMENT
??_C@_0BK@FHHANEEI@Win32_QuickFixEngineering@ DB 'Win32_QuickFixEngineeri'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCLOCIPO@WordCount@
CONST	SEGMENT
??_C@_09JCLOCIPO@WordCount@ DB 'WordCount', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDAGMPND@URLUpdateInfo@
CONST	SEGMENT
??_C@_0O@FDAGMPND@URLUpdateInfo@ DB 'URLUpdateInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIJCJNDA@URLInfoAbout@
CONST	SEGMENT
??_C@_0N@CIJCJNDA@URLInfoAbout@ DB 'URLInfoAbout', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNLOEOEC@Transforms@
CONST	SEGMENT
??_C@_0L@LNLOEOEC@Transforms@ DB 'Transforms', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BDBMLIBF@RegCompany@
CONST	SEGMENT
??_C@_0L@BDBMLIBF@RegCompany@ DB 'RegCompany', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KOFIEIPM@RegOwner@
CONST	SEGMENT
??_C@_08KOFIEIPM@RegOwner@ DB 'RegOwner', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLFIHHBG@PackageName@
CONST	SEGMENT
??_C@_0M@PLFIHHBG@PackageName@ DB 'PackageName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OMMGPPBL@PackageCode@
CONST	SEGMENT
??_C@_0M@OMMGPPBL@PackageCode@ DB 'PackageCode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LIDMIFHK@PackageCache@
CONST	SEGMENT
??_C@_0N@LIDMIFHK@PackageCache@ DB 'PackageCache', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONDNCIN@LocalPackage@
CONST	SEGMENT
??_C@_0N@ONDNCIN@LocalPackage@ DB 'LocalPackage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BENDAOKD@Language@
CONST	SEGMENT
??_C@_08BENDAOKD@Language@ DB 'Language', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCCHCBIO@InstallSource@
CONST	SEGMENT
??_C@_0O@GCCHCBIO@InstallSource@ DB 'InstallSource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PPCFOOHH@HelpTelephone@
CONST	SEGMENT
??_C@_0O@PPCFOOHH@HelpTelephone@ DB 'HelpTelephone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMOOJGEG@HelpLink@
CONST	SEGMENT
??_C@_08LMOOJGEG@HelpLink@ DB 'HelpLink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FNHIHJOE@InstallState@
CONST	SEGMENT
??_C@_0N@FNHIHJOE@InstallState@ DB 'InstallState', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DLLPKNMD@InstallLocation@
CONST	SEGMENT
??_C@_0BA@DLLPKNMD@InstallLocation@ DB 'InstallLocation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CAOEPKFE@AssignmentType@
CONST	SEGMENT
??_C@_0P@CAOEPKFE@AssignmentType@ DB 'AssignmentType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IHHILKBJ@ProductID@
CONST	SEGMENT
??_C@_09IHHILKBJ@ProductID@ DB 'ProductID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LCAALOJJ@Win32_Product@
CONST	SEGMENT
??_C@_0O@LCAALOJJ@Win32_Product@ DB 'Win32_Product', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODBEMGCH@SKUNumber@
CONST	SEGMENT
??_C@_09ODBEMGCH@SKUNumber@ DB 'SKUNumber', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IBEJLMDM@IdentifyingNumber@
CONST	SEGMENT
??_C@_0BC@IBEJLMDM@IdentifyingNumber@ DB 'IdentifyingNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04NOKDILIH@UUID@
CONST	SEGMENT
??_C@_04NOKDILIH@UUID@ DB 'UUID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGGLFMPE@Vendor@
CONST	SEGMENT
??_C@_06LGGLFMPE@Vendor@ DB 'Vendor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@
CONST	SEGMENT
??_C@_0BM@IEKJLBKB@Win32_ComputerSystemProduct@ DB 'Win32_ComputerSystemP'
	DB	'roduct', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09CLAAHCGK@Workgroup@
CONST	SEGMENT
??_C@_09CLAAHCGK@Workgroup@ DB 'Workgroup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FAPFOCCC@WakeUpType@
CONST	SEGMENT
??_C@_0L@FAPFOCCC@WakeUpType@ DB 'WakeUpType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LPDNMOEG@TotalPhysicalMemory@
CONST	SEGMENT
??_C@_0BE@LPDNMOEG@TotalPhysicalMemory@ DB 'TotalPhysicalMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HHACICKK@ThermalState@
CONST	SEGMENT
??_C@_0N@HHACICKK@ThermalState@ DB 'ThermalState', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IKJAHOGK@SystemStartupSetting@
CONST	SEGMENT
??_C@_0BF@IKJAHOGK@SystemStartupSetting@ DB 'SystemStartupSetting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HNHDCNN@SystemStartupOptions@
CONST	SEGMENT
??_C@_0BF@HNHDCNN@SystemStartupOptions@ DB 'SystemStartupOptions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MJBJDOPG@SystemStartupDelay@
CONST	SEGMENT
??_C@_0BD@MJBJDOPG@SystemStartupDelay@ DB 'SystemStartupDelay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GHHBNFKI@SupportContactDescription@
CONST	SEGMENT
??_C@_0BK@GHHBNFKI@SupportContactDescription@ DB 'SupportContactDescripti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05CPOHHMHJ@Roles@
CONST	SEGMENT
??_C@_05CPOHHMHJ@Roles@ DB 'Roles', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ODMHPMJN@ResetLimit@
CONST	SEGMENT
??_C@_0L@ODMHPMJN@ResetLimit@ DB 'ResetLimit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDDNCBN@ResetCount@
CONST	SEGMENT
??_C@_0L@NDDNCBN@ResetCount@ DB 'ResetCount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGMMLHGF@ResetCapability@
CONST	SEGMENT
??_C@_0BA@JGMMLHGF@ResetCapability@ DB 'ResetCapability', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CIHLIHGG@PrimaryOwnerName@
CONST	SEGMENT
??_C@_0BB@CIHLIHGG@PrimaryOwnerName@ DB 'PrimaryOwnerName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GNDJOKHP@PrimaryOwnerContact@
CONST	SEGMENT
??_C@_0BE@GNDJOKHP@PrimaryOwnerContact@ DB 'PrimaryOwnerContact', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PGEJAGBJ@PowerSupplyState@
CONST	SEGMENT
??_C@_0BB@PGEJAGBJ@PowerSupplyState@ DB 'PowerSupplyState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PFLEPOFF@PowerState@
CONST	SEGMENT
??_C@_0L@PFLEPOFF@PowerState@ DB 'PowerState', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MGBDJIM@PowerOnPasswordStatus@
CONST	SEGMENT
??_C@_0BG@MGBDJIM@PowerOnPasswordStatus@ DB 'PowerOnPasswordStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EOPDJAGI@PCSystemType@
CONST	SEGMENT
??_C@_0N@EOPDJAGI@PCSystemType@ DB 'PCSystemType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BAAGJACJ@PauseAfterReset@
CONST	SEGMENT
??_C@_0BA@BAAGJACJ@PauseAfterReset@ DB 'PauseAfterReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDBDHMKI@PartOfDomain@
CONST	SEGMENT
??_C@_0N@BDBDHMKI@PartOfDomain@ DB 'PartOfDomain', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DEDOEGFN@OEMStringArray@
CONST	SEGMENT
??_C@_0P@DEDOEGFN@OEMStringArray@ DB 'OEMStringArray', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KFCLFAME@OEMLogoBitmap@
CONST	SEGMENT
??_C@_0O@KFCLFAME@OEMLogoBitmap@ DB 'OEMLogoBitmap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OJMPPEPI@NetworkServerModeEnabled@
CONST	SEGMENT
??_C@_0BJ@OJMPPEPI@NetworkServerModeEnabled@ DB 'NetworkServerModeEnabled'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INCFKHMA@NameFormat@
CONST	SEGMENT
??_C@_0L@INCFKHMA@NameFormat@ DB 'NameFormat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDMFJCLB@LastLoadInfo@
CONST	SEGMENT
??_C@_0N@FDMFJCLB@LastLoadInfo@ DB 'LastLoadInfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NPMFKEOG@KeyboardPasswordStatus@
CONST	SEGMENT
??_C@_0BH@NPMFKEOG@KeyboardPasswordStatus@ DB 'KeyboardPasswordStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FHFMLOBH@InitialLoadInfo@
CONST	SEGMENT
??_C@_0BA@FHFMLOBH@InitialLoadInfo@ DB 'InitialLoadInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MOGIEFCC@InfraredSupported@
CONST	SEGMENT
??_C@_0BC@MOGIEFCC@InfraredSupported@ DB 'InfraredSupported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OFHEPCGG@FrontPanelResetStatus@
CONST	SEGMENT
??_C@_0BG@OFHEPCGG@FrontPanelResetStatus@ DB 'FrontPanelResetStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DMLHGPE@EnableDaylightSavingsTime@
CONST	SEGMENT
??_C@_0BK@DMLHGPE@EnableDaylightSavingsTime@ DB 'EnableDaylightSavingsTim'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHGJAMBB@DomainRole@
CONST	SEGMENT
??_C@_0L@DHGJAMBB@DomainRole@ DB 'DomainRole', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HFDFFJHI@Domain@
CONST	SEGMENT
??_C@_06HFDFFJHI@Domain@ DB 'Domain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HMDMJNAL@DNSHostName@
CONST	SEGMENT
??_C@_0M@HMDMJNAL@DNSHostName@ DB 'DNSHostName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PNOOHJBN@DaylightInEffect@
CONST	SEGMENT
??_C@_0BB@PNOOHJBN@DaylightInEffect@ DB 'DaylightInEffect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KEBGPOLH@CurrentTimeZone@
CONST	SEGMENT
??_C@_0BA@KEBGPOLH@CurrentTimeZone@ DB 'CurrentTimeZone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NPOFELCJ@ChassisBootupState@
CONST	SEGMENT
??_C@_0BD@NPOFELCJ@ChassisBootupState@ DB 'ChassisBootupState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FAIFADKE@BootupState@
CONST	SEGMENT
??_C@_0M@FAIFADKE@BootupState@ DB 'BootupState', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KCAGDBFG@BootROMSupported@
CONST	SEGMENT
??_C@_0BB@KCAGDBFG@BootROMSupported@ DB 'BootROMSupported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NHNHHNLM@BootOptionOnWatchDog@
CONST	SEGMENT
??_C@_0BF@NHNHHNLM@BootOptionOnWatchDog@ DB 'BootOptionOnWatchDog', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOIFGJNH@BootOptionOnLimit@
CONST	SEGMENT
??_C@_0BC@LOIFGJNH@BootOptionOnLimit@ DB 'BootOptionOnLimit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HFJMLPDD@AutomaticResetCapability@
CONST	SEGMENT
??_C@_0BJ@HFJMLPDD@AutomaticResetCapability@ DB 'AutomaticResetCapability'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CCCKPNOE@AutomaticResetBootOption@
CONST	SEGMENT
??_C@_0BJ@CCCKPNOE@AutomaticResetBootOption@ DB 'AutomaticResetBootOption'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GMKDMOMC@AutomaticManagedPagefile@
CONST	SEGMENT
??_C@_0BJ@GMKDMOMC@AutomaticManagedPagefile@ DB 'AutomaticManagedPagefile'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BPKIAGEB@AdminPasswordStatus@
CONST	SEGMENT
??_C@_0BE@BPKIAGEB@AdminPasswordStatus@ DB 'AdminPasswordStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KAFEAHEM@UserName@
CONST	SEGMENT
??_C@_08KAFEAHEM@UserName@ DB 'UserName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KEFEPCEP@NumberOfProcessors@
CONST	SEGMENT
??_C@_0BD@KEFEPCEP@NumberOfProcessors@ DB 'NumberOfProcessors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEHHDFHH@SystemType@
CONST	SEGMENT
??_C@_0L@GEHHDFHH@SystemType@ DB 'SystemType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@
CONST	SEGMENT
??_C@_0BF@GMDCFJKK@Win32_ComputerSystem@ DB 'Win32_ComputerSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@
CONST	SEGMENT
??_C@_0BL@GIIBFPAF@Win32_SystemMemoryResource@ DB 'Win32_SystemMemoryReso'
	DB	'urce', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@
CONST	SEGMENT
??_C@_0BD@CLOLHCII@Win32_SMBIOSMemory@ DB 'Win32_SMBIOSMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMFFJGJI@Use@
CONST	SEGMENT
??_C@_03GMFFJGJI@Use@ DB 'Use', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDKPEMKD@MemoryErrorCorrection@
CONST	SEGMENT
??_C@_0BG@BDKPEMKD@MemoryErrorCorrection@ DB 'MemoryErrorCorrection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LPAFCHAO@MaxCapacity@
CONST	SEGMENT
??_C@_0M@LPAFCHAO@MaxCapacity@ DB 'MaxCapacity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOCLGIEK@MemoryDevices@
CONST	SEGMENT
??_C@_0O@EOCLGIEK@MemoryDevices@ DB 'MemoryDevices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@
CONST	SEGMENT
??_C@_0BK@FKMONDCJ@Win32_PhysicalMemoryArray@ DB 'Win32_PhysicalMemoryArr'
	DB	'ay', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NHBAOOAD@TypeDetail@
CONST	SEGMENT
??_C@_0L@NHBAOOAD@TypeDetail@ DB 'TypeDetail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EONKMHCB@TotalWidth@
CONST	SEGMENT
??_C@_0L@EONKMHCB@TotalWidth@ DB 'TotalWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HOIAGEJD@Speed@
CONST	SEGMENT
??_C@_05HOIAGEJD@Speed@ DB 'Speed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJAFBIEI@PositionInRow@
CONST	SEGMENT
??_C@_0O@MJAFBIEI@PositionInRow@ DB 'PositionInRow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OOBFBMPB@InterleavePosition@
CONST	SEGMENT
??_C@_0BD@OOBFBMPB@InterleavePosition@ DB 'InterleavePosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GAJMAAIE@InterleaveDataDepth@
CONST	SEGMENT
??_C@_0BE@GAJMAAIE@InterleaveDataDepth@ DB 'InterleaveDataDepth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JPOMKNPI@FormFactor@
CONST	SEGMENT
??_C@_0L@JPOMKNPI@FormFactor@ DB 'FormFactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKGGAIKL@DeviceLocator@
CONST	SEGMENT
??_C@_0O@DKGGAIKL@DeviceLocator@ DB 'DeviceLocator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELEBPJGH@BankLabel@
CONST	SEGMENT
??_C@_09ELEBPJGH@BankLabel@ DB 'BankLabel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@
CONST	SEGMENT
??_C@_0BF@CGHJBIMG@Win32_PhysicalMemory@ DB 'Win32_PhysicalMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@
CONST	SEGMENT
??_C@_0BD@MHIIAMPP@Win32_MemoryDevice@ DB 'Win32_MemoryDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CCADGENH@ErrorGranularity@
CONST	SEGMENT
??_C@_0BB@CCADGENH@ErrorGranularity@ DB 'ErrorGranularity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBCNDILJ@Win32_MemoryArray@
CONST	SEGMENT
??_C@_0BC@NBCNDILJ@Win32_MemoryArray@ DB 'Win32_MemoryArray', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NKIIONIP@MemoryType@
CONST	SEGMENT
??_C@_0L@NKIIONIP@MemoryType@ DB 'MemoryType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@
CONST	SEGMENT
??_C@_0BK@CHMJMDKA@Win32_DeviceMemoryAddress@ DB 'Win32_DeviceMemoryAddre'
	DB	'ss', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GMGLDKG@WritePolicy@
CONST	SEGMENT
??_C@_0M@GMGLDKG@WritePolicy@ DB 'WritePolicy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EHELDMNK@SystemLevelAddress@
CONST	SEGMENT
??_C@_0BD@EHELDMNK@SystemLevelAddress@ DB 'SystemLevelAddress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LOONNFKJ@SupportedSRAM@
CONST	SEGMENT
??_C@_0O@LOONNFKJ@SupportedSRAM@ DB 'SupportedSRAM', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JKJCLFJA@StartingAddress@
CONST	SEGMENT
??_C@_0BA@JKJCLFJA@StartingAddress@ DB 'StartingAddress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CACAEAGO@ReplacementPolicy@
CONST	SEGMENT
??_C@_0BC@CACAEAGO@ReplacementPolicy@ DB 'ReplacementPolicy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OICKBPFP@ReadPolicy@
CONST	SEGMENT
??_C@_0L@OICKBPFP@ReadPolicy@ DB 'ReadPolicy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMMANAIM@OtherErrorDescription@
CONST	SEGMENT
??_C@_0BG@GMMANAIM@OtherErrorDescription@ DB 'OtherErrorDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDOEBHGA@Location@
CONST	SEGMENT
??_C@_08KDOEBHGA@Location@ DB 'Location', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFDFHGHF@LineSize@
CONST	SEGMENT
??_C@_08BFDFHGHF@LineSize@ DB 'LineSize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BJDNNDOA@InstalledSize@
CONST	SEGMENT
??_C@_0O@BJDNNDOA@InstalledSize@ DB 'InstalledSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NIIIAJJG@FlushTimer@
CONST	SEGMENT
??_C@_0L@NIIIAJJG@FlushTimer@ DB 'FlushTimer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FEODMBII@ErrorTransferSize@
CONST	SEGMENT
??_C@_0BC@FEODMBII@ErrorTransferSize@ DB 'ErrorTransferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMOKKAAG@ErrorTime@
CONST	SEGMENT
??_C@_09LMOKKAAG@ErrorTime@ DB 'ErrorTime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DBMDPLBE@ErrorResolution@
CONST	SEGMENT
??_C@_0BA@DBMDPLBE@ErrorResolution@ DB 'ErrorResolution', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPPHMMOH@ErrorInfo@
CONST	SEGMENT
??_C@_09EPPHMMOH@ErrorInfo@ DB 'ErrorInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LPKOAMHJ@ErrorDataOrder@
CONST	SEGMENT
??_C@_0P@LPKOAMHJ@ErrorDataOrder@ DB 'ErrorDataOrder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOCFECJA@ErrorData@
CONST	SEGMENT
??_C@_09GOCFECJA@ErrorData@ DB 'ErrorData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OEAEPHLK@ErrorCorrectType@
CONST	SEGMENT
??_C@_0BB@OEAEPHLK@ErrorCorrectType@ DB 'ErrorCorrectType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BEELHEFJ@ErrorAddress@
CONST	SEGMENT
??_C@_0N@BEELHEFJ@ErrorAddress@ DB 'ErrorAddress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJGEGKNG@ErrorAccess@
CONST	SEGMENT
??_C@_0M@PJGEGKNG@ErrorAccess@ DB 'ErrorAccess', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMEOEBEF@EndingAddress@
CONST	SEGMENT
??_C@_0O@DMEOEBEF@EndingAddress@ DB 'EndingAddress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JJECGOOK@CurrentSRAM@
CONST	SEGMENT
??_C@_0M@JJECGOOK@CurrentSRAM@ DB 'CurrentSRAM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJBOPHEK@CorrectableError@
CONST	SEGMENT
??_C@_0BB@HJBOPHEK@CorrectableError@ DB 'CorrectableError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FNMLGPI@MaxCacheSize@
CONST	SEGMENT
??_C@_0N@FNMLGPI@MaxCacheSize@ DB 'MaxCacheSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDLPEFB@CacheType@
CONST	SEGMENT
??_C@_09LDLPEFB@CacheType@ DB 'CacheType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKCEABFB@CacheSpeed@
CONST	SEGMENT
??_C@_0L@GKCEABFB@CacheSpeed@ DB 'CacheSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BJAAJMNJ@Associativity@
CONST	SEGMENT
??_C@_0O@BJAAJMNJ@Associativity@ DB 'Associativity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FGEPBFNL@AdditionalErrorData@
CONST	SEGMENT
??_C@_0BE@FGEPBFNL@AdditionalErrorData@ DB 'AdditionalErrorData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BKKBKJDE@Win32_CacheMemory@
CONST	SEGMENT
??_C@_0BC@BKKBKJDE@Win32_CacheMemory@ DB 'Win32_CacheMemory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OCFCAPCK@ReportSetMarks@
CONST	SEGMENT
??_C@_0P@OCFCAPCK@ReportSetMarks@ DB 'ReportSetMarks', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDDGKLAD@Padding@
CONST	SEGMENT
??_C@_07DDDGKLAD@Padding@ DB 'Padding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NKLHGLCM@MaxPartitionCount@
CONST	SEGMENT
??_C@_0BC@NKLHGLCM@MaxPartitionCount@ DB 'MaxPartitionCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GCKGDCME@FeaturesLow@
CONST	SEGMENT
??_C@_0M@GCKGDCME@FeaturesLow@ DB 'FeaturesLow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PNICBLFI@FeaturesHigh@
CONST	SEGMENT
??_C@_0N@PNICBLFI@FeaturesHigh@ DB 'FeaturesHigh', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IDPNAMKG@EOTWarningZoneSize@
CONST	SEGMENT
??_C@_0BD@IDPNAMKG@EOTWarningZoneSize@ DB 'EOTWarningZoneSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NLPJKHLD@ECC@
CONST	SEGMENT
??_C@_03NLPJKHLD@ECC@ DB 'ECC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COKFBABJ@Compression@
CONST	SEGMENT
??_C@_0M@COKFBABJ@Compression@ DB 'Compression', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HOGEDOAB@Id@
CONST	SEGMENT
??_C@_02HOGEDOAB@Id@ DB 'Id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GLDDIFFN@Win32_TapeDrive@
CONST	SEGMENT
??_C@_0BA@GLDDIFFN@Win32_TapeDrive@ DB 'Win32_TapeDrive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NINPCONM@CleanerMedia@
CONST	SEGMENT
??_C@_0N@NINPCONM@CleanerMedia@ DB 'CleanerMedia', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CNPPDDMA@WriteProtectOn@
CONST	SEGMENT
??_C@_0P@CNPPDDMA@WriteProtectOn@ DB 'WriteProtectOn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PINBMPEF@Capacity@
CONST	SEGMENT
??_C@_08PINBMPEF@Capacity@ DB 'Capacity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FNAKMFAB@CreationClassName@
CONST	SEGMENT
??_C@_0BC@FNAKMFAB@CreationClassName@ DB 'CreationClassName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GANKFIKA@MediaDescription@
CONST	SEGMENT
??_C@_0BB@GANKFIKA@MediaDescription@ DB 'MediaDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@
CONST	SEGMENT
??_C@_0BE@JBJLNBAC@Win32_PhysicalMedia@ DB 'Win32_PhysicalMedia', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HEMAHOJD@StartingOffset@
CONST	SEGMENT
??_C@_0P@HEMAHOJD@StartingOffset@ DB 'StartingOffset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CLPKNLNO@RewritePartition@
CONST	SEGMENT
??_C@_0BB@CLPKNLNO@RewritePartition@ DB 'RewritePartition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODOLMOGH@Purpose@
CONST	SEGMENT
??_C@_07ODOLMOGH@Purpose@ DB 'Purpose', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMDEFEE@HiddenSectors@
CONST	SEGMENT
??_C@_0O@NMDEFEE@HiddenSectors@ DB 'HiddenSectors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PGINBNEO@NumberOfBlocks@
CONST	SEGMENT
??_C@_0P@PGINBNEO@NumberOfBlocks@ DB 'NumberOfBlocks', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JFLKFGKE@BlockSize@
CONST	SEGMENT
??_C@_09JFLKFGKE@BlockSize@ DB 'BlockSize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IOEANFCI@Access@
CONST	SEGMENT
??_C@_06IOEANFCI@Access@ DB 'Access', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GMPNKCND@PrimaryPartition@
CONST	SEGMENT
??_C@_0BB@GMPNKCND@PrimaryPartition@ DB 'PrimaryPartition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKABHDFN@BootPartition@
CONST	SEGMENT
??_C@_0O@GKABHDFN@BootPartition@ DB 'BootPartition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBCOMNMP@Bootable@
CONST	SEGMENT
??_C@_08GBCOMNMP@Bootable@ DB 'Bootable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KOACHJEN@Type@
CONST	SEGMENT
??_C@_04KOACHJEN@Type@ DB 'Type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GBMGFCLI@Win32_DiskPartition@
CONST	SEGMENT
??_C@_0BE@GBMGFCLI@Win32_DiskPartition@ DB 'Win32_DiskPartition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KOKBEBBE@TracksPerCylinder@
CONST	SEGMENT
??_C@_0BC@KOKBEBBE@TracksPerCylinder@ DB 'TracksPerCylinder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BHKEFGGG@TotalTracks@
CONST	SEGMENT
??_C@_0M@BHKEFGGG@TotalTracks@ DB 'TotalTracks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BJMAPGKO@TotalSectors@
CONST	SEGMENT
??_C@_0N@BJMAPGKO@TotalSectors@ DB 'TotalSectors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PLGEACLG@TotalHeads@
CONST	SEGMENT
??_C@_0L@PLGEACLG@TotalHeads@ DB 'TotalHeads', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NEMACPGO@TotalCylinders@
CONST	SEGMENT
??_C@_0P@NEMACPGO@TotalCylinders@ DB 'TotalCylinders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CCMKCJPC@SectorsPerTrack@
CONST	SEGMENT
??_C@_0BA@CCMKCJPC@SectorsPerTrack@ DB 'SectorsPerTrack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IHENGMAG@InterfaceType@
CONST	SEGMENT
??_C@_0O@IHENGMAG@InterfaceType@ DB 'InterfaceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMBACBBL@FirmwareRevision@
CONST	SEGMENT
??_C@_0BB@HMBACBBL@FirmwareRevision@ DB 'FirmwareRevision', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MMMIFHLL@BytesPerSector@
CONST	SEGMENT
??_C@_0P@MMMIFHLL@BytesPerSector@ DB 'BytesPerSector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDNFOKKF@Signature@
CONST	SEGMENT
??_C@_09GDNFOKKF@Signature@ DB 'Signature', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BLANPANH@Partitions@
CONST	SEGMENT
??_C@_0L@BLANPANH@Partitions@ DB 'Partitions', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJPFNKBD@Win32_DiskDrive@
CONST	SEGMENT
??_C@_0BA@CJPFNKBD@Win32_DiskDrive@ DB 'Win32_DiskDrive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HGGDLIIF@SpecificationVersion@
CONST	SEGMENT
??_C@_0BF@HGGDLIIF@SpecificationVersion@ DB 'SpecificationVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FJFLBOEO@ReservedSystemPaletteEntries@
CONST	SEGMENT
??_C@_0BN@FJFLBOEO@ReservedSystemPaletteEntries@ DB 'ReservedSystemPalett'
	DB	'eEntries', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCAJOFAD@Monochrome@
CONST	SEGMENT
??_C@_0L@NCAJOFAD@Monochrome@ DB 'Monochrome', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BADPIIJO@MinRefreshRate@
CONST	SEGMENT
??_C@_0P@BADPIIJO@MinRefreshRate@ DB 'MinRefreshRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHIEOPKP@MaxRefreshRate@
CONST	SEGMENT
??_C@_0P@DHIEOPKP@MaxRefreshRate@ DB 'MaxRefreshRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KFJBBNPN@MaxMemorySupported@
CONST	SEGMENT
??_C@_0BD@KFJBBNPN@MaxMemorySupported@ DB 'MaxMemorySupported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NCJGCGIA@InstalledDisplayDrivers@
CONST	SEGMENT
??_C@_0BI@NCJGCGIA@InstalledDisplayDrivers@ DB 'InstalledDisplayDrivers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGGCGCBA@ICMMethod@
CONST	SEGMENT
??_C@_09OGGCGCBA@ICMMethod@ DB 'ICMMethod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBIABGHL@ICMIntent@
CONST	SEGMENT
??_C@_09MBIABGHL@ICMIntent@ DB 'ICMIntent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GAFFCADK@DriverDate@
CONST	SEGMENT
??_C@_0L@GAFFCADK@DriverDate@ DB 'DriverDate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HJOBJMDE@DitherType@
CONST	SEGMENT
??_C@_0L@HJOBJMDE@DitherType@ DB 'DitherType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HBMCPLLH@DeviceSpecificPens@
CONST	SEGMENT
??_C@_0BD@HBMCPLLH@DeviceSpecificPens@ DB 'DeviceSpecificPens', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KKIKAADI@DriverVersion@
CONST	SEGMENT
??_C@_0O@KKIKAADI@DriverVersion@ DB 'DriverVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HMKFJKEG@InfFilename@
CONST	SEGMENT
??_C@_0M@HMKFJKEG@InfFilename@ DB 'InfFilename', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CKHNOAKJ@AdapterRAM@
CONST	SEGMENT
??_C@_0L@CKHNOAKJ@AdapterRAM@ DB 'AdapterRAM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MPKKGADB@AdapterDACType@
CONST	SEGMENT
??_C@_0P@MPKKGADB@AdapterDACType@ DB 'AdapterDACType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LPCADEJI@AdapterCompatibility@
CONST	SEGMENT
??_C@_0BF@LPCADEJI@AdapterCompatibility@ DB 'AdapterCompatibility', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFJMJFBI@AcceleratorCapabilities@
CONST	SEGMENT
??_C@_0BI@DFJMJFBI@AcceleratorCapabilities@ DB 'AcceleratorCapabilities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FKKNOPFN@SystemPaletteEntries@
CONST	SEGMENT
??_C@_0BF@FKKNOPFN@SystemPaletteEntries@ DB 'SystemPaletteEntries', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DECAKEGH@NumberOfVideoPages@
CONST	SEGMENT
??_C@_0BD@DECAKEGH@NumberOfVideoPages@ DB 'NumberOfVideoPages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCFFEIIM@NumberOfColorPlanes?$DL@
CONST	SEGMENT
??_C@_0BF@JCFFEIIM@NumberOfColorPlanes?$DL@ DB 'NumberOfColorPlanes;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PEHKLIOA@ColorTableEntries@
CONST	SEGMENT
??_C@_0BC@PEHKLIOA@ColorTableEntries@ DB 'ColorTableEntries', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OMEGAAG@VideoProcessor@
CONST	SEGMENT
??_C@_0P@OMEGAAG@VideoProcessor@ DB 'VideoProcessor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MAGAOPPB@VideoModeDescription@
CONST	SEGMENT
??_C@_0BF@MAGAOPPB@VideoModeDescription@ DB 'VideoModeDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LIEAKBEG@VideoMode@
CONST	SEGMENT
??_C@_09LIEAKBEG@VideoMode@ DB 'VideoMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@COFLHODM@VideoMemoryType@
CONST	SEGMENT
??_C@_0BA@COFLHODM@VideoMemoryType@ DB 'VideoMemoryType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GFHBBCIN@VideoArchitecture@
CONST	SEGMENT
??_C@_0BC@GFHBBCIN@VideoArchitecture@ DB 'VideoArchitecture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BKBIMFEG@CurrentNumberOfRows@
CONST	SEGMENT
??_C@_0BE@BKBIMFEG@CurrentNumberOfRows@ DB 'CurrentNumberOfRows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IKBJPLJ@CurrentNumberOfColumns@
CONST	SEGMENT
??_C@_0BH@IKBJPLJ@CurrentNumberOfColumns@ DB 'CurrentNumberOfColumns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CDIHNLEF@CurrentScanMode@
CONST	SEGMENT
??_C@_0BA@CDIHNLEF@CurrentScanMode@ DB 'CurrentScanMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JKLPINND@CurrentRefreshRate@
CONST	SEGMENT
??_C@_0BD@JKLPINND@CurrentRefreshRate@ DB 'CurrentRefreshRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NCBMILGB@CurrentNumberOfColors@
CONST	SEGMENT
??_C@_0BG@NCBMILGB@CurrentNumberOfColors@ DB 'CurrentNumberOfColors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LFIAOAGD@CurrentVerticalResolution@
CONST	SEGMENT
??_C@_0BK@LFIAOAGD@CurrentVerticalResolution@ DB 'CurrentVerticalResoluti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OFHJCNEB@CurrentHorizontalResolution@
CONST	SEGMENT
??_C@_0BM@OFHJCNEB@CurrentHorizontalResolution@ DB 'CurrentHorizontalReso'
	DB	'lution', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FEOPMOOE@CurrentBitsPerPixel@
CONST	SEGMENT
??_C@_0BE@FEOPMOOE@CurrentBitsPerPixel@ DB 'CurrentBitsPerPixel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IOBPPLKC@Win32_VideoController@
CONST	SEGMENT
??_C@_0BG@IOBPPLKC@Win32_VideoController@ DB 'Win32_VideoController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KNIHCNGM@Win32_USBController@
CONST	SEGMENT
??_C@_0BE@KNIHCNGM@Win32_USBController@ DB 'Win32_USBController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GHJKPLAG@DMABufferSize@
CONST	SEGMENT
??_C@_0O@GHJKPLAG@DMABufferSize@ DB 'DMABufferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GILLNKKD@MPU401Address@
CONST	SEGMENT
??_C@_0O@GILLNKKD@MPU401Address@ DB 'MPU401Address', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MNPNDAHP@ProductName@
CONST	SEGMENT
??_C@_0M@MNPNDAHP@ProductName@ DB 'ProductName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@INJPMPPD@Win32_SoundDevice@
CONST	SEGMENT
??_C@_0BC@INJPMPPD@Win32_SoundDevice@ DB 'Win32_SoundDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LCMFOHKE@XOnXOffOutFlowControl@
CONST	SEGMENT
??_C@_0BG@LCMFOHKE@XOnXOffOutFlowControl@ DB 'XOnXOffOutFlowControl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FMELJHC@XOnXOffInFlowControl@
CONST	SEGMENT
??_C@_0BF@FMELJHC@XOnXOffInFlowControl@ DB 'XOnXOffInFlowControl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OHGPOKOF@XOnXMitThreshold@
CONST	SEGMENT
??_C@_0BB@OHGPOKOF@XOnXMitThreshold@ DB 'XOnXMitThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMKFMCPA@XOnCharacter@
CONST	SEGMENT
??_C@_0N@LMKFMCPA@XOnCharacter@ DB 'XOnCharacter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PIOKAKHD@XOffXMitThreshold@
CONST	SEGMENT
??_C@_0BC@PIOKAKHD@XOffXMitThreshold@ DB 'XOffXMitThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IABHIILA@XOffCharacter@
CONST	SEGMENT
??_C@_0O@IABHIILA@XOffCharacter@ DB 'XOffCharacter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CMMJGBDB@SettingID@
CONST	SEGMENT
??_C@_09CMMJGBDB@SettingID@ DB 'SettingID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HDDKDMKB@RTSFlowControlType@
CONST	SEGMENT
??_C@_0BD@HDDKDMKB@RTSFlowControlType@ DB 'RTSFlowControlType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KACACAPH@ParityCheckEnabled@
CONST	SEGMENT
??_C@_0BD@KACACAPH@ParityCheckEnabled@ DB 'ParityCheckEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELDMBJ@EventCharacter@
CONST	SEGMENT
??_C@_0P@ELDMBJ@EventCharacter@ DB 'EventCharacter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MDNCEDD@ErrorReplacementEnabled@
CONST	SEGMENT
??_C@_0BI@MDNCEDD@ErrorReplacementEnabled@ DB 'ErrorReplacementEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HECEEKCN@ErrorReplaceCharacter@
CONST	SEGMENT
??_C@_0BG@HECEEKCN@ErrorReplaceCharacter@ DB 'ErrorReplaceCharacter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HDNBGKMG@EOFCharacter@
CONST	SEGMENT
??_C@_0N@HDNBGKMG@EOFCharacter@ DB 'EOFCharacter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HKACMHPL@DTRFlowControlType@
CONST	SEGMENT
??_C@_0BD@HKACMHPL@DTRFlowControlType@ DB 'DTRFlowControlType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDLAEJMA@DSRSensitivity@
CONST	SEGMENT
??_C@_0P@FDLAEJMA@DSRSensitivity@ DB 'DSRSensitivity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HDHNIDHE@DSROutflowControl@
CONST	SEGMENT
??_C@_0BC@HDHNIDHE@DSROutflowControl@ DB 'DSROutflowControl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNMOOKGE@DiscardNULLBytes@
CONST	SEGMENT
??_C@_0BB@LNMOOKGE@DiscardNULLBytes@ DB 'DiscardNULLBytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BMKJGEMK@CTSOutflowControl@
CONST	SEGMENT
??_C@_0BC@BMKJGEMK@CTSOutflowControl@ DB 'CTSOutflowControl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MCBMPIAJ@ContinueXMitOnXOff@
CONST	SEGMENT
??_C@_0BD@MCBMPIAJ@ContinueXMitOnXOff@ DB 'ContinueXMitOnXOff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OGEDEEBA@BinaryModeEnabled@
CONST	SEGMENT
??_C@_0BC@OGEDEEBA@BinaryModeEnabled@ DB 'BinaryModeEnabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DFLLPBBO@AbortReadWriteOnError@
CONST	SEGMENT
??_C@_0BG@DFLLPBBO@AbortReadWriteOnError@ DB 'AbortReadWriteOnError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OICOCAHF@IsBusy@
CONST	SEGMENT
??_C@_06OICOCAHF@IsBusy@ DB 'IsBusy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPBIGBFM@StopBits@
CONST	SEGMENT
??_C@_08DPBIGBFM@StopBits@ DB 'StopBits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OKNHBMNM@Parity@
CONST	SEGMENT
??_C@_06OKNHBMNM@Parity@ DB 'Parity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PAFDOFKP@BitsPerByte@
CONST	SEGMENT
??_C@_0M@PAFDOFKP@BitsPerByte@ DB 'BitsPerByte', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FCNNIBJG@BaudRate@
CONST	SEGMENT
??_C@_08FCNNIBJG@BaudRate@ DB 'BaudRate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@
CONST	SEGMENT
??_C@_0BO@BPJAPEGK@Win32_SerialPortConfiguration@ DB 'Win32_SerialPortCon'
	DB	'figuration', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GDEAPHBI@SupportsXOnXOffSet@
CONST	SEGMENT
??_C@_0BD@GDEAPHBI@SupportsXOnXOffSet@ DB 'SupportsXOnXOffSet', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OPAGJFHI@SupportsXOnXOff@
CONST	SEGMENT
??_C@_0BA@OPAGJFHI@SupportsXOnXOff@ DB 'SupportsXOnXOff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGENNCGN@SupportsSpecialCharacters@
CONST	SEGMENT
??_C@_0BK@GGENNCGN@SupportsSpecialCharacters@ DB 'SupportsSpecialCharacte'
	DB	'rs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NGNOBJLG@SupportsRTSCTS@
CONST	SEGMENT
??_C@_0P@NGNOBJLG@SupportsRTSCTS@ DB 'SupportsRTSCTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GBIJPBEE@SupportsRLSD@
CONST	SEGMENT
??_C@_0N@GBIJPBEE@SupportsRLSD@ DB 'SupportsRLSD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JCPAAGPO@SupportsParityCheck@
CONST	SEGMENT
??_C@_0BE@JCPAAGPO@SupportsParityCheck@ DB 'SupportsParityCheck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JOEIKOLI@SupportsIntTimeouts@
CONST	SEGMENT
??_C@_0BE@JOEIKOLI@SupportsIntTimeouts@ DB 'SupportsIntTimeouts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJLLOLPH@SupportsElapsedTimeouts@
CONST	SEGMENT
??_C@_0BI@LJLLOLPH@SupportsElapsedTimeouts@ DB 'SupportsElapsedTimeouts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GODDIGIP@SupportsDTRDSR@
CONST	SEGMENT
??_C@_0P@GODDIGIP@SupportsDTRDSR@ DB 'SupportsDTRDSR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EEEMKCBH@Supports16BitMode@
CONST	SEGMENT
??_C@_0BC@EEEMKCBH@Supports16BitMode@ DB 'Supports16BitMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EPIEMKMF@SettableStopBits@
CONST	SEGMENT
??_C@_0BB@EPIEMKMF@SettableStopBits@ DB 'SettableStopBits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OBGEBGNG@SettableRLSD@
CONST	SEGMENT
??_C@_0N@OBGEBGNG@SettableRLSD@ DB 'SettableRLSD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NMPLPPIE@SettableParityCheck@
CONST	SEGMENT
??_C@_0BE@NMPLPPIE@SettableParityCheck@ DB 'SettableParityCheck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOHECAJ@SettableParity@
CONST	SEGMENT
??_C@_0P@MOHECAJ@SettableParity@ DB 'SettableParity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FMKJPGFK@SettableFlowControl@
CONST	SEGMENT
??_C@_0BE@FMKJPGFK@SettableFlowControl@ DB 'SettableFlowControl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BOCNMDDI@SettableDataBits@
CONST	SEGMENT
??_C@_0BB@BOCNMDDI@SettableDataBits@ DB 'SettableDataBits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CCEBCKAP@SettableBaudRate@
CONST	SEGMENT
??_C@_0BB@CCEBCKAP@SettableBaudRate@ DB 'SettableBaudRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NCMHEECO@OSAutoDiscovered@
CONST	SEGMENT
??_C@_0BB@NCMHEECO@OSAutoDiscovered@ DB 'OSAutoDiscovered', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EAKFLPF@MaximumOutputBufferSize@
CONST	SEGMENT
??_C@_0BI@EAKFLPF@MaximumOutputBufferSize@ DB 'MaximumOutputBufferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PKAPBGLB@MaximumInputBufferSize@
CONST	SEGMENT
??_C@_0BH@PKAPBGLB@MaximumInputBufferSize@ DB 'MaximumInputBufferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JCOMDNII@Binary@
CONST	SEGMENT
??_C@_06JCOMDNII@Binary@ DB 'Binary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFNBCBNP@ProviderType@
CONST	SEGMENT
??_C@_0N@KFNBCBNP@ProviderType@ DB 'ProviderType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFAJGJNN@MaxBaudRate@
CONST	SEGMENT
??_C@_0M@BFAJGJNN@MaxBaudRate@ DB 'MaxBaudRate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DLHLCIMJ@Win32_SerialPort@
CONST	SEGMENT
??_C@_0BB@DLHLCIMJ@Win32_SerialPort@ DB 'Win32_SerialPort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OGNJDJGP@ProtectionManagement@
CONST	SEGMENT
??_C@_0BF@OGNJDJGP@ProtectionManagement@ DB 'ProtectionManagement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDEAMGMB@MaxTransferRate@
CONST	SEGMENT
??_C@_0BA@IDEAMGMB@MaxTransferRate@ DB 'MaxTransferRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OLJPFNHL@MaxDataWidth@
CONST	SEGMENT
??_C@_0N@OLJPFNHL@MaxDataWidth@ DB 'MaxDataWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FNNGFGLF@Index@
CONST	SEGMENT
??_C@_05FNNGFGLF@Index@ DB 'Index', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DJCHLIFB@DeviceMap@
CONST	SEGMENT
??_C@_09DJCHLIFB@DeviceMap@ DB 'DeviceMap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LPBNFPJD@ControllerTimeouts@
CONST	SEGMENT
??_C@_0BD@LPBNFPJD@ControllerTimeouts@ DB 'ControllerTimeouts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJODOJJC@HardwareVersion@
CONST	SEGMENT
??_C@_0BA@BJODOJJC@HardwareVersion@ DB 'HardwareVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJBCKAGE@DriverName@
CONST	SEGMENT
??_C@_0L@DJBCKAGE@DriverName@ DB 'DriverName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OGHHAMBD@Win32_SCSIController@
CONST	SEGMENT
??_C@_0BF@OGHHAMBD@Win32_SCSIController@ DB 'Win32_SCSIController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DEJHGOJI@VoltageCaps@
CONST	SEGMENT
??_C@_0M@DEJHGOJI@VoltageCaps@ DB 'VoltageCaps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KHACBBMN@UpgradeMethod@
CONST	SEGMENT
??_C@_0O@KHACBBMN@UpgradeMethod@ DB 'UpgradeMethod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HJBCPKNB@UniqueId@
CONST	SEGMENT
??_C@_08HJBCPKNB@UniqueId@ DB 'UniqueId', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HPJGCEAH@Stepping@
CONST	SEGMENT
??_C@_08HPJGCEAH@Stepping@ DB 'Stepping', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GCIFEBIL@SocketDesignation@
CONST	SEGMENT
??_C@_0BC@GCIFEBIL@SocketDesignation@ DB 'SocketDesignation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBAMNOLK@Role@
CONST	SEGMENT
??_C@_04EBAMNOLK@Role@ DB 'Role', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNLDHPFP@Revision@
CONST	SEGMENT
??_C@_08DNLDHPFP@Revision@ DB 'Revision', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAODMABE@ProcessorType@
CONST	SEGMENT
??_C@_0O@DAODMABE@ProcessorType@ DB 'ProcessorType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DHKOOBFD@ProcessorId@
CONST	SEGMENT
??_C@_0M@DHKOOBFD@ProcessorId@ DB 'ProcessorId', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LLAHKBOJ@OtherFamilyDescription@
CONST	SEGMENT
??_C@_0BH@LLAHKBOJ@OtherFamilyDescription@ DB 'OtherFamilyDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLLBIGKP@LoadPercentage@
CONST	SEGMENT
??_C@_0P@HLLBIGKP@LoadPercentage@ DB 'LoadPercentage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOHFLOFG@Level@
CONST	SEGMENT
??_C@_05KOHFLOFG@Level@ DB 'Level', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08JALCBBMK@ExtClock@
CONST	SEGMENT
??_C@_08JALCBBMK@ExtClock@ DB 'ExtClock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KNGBBIL@DataWidth@
CONST	SEGMENT
??_C@_09KNGBBIL@DataWidth@ DB 'DataWidth', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHAGOHLC@CurrentVoltage@
CONST	SEGMENT
??_C@_0P@IHAGOHLC@CurrentVoltage@ DB 'CurrentVoltage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JFANJPME@CurrentClockSpeed@
CONST	SEGMENT
??_C@_0BC@JFANJPME@CurrentClockSpeed@ DB 'CurrentClockSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OJECCCEO@CpuStatus@
CONST	SEGMENT
??_C@_09OJECCCEO@CpuStatus@ DB 'CpuStatus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IPOPOCBB@AddressWidth@
CONST	SEGMENT
??_C@_0N@IPOPOCBB@AddressWidth@ DB 'AddressWidth', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKFHDKJL@L3CacheSpeed@
CONST	SEGMENT
??_C@_0N@EKFHDKJL@L3CacheSpeed@ DB 'L3CacheSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PICLIDHN@L3CacheSize@
CONST	SEGMENT
??_C@_0M@PICLIDHN@L3CacheSize@ DB 'L3CacheSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NBPCHGPE@L2CacheSpeed@
CONST	SEGMENT
??_C@_0N@NBPCHGPE@L2CacheSpeed@ DB 'L2CacheSpeed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DJKFFMLN@L2CacheSize@
CONST	SEGMENT
??_C@_0M@DJKFFMLN@L2CacheSize@ DB 'L2CacheSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BOFMEHLD@Family@
CONST	SEGMENT
??_C@_06BOFMEHLD@Family@ DB 'Family', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors@
CONST	SEGMENT
??_C@_0BK@OBFFNDNO@NumberOfLogicalProcessors@ DB 'NumberOfLogicalProcesso'
	DB	'rs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJOHKFKO@MaxClockSpeed@
CONST	SEGMENT
??_C@_0O@MJOHKFKO@MaxClockSpeed@ DB 'MaxClockSpeed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FFCOPHIP@NumberOfCores@
CONST	SEGMENT
??_C@_0O@FFCOPHIP@NumberOfCores@ DB 'NumberOfCores', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDJPNJNL@Architecture@
CONST	SEGMENT
??_C@_0N@MDJPNJNL@Architecture@ DB 'Architecture', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OJJOBJJP@Win32_Processor@
CONST	SEGMENT
??_C@_0BA@OJJOBJJP@Win32_Processor@ DB 'Win32_Processor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IAGOJBFI@StartMode@
CONST	SEGMENT
??_C@_09IAGOJBFI@StartMode@ DB 'StartMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCDJNPHI@Started@
CONST	SEGMENT
??_C@_07LCDJNPHI@Started@ DB 'Started', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENMIEFDD@OEMUrl@
CONST	SEGMENT
??_C@_06ENMIEFDD@OEMUrl@ DB 'OEMUrl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBBGILI@DependentFiles@
CONST	SEGMENT
??_C@_0P@NBBGILI@DependentFiles@ DB 'DependentFiles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GLFJHHAH@HelpFile@
CONST	SEGMENT
??_C@_08GLFJHHAH@HelpFile@ DB 'HelpFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JFPHJDHA@InfName@
CONST	SEGMENT
??_C@_07JFPHJDHA@InfName@ DB 'InfName', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLDLGMGB@SupportedPlatform@
CONST	SEGMENT
??_C@_0BC@MLDLGMGB@SupportedPlatform@ DB 'SupportedPlatform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PJPGFADP@MonitorName@
CONST	SEGMENT
??_C@_0M@PJPGFADP@MonitorName@ DB 'MonitorName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JFJMIJHO@DataFile@
CONST	SEGMENT
??_C@_08JFJMIJHO@DataFile@ DB 'DataFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LKBOBDBI@ConfigFile@
CONST	SEGMENT
??_C@_0L@LKBOBDBI@ConfigFile@ DB 'ConfigFile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CKKAOMLK@FilePath@
CONST	SEGMENT
??_C@_08CKKAOMLK@FilePath@ DB 'FilePath', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAJLGPDF@DriverPath@
CONST	SEGMENT
??_C@_0L@EAJLGPDF@DriverPath@ DB 'DriverPath', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFCCEOEE@DefaultDataType@
CONST	SEGMENT
??_C@_0BA@PFCCEOEE@DefaultDataType@ DB 'DefaultDataType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HLKMDILE@Win32_PrinterDriver@
CONST	SEGMENT
??_C@_0BE@HLKMDILE@Win32_PrinterDriver@ DB 'Win32_PrinterDriver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NNNCCOHC@Alias@
CONST	SEGMENT
??_C@_05NNNCCOHC@Alias@ DB 'Alias', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJNGNMBL@Win32_PortResource@
CONST	SEGMENT
??_C@_0BD@JJNGNMBL@Win32_PortResource@ DB 'Win32_PortResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KNNOFNF@ConnectorPinout@
CONST	SEGMENT
??_C@_0BA@KNNOFNF@ConnectorPinout@ DB 'ConnectorPinout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CPCPFFAH@ConnectorType@
CONST	SEGMENT
??_C@_0O@CPCPFFAH@ConnectorType@ DB 'ConnectorType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOPEOHEK@PortType@
CONST	SEGMENT
??_C@_08BOPEOHEK@PortType@ DB 'PortType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JBGCGAG@InternalReferenceDesignator@
CONST	SEGMENT
??_C@_0BM@JBGCGAG@InternalReferenceDesignator@ DB 'InternalReferenceDesig'
	DB	'nator', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OAEDMMAI@ExternalReferenceDesignator@
CONST	SEGMENT
??_C@_0BM@OAEDMMAI@ExternalReferenceDesignator@ DB 'ExternalReferenceDesi'
	DB	'gnator', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BFHBBNBL@Win32_PortConnector@
CONST	SEGMENT
??_C@_0BE@BFHBBNBL@Win32_PortConnector@ DB 'Win32_PortConnector', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKJLCFN@Synch@
CONST	SEGMENT
??_C@_05MKJLCFN@Synch@ DB 'Synch', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NEGJIGMA@SampleRate@
CONST	SEGMENT
??_C@_0L@NEGJIGMA@SampleRate@ DB 'SampleRate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KGPBCGJE@Resolution@
CONST	SEGMENT
??_C@_0L@KGPBCGJE@Resolution@ DB 'Resolution', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MJAHKLJJ@QuadSpeedThreshold@
CONST	SEGMENT
??_C@_0BD@MJAHKLJJ@QuadSpeedThreshold@ DB 'QuadSpeedThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHOEHLLF@InfSection@
CONST	SEGMENT
??_C@_0L@KHOEHLLF@InfSection@ DB 'InfSection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LNGELFEC@InfFileName@
CONST	SEGMENT
??_C@_0M@LNGELFEC@InfFileName@ DB 'InfFileName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FLDPHBAC@DoubleSpeedThreshold@
CONST	SEGMENT
??_C@_0BF@FLDPHBAC@DoubleSpeedThreshold@ DB 'DoubleSpeedThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DEGCDBKP@Handedness@
CONST	SEGMENT
??_C@_0L@DEGCDBKP@Handedness@ DB 'Handedness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGCCLEJJ@HardwareType@
CONST	SEGMENT
??_C@_0N@OGCCLEJJ@HardwareType@ DB 'HardwareType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLLFIHNG@DeviceInterface@
CONST	SEGMENT
??_C@_0BA@PLLFIHNG@DeviceInterface@ DB 'DeviceInterface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EHILAMBM@NumberOfButtons@
CONST	SEGMENT
??_C@_0BA@EHILAMBM@NumberOfButtons@ DB 'NumberOfButtons', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HMDMLBLH@PointingType@
CONST	SEGMENT
??_C@_0N@HMDMLBLH@PointingType@ DB 'PointingType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MJMHBKMK@Win32_PointingDevice@
CONST	SEGMENT
??_C@_0BF@MJMHBKMK@Win32_PointingDevice@ DB 'Win32_PointingDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCPBCGGP@HardwareID@
CONST	SEGMENT
??_C@_0L@MCPBCGGP@HardwareID@ DB 'HardwareID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EEHHOFBP@CompatibleID@
CONST	SEGMENT
??_C@_0N@EEHHOFBP@CompatibleID@ DB 'CompatibleID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPHNMGJN@ClassGuid@
CONST	SEGMENT
??_C@_09GPHNMGJN@ClassGuid@ DB 'ClassGuid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LMLHFMEG@Service@
CONST	SEGMENT
??_C@_07LMLHFMEG@Service@ DB 'Service', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EHCOOLPP@Win32_PnPEntity@
CONST	SEGMENT
??_C@_0BA@EHCOOLPP@Win32_PnPEntity@ DB 'Win32_PnPEntity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@
CONST	SEGMENT
??_C@_0BH@CNGPGCKD@Win32_PCMCIAController@ DB 'Win32_PCMCIAController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOAOMMKG@Enabled@
CONST	SEGMENT
??_C@_07DOAOMMKG@Enabled@ DB 'Enabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PMICFDLL@DeviceType@
CONST	SEGMENT
??_C@_0L@PMICFDLL@DeviceType@ DB 'DeviceType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@
CONST	SEGMENT
??_C@_0BE@ILPPNPBM@Win32_OnBoardDevice@ DB 'Win32_OnBoardDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MKKJDBAN@SecondaryBusType@
CONST	SEGMENT
??_C@_0BB@MKKJDBAN@SecondaryBusType@ DB 'SecondaryBusType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJGNFGBG@RevisionNumber@
CONST	SEGMENT
??_C@_0P@EJGNFGBG@RevisionNumber@ DB 'RevisionNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GCEIIPJN@PrimaryBusType@
CONST	SEGMENT
??_C@_0P@GCEIIPJN@PrimaryBusType@ DB 'PrimaryBusType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@
CONST	SEGMENT
??_C@_0BI@DKDNDIIN@Win32_MotherboardDevice@ DB 'Win32_MotherboardDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJIAHGMM@Password@
CONST	SEGMENT
??_C@_08FJIAHGMM@Password@ DB 'Password', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOCJLAAL@IsLocked@
CONST	SEGMENT
??_C@_08EOCJLAAL@IsLocked@ DB 'IsLocked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DODFNOHG@NumberOfFunctionKeys@
CONST	SEGMENT
??_C@_0BF@DODFNOHG@NumberOfFunctionKeys@ DB 'NumberOfFunctionKeys', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMHOJANB@Layout@
CONST	SEGMENT
??_C@_06KMHOJANB@Layout@ DB 'Layout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IGJIBAJA@Win32_Keyboard@
CONST	SEGMENT
??_C@_0P@IGJIBAJA@Win32_Keyboard@ DB 'Win32_Keyboard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BOOCMPNK@Vector@
CONST	SEGMENT
??_C@_06BOOCMPNK@Vector@ DB 'Vector', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NKHMGHID@TriggerType@
CONST	SEGMENT
??_C@_0M@NKHMGHID@TriggerType@ DB 'TriggerType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NCNNCPPP@TriggerLevel@
CONST	SEGMENT
??_C@_0N@NCNNCPPP@TriggerLevel@ DB 'TriggerLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKFILKGD@Shareable@
CONST	SEGMENT
??_C@_09PKFILKGD@Shareable@ DB 'Shareable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPIOJEA@Hardware@
CONST	SEGMENT
??_C@_08PPIOJEA@Hardware@ DB 'Hardware', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MGLAEOHD@Win32_IRQResource@
CONST	SEGMENT
??_C@_0BC@MGLAEOHD@Win32_IRQResource@ DB 'Win32_IRQResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EEIPINHM@Win32_InfraredDevice@
CONST	SEGMENT
??_C@_0BF@EEIPINHM@Win32_InfraredDevice@ DB 'Win32_InfraredDevice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FMCMMJCA@Win32_IDEController@
CONST	SEGMENT
??_C@_0BE@FMCMMJCA@Win32_IDEController@ DB 'Win32_IDEController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBOKHICP@ActiveCooling@
CONST	SEGMENT
??_C@_0O@PBOKHICP@ActiveCooling@ DB 'ActiveCooling', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCPBPNON@Win32_HeatPipe@
CONST	SEGMENT
??_C@_0P@MCPBPNON@Win32_HeatPipe@ DB 'Win32_HeatPipe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@
CONST	SEGMENT
??_C@_0BC@MGJAFBFH@Win32_FloppyDrive@ DB 'Win32_FloppyDrive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GBOCBJMM@Win32_FloppyController@
CONST	SEGMENT
??_C@_0BH@GBOCBJMM@Win32_FloppyController@ DB 'Win32_FloppyController', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JENHGIOM@V86_API@
CONST	SEGMENT
??_C@_07JENHGIOM@V86_API@ DB 'V86_API', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LEBBIDOP@TargetOperatingSystem@
CONST	SEGMENT
??_C@_0BG@LEBBIDOP@TargetOperatingSystem@ DB 'TargetOperatingSystem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CCKMONLJ@ServiceTableSize@
CONST	SEGMENT
??_C@_0BB@CCKMONLJ@ServiceTableSize@ DB 'ServiceTableSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CGGMGNDK@PM_API@
CONST	SEGMENT
??_C@_06CGGMGNDK@PM_API@ DB 'PM_API', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JOJBKDJN@LanguageEdition@
CONST	SEGMENT
??_C@_0BA@JOJBKDJN@LanguageEdition@ DB 'LanguageEdition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IOIHNNJK@DeviceDescriptorBlock@
CONST	SEGMENT
??_C@_0BG@IOIHNNJK@DeviceDescriptorBlock@ DB 'DeviceDescriptorBlock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFGIDBBA@Control@
CONST	SEGMENT
??_C@_07DFGIDBBA@Control@ DB 'Control', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DGOGJGDP@Win32_DriverVXD@
CONST	SEGMENT
??_C@_0BA@DGOGJGDP@Win32_DriverVXD@ DB 'Win32_DriverVXD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HKOOHOAE@WordMode@
CONST	SEGMENT
??_C@_08HKOOHOAE@WordMode@ DB 'WordMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MOIPDDOB@TypeCTiming@
CONST	SEGMENT
??_C@_0M@MOIPDDOB@TypeCTiming@ DB 'TypeCTiming', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HFMGHLOP@TransferWidths@
CONST	SEGMENT
??_C@_0P@HFMGHLOP@TransferWidths@ DB 'TransferWidths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HBAKOKJE@MaxTransferSize@
CONST	SEGMENT
??_C@_0BA@HBAKOKJE@MaxTransferSize@ DB 'MaxTransferSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BPLPAGKN@ChannelTiming@
CONST	SEGMENT
??_C@_0O@BPLPAGKN@ChannelTiming@ DB 'ChannelTiming', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOOBKHAJ@ByteMode@
CONST	SEGMENT
??_C@_08IOOBKHAJ@ByteMode@ DB 'ByteMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDKFCLB@BurstMode@
CONST	SEGMENT
??_C@_09LDKFCLB@BurstMode@ DB 'BurstMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HJPEAMBM@AddressSize@
CONST	SEGMENT
??_C@_0M@HJPEAMBM@AddressSize@ DB 'AddressSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGAIMACF@DMAChannel@
CONST	SEGMENT
??_C@_0L@PGAIMACF@DMAChannel@ DB 'DMAChannel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOKNCALA@Port@
CONST	SEGMENT
??_C@_04HOKNCALA@Port@ DB 'Port', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ILOPCCAP@Win32_DMAChannel@
CONST	SEGMENT
??_C@_0BB@ILOPCCAP@Win32_DMAChannel@ DB 'Win32_DMAChannel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFEIEMMN@TransferRate@
CONST	SEGMENT
??_C@_0N@GFEIEMMN@TransferRate@ DB 'TransferRate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBKMHHBE@Size@
CONST	SEGMENT
??_C@_04EBKMHHBE@Size@ DB 'Size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGGJIJCI@SCSITargetId@
CONST	SEGMENT
??_C@_0N@BGGJIJCI@SCSITargetId@ DB 'SCSITargetId', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IICBNDDA@SCSIPort@
CONST	SEGMENT
??_C@_08IICBNDDA@SCSIPort@ DB 'SCSIPort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FGFDLPLK@SCSILogicalUnit@
CONST	SEGMENT
??_C@_0BA@FGFDLPLK@SCSILogicalUnit@ DB 'SCSILogicalUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMFLOLAO@SCSIBus@
CONST	SEGMENT
??_C@_07IMFLOLAO@SCSIBus@ DB 'SCSIBus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MEKHAACN@RevisionLevel@
CONST	SEGMENT
??_C@_0O@MEKHAACN@RevisionLevel@ DB 'RevisionLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@COPKOGMD@NumberOfMediaSupported@
CONST	SEGMENT
??_C@_0BH@COPKOGMD@NumberOfMediaSupported@ DB 'NumberOfMediaSupported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IIJMNCFJ@NeedsCleaning@
CONST	SEGMENT
??_C@_0O@IIJMNCFJ@NeedsCleaning@ DB 'NeedsCleaning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DELMGCCC@MinBlockSize@
CONST	SEGMENT
??_C@_0N@DELMGCCC@MinBlockSize@ DB 'MinBlockSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FCFAAAMD@MfrAssignedRevisionLevel@
CONST	SEGMENT
??_C@_0BJ@FCFAAAMD@MfrAssignedRevisionLevel@ DB 'MfrAssignedRevisionLevel'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPDNNFFF@MediaType@
CONST	SEGMENT
??_C@_09HPDNNFFF@MediaType@ DB 'MediaType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BKHKLNGH@MediaLoaded@
CONST	SEGMENT
??_C@_0M@BKHKLNGH@MediaLoaded@ DB 'MediaLoaded', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HBNKJHPM@MaxMediaSize@
CONST	SEGMENT
??_C@_0N@HBNKJHPM@MaxMediaSize@ DB 'MaxMediaSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GKGMNPDK@MaximumComponentLength@
CONST	SEGMENT
??_C@_0BH@GKGMNPDK@MaximumComponentLength@ DB 'MaximumComponentLength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HEPDBKFE@MaxBlockSize@
CONST	SEGMENT
??_C@_0N@HEPDBKFE@MaxBlockSize@ DB 'MaxBlockSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JDDJOAMF@FileSystemFlagsEx@
CONST	SEGMENT
??_C@_0BC@JDDJOAMF@FileSystemFlagsEx@ DB 'FileSystemFlagsEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMBBNBII@FileSystemFlags@
CONST	SEGMENT
??_C@_0BA@KMBBNBII@FileSystemFlags@ DB 'FileSystemFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PNCBAHDK@ErrorMethodology@
CONST	SEGMENT
??_C@_0BB@PNCBAHDK@ErrorMethodology@ DB 'ErrorMethodology', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HKGKOHLF@DriveIntegrity@
CONST	SEGMENT
??_C@_0P@HKGKOHLF@DriveIntegrity@ DB 'DriveIntegrity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHOHONOE@DefaultBlockSize@
CONST	SEGMENT
??_C@_0BB@GHOHONOE@DefaultBlockSize@ DB 'DefaultBlockSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBGAHHAB@CompressionMethod@
CONST	SEGMENT
??_C@_0BC@MBGAHHAB@CompressionMethod@ DB 'CompressionMethod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EPMKAGLN@CapabilityDescriptions@
CONST	SEGMENT
??_C@_0BH@EPMKAGLN@CapabilityDescriptions@ DB 'CapabilityDescriptions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FNJCOOAL@Capabilities@
CONST	SEGMENT
??_C@_0N@FNJCOOAL@Capabilities@ DB 'Capabilities', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNELKJMD@VolumeSerialNumber@
CONST	SEGMENT
??_C@_0BD@KNELKJMD@VolumeSerialNumber@ DB 'VolumeSerialNumber', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PEPMOJNO@VolumeName@
CONST	SEGMENT
??_C@_0L@PEPMOJNO@VolumeName@ DB 'VolumeName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHDOJGAA@Drive@
CONST	SEGMENT
??_C@_05FHDOJGAA@Drive@ DB 'Drive', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@
CONST	SEGMENT
??_C@_0BB@KBKCBBFJ@Win32_CDROMDrive@ DB 'Win32_CDROMDrive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFFMBEEK@BusType@
CONST	SEGMENT
??_C@_07FFFMBEEK@BusType@ DB 'BusType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNDINCOD@BusNum@
CONST	SEGMENT
??_C@_06KNDINCOD@BusNum@ DB 'BusNum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPFDNOIF@Win32_Bus@
CONST	SEGMENT
??_C@_09HPFDNOIF@Win32_Bus@ DB 'Win32_Bus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GFDCFGAP@SoftwareElementState@
CONST	SEGMENT
??_C@_0BF@GFDCFGAP@SoftwareElementState@ DB 'SoftwareElementState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBHIKAHO@SoftwareElementID@
CONST	SEGMENT
??_C@_0BC@MBHIKAHO@SoftwareElementID@ DB 'SoftwareElementID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BHMENNOL@SMBIOSPresent@
CONST	SEGMENT
??_C@_0O@BHMENNOL@SMBIOSPresent@ DB 'SMBIOSPresent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NBGOPAJG@SMBIOSMinorVersion@
CONST	SEGMENT
??_C@_0BD@NBGOPAJG@SMBIOSMinorVersion@ DB 'SMBIOSMinorVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GHLLPFOK@SMBIOSMajorVersion@
CONST	SEGMENT
??_C@_0BD@GHLLPFOK@SMBIOSMajorVersion@ DB 'SMBIOSMajorVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GDJFCIN@SMBIOSBIOSVersion@
CONST	SEGMENT
??_C@_0BC@GDJFCIN@SMBIOSBIOSVersion@ DB 'SMBIOSBIOSVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FEKFCCJH@ReleaseDate@
CONST	SEGMENT
??_C@_0M@FEKFCCJH@ReleaseDate@ DB 'ReleaseDate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLCFCEDN@PrimaryBIOS@
CONST	SEGMENT
??_C@_0M@PLCFCEDN@PrimaryBIOS@ DB 'PrimaryBIOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LMGDODCH@OtherTargetOS@
CONST	SEGMENT
??_C@_0O@LMGDODCH@OtherTargetOS@ DB 'OtherTargetOS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OPCNKLIC@ListOfLanguages@
CONST	SEGMENT
??_C@_0BA@OPCNKLIC@ListOfLanguages@ DB 'ListOfLanguages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JGHHIKJK@InstallableLanguages@
CONST	SEGMENT
??_C@_0BF@JGHHIKJK@InstallableLanguages@ DB 'InstallableLanguages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IAKLNJOL@IdentificationCode@
CONST	SEGMENT
??_C@_0BD@IAKLNJOL@IdentificationCode@ DB 'IdentificationCode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LAFEEKJE@CurrentLanguage@
CONST	SEGMENT
??_C@_0BA@LAFEEKJE@CurrentLanguage@ DB 'CurrentLanguage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FOHBHJJA@CodeSet@
CONST	SEGMENT
??_C@_07FOHBHJJA@CodeSet@ DB 'CodeSet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIEABBJI@BuildNumber@
CONST	SEGMENT
??_C@_0M@PIEABBJI@BuildNumber@ DB 'BuildNumber', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JNJNMLGA@BIOSVersion@
CONST	SEGMENT
??_C@_0M@JNJNMLGA@BIOSVersion@ DB 'BIOSVersion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DHLHFABD@BiosCharacteristics@
CONST	SEGMENT
??_C@_0BE@DHLHFABD@BiosCharacteristics@ DB 'BiosCharacteristics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JLLHHBAL@Win32_BIOS@
CONST	SEGMENT
??_C@_0L@JLLHHBAL@Win32_BIOS@ DB 'Win32_BIOS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IIEJDIAD@SmartBatteryVersion@
CONST	SEGMENT
??_C@_0BE@IIEJDIAD@SmartBatteryVersion@ DB 'SmartBatteryVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KENPOHHF@MaxRechargeTime@
CONST	SEGMENT
??_C@_0BA@KENPOHHF@MaxRechargeTime@ DB 'MaxRechargeTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HADPLBCE@FullChargeCapacity@
CONST	SEGMENT
??_C@_0BD@HADPLBCE@FullChargeCapacity@ DB 'FullChargeCapacity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DDGBNILM@ExpectedLife@
CONST	SEGMENT
??_C@_0N@DDGBNILM@ExpectedLife@ DB 'ExpectedLife', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEEKJBPN@ExpectedBatteryLife@
CONST	SEGMENT
??_C@_0BE@NEEKJBPN@ExpectedBatteryLife@ DB 'ExpectedBatteryLife', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NPKJIND@EstimatedRunTime@
CONST	SEGMENT
??_C@_0BB@NPKJIND@EstimatedRunTime@ DB 'EstimatedRunTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining@
CONST	SEGMENT
??_C@_0BJ@CDCEHMEP@EstimatedChargeRemaining@ DB 'EstimatedChargeRemaining'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBABLEFL@DesignVoltage@
CONST	SEGMENT
??_C@_0O@PBABLEFL@DesignVoltage@ DB 'DesignVoltage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IFPGNGPN@DesignCapacity@
CONST	SEGMENT
??_C@_0P@IFPGNGPN@DesignCapacity@ DB 'DesignCapacity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CAHFAGKL@Chemistry@
CONST	SEGMENT
??_C@_09CAHFAGKL@Chemistry@ DB 'Chemistry', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HNKJKBND@BatteryRechargeTime@
CONST	SEGMENT
??_C@_0BE@HNKJKBND@BatteryRechargeTime@ DB 'BatteryRechargeTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMDCOCCC@TimeToFullCharge@
CONST	SEGMENT
??_C@_0BB@HMDCOCCC@TimeToFullCharge@ DB 'TimeToFullCharge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IKADLBCG@TimeOnBattery@
CONST	SEGMENT
??_C@_0O@IKADLBCG@TimeOnBattery@ DB 'TimeOnBattery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKGMNGNM@BatteryStatus@
CONST	SEGMENT
??_C@_0O@PKGMNGNM@BatteryStatus@ DB 'BatteryStatus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLAKILND@Win32_Battery@
CONST	SEGMENT
??_C@_0O@CLAKILND@Win32_Battery@ DB 'Win32_Battery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DAJBDDHL@SpecialRequirements@
CONST	SEGMENT
??_C@_0BE@DAJBDDHL@SpecialRequirements@ DB 'SpecialRequirements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLNCHAIH@SlotLayout@
CONST	SEGMENT
??_C@_0L@NLNCHAIH@SlotLayout@ DB 'SlotLayout', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LMAAELJP@SKU@
CONST	SEGMENT
??_C@_03LMAAELJP@SKU@ DB 'SKU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPJJBBNM@SerialNumber@
CONST	SEGMENT
??_C@_0N@FPJJBBNM@SerialNumber@ DB 'SerialNumber', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KNNEFNEE@RequiresDaughterBoard@
CONST	SEGMENT
??_C@_0BG@KNNEFNEE@RequiresDaughterBoard@ DB 'RequiresDaughterBoard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NLNEBFOD@RequirementsDescription@
CONST	SEGMENT
??_C@_0BI@NLNEBFOD@RequirementsDescription@ DB 'RequirementsDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLOLJEDG@Replaceable@
CONST	SEGMENT
??_C@_0M@KLOLJEDG@Replaceable@ DB 'Replaceable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DADBKOHO@Removable@
CONST	SEGMENT
??_C@_09DADBKOHO@Removable@ DB 'Removable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HKGEBMAI@PoweredOn@
CONST	SEGMENT
??_C@_09HKGEBMAI@PoweredOn@ DB 'PoweredOn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MIOPIENN@PartNumber@
CONST	SEGMENT
??_C@_0L@MIOPIENN@PartNumber@ DB 'PartNumber', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@
CONST	SEGMENT
??_C@_0BF@DMENANMJ@OtherIdentifyingInfo@ DB 'OtherIdentifyingInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FCOIALPI@HotSwappable@
CONST	SEGMENT
??_C@_0N@FCOIALPI@HotSwappable@ DB 'HotSwappable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCJNCHMP@HostingBoard@
CONST	SEGMENT
??_C@_0N@CCJNCHMP@HostingBoard@ DB 'HostingBoard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IBAMDCFI@Width@
CONST	SEGMENT
??_C@_05IBAMDCFI@Width@ DB 'Width', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODJMJFLN@Weight@
CONST	SEGMENT
??_C@_06ODJMJFLN@Weight@ DB 'Weight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCAKHJJK@Height@
CONST	SEGMENT
??_C@_06HCAKHJJK@Height@ DB 'Height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BOMFGPKE@Depth@
CONST	SEGMENT
??_C@_05BOMFGPKE@Depth@ DB 'Depth', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLLHAKAI@ConfigOptions@
CONST	SEGMENT
??_C@_0O@GLLHAKAI@ConfigOptions@ DB 'ConfigOptions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGFJPNPN@Version@
CONST	SEGMENT
??_C@_07NGFJPNPN@Version@ DB 'Version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NFIJOKEG@Model@
CONST	SEGMENT
??_C@_05NFIJOKEG@Model@ DB 'Model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07HMDPOHHF@Product@
CONST	SEGMENT
??_C@_07HMDPOHHF@Product@ DB 'Product', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PJHNOEGB@Tag@
CONST	SEGMENT
??_C@_03PJHNOEGB@Tag@ DB 'Tag', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FKIDHCEN@Win32_BaseBoard@
CONST	SEGMENT
??_C@_0BA@FKIDHCEN@Win32_BaseBoard@ DB 'Win32_BaseBoard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HADKHLAI@TimeOfLastReset@
CONST	SEGMENT
??_C@_0BA@HADKHLAI@TimeOfLastReset@ DB 'TimeOfLastReset', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKEHCAEI@StatusInfo@
CONST	SEGMENT
??_C@_0L@PKEHCAEI@StatusInfo@ DB 'StatusInfo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGDKHFME@Status@
CONST	SEGMENT
??_C@_06PGDKHFME@Status@ DB 'Status', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHPOAJCM@ProtocolSupported@
CONST	SEGMENT
??_C@_0BC@JHPOAJCM@ProtocolSupported@ DB 'ProtocolSupported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CFOPGMLH@PowerManagementSupported@
CONST	SEGMENT
??_C@_0BJ@CFOPGMLH@PowerManagementSupported@ DB 'PowerManagementSupported'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@
CONST	SEGMENT
??_C@_0BM@NFDEHNHA@PowerManagementCapabilities@ DB 'PowerManagementCapabi'
	DB	'lities', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JDLAPHJE@MaxNumberControlled@
CONST	SEGMENT
??_C@_0BE@JDLAPHJE@MaxNumberControlled@ DB 'MaxNumberControlled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NDKHIJAE@LastErrorCode@
CONST	SEGMENT
??_C@_0O@NDKHIJAE@LastErrorCode@ DB 'LastErrorCode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NBIJNNJJ@InstallDate@
CONST	SEGMENT
??_C@_0M@NBIJNNJJ@InstallDate@ DB 'InstallDate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KIDBLMK@ErrorDescription@
CONST	SEGMENT
??_C@_0BB@KIDBLMK@ErrorDescription@ DB 'ErrorDescription', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FJHLDHMG@ErrorCleared@
CONST	SEGMENT
??_C@_0N@FJHLDHMG@ErrorCleared@ DB 'ErrorCleared', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHKMKKDH@Description@
CONST	SEGMENT
??_C@_0M@OHKMKKDH@Description@ DB 'Description', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@
CONST	SEGMENT
??_C@_0BI@OBNCDCBF@ConfigManagerUserConfig@ DB 'ConfigManagerUserConfig', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@
CONST	SEGMENT
??_C@_0BH@JDEEEDCN@ConfigManagerErrorCode@ DB 'ConfigManagerErrorCode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJKFJLLK@Caption@
CONST	SEGMENT
??_C@_07OJKFJLLK@Caption@ DB 'Caption', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFGCECDI@Availability@
CONST	SEGMENT
??_C@_0N@MFGCECDI@Availability@ DB 'Availability', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBNLMPJO@Manufacturer@
CONST	SEGMENT
??_C@_0N@BBNLMPJO@Manufacturer@ DB 'Manufacturer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JLPEJKOE@DeviceID@
CONST	SEGMENT
??_C@_08JLPEJKOE@DeviceID@ DB 'DeviceID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHJKGII@PNPDeviceID@
CONST	SEGMENT
??_C@_0M@HHJKGII@PNPDeviceID@ DB 'PNPDeviceID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name@
CONST	SEGMENT
??_C@_04FABLJDN@Name@ DB 'Name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GIOJHHEG@Win32_1394Controller@
CONST	SEGMENT
??_C@_0BF@GIOJHHEG@Win32_1394Controller@ DB 'Win32_1394Controller', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NFANNNEC@UNKNOWN@
CONST	SEGMENT
??_C@_07NFANNNEC@UNKNOWN@ DB 'UNKNOWN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HMOFPNPP@HGST?0?5a?5Western?5Digital?5Company@
CONST	SEGMENT
??_C@_0CA@HMOFPNPP@HGST?0?5a?5Western?5Digital?5Company@ DB 'HGST, a West'
	DB	'ern Digital Company', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPADBEEC@Inhon?5Computer?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@FPADBEEC@Inhon?5Computer?5Co?4?0?5Ltd?4@ DB 'Inhon Computer Co.'
	DB	', Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBEJIPHO@MITACHI?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BC@EBEJIPHO@MITACHI?5CO?4?0?5LTD?4@ DB 'MITACHI CO., LTD.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EHDKCLMM@Morning?5Star?5Digital?5Connector?5@
CONST	SEGMENT
??_C@_0CJ@EHDKCLMM@Morning?5Star?5Digital?5Connector?5@ DB 'Morning Star '
	DB	'Digital Connector Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKPEFBBD@Broadway?5System?0?5Inc?4@
CONST	SEGMENT
??_C@_0BG@BKPEFBBD@Broadway?5System?0?5Inc?4@ DB 'Broadway System, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BKLIFGG@Integral?5Memory?5Plc?4@
CONST	SEGMENT
??_C@_0BF@BKLIFGG@Integral?5Memory?5Plc?4@ DB 'Integral Memory Plc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IPDEOKJG@Zhejiang?5Senda?5Electronics?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@IPDEOKJG@Zhejiang?5Senda?5Electronics?5Co?4?0@ DB 'Zhejiang Sen'
	DB	'da Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIHAOBJB@UNIREX?5CORPORATION@
CONST	SEGMENT
??_C@_0BD@LIHAOBJB@UNIREX?5CORPORATION@ DB 'UNIREX CORPORATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@INIEIBBC@BESTMEDIA?5CD?9Recordable?5GmbH?5?$CG?5@
CONST	SEGMENT
??_C@_0CG@INIEIBBC@BESTMEDIA?5CD?9Recordable?5GmbH?5?$CG?5@ DB 'BESTMEDIA'
	DB	' CD-Recordable GmbH & Co. KG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGJCNJFM@Basler?5AG@
CONST	SEGMENT
??_C@_09BGJCNJFM@Basler?5AG@ DB 'Basler AG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LEBIHPBN@Innovative?5Logic@
CONST	SEGMENT
??_C@_0BB@LEBIHPBN@Innovative?5Logic@ DB 'Innovative Logic', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HNELJFDJ@Shenzhen?5Yuwenfa?5Electronic?5Tec@
CONST	SEGMENT
??_C@_0DB@HNELJFDJ@Shenzhen?5Yuwenfa?5Electronic?5Tec@ DB 'Shenzhen Yuwen'
	DB	'fa Electronic Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PHCBCBDD@Electronics?5For?5Imaging?0?5Inc?4@
CONST	SEGMENT
??_C@_0BO@PHCBCBDD@Electronics?5For?5Imaging?0?5Inc?4@ DB 'Electronics Fo'
	DB	'r Imaging, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PHDNLNGC@Inno?5Audio?5?$CG?5Video?5?$CIHK?$CJ?5Limited@
CONST	SEGMENT
??_C@_0CA@PHDNLNGC@Inno?5Audio?5?$CG?5Video?5?$CIHK?$CJ?5Limited@ DB 'Inn'
	DB	'o Audio & Video (HK) Limited', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FNFDMCAN@JXT?5Precision?5Electronics?5Techn@
CONST	SEGMENT
??_C@_0CO@FNFDMCAN@JXT?5Precision?5Electronics?5Techn@ DB 'JXT Precision '
	DB	'Electronics Technical Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KCHFFECA@EISST?5Limited@
CONST	SEGMENT
??_C@_0O@KCHFFECA@EISST?5Limited@ DB 'EISST Limited', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPNGMFON@INTELLIGENT?5ENERGY?0?5LTD?4@
CONST	SEGMENT
??_C@_0BJ@FPNGMFON@INTELLIGENT?5ENERGY?0?5LTD?4@ DB 'INTELLIGENT ENERGY, '
	DB	'LTD.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HOIKDMEJ@Advanced?5Silicon?5SA@
CONST	SEGMENT
??_C@_0BE@HOIKDMEJ@Advanced?5Silicon?5SA@ DB 'Advanced Silicon SA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GLDMKJH@DongGuan?5HYX?5Industrial?5Co?4?0?5Lt@
CONST	SEGMENT
??_C@_0CC@GLDMKJH@DongGuan?5HYX?5Industrial?5Co?4?0?5Lt@ DB 'DongGuan HYX'
	DB	' Industrial Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BOLFLJP@RICOH?5IMAGING?5COMPANY?0?5LTD?4@
CONST	SEGMENT
??_C@_0BM@BOLFLJP@RICOH?5IMAGING?5COMPANY?0?5LTD?4@ DB 'RICOH IMAGING COM'
	DB	'PANY, LTD.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OAMKINAC@Dongguan?5Jinyue?5Electronics?5Co?4@
CONST	SEGMENT
??_C@_0CG@OAMKINAC@Dongguan?5Jinyue?5Electronics?5Co?4@ DB 'Dongguan Jiny'
	DB	'ue Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EJBKCNKI@Zhe?5Jiang?5Huasheng?5Technology?5C@
CONST	SEGMENT
??_C@_0CI@EJBKCNKI@Zhe?5Jiang?5Huasheng?5Technology?5C@ DB 'Zhe Jiang Hua'
	DB	'sheng Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DKIKJOEB@Corning?5Cable?5Systems?5LLC@
CONST	SEGMENT
??_C@_0BK@DKIKJOEB@Corning?5Cable?5Systems?5LLC@ DB 'Corning Cable System'
	DB	's LLC', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LHOCOHOF@DongGuan?5Elinke?5Industrial?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@LHOCOHOF@DongGuan?5Elinke?5Industrial?5Co?4?0@ DB 'DongGuan Eli'
	DB	'nke Industrial Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LNBMPCHG@Top?5Victory?5Investments?5Ltd?4?5?$CIH@
CONST	SEGMENT
??_C@_0CC@LNBMPCHG@Top?5Victory?5Investments?5Ltd?4?5?$CIH@ DB 'Top Victo'
	DB	'ry Investments Ltd. (HK)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GGHEMJJH@ALGOLTEK?0?5INC?4@
CONST	SEGMENT
??_C@_0P@GGHEMJJH@ALGOLTEK?0?5INC?4@ DB 'ALGOLTEK, INC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NLMAPGEN@Sequans?5Communications@
CONST	SEGMENT
??_C@_0BH@NLMAPGEN@Sequans?5Communications@ DB 'Sequans Communications', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CBMJJLAP@Dongguan?5Wisechamp?5Electronic?5C@
CONST	SEGMENT
??_C@_0CI@CBMJJLAP@Dongguan?5Wisechamp?5Electronic?5C@ DB 'Dongguan Wisec'
	DB	'hamp Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MHBLLANG@Weida?5Hi?9Tech?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BI@MHBLLANG@Weida?5Hi?9Tech?5Co?4?0?5Ltd?4@ DB 'Weida Hi-Tech Co.,'
	DB	' Ltd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NMMKCBIB@DongGuan?5LongTao?5Electronic?5Co?4@
CONST	SEGMENT
??_C@_0CG@NMMKCBIB@DongGuan?5LongTao?5Electronic?5Co?4@ DB 'DongGuan Long'
	DB	'Tao Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KMBODLJH@ASSA?5ABLOY?5AB@
CONST	SEGMENT
??_C@_0O@KMBODLJH@ASSA?5ABLOY?5AB@ DB 'ASSA ABLOY AB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PLHJJNHE@Norel?5Systems?5Ltd?4@
CONST	SEGMENT
??_C@_0BD@PLHJJNHE@Norel?5Systems?5Ltd?4@ DB 'Norel Systems Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FBCGPDBL@ShenZhen?5Hogend?5Precision?5Techn@
CONST	SEGMENT
??_C@_0CP@FBCGPDBL@ShenZhen?5Hogend?5Precision?5Techn@ DB 'ShenZhen Hogen'
	DB	'd Precision Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BNJPCKEF@TOP?5Exactitude?5Industry?5?$CIShenZh@
CONST	SEGMENT
??_C@_0CN@BNJPCKEF@TOP?5Exactitude?5Industry?5?$CIShenZh@ DB 'TOP Exactit'
	DB	'ude Industry (ShenZhen) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KGBBCJH@Chain?9In?5Electronic?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@KGBBCJH@Chain?9In?5Electronic?5Co?4?0?5Ltd?4@ DB 'Chain-In Elec'
	DB	'tronic Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ONHDIMLP@ZEN?5FACTORY?5GROUP?5?$CIASIA?$CJ?5LTD?4@
CONST	SEGMENT
??_C@_0BO@ONHDIMLP@ZEN?5FACTORY?5GROUP?5?$CIASIA?$CJ?5LTD?4@ DB 'ZEN FACT'
	DB	'ORY GROUP (ASIA) LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DEJKGIMK@Smith?5Micro?5Software?0?5Inc?4@
CONST	SEGMENT
??_C@_0BL@DEJKGIMK@Smith?5Micro?5Software?0?5Inc?4@ DB 'Smith Micro Softw'
	DB	'are, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMCNEDLC@Lytro?0?5Inc?4@
CONST	SEGMENT
??_C@_0M@NMCNEDLC@Lytro?0?5Inc?4@ DB 'Lytro, Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JOMBCIJH@Shenzhen?5Deren?5Electronic?5Co?4?0?5@
CONST	SEGMENT
??_C@_0CE@JOMBCIJH@Shenzhen?5Deren?5Electronic?5Co?4?0?5@ DB 'Shenzhen De'
	DB	'ren Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IDDOGDKP@Shenzhen?5Pangngai?5Industrial?5Co@
CONST	SEGMENT
??_C@_0CH@IDDOGDKP@Shenzhen?5Pangngai?5Industrial?5Co@ DB 'Shenzhen Pangn'
	DB	'gai Industrial Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFHJHDDG@SYNCONN?5INTERCONNECT?5INC?4@
CONST	SEGMENT
??_C@_0BK@CFHJHDDG@SYNCONN?5INTERCONNECT?5INC?4@ DB 'SYNCONN INTERCONNECT'
	DB	' INC.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EHAGJFEE@Fullconn?5Industry?5Inc?4@
CONST	SEGMENT
??_C@_0BH@EHAGJFEE@Fullconn?5Industry?5Inc?4@ DB 'Fullconn Industry Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BAFKLNDB@WuJiang?5XinYa?5Electronics?5Co?4?0?5@
CONST	SEGMENT
??_C@_0CE@BAFKLNDB@WuJiang?5XinYa?5Electronics?5Co?4?0?5@ DB 'WuJiang Xin'
	DB	'Ya Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FEINIIOM@Anton?1Bauer?0?5Inc?4@
CONST	SEGMENT
??_C@_0BC@FEINIIOM@Anton?1Bauer?0?5Inc?4@ DB 'Anton/Bauer, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LPJGBHEM@Velosti?5Technology?5Limited@
CONST	SEGMENT
??_C@_0BL@LPJGBHEM@Velosti?5Technology?5Limited@ DB 'Velosti Technology L'
	DB	'imited', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06HHAPBGEJ@BAANTO@
CONST	SEGMENT
??_C@_06HHAPBGEJ@BAANTO@ DB 'BAANTO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MIHCGNOI@Minebea?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BC@MIHCGNOI@Minebea?5Co?4?0?5Ltd?4@ DB 'Minebea Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PEDMBLOK@Dongguan?5City?5Qirui?5Electronics@
CONST	SEGMENT
??_C@_0CK@PEDMBLOK@Dongguan?5City?5Qirui?5Electronics@ DB 'Dongguan City '
	DB	'Qirui Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GMFHMCEF@The?5Silanna?5Group?5Pty?4?5Ltd?4@
CONST	SEGMENT
??_C@_0BM@GMFHMCEF@The?5Silanna?5Group?5Pty?4?5Ltd?4@ DB 'The Silanna Gro'
	DB	'up Pty. Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KJMMFBKI@Incasolution?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BH@KJMMFBKI@Incasolution?5Co?4?0?5Ltd?4@ DB 'Incasolution Co., Ltd'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNIKCMOM@INSIDE?5Secure@
CONST	SEGMENT
??_C@_0O@BNIKCMOM@INSIDE?5Secure@ DB 'INSIDE Secure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJBOGONI@ChuangYi?5Hardware?5Precision?5Mou@
CONST	SEGMENT
??_C@_0CN@EJBOGONI@ChuangYi?5Hardware?5Precision?5Mou@ DB 'ChuangYi Hardw'
	DB	'are Precision Mould Com., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CFJNEAJP@BitifEye?5Digital?5Test?5Solutions@
CONST	SEGMENT
??_C@_0CF@CFJNEAJP@BitifEye?5Digital?5Test?5Solutions@ DB 'BitifEye Digit'
	DB	'al Test Solutions GmbH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GCMJJPNA@DONGGUAN?5LICHENG?5ELECTRONICS?5CO@
CONST	SEGMENT
??_C@_0CH@GCMJJPNA@DONGGUAN?5LICHENG?5ELECTRONICS?5CO@ DB 'DONGGUAN LICHE'
	DB	'NG ELECTRONICS CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHNJGPJN@Marunix?5Electron?5Limited@
CONST	SEGMENT
??_C@_0BJ@OHNJGPJN@Marunix?5Electron?5Limited@ DB 'Marunix Electron Limit'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CBFBKCKO@IXT?5Systems?5International?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@CBFBKCKO@IXT?5Systems?5International?5Ltd?4@ DB 'IXT Systems In'
	DB	'ternational Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GJOKBILK@KangXiang?5Electronic?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@GJOKBILK@KangXiang?5Electronic?5Co?4?0?5Ltd?4@ DB 'KangXiang El'
	DB	'ectronic Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MLMJGOMM@Shenzhen?5Autone?9Tronic?5Technolo@
CONST	SEGMENT
??_C@_0CM@MLMJGOMM@Shenzhen?5Autone?9Tronic?5Technolo@ DB 'Shenzhen Auton'
	DB	'e-Tronic Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNELPEDJ@Zenverge?5Inc?4@
CONST	SEGMENT
??_C@_0O@DNELPEDJ@Zenverge?5Inc?4@ DB 'Zenverge Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GCGEMCFF@Tensorcom@
CONST	SEGMENT
??_C@_09GCGEMCFF@Tensorcom@ DB 'Tensorcom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LPLOPAA@Huawei?5Device?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BI@LPLOPAA@Huawei?5Device?5Co?4?0?5Ltd?4@ DB 'Huawei Device Co., L'
	DB	'td.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CONNOJEO@Avery?5Design?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BL@CONNOJEO@Avery?5Design?5Systems?0?5Inc?4@ DB 'Avery Design Syst'
	DB	'ems, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DNEMFNPO@Kunshan?5Jiahua?5Electronics?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@DNEMFNPO@Kunshan?5Jiahua?5Electronics?5Co?4?0@ DB 'Kunshan Jiah'
	DB	'ua Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJFFELIC@Miltope?5Corp?4@
CONST	SEGMENT
??_C@_0O@LJFFELIC@Miltope?5Corp?4@ DB 'Miltope Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PFEHLJC@Phase?5One?5A?1S@
CONST	SEGMENT
??_C@_0O@PFEHLJC@Phase?5One?5A?1S@ DB 'Phase One A/S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KOHELOKO@Karming?5Electronic?5?$CIShenzhen?$CJ?5C@
CONST	SEGMENT
??_C@_0CI@KOHELOKO@Karming?5Electronic?5?$CIShenzhen?$CJ?5C@ DB 'Karming '
	DB	'Electronic (Shenzhen) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JCNJIDNH@Motorola?5Mobility?5Inc?4@
CONST	SEGMENT
??_C@_0BH@JCNJIDNH@Motorola?5Mobility?5Inc?4@ DB 'Motorola Mobility Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LAOLKJDB@Trigence?5Semiconductor?0?5Inc?4@
CONST	SEGMENT
??_C@_0BN@LAOLKJDB@Trigence?5Semiconductor?0?5Inc?4@ DB 'Trigence Semicon'
	DB	'ductor, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JIBHMNOD@Hotron?5Precision?5Electronic?5Ind@
CONST	SEGMENT
??_C@_0CH@JIBHMNOD@Hotron?5Precision?5Electronic?5Ind@ DB 'Hotron Precisi'
	DB	'on Electronic Ind. Corp.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GPGEJOEG@Sun?5Fair?5Electric?5Wire?5?$CG?5Cable?5@
CONST	SEGMENT
??_C@_0CO@GPGEJOEG@Sun?5Fair?5Electric?5Wire?5?$CG?5Cable?5@ DB 'Sun Fair'
	DB	' Electric Wire & Cable (HK) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JFNFEMAF@Digital?5EMC?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BG@JFNFEMAF@Digital?5EMC?5Co?4?0?5Ltd?4@ DB 'Digital EMC Co., Ltd.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PEIOBOIA@Granite?5River?5Labs@
CONST	SEGMENT
??_C@_0BD@PEIOBOIA@Granite?5River?5Labs@ DB 'Granite River Labs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DJPOBBOH@T?9CONN?5PRECISION?5CORPORATION@
CONST	SEGMENT
??_C@_0BN@DJPOBBOH@T?9CONN?5PRECISION?5CORPORATION@ DB 'T-CONN PRECISION '
	DB	'CORPORATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FFGBANPN@Plugable?5Technologies@
CONST	SEGMENT
??_C@_0BG@FFGBANPN@Plugable?5Technologies@ DB 'Plugable Technologies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NEPAELKJ@Wiretek?5International?5Investmen@
CONST	SEGMENT
??_C@_0CG@NEPAELKJ@Wiretek?5International?5Investmen@ DB 'Wiretek Interna'
	DB	'tional Investment Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CHMCCAAM@3eYamaichi?5Electronics?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0CB@CHMCCAAM@3eYamaichi?5Electronics?5Co?4?0?5Ltd@ DB '3eYamaichi E'
	DB	'lectronics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BEMCGCHG@Shin?5Shin?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BE@BEMCGCHG@Shin?5Shin?5Co?4?0?5Ltd?4@ DB 'Shin Shin Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OHNMOHEM@Wuerth?9Elektronik?5eiSos?5GmbH?5?$CG?5@
CONST	SEGMENT
??_C@_0CG@OHNMOHEM@Wuerth?9Elektronik?5eiSos?5GmbH?5?$CG?5@ DB 'Wuerth-El'
	DB	'ektronik eiSos GmbH & Co. KG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FAJGPKNC@Compupack?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@FAJGPKNC@Compupack?5Technology?5Co?4?0?5Ltd?4@ DB 'Compupack Te'
	DB	'chnology Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PBMDMJMJ@Netcom?5Technology?5?$CIHK?$CJ?5Limited@
CONST	SEGMENT
??_C@_0BP@PBMDMJMJ@Netcom?5Technology?5?$CIHK?$CJ?5Limited@ DB 'Netcom Te'
	DB	'chnology (HK) Limited', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LAFBKCJH@Dongguan?5Teconn?5Electronics?5Tec@
CONST	SEGMENT
??_C@_0DB@LAFBKCJH@Dongguan?5Teconn?5Electronics?5Tec@ DB 'Dongguan Tecon'
	DB	'n Electronics Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPBIMIG@CalDigit@
CONST	SEGMENT
??_C@_08EPBIMIG@CalDigit@ DB 'CalDigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BAPBHHHN@TMC?1Allion?5Test?5Labs@
CONST	SEGMENT
??_C@_0BF@BAPBHHHN@TMC?1Allion?5Test?5Labs@ DB 'TMC/Allion Test Labs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BKHGEKPK@Transcend?5Information?0?5Inc?4@
CONST	SEGMENT
??_C@_0BM@BKHGEKPK@Transcend?5Information?0?5Inc?4@ DB 'Transcend Informa'
	DB	'tion, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FBCKNBLM@JVC?5KENWOOD?5Corporation@
CONST	SEGMENT
??_C@_0BI@FBCKNBLM@JVC?5KENWOOD?5Corporation@ DB 'JVC KENWOOD Corporation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LDDEGFID@Y?5Soft?5Corporation@
CONST	SEGMENT
??_C@_0BD@LDDEGFID@Y?5Soft?5Corporation@ DB 'Y Soft Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CNOJBLBI@Amphenol?5AssembleTech?5?$CIXiamen?$CJ?5@
CONST	SEGMENT
??_C@_0CJ@CNOJBLBI@Amphenol?5AssembleTech?5?$CIXiamen?$CJ?5@ DB 'Amphenol'
	DB	' AssembleTech (Xiamen) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LALHIFNG@Dong?5Guan?5City?5Wanhong?5Electric@
CONST	SEGMENT
??_C@_0CK@LALHIFNG@Dong?5Guan?5City?5Wanhong?5Electric@ DB 'Dong Guan Cit'
	DB	'y Wanhong Electric Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GAGJPPB@Shenzhen?5Linoya?5Electronic?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@GAGJPPB@Shenzhen?5Linoya?5Electronic?5Co?4?0@ DB 'Shenzhen Lino'
	DB	'ya Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBIKBMAL@VIA?5Labs?0?5Inc?4@
CONST	SEGMENT
??_C@_0P@GBIKBMAL@VIA?5Labs?0?5Inc?4@ DB 'VIA Labs, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DAENHNHN@XIMEA?5s?4r?4o?4@
CONST	SEGMENT
??_C@_0N@DAENHNHN@XIMEA?5s?4r?4o?4@ DB 'XIMEA s.r.o.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EMOPPBDG@Sumitomo?5Electric?5Ind?4?0?5Ltd?4?0?5O@
CONST	SEGMENT
??_C@_0DE@EMOPPBDG@Sumitomo?5Electric?5Ind?4?0?5Ltd?4?0?5O@ DB 'Sumitomo '
	DB	'Electric Ind., Ltd., Optical Comm. R&D Lab', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EIBNNPGD@FENGHUA?5KINGSUN?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BK@EIBNNPGD@FENGHUA?5KINGSUN?5CO?4?0?5LTD?4@ DB 'FENGHUA KINGSUN C'
	DB	'O., LTD.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MCDKIGNK@Shenzhen?5CARVE?5Electronics?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@MCDKIGNK@Shenzhen?5CARVE?5Electronics?5Co?4?0@ DB 'Shenzhen CAR'
	DB	'VE Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FNHFFJPK@Microconn?5Electronic?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@FNHFFJPK@Microconn?5Electronic?5Co?4?0?5Ltd?4@ DB 'Microconn El'
	DB	'ectronic Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CFCNDLPN@CE?5LINK?5LIMITED@
CONST	SEGMENT
??_C@_0BA@CFCNDLPN@CE?5LINK?5LIMITED@ DB 'CE LINK LIMITED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJLIGBFN@Luxshare?9ICT@
CONST	SEGMENT
??_C@_0N@JJLIGBFN@Luxshare?9ICT@ DB 'Luxshare-ICT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DJALMDKA@CESI?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BK@DJALMDKA@CESI?5Technology?5Co?4?0?5Ltd?4@ DB 'CESI Technology C'
	DB	'o., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OEPJLPBL@Unicorn?5Electronics?5Components?5@
CONST	SEGMENT
??_C@_0CJ@OEPJLPBL@Unicorn?5Electronics?5Components?5@ DB 'Unicorn Electr'
	DB	'onics Components Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FBHBCILE@Shenzhen?5Tronixin?5Electronics?5C@
CONST	SEGMENT
??_C@_0CI@FBHBCILE@Shenzhen?5Tronixin?5Electronics?5C@ DB 'Shenzhen Troni'
	DB	'xin Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PIIFGLBL@DETAS?5TECHNOLOGY?5LTD?4@
CONST	SEGMENT
??_C@_0BG@PIIFGLBL@DETAS?5TECHNOLOGY?5LTD?4@ DB 'DETAS TECHNOLOGY LTD.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DHGBCKNB@Freeport?5Resources?5Enterprises?5@
CONST	SEGMENT
??_C@_0CF@DHGBCKNB@Freeport?5Resources?5Enterprises?5@ DB 'Freeport Resou'
	DB	'rces Enterprises Corp.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GOBPPKNF@Belkin?5Electronic?5?$CIChangzhou?$CJ?5C@
CONST	SEGMENT
??_C@_0CI@GOBPPKNF@Belkin?5Electronic?5?$CIChangzhou?$CJ?5C@ DB 'Belkin E'
	DB	'lectronic (Changzhou) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJBLIGAM@D?9Link?5Corporation@
CONST	SEGMENT
??_C@_0BD@BJBLIGAM@D?9Link?5Corporation@ DB 'D-Link Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KONADFN@Changzhou?5Wujin?5BEST?5Electronic@
CONST	SEGMENT
??_C@_0DB@KONADFN@Changzhou?5Wujin?5BEST?5Electronic@ DB 'Changzhou Wujin'
	DB	' BEST Electronic Cables Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CAPPIABK@NIAN?5YEONG?5ENTERPRISE?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0CA@CAPPIABK@NIAN?5YEONG?5ENTERPRISE?5CO?4?0?5LTD?4@ DB 'NIAN YEONG'
	DB	' ENTERPRISE CO., LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMPBKEIC@NXP?5Semiconductors@
CONST	SEGMENT
??_C@_0BD@GMPBKEIC@NXP?5Semiconductors@ DB 'NXP Semiconductors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDFCKAEG@Unify?5GmbH?5?$CG?5Co?4?5KG@
CONST	SEGMENT
??_C@_0BE@KDFCKAEG@Unify?5GmbH?5?$CG?5Co?4?5KG@ DB 'Unify GmbH & Co. KG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EHEKJNGP@Owl?5Computing?5Technologies?0?5Inc@
CONST	SEGMENT
??_C@_0CB@EHEKJNGP@Owl?5Computing?5Technologies?0?5Inc@ DB 'Owl Computing'
	DB	' Technologies, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LPIGCLDE@Morning?5Star?5Industrial?5Co?4?0?5Lt@
CONST	SEGMENT
??_C@_0CC@LPIGCLDE@Morning?5Star?5Industrial?5Co?4?0?5Lt@ DB 'Morning Sta'
	DB	'r Industrial Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NHHBKKBH@Dongguan?5Goldconn?5Electronics?5C@
CONST	SEGMENT
??_C@_0CI@NHHBKKBH@Dongguan?5Goldconn?5Electronics?5C@ DB 'Dongguan Goldc'
	DB	'onn Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GGCBPHPK@Innostor?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BD@GGCBPHPK@Innostor?5Co?4?0?5Ltd?4@ DB 'Innostor Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MEDMJIF@Chang?5Yang?5Electronics?5Company?5@
CONST	SEGMENT
??_C@_0CE@MEDMJIF@Chang?5Yang?5Electronics?5Company?5@ DB 'Chang Yang Ele'
	DB	'ctronics Company Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LKIHKKAD@Cal?9Comp?5Electronics?5?$CG?5Communic@
CONST	SEGMENT
??_C@_0CG@LKIHKKAD@Cal?9Comp?5Electronics?5?$CG?5Communic@ DB 'Cal-Comp E'
	DB	'lectronics & Communications', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IALAEKLI@JIANGXI?5SHIP?5ELECTRONICS?5CO?4?0?5L@
CONST	SEGMENT
??_C@_0CD@IALAEKLI@JIANGXI?5SHIP?5ELECTRONICS?5CO?4?0?5L@ DB 'JIANGXI SHI'
	DB	'P ELECTRONICS CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LCFIOKDG@AIRTIES?5WIRELESS?5NETWORKS@
CONST	SEGMENT
??_C@_0BK@LCFIOKDG@AIRTIES?5WIRELESS?5NETWORKS@ DB 'AIRTIES WIRELESS NETW'
	DB	'ORKS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PIBOCPGJ@Gefen?5Inc?4@
CONST	SEGMENT
??_C@_0L@PIBOCPGJ@Gefen?5Inc?4@ DB 'Gefen Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IFPLLPOK@WIN?5WIN?5PRECISION?5INDUSTRIAL?5CO@
CONST	SEGMENT
??_C@_0CH@IFPLLPOK@WIN?5WIN?5PRECISION?5INDUSTRIAL?5CO@ DB 'WIN WIN PRECI'
	DB	'SION INDUSTRIAL CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BINCEHIC@Concraft?5Holding?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@BINCEHIC@Concraft?5Holding?5Co?4?0?5Ltd?4@ DB 'Concraft Holding'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EHNBGDFF@Other?5World?5Computing@
CONST	SEGMENT
??_C@_0BG@EHNBGDFF@Other?5World?5Computing@ DB 'Other World Computing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JAHIBMAB@HIBEST?5Electronic?5?$CIDongGuan?$CJ?5Co@
CONST	SEGMENT
??_C@_0CH@JAHIBMAB@HIBEST?5Electronic?5?$CIDongGuan?$CJ?5Co@ DB 'HIBEST E'
	DB	'lectronic (DongGuan) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OPAJPFGF@COMLINK?5ELECTRONICS?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BO@OPAJPFGF@COMLINK?5ELECTRONICS?5CO?4?0?5LTD?4@ DB 'COMLINK ELECT'
	DB	'RONICS CO., LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JAAJJDAF@Etron?5Technology?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@JAAJJDAF@Etron?5Technology?0?5Inc?4@ DB 'Etron Technology, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKOLJNN@HUNG?5TA?5H?4T?4ENTERPRISE?5CO?4?0?5LTD@
CONST	SEGMENT
??_C@_0CB@BKOLJNN@HUNG?5TA?5H?4T?4ENTERPRISE?5CO?4?0?5LTD@ DB 'HUNG TA H.'
	DB	'T.ENTERPRISE CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIIMMKIN@KOBIAN?5CANADA?5INC?4@
CONST	SEGMENT
??_C@_0BD@LIIMMKIN@KOBIAN?5CANADA?5INC?4@ DB 'KOBIAN CANADA INC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FEMBFAJG@Point?5Grey?5Research?5Inc?4@
CONST	SEGMENT
??_C@_0BJ@FEMBFAJG@Point?5Grey?5Research?5Inc?4@ DB 'Point Grey Research '
	DB	'Inc.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IHINPAOL@SHEN?5ZHEN?5FORMAN?5PRECISION?5INDU@
CONST	SEGMENT
??_C@_0CO@IHINPAOL@SHEN?5ZHEN?5FORMAN?5PRECISION?5INDU@ DB 'SHEN ZHEN FOR'
	DB	'MAN PRECISION INDUSTRY CO., LTD.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@INFLCDIC@Telecommunication?5Metrology?5Cen@
CONST	SEGMENT
??_C@_0CK@INFLCDIC@Telecommunication?5Metrology?5Cen@ DB 'Telecommunicati'
	DB	'on Metrology Center of MII', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BBLGIHKL@Actions?5Microelectronics?5Co?4?0?5L@
CONST	SEGMENT
??_C@_0CD@BBLGIHKL@Actions?5Microelectronics?5Co?4?0?5L@ DB 'Actions Micr'
	DB	'oelectronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NMLKIBDM@GDA?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@NMLKIBDM@GDA?5Technologies?0?5Inc?4@ DB 'GDA Technologies, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGHGGAJG@Document?5Capture?5Technologies?0?5@
CONST	SEGMENT
??_C@_0CE@EGHGGAJG@Document?5Capture?5Technologies?0?5@ DB 'Document Capt'
	DB	'ure Technologies, Inc.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FNCNBIIF@Parade?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BK@FNCNBIIF@Parade?5Technologies?0?5Inc?4@ DB 'Parade Technologies'
	DB	', Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IDOJMHNI@NINGBO?5SHUNSHENG?5COMMUNICATION?5@
CONST	SEGMENT
??_C@_0DD@IDOJMHNI@NINGBO?5SHUNSHENG?5COMMUNICATION?5@ DB 'NINGBO SHUNSHE'
	DB	'NG COMMUNICATION APPARATUS CO., LTD.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EKHHMHEC@Shenzhen?5My?9Power?5Technology?5Co@
CONST	SEGMENT
??_C@_0CH@EKHHMHEC@Shenzhen?5My?9Power?5Technology?5Co@ DB 'Shenzhen My-P'
	DB	'ower Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IMGLKMI@Yueqing?5Changling?5Electronic?5In@
CONST	SEGMENT
??_C@_0DE@IMGLKMI@Yueqing?5Changling?5Electronic?5In@ DB 'Yueqing Changli'
	DB	'ng Electronic Instrument Corp., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NKBOOFNF@Walta?5Electronic?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@NKBOOFNF@Walta?5Electronic?5Co?4?0?5Ltd?4@ DB 'Walta Electronic'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MMCBELAO@QIXING?5INDUSTRIAL?5?$CIHK?$CJ?5CO?4@
CONST	SEGMENT
??_C@_0BL@MMCBELAO@QIXING?5INDUSTRIAL?5?$CIHK?$CJ?5CO?4@ DB 'QIXING INDUS'
	DB	'TRIAL (HK) CO.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HAMMCKPN@Fresco?5Logic?5Inc?4@
CONST	SEGMENT
??_C@_0BC@HAMMCKPN@Fresco?5Logic?5Inc?4@ DB 'Fresco Logic Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EEHMEIJP@Pegatron?5Corporation@
CONST	SEGMENT
??_C@_0BF@EEHMEIJP@Pegatron?5Corporation@ DB 'Pegatron Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KIFIHBOP@Qisda?5Corporation@
CONST	SEGMENT
??_C@_0BC@KIFIHBOP@Qisda?5Corporation@ DB 'Qisda Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJOGFDJ@DRAGON?5JOY?5LIMITED@
CONST	SEGMENT
??_C@_0BD@JJOGFDJ@DRAGON?5JOY?5LIMITED@ DB 'DRAGON JOY LIMITED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GDMPIAIK@Horng?5Tong?5Enterprise?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@GDMPIAIK@Horng?5Tong?5Enterprise?5Co?4?0?5Ltd?4@ DB 'Horng Tong'
	DB	' Enterprise Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GIIFDIFG@Johnson?5Controls?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@GIIFDIFG@Johnson?5Controls?0?5Inc?4@ DB 'Johnson Controls, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OJLMBANN@NINGBO?5HENTEK?5DRAGON?5ELECTRONIC@
CONST	SEGMENT
??_C@_0CL@OJLMBANN@NINGBO?5HENTEK?5DRAGON?5ELECTRONIC@ DB 'NINGBO HENTEK '
	DB	'DRAGON ELECTRONICS CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BKKOBFJG@Telecommunications?5Technology?5A@
CONST	SEGMENT
??_C@_0DA@BKKOBFJG@Telecommunications?5Technology?5A@ DB 'Telecommunicati'
	DB	'ons Technology Association (TTA)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EIGDHDFJ@OPEX?5CORPORATION@
CONST	SEGMENT
??_C@_0BB@EIGDHDFJ@OPEX?5CORPORATION@ DB 'OPEX CORPORATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CHCFPHFA@Aces?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@CHCFPHFA@Aces?5Electronics?5Co?4?0?5Ltd?4@ DB 'Aces Electronics'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BICMBKIN@LEGRAND?5FRANCE@
CONST	SEGMENT
??_C@_0P@BICMBKIN@LEGRAND?5FRANCE@ DB 'LEGRAND FRANCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GEGPHPDK@ALPINE?5ELECTRONICS?0?5INC?4@
CONST	SEGMENT
??_C@_0BJ@GEGPHPDK@ALPINE?5ELECTRONICS?0?5INC?4@ DB 'ALPINE ELECTRONICS, '
	DB	'INC.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PPLCBMMB@Philips?5?$CG?5Lite?9ON?5Digital?5Solut@
CONST	SEGMENT
??_C@_0DA@PPLCBMMB@Philips?5?$CG?5Lite?9ON?5Digital?5Solut@ DB 'Philips &'
	DB	' Lite-ON Digital Solutions Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCHINJIL@NONIN?5MEDICAL?5INC?4@
CONST	SEGMENT
??_C@_0BD@DCHINJIL@NONIN?5MEDICAL?5INC?4@ DB 'NONIN MEDICAL INC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PDBDCLGF@LS?5Mtron@
CONST	SEGMENT
??_C@_08PDBDCLGF@LS?5Mtron@ DB 'LS Mtron', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEFGPOJP@SHENZHEN?5DNS?5INDUSTRIES?5CO?4?0?5LT@
CONST	SEGMENT
??_C@_0CC@GEFGPOJP@SHENZHEN?5DNS?5INDUSTRIES?5CO?4?0?5LT@ DB 'SHENZHEN DN'
	DB	'S INDUSTRIES CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IHAPHGGJ@Lanterra?5Industrial?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@IHAPHGGJ@Lanterra?5Industrial?5Co?4?0?5Ltd?4@ DB 'Lanterra Indu'
	DB	'strial Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KIMIGBPK@Orient?5Semiconductor?5Electronic@
CONST	SEGMENT
??_C@_0CH@KIMIGBPK@Orient?5Semiconductor?5Electronic@ DB 'Orient Semicond'
	DB	'uctor Electronics, Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFOIMFJ@Sunplus?5Innovation?5Technology?5I@
CONST	SEGMENT
??_C@_0CD@HFOIMFJ@Sunplus?5Innovation?5Technology?5I@ DB 'Sunplus Innovat'
	DB	'ion Technology Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FCJOHAEE@Contac?5Cable?5Industrial?5Limited@
CONST	SEGMENT
??_C@_0CA@FCJOHAEE@Contac?5Cable?5Industrial?5Limited@ DB 'Contac Cable I'
	DB	'ndustrial Limited', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JGHIOJAI@Ford?5Motor?5Co?4@
CONST	SEGMENT
??_C@_0P@JGHIOJAI@Ford?5Motor?5Co?4@ DB 'Ford Motor Co.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IHCMPCEB@Shenzhen?5Yuanchuan?5Electronic@
CONST	SEGMENT
??_C@_0BO@IHCMPCEB@Shenzhen?5Yuanchuan?5Electronic@ DB 'Shenzhen Yuanchua'
	DB	'n Electronic', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IPLHGMF@Amlogic?0?5Inc?4@
CONST	SEGMENT
??_C@_0O@IPLHGMF@Amlogic?0?5Inc?4@ DB 'Amlogic, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GNFBMNPP@ShenMing?5Electron?5?$CIDong?5Guan?$CJ?5C@
CONST	SEGMENT
??_C@_0CI@GNFBMNPP@ShenMing?5Electron?5?$CIDong?5Guan?$CJ?5C@ DB 'ShenMin'
	DB	'g Electron (Dong Guan) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EOOOBNLE@The?5Hong?5Kong?5Standards?5and?5Tes@
CONST	SEGMENT
??_C@_0DA@EOOOBNLE@The?5Hong?5Kong?5Standards?5and?5Tes@ DB 'The Hong Kon'
	DB	'g Standards and Testing Centre Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ODKKJGBD@Plastron?5Precision?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@ODKKJGBD@Plastron?5Precision?5Co?4?0?5Ltd?4@ DB 'Plastron Preci'
	DB	'sion Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DPNOIOGL@ViXS?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BD@DPNOIOGL@ViXS?5Systems?0?5Inc?4@ DB 'ViXS Systems, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BAHHJBOM@Octekconn?5Incorporation@
CONST	SEGMENT
??_C@_0BI@BAHHJBOM@Octekconn?5Incorporation@ DB 'Octekconn Incorporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KCEJLGKF@SHEN?5ZHEN?5REX?5TECHNOLOGY?5CO?4?0?5L@
CONST	SEGMENT
??_C@_0CD@KCEJLGKF@SHEN?5ZHEN?5REX?5TECHNOLOGY?5CO?4?0?5L@ DB 'SHEN ZHEN '
	DB	'REX TECHNOLOGY CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ENEIOO@High?5Top?5Precision?5Electronic?5C@
CONST	SEGMENT
??_C@_0CI@ENEIOO@High?5Top?5Precision?5Electronic?5C@ DB 'High Top Precis'
	DB	'ion Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BNPJBJHO@Salcomp?5Plc@
CONST	SEGMENT
??_C@_0M@BNPJBJHO@Salcomp?5Plc@ DB 'Salcomp Plc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EENODCNA@Johnson?5Component?5?$CG?5Equipments?5@
CONST	SEGMENT
??_C@_0CJ@EENODCNA@Johnson?5Component?5?$CG?5Equipments?5@ DB 'Johnson Co'
	DB	'mponent & Equipments Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FEGEHHGG@Asia?5Tai?5Technology?5?$CIDongguan?$CJ?5@
CONST	SEGMENT
??_C@_0CJ@FEGEHHGG@Asia?5Tai?5Technology?5?$CIDongguan?$CJ?5@ DB 'Asia Ta'
	DB	'i Technology (Dongguan) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GPGHJPOJ@Leica?5Camera?5AG@
CONST	SEGMENT
??_C@_0BA@GPGHJPOJ@Leica?5Camera?5AG@ DB 'Leica Camera AG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KBMPMKDN@SGS?5Taiwan?5Ltd?4@
CONST	SEGMENT
??_C@_0BA@KBMPMKDN@SGS?5Taiwan?5Ltd?4@ DB 'SGS Taiwan Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HJFKHBGL@Simula?5Technology?5Inc?4@
CONST	SEGMENT
??_C@_0BH@HJFKHBGL@Simula?5Technology?5Inc?4@ DB 'Simula Technology Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GMHKDAOP@Proconn?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@GMHKDAOP@Proconn?5Technology?5Co?4?0?5Ltd?4@ DB 'Proconn Techno'
	DB	'logy Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IOFCBCHK@Bayer?5Health?5Care?5LLC@
CONST	SEGMENT
??_C@_0BG@IOFCBCHK@Bayer?5Health?5Care?5LLC@ DB 'Bayer Health Care LLC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IBCFPAGK@Global?5Unichip?5Corp?4@
CONST	SEGMENT
??_C@_0BF@IBCFPAGK@Global?5Unichip?5Corp?4@ DB 'Global Unichip Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KAKHDDLA@TERMINUS?5TECHNOLOGY?5INC?4@
CONST	SEGMENT
??_C@_0BJ@KAKHDDLA@TERMINUS?5TECHNOLOGY?5INC?4@ DB 'TERMINUS TECHNOLOGY I'
	DB	'NC.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EKBPAFBH@Topdisk?5Technology?5Limited@
CONST	SEGMENT
??_C@_0BL@EKBPAFBH@Topdisk?5Technology?5Limited@ DB 'Topdisk Technology L'
	DB	'imited', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPAGGINC@Astec?5America@
CONST	SEGMENT
??_C@_0O@OPAGGINC@Astec?5America@ DB 'Astec America', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PPNCKFLJ@Amphenol?5East?5Asia?5Ltd?4@
CONST	SEGMENT
??_C@_0BI@PPNCKFLJ@Amphenol?5East?5Asia?5Ltd?4@ DB 'Amphenol East Asia Lt'
	DB	'd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BIONMJOM@USB?9IF?5non?9workshop@
CONST	SEGMENT
??_C@_0BE@BIONMJOM@USB?9IF?5non?9workshop@ DB 'USB-IF non-workshop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PPEHNAPN@Best?5Buy?5China?5Ltd?4@
CONST	SEGMENT
??_C@_0BE@PPEHNAPN@Best?5Buy?5China?5Ltd?4@ DB 'Best Buy China Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GONBANIC@Pak?5Heng?5Technology?5?$CIShenzhen?$CJ?5@
CONST	SEGMENT
??_C@_0CJ@GONBANIC@Pak?5Heng?5Technology?5?$CIShenzhen?$CJ?5@ DB 'Pak Hen'
	DB	'g Technology (Shenzhen) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HAKCLNCA@Industrial?5Technology?5Research?5@
CONST	SEGMENT
??_C@_0CJ@HAKCLNCA@Industrial?5Technology?5Research?5@ DB 'Industrial Tec'
	DB	'hnology Research Institute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LGPAAFDD@Dexxon?5Data?5Media@
CONST	SEGMENT
??_C@_0BC@LGPAAFDD@Dexxon?5Data?5Media@ DB 'Dexxon Data Media', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EPIBIIDM@Nuconn?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BI@EPIBIIDM@Nuconn?5Technology?5Corp?4@ DB 'Nuconn Technology Corp'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PPNLBENA@BIOS?5Corporation@
CONST	SEGMENT
??_C@_0BB@PPNLBENA@BIOS?5Corporation@ DB 'BIOS Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHAGPIBB@Lab126@
CONST	SEGMENT
??_C@_06CHAGPIBB@Lab126@ DB 'Lab126', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PCAKKDFD@Irisguard?5UK?5Ltd@
CONST	SEGMENT
??_C@_0BB@PCAKKDFD@Irisguard?5UK?5Ltd@ DB 'Irisguard UK Ltd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FJMLIAEB@Ningbo?5Broad?5Telecommunication?5@
CONST	SEGMENT
??_C@_0CJ@FJMLIAEB@Ningbo?5Broad?5Telecommunication?5@ DB 'Ningbo Broad T'
	DB	'elecommunication Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NLNPHLHC@Shenzhen?5Xianhe?5Technology?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@NLNPHLHC@Shenzhen?5Xianhe?5Technology?5Co?4?0@ DB 'Shenzhen Xia'
	DB	'nhe Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FNMFPLIK@Nordic?5Semiconductor?5ASA@
CONST	SEGMENT
??_C@_0BJ@FNMFPLIK@Nordic?5Semiconductor?5ASA@ DB 'Nordic Semiconductor A'
	DB	'SA', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DABKNPLD@Fitilink?5Integrated?5Technology?0@
CONST	SEGMENT
??_C@_0CF@DABKNPLD@Fitilink?5Integrated?5Technology?0@ DB 'Fitilink Integ'
	DB	'rated Technology, Inc.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@INPJKDFM@Google?5Inc?4@
CONST	SEGMENT
??_C@_0M@INPJKDFM@Google?5Inc?4@ DB 'Google Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBKKPCPF@Linkiss?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BC@HBKKPCPF@Linkiss?5Co?4?0?5Ltd?4@ DB 'Linkiss Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MMEONNIC@Galaxy?5Far?5East?5Corp@
CONST	SEGMENT
??_C@_0BF@MMEONNIC@Galaxy?5Far?5East?5Corp@ DB 'Galaxy Far East Corp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DPMJHMBK@Gwo?5Jinn?5Industries?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@DPMJHMBK@Gwo?5Jinn?5Industries?5Co?4?0?5Ltd?4@ DB 'Gwo Jinn Ind'
	DB	'ustries Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KAKIFJIN@Dongguan?5YuQiu?5Electronics?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@KAKIFJIN@Dongguan?5YuQiu?5Electronics?5Co?4?0@ DB 'Dongguan YuQ'
	DB	'iu Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGMLMAAK@K?4K?4?5Rocky@
CONST	SEGMENT
??_C@_0L@IGMLMAAK@K?4K?4?5Rocky@ DB 'K.K. Rocky', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOFPOMJG@Lenovo@
CONST	SEGMENT
??_C@_06EOFPOMJG@Lenovo@ DB 'Lenovo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PLILAAEO@DisplayLink?5?$CIUK?$CJ?5Ltd?4@
CONST	SEGMENT
??_C@_0BG@PLILAAEO@DisplayLink?5?$CIUK?$CJ?5Ltd?4@ DB 'DisplayLink (UK) L'
	DB	'td.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FKGCAAGK@Hip?5Hing?5Cable?5?$CG?5Plug?5Mfy?4?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@FKGCAAGK@Hip?5Hing?5Cable?5?$CG?5Plug?5Mfy?4?5Ltd?4@ DB 'Hip Hi'
	DB	'ng Cable & Plug Mfy. Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@DPFEGAEM@Dongguan?5Yangming?5Precision?5of?5@
CONST	SEGMENT
??_C@_0DI@DPFEGAEM@Dongguan?5Yangming?5Precision?5of?5@ DB 'Dongguan Yang'
	DB	'ming Precision of Plastic Metal Elec Co Lt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GLPFKNO@ShenZhen?5Litkconn?5Technology?5Co@
CONST	SEGMENT
??_C@_0CH@GLPFKNO@ShenZhen?5Litkconn?5Technology?5Co@ DB 'ShenZhen Litkco'
	DB	'nn Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PDCKJENN@Spreadtrum?5Communications?5Inc?4@
CONST	SEGMENT
??_C@_0BP@PDCKJENN@Spreadtrum?5Communications?5Inc?4@ DB 'Spreadtrum Comm'
	DB	'unications Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MGLGHCII@System?5Level?5Solutions?0?5Inc?4@
CONST	SEGMENT
??_C@_0BN@MGLGHCII@System?5Level?5Solutions?0?5Inc?4@ DB 'System Level So'
	DB	'lutions, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KBPLCNPO@Shenzhen?5Alex?5Connector?5Co?4?0?5Lt@
CONST	SEGMENT
??_C@_0CC@KBPLCNPO@Shenzhen?5Alex?5Connector?5Co?4?0?5Lt@ DB 'Shenzhen Al'
	DB	'ex Connector Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LLHADAIP@UD?5electronic?5corp?4@
CONST	SEGMENT
??_C@_0BE@LLHADAIP@UD?5electronic?5corp?4@ DB 'UD electronic corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EFCFBFPB@ASMedia?5Technology?5Inc?4@
CONST	SEGMENT
??_C@_0BI@EFCFBFPB@ASMedia?5Technology?5Inc?4@ DB 'ASMedia Technology Inc'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BACBMICM@MQP?5Electronics?5Ltd?4@
CONST	SEGMENT
??_C@_0BF@BACBMICM@MQP?5Electronics?5Ltd?4@ DB 'MQP Electronics Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LFEKPOAD@Roche?5Diagnostics@
CONST	SEGMENT
??_C@_0BC@LFEKPOAD@Roche?5Diagnostics@ DB 'Roche Diagnostics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MBCLBNK@CANON?5IMAGING?5SYSTEMS?5INC?4@
CONST	SEGMENT
??_C@_0BL@MBCLBNK@CANON?5IMAGING?5SYSTEMS?5INC?4@ DB 'CANON IMAGING SYSTE'
	DB	'MS INC.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EKGKEMKL@silex?5technology?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@EKGKEMKL@silex?5technology?0?5Inc?4@ DB 'silex technology, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GHEMOGNO@Dongguan?5ChingLung?5Wire?5?$CG?5Cable@
CONST	SEGMENT
??_C@_0CK@GHEMOGNO@Dongguan?5ChingLung?5Wire?5?$CG?5Cable@ DB 'Dongguan C'
	DB	'hingLung Wire & Cable Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LPNLCPKP@Shenzhen?5Zhengerya?5Technology?5C@
CONST	SEGMENT
??_C@_0CI@LPNLCPKP@Shenzhen?5Zhengerya?5Technology?5C@ DB 'Shenzhen Zheng'
	DB	'erya Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OMFDOLIG@Total?5Phase@
CONST	SEGMENT
??_C@_0M@OMFDOLIG@Total?5Phase@ DB 'Total Phase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CCKIBDCK@HongLin?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@CCKIBDCK@HongLin?5Electronics?5Co?4?0?5Ltd?4@ DB 'HongLin Elect'
	DB	'ronics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GNFMIBKN@Soft?5DB?5Inc?4@
CONST	SEGMENT
??_C@_0N@GNFMIBKN@Soft?5DB?5Inc?4@ DB 'Soft DB Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DGDFLKMM@Samtec@
CONST	SEGMENT
??_C@_06DGDFLKMM@Samtec@ DB 'Samtec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FIJNAGLJ@Seong?5Ji?5Industrial?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@FIJNAGLJ@Seong?5Ji?5Industrial?5Co?4?0?5Ltd?4@ DB 'Seong Ji Ind'
	DB	'ustrial Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HKNGFKOP@Apexone?5Microelectronics?5Inc?4@
CONST	SEGMENT
??_C@_0BO@HKNGFKOP@Apexone?5Microelectronics?5Inc?4@ DB 'Apexone Microele'
	DB	'ctronics Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HBACFJJO@Shen?5Zhen?5Teamspower?5Electronic@
CONST	SEGMENT
??_C@_0CL@HBACFJJO@Shen?5Zhen?5Teamspower?5Electronic@ DB 'Shen Zhen Team'
	DB	'spower Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KPCEMMAE@Freescale?5Semiconductor?0?5Inc?4@
CONST	SEGMENT
??_C@_0BO@KPCEMMAE@Freescale?5Semiconductor?0?5Inc?4@ DB 'Freescale Semic'
	DB	'onductor, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@PGJPGLLG@Kunshan?5Guoji?5Electronics?5Co?4?0?5@
CONST	SEGMENT
??_C@_0CE@PGJPGLLG@Kunshan?5Guoji?5Electronics?5Co?4?0?5@ DB 'Kunshan Guo'
	DB	'ji Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MGGPMLNL@Palconn?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@MGGPMLNL@Palconn?5Technology?5Co?4?0?5Ltd?4@ DB 'Palconn Techno'
	DB	'logy Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PJFBNPPK@ALLTOP?5TECHNOLOGY?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BM@PJFBNPPK@ALLTOP?5TECHNOLOGY?5CO?4?0?5LTD?4@ DB 'ALLTOP TECHNOLO'
	DB	'GY CO., LTD.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MLLCLJKN@Sunf?5Pu?5Technology?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0BM@MLLCLJKN@Sunf?5Pu?5Technology?5Co?4?0?5Ltd@ DB 'Sunf Pu Technol'
	DB	'ogy Co., Ltd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCLHJFIN@D?5?$CG?5M?5Holdings?0?5Inc?4@
CONST	SEGMENT
??_C@_0BF@KCLHJFIN@D?5?$CG?5M?5Holdings?0?5Inc?4@ DB 'D & M Holdings, Inc'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PJGLCGBH@Rapid?5Conn?0?5Connect?5County?5Hold@
CONST	SEGMENT
??_C@_0CI@PJGLCGBH@Rapid?5Conn?0?5Connect?5County?5Hold@ DB 'Rapid Conn, '
	DB	'Connect County Holdings Bhd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FDFFBPKH@PNY?5Technologies?5Inc?4@
CONST	SEGMENT
??_C@_0BG@FDFFBPKH@PNY?5Technologies?5Inc?4@ DB 'PNY Technologies Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PJAMMHJM@Phihong?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@PJAMMHJM@Phihong?5Technology?5Co?4?0?5Ltd?4@ DB 'Phihong Techno'
	DB	'logy Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KFFNHPKK@HLDS?5?$CIHitachi?9LG?5Data?5Storage?0?5@
CONST	SEGMENT
??_C@_0CF@KFFNHPKK@HLDS?5?$CIHitachi?9LG?5Data?5Storage?0?5@ DB 'HLDS (Hi'
	DB	'tachi-LG Data Storage, Inc.)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NNBEAIKI@JMicron?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BJ@NNBEAIKI@JMicron?5Technology?5Corp?4@ DB 'JMicron Technology Co'
	DB	'rp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NFMNNPJJ@VeriSilicon?5Holdings?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@NFMNNPJJ@VeriSilicon?5Holdings?5Co?4?0?5Ltd?4@ DB 'VeriSilicon '
	DB	'Holdings Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MEIKBKHJ@Skymedi?5Corporation@
CONST	SEGMENT
??_C@_0BE@MEIKBKHJ@Skymedi?5Corporation@ DB 'Skymedi Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HKBKGGAL@Ellisys@
CONST	SEGMENT
??_C@_07HKBKGGAL@Ellisys@ DB 'Ellisys', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OBOFFJMJ@MOAI?5ELECTRONICS?5CORPORATION@
CONST	SEGMENT
??_C@_0BN@OBOFFJMJ@MOAI?5ELECTRONICS?5CORPORATION@ DB 'MOAI ELECTRONICS C'
	DB	'ORPORATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNFIEHCE@StarTech?4com?5Ltd?4@
CONST	SEGMENT
??_C@_0BC@LNFIEHCE@StarTech?4com?5Ltd?4@ DB 'StarTech.com Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@POKLDLPA@ATP?5Electronics?5Inc?4@
CONST	SEGMENT
??_C@_0BF@POKLDLPA@ATP?5Electronics?5Inc?4@ DB 'ATP Electronics Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GIDLPKMM@CTK?5Corporation@
CONST	SEGMENT
??_C@_0BA@GIDLPKMM@CTK?5Corporation@ DB 'CTK Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BDFMJCOJ@Panstrong?5Company?5Ltd?4@
CONST	SEGMENT
??_C@_0BH@BDFMJCOJ@Panstrong?5Company?5Ltd?4@ DB 'Panstrong Company Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JLOFKNJM@EVATRONIX?5SA@
CONST	SEGMENT
??_C@_0N@JLOFKNJM@EVATRONIX?5SA@ DB 'EVATRONIX SA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EJBEDMD@DSP?5Group?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BA@EJBEDMD@DSP?5Group?0?5Ltd?4@ DB 'DSP Group, Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KIAEGNEO@Sensor?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BM@KIAEGNEO@Sensor?5Technology?5Co?4?0?5Ltd?4@ DB 'Sensor Technolo'
	DB	'gy Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KECIKNAF@ABILITY?5ENTERPRISE?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BN@KECIKNAF@ABILITY?5ENTERPRISE?5CO?4?0?5LTD?4@ DB 'ABILITY ENTERP'
	DB	'RISE CO., LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBAJJPHC@Telechips?0?5Inc?4@
CONST	SEGMENT
??_C@_0BA@EBAJJPHC@Telechips?0?5Inc?4@ DB 'Telechips, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PODMPDKE@Phison?5Electronics?5Corp?4@
CONST	SEGMENT
??_C@_0BJ@PODMPDKE@Phison?5Electronics?5Corp?4@ DB 'Phison Electronics Co'
	DB	'rp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MJPGJJIB@Initio?5Corporation@
CONST	SEGMENT
??_C@_0BD@MJPGJJIB@Initio?5Corporation@ DB 'Initio Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EADKLFFK@ALEREON?0?5INC?4@
CONST	SEGMENT
??_C@_0O@EADKLFFK@ALEREON?0?5INC?4@ DB 'ALEREON, INC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BNPLLCII@AzureWave?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BN@BNPLLCII@AzureWave?5Technologies?0?5Inc?4@ DB 'AzureWave Techno'
	DB	'logies, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BGIJPEKA@JyeTai?5Precision?5Industrial?5Co?4@
CONST	SEGMENT
??_C@_0CG@BGIJPEKA@JyeTai?5Precision?5Industrial?5Co?4@ DB 'JyeTai Precis'
	DB	'ion Industrial Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DKMEKHIM@Pericom?5Semiconductor?5Corp?4@
CONST	SEGMENT
??_C@_0BM@DKMEKHIM@Pericom?5Semiconductor?5Corp?4@ DB 'Pericom Semiconduc'
	DB	'tor Corp.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPAHGEJP@Swissbit?5AG@
CONST	SEGMENT
??_C@_0M@IPAHGEJP@Swissbit?5AG@ DB 'Swissbit AG', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ODBMNHOP@Katsuragawa?5Electric?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@ODBMNHOP@Katsuragawa?5Electric?5Co?4?0?5Ltd?4@ DB 'Katsuragawa '
	DB	'Electric Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FPEFMCEM@Konica?5Minolta?0?5Inc?4@
CONST	SEGMENT
??_C@_0BF@FPEFMCEM@Konica?5Minolta?0?5Inc?4@ DB 'Konica Minolta, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DKNOJINI@Better?5Holdings?5?$CIHK?$CJ?5Limited@
CONST	SEGMENT
??_C@_0BN@DKNOJINI@Better?5Holdings?5?$CIHK?$CJ?5Limited@ DB 'Better Hold'
	DB	'ings (HK) Limited', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JPNNFCKE@LINE?5TECH?5INDUSTRIAL?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BP@JPNNFCKE@LINE?5TECH?5INDUSTRIAL?5CO?4?0?5LTD?4@ DB 'LINE TECH I'
	DB	'NDUSTRIAL CO., LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OPCIAOPO@Zhejiang?5Xinya?5Electronic?5Techn@
CONST	SEGMENT
??_C@_0CP@OPCIAOPO@Zhejiang?5Xinya?5Electronic?5Techn@ DB 'Zhejiang Xinya'
	DB	' Electronic Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JGPGOHBM@Honey?5Bee?5?$CIHong?5Kong?$CJ?5Limited@
CONST	SEGMENT
??_C@_0BO@JGPGOHBM@Honey?5Bee?5?$CIHong?5Kong?$CJ?5Limited@ DB 'Honey Bee'
	DB	' (Hong Kong) Limited', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CDINJBKA@RISO?5KAGAKU?5CORP?4@
CONST	SEGMENT
??_C@_0BC@CDINJBKA@RISO?5KAGAKU?5CORP?4@ DB 'RISO KAGAKU CORP.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FDHCJPEM@MARVELL?5SEMICONDUCTOR?0?5INC?4@
CONST	SEGMENT
??_C@_0BM@FDHCJPEM@MARVELL?5SEMICONDUCTOR?0?5INC?4@ DB 'MARVELL SEMICONDU'
	DB	'CTOR, INC.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HPCCHOFJ@Bel?5Stewart@
CONST	SEGMENT
??_C@_0M@HPCCHOFJ@Bel?5Stewart@ DB 'Bel Stewart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BANJHMOB@Aristocrat?5Technologies@
CONST	SEGMENT
??_C@_0BI@BANJHMOB@Aristocrat?5Technologies@ DB 'Aristocrat Technologies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FCGNNKPJ@ADATA?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@FCGNNKPJ@ADATA?5Technology?5Co?4?0?5Ltd?4@ DB 'ADATA Technology'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKGDFIOD@NYKO?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BI@KKGDFIOD@NYKO?5Technologies?0?5Inc?4@ DB 'NYKO Technologies, In'
	DB	'c.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MNCEAPFD@SKYCABLE?5ENTERPRISE?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BO@MNCEAPFD@SKYCABLE?5ENTERPRISE?5CO?4?0?5LTD?4@ DB 'SKYCABLE ENTE'
	DB	'RPRISE CO., LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HFAICOFB@ATECH?5FLASH?5TECHNOLOGY@
CONST	SEGMENT
??_C@_0BH@HFAICOFB@ATECH?5FLASH?5TECHNOLOGY@ DB 'ATECH FLASH TECHNOLOGY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LNLMLHPJ@GlobalMedia?5Group?0?5LLC@
CONST	SEGMENT
??_C@_0BH@LNLMLHPJ@GlobalMedia?5Group?0?5LLC@ DB 'GlobalMedia Group, LLC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JCFADKIE@DONG?5GUAN?5JALINK?5ELECTRONICES?5C@
CONST	SEGMENT
??_C@_0CG@JCFADKIE@DONG?5GUAN?5JALINK?5ELECTRONICES?5C@ DB 'DONG GUAN JAL'
	DB	'INK ELECTRONICES CO.,LTD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FDIEEFFD@Sierra?5Wireless?5Inc?4@
CONST	SEGMENT
??_C@_0BF@FDIEEFFD@Sierra?5Wireless?5Inc?4@ DB 'Sierra Wireless Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BGNNABKD@Sheng?5Yih?5Technologies?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0CB@BGNNABKD@Sheng?5Yih?5Technologies?5Co?4?0?5Ltd@ DB 'Sheng Yih T'
	DB	'echnologies Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NKCLDENL@Alpha?5Imaging?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BP@NKCLDENL@Alpha?5Imaging?5Technology?5Corp?4@ DB 'Alpha Imaging '
	DB	'Technology Corp.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JFAAFJPO@Tenx?5Technology?0?5Inc?4@
CONST	SEGMENT
??_C@_0BG@JFAAFJPO@Tenx?5Technology?0?5Inc?4@ DB 'Tenx Technology, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HLACDLIC@Master?5Hill?5Electric?5Wire?5and?5C@
CONST	SEGMENT
??_C@_0CO@HLACDLIC@Master?5Hill?5Electric?5Wire?5and?5C@ DB 'Master Hill '
	DB	'Electric Wire and Cable Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DEMMBJPB@VSO?5ELECTRONICS?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BK@DEMMBJPB@VSO?5ELECTRONICS?5CO?4?0?5LTD?4@ DB 'VSO ELECTRONICS C'
	DB	'O., LTD.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NDHMOMGK@Golden?5Bright?5?$CISichuan?$CJ?5Electro@
CONST	SEGMENT
??_C@_0DF@NDHMOMGK@Golden?5Bright?5?$CISichuan?$CJ?5Electro@ DB 'Golden B'
	DB	'right (Sichuan) Electronic Technology Co Ltd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOLPFLPD@Moxa?5Inc?4@
CONST	SEGMENT
??_C@_09GOLPFLPD@Moxa?5Inc?4@ DB 'Moxa Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BFJDJKMK@Actions?5Semiconductor?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@BFJDJKMK@Actions?5Semiconductor?5Co?4?0?5Ltd?4@ DB 'Actions Sem'
	DB	'iconductor Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BEMBIFEP@Kycon?5Inc?4@
CONST	SEGMENT
??_C@_0L@BEMBIFEP@Kycon?5Inc?4@ DB 'Kycon Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BEPCHFBK@Silicon?5Laboratories?0?5Inc?4@
CONST	SEGMENT
??_C@_0BL@BEPCHFBK@Silicon?5Laboratories?0?5Inc?4@ DB 'Silicon Laboratori'
	DB	'es, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GMIJPDAF@Princeton?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BL@GMIJPDAF@Princeton?5Technology?5Corp?4@ DB 'Princeton Technolog'
	DB	'y Corp.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OABIDDLN@Universal?5Global?5Scientific?5Ind@
CONST	SEGMENT
??_C@_0DB@OABIDDLN@Universal?5Global?5Scientific?5Ind@ DB 'Universal Glob'
	DB	'al Scientific Industrial Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MADBCNBC@Cables?5To?5Go@
CONST	SEGMENT
??_C@_0N@MADBCNBC@Cables?5To?5Go@ DB 'Cables To Go', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JBGEKCBJ@Lotes?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BA@JBGEKCBJ@Lotes?5Co?4?0?5Ltd?4@ DB 'Lotes Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MMEHCLPH@Robert?5Bosch?5GmbH@
CONST	SEGMENT
??_C@_0BC@MMEHCLPH@Robert?5Bosch?5GmbH@ DB 'Robert Bosch GmbH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HEECLKMJ@Grand?9tek?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@HEECLKMJ@Grand?9tek?5Technology?5Co?4?0?5Ltd?4@ DB 'Grand-tek T'
	DB	'echnology Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JLIOEOBP@PANTECH?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BC@JLIOEOBP@PANTECH?5CO?4?0?5LTD?4@ DB 'PANTECH CO., LTD.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GGINDOFM@CANON?5ELECTRONICS?5INC?4@
CONST	SEGMENT
??_C@_0BH@GGINDOFM@CANON?5ELECTRONICS?5INC?4@ DB 'CANON ELECTRONICS INC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EJNCJCJN@Freeway?5Electronic?5Wire?5?$CG?5Cable@
CONST	SEGMENT
??_C@_0DF@EJNCJCJN@Freeway?5Electronic?5Wire?5?$CG?5Cable@ DB 'Freeway El'
	DB	'ectronic Wire & Cable (Dongguan) Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OEFJDFLG@Western?5Digital?5Technologies?0?5I@
CONST	SEGMENT
??_C@_0CD@OEFJDFLG@Western?5Digital?5Technologies?0?5I@ DB 'Western Digit'
	DB	'al Technologies, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MCAPDOMI@ON?5Semiconductor@
CONST	SEGMENT
??_C@_0BB@MCAPDOMI@ON?5Semiconductor@ DB 'ON Semiconductor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DIDNCHDM@Targus?5Group?5International@
CONST	SEGMENT
??_C@_0BL@DIDNCHDM@Targus?5Group?5International@ DB 'Targus Group Interna'
	DB	'tional', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MAFJOCHL@WENZHOU?5YIHUA?5CONNECTOR?5CO?4?0LTD@
CONST	SEGMENT
??_C@_0CB@MAFJOCHL@WENZHOU?5YIHUA?5CONNECTOR?5CO?4?0LTD@ DB 'WENZHOU YIHU'
	DB	'A CONNECTOR CO.,LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KLMPEDJE@Newly?5Corporation@
CONST	SEGMENT
??_C@_0BC@KLMPEDJE@Newly?5Corporation@ DB 'Newly Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PPCAGGEP@LG?5Electronics?5Inc?4@
CONST	SEGMENT
??_C@_0BE@PPCAGGEP@LG?5Electronics?5Inc?4@ DB 'LG Electronics Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FNNKEBO@Speed?5Tech?5Corp?4@
CONST	SEGMENT
??_C@_0BB@FNNKEBO@Speed?5Tech?5Corp?4@ DB 'Speed Tech Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MNOHKIGC@CHI?5SHING?5COMPUTER?5ACCESSORIES?5@
CONST	SEGMENT
??_C@_0CJ@MNOHKIGC@CHI?5SHING?5COMPUTER?5ACCESSORIES?5@ DB 'CHI SHING COM'
	DB	'PUTER ACCESSORIES CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OGPLHBON@Sony?5Mobile?5Communications@
CONST	SEGMENT
??_C@_0BL@OGPLHBON@Sony?5Mobile?5Communications@ DB 'Sony Mobile Communic'
	DB	'ations', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NPCAKEK@CviLux?5Corporation@
CONST	SEGMENT
??_C@_0BD@NPCAKEK@CviLux?5Corporation@ DB 'CviLux Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KEDKNNLF@Yazaki?5Corporation@
CONST	SEGMENT
??_C@_0BD@KEDKNNLF@Yazaki?5Corporation@ DB 'Yazaki Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CHAEBCC@UQUEST?0?5LTD?4@
CONST	SEGMENT
??_C@_0N@CHAEBCC@UQUEST?0?5LTD?4@ DB 'UQUEST, LTD.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KCDILGEE@GuangZhou?5Chief?5Tech?5Electronic@
CONST	SEGMENT
??_C@_0DE@KCDILGEE@GuangZhou?5Chief?5Tech?5Electronic@ DB 'GuangZhou Chie'
	DB	'f Tech Electronic Technology Co. Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GLJCMOOM@Kawai?5Musical?5Instruments?5Mfg?4?5@
CONST	SEGMENT
??_C@_0CJ@GLJCMOOM@Kawai?5Musical?5Instruments?5Mfg?4?5@ DB 'Kawai Musica'
	DB	'l Instruments Mfg. Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JJBCDJBC@Taiyo?5Cable?5?$CIDongguan?$CJ?5Co?4?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@JJBCDJBC@Taiyo?5Cable?5?$CIDongguan?$CJ?5Co?4?5Ltd?4@ DB 'Taiyo'
	DB	' Cable (Dongguan) Co. Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PCHAGLHO@WORLDWIDE?5CABLE?5OPTO?5CORP?4@
CONST	SEGMENT
??_C@_0BL@PCHAGLHO@WORLDWIDE?5CABLE?5OPTO?5CORP?4@ DB 'WORLDWIDE CABLE OP'
	DB	'TO CORP.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KJGCCIGG@Nien?9Yi?5Industrial?5Corp?4@
CONST	SEGMENT
??_C@_0BJ@KJGCCIGG@Nien?9Yi?5Industrial?5Corp?4@ DB 'Nien-Yi Industrial C'
	DB	'orp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JKBEBDIB@YFC?9BonEagle?5Electric?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@JKBEBDIB@YFC?9BonEagle?5Electric?5Co?4?0?5Ltd?4@ DB 'YFC-BonEag'
	DB	'le Electric Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HHKPOBJN@Good?5Man?5Corporation@
CONST	SEGMENT
??_C@_0BF@HHKPOBJN@Good?5Man?5Corporation@ DB 'Good Man Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BFCEICOB@Funai?5Electric?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@BFCEICOB@Funai?5Electric?5Co?4?0?5Ltd?4@ DB 'Funai Electric Co.'
	DB	', Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LHKAEIDJ@CSL?5Wire?5?$CG?5Plug?5?$CIShen?5Zhen?$CJ?5Com@
CONST	SEGMENT
??_C@_0CE@LHKAEIDJ@CSL?5Wire?5?$CG?5Plug?5?$CIShen?5Zhen?$CJ?5Com@ DB 'CS'
	DB	'L Wire & Plug (Shen Zhen) Company', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLFMJOLO@Sunrich?5Technology?5?$CIH?4K?4?$CJ?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@OLFMJOLO@Sunrich?5Technology?5?$CIH?4K?4?$CJ?5Ltd?4@ DB 'Sunric'
	DB	'h Technology (H.K.) Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LAJGACMM@TaiSol?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@LAJGACMM@TaiSol?5Electronics?5Co?4?0?5Ltd?4@ DB 'TaiSol Electro'
	DB	'nics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HGLIFDP@InnoVISION?5Multimedia?5Limited@
CONST	SEGMENT
??_C@_0BO@HGLIFDP@InnoVISION?5Multimedia?5Limited@ DB 'InnoVISION Multime'
	DB	'dia Limited', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NLMJJEGP@Axell?5Corporation@
CONST	SEGMENT
??_C@_0BC@NLMJJEGP@Axell?5Corporation@ DB 'Axell Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EEJFEJAC@Sweetray?5Industrial?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@EEJFEJAC@Sweetray?5Industrial?5Ltd?4@ DB 'Sweetray Industrial L'
	DB	'td.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FFOINCNP@Y?9S?5ELECTRONIC?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BJ@FFOINCNP@Y?9S?5ELECTRONIC?5CO?4?0?5LTD?4@ DB 'Y-S ELECTRONIC CO'
	DB	'., LTD.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LFNPLID@Ours?5Technology?5Inc?4@
CONST	SEGMENT
??_C@_0BF@LFNPLID@Ours?5Technology?5Inc?4@ DB 'Ours Technology Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PLHJNEDE@ADTEC?5CORPORATION@
CONST	SEGMENT
??_C@_0BC@PLHJNEDE@ADTEC?5CORPORATION@ DB 'ADTEC CORPORATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03PPOOIEPP@CRU@
CONST	SEGMENT
??_C@_03PPOOIEPP@CRU@ DB 'CRU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBHJNIK@MediaTek?5Inc?4@
CONST	SEGMENT
??_C@_0O@DBHJNIK@MediaTek?5Inc?4@ DB 'MediaTek Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FIEIALAE@Hsi?9Chin?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@FIEIALAE@Hsi?9Chin?5Electronics?5Co?4?0?5Ltd?4@ DB 'Hsi-Chin El'
	DB	'ectronics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PNJNPPHF@Megawin?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@PNJNPPHF@Megawin?5Technology?5Co?4?0?5Ltd?4@ DB 'Megawin Techno'
	DB	'logy Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DKLMDFEK@Neltron?5Industrial?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@DKLMDFEK@Neltron?5Industrial?5Co?4?0?5Ltd?4@ DB 'Neltron Indust'
	DB	'rial Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@OJLHPIE@Shenzhen?5Bao?5Hing?5Electric?5Wire@
CONST	SEGMENT
??_C@_0DB@OJLHPIE@Shenzhen?5Bao?5Hing?5Electric?5Wire@ DB 'Shenzhen Bao H'
	DB	'ing Electric Wire & Cable Mfr. Co.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BNIAIBOP@Smart?5Modular?5Technologies?0?5Inc@
CONST	SEGMENT
??_C@_0CB@BNIAIBOP@Smart?5Modular?5Technologies?0?5Inc@ DB 'Smart Modular'
	DB	' Technologies, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MECAJMAF@Liou?5Yuane?5International?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@MECAJMAF@Liou?5Yuane?5International?5Ltd?4@ DB 'Liou Yuane Inte'
	DB	'rnational Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JAOPMIJP@Custom?5Engineering?5SPA@
CONST	SEGMENT
??_C@_0BH@JAOPMIJP@Custom?5Engineering?5SPA@ DB 'Custom Engineering SPA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HKHHADBM@Power?5Quotient?5International?5Co@
CONST	SEGMENT
??_C@_0CH@HKHHADBM@Power?5Quotient?5International?5Co@ DB 'Power Quotient'
	DB	' International Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MEJNGPFO@Contek?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@MEJNGPFO@Contek?5Electronics?5Co?4?0?5Ltd?4@ DB 'Contek Electro'
	DB	'nics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LDGCJJON@Micro?9Star?5International?5Co?4?0?5L@
CONST	SEGMENT
??_C@_0CD@LDGCJJON@Micro?9Star?5International?5Co?4?0?5L@ DB 'Micro-Star '
	DB	'International Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBFDLJEL@IOGEAR?0?5Inc?4@
CONST	SEGMENT
??_C@_0N@BBFDLJEL@IOGEAR?0?5Inc?4@ DB 'IOGEAR, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBEHKKIA@Sure?9Fire?5Electrical?5Corporatio@
CONST	SEGMENT
??_C@_0CB@CBEHKKIA@Sure?9Fire?5Electrical?5Corporatio@ DB 'Sure-Fire Elec'
	DB	'trical Corporation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICKBMN@C?9MEDIA?5ELECTRONICS?5INC?4@
CONST	SEGMENT
??_C@_0BJ@ICKBMN@C?9MEDIA?5ELECTRONICS?5INC?4@ DB 'C-MEDIA ELECTRONICS IN'
	DB	'C.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BKFMOADO@Dolby?5Laboratories?5Inc?4@
CONST	SEGMENT
??_C@_0BI@BKFMOADO@Dolby?5Laboratories?5Inc?4@ DB 'Dolby Laboratories Inc'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DEKDBPDL@Taiwan?5Line?5Tek?5Electronic?5Co?4?0@
CONST	SEGMENT
??_C@_0CF@DEKDBPDL@Taiwan?5Line?5Tek?5Electronic?5Co?4?0@ DB 'Taiwan Line'
	DB	' Tek Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNDMIFOJ@Hirakawa?5Hewtech?5Corp?4@
CONST	SEGMENT
??_C@_0BH@JNDMIFOJ@Hirakawa?5Hewtech?5Corp?4@ DB 'Hirakawa Hewtech Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DILBGHLF@MEILU?5ELECTRONICS?5?$CISHENZHEN?$CJ?5CO@
CONST	SEGMENT
??_C@_0CH@DILBGHLF@MEILU?5ELECTRONICS?5?$CISHENZHEN?$CJ?5CO@ DB 'MEILU EL'
	DB	'ECTRONICS (SHENZHEN) CO., LTD.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GHDJEHFK@Volex?5?$CIAsia?$CJ?5Pte?5Ltd@
CONST	SEGMENT
??_C@_0BF@GHDJEHFK@Volex?5?$CIAsia?$CJ?5Pte?5Ltd@ DB 'Volex (Asia) Pte Lt'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KEPOILEK@Grape?5Systems?5Inc?4@
CONST	SEGMENT
??_C@_0BD@KEPOILEK@Grape?5Systems?5Inc?4@ DB 'Grape Systems Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MAHCGCHE@NF?5Corporation@
CONST	SEGMENT
??_C@_0P@MAHCGCHE@NF?5Corporation@ DB 'NF Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDKBGBCG@NALTEC?0?5Inc?4@
CONST	SEGMENT
??_C@_0N@IDKBGBCG@NALTEC?0?5Inc?4@ DB 'NALTEC, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KPNEJJKA@ENE?5Technology?5Inc?4@
CONST	SEGMENT
??_C@_0BE@KPNEJJKA@ENE?5Technology?5Inc?4@ DB 'ENE Technology Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OOCFEMN@e?9CONN?5ELECTRONIC?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BM@OOCFEMN@e?9CONN?5ELECTRONIC?5CO?4?0?5LTD?4@ DB 'e-CONN ELECTRON'
	DB	'IC CO., LTD.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OACAMJJG@Z?9Com?5INC?4@
CONST	SEGMENT
??_C@_0L@OACAMJJG@Z?9Com?5INC?4@ DB 'Z-Com INC.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ECMAKMHG@Intel?5Corporation@
CONST	SEGMENT
??_C@_0BC@ECMAKMHG@Intel?5Corporation@ DB 'Intel Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NGPEIKDH@emsys?5Embedded?5Systems?5GmbH@
CONST	SEGMENT
??_C@_0BM@NGPEIKDH@emsys?5Embedded?5Systems?5GmbH@ DB 'emsys Embedded Sys'
	DB	'tems GmbH', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DKFGFGHA@Singatron?5Enterprise?5Co?4?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@DKFGFGHA@Singatron?5Enterprise?5Co?4?5Ltd?4@ DB 'Singatron Ente'
	DB	'rprise Co. Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCKEPBKO@Motorola?5Solutions@
CONST	SEGMENT
??_C@_0BD@PCKEPBKO@Motorola?5Solutions@ DB 'Motorola Solutions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KPNGPOOH@Honda?5Tsushin?5Kogyo?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0BN@KPNGPOOH@Honda?5Tsushin?5Kogyo?5Co?4?0?5Ltd@ DB 'Honda Tsushin '
	DB	'Kogyo Co., Ltd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PNHCHLDH@Solid?5State?5System?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@PNHCHLDH@Solid?5State?5System?5Co?4?0?5Ltd?4@ DB 'Solid State S'
	DB	'ystem Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KANEMGNF@Whanam?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@KANEMGNF@Whanam?5Electronics?5Co?4?0?5Ltd?4@ DB 'Whanam Electro'
	DB	'nics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FHGKBINA@Chant?5Sincere?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0BH@FHGKBINA@Chant?5Sincere?5Co?4?0?5Ltd@ DB 'Chant Sincere Co., Lt'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KMAKLJKD@Dong?5Guan?5Shinko?5Wire?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@KMAKLJKD@Dong?5Guan?5Shinko?5Wire?5Co?4?0?5Ltd?4@ DB 'Dong Guan'
	DB	' Shinko Wire Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IIBBHDLP@Sonix?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@IIBBHDLP@Sonix?5Technology?5Co?4?0?5Ltd?4@ DB 'Sonix Technology'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDJBOCE@Aeroflex@
CONST	SEGMENT
??_C@_08EDJBOCE@Aeroflex@ DB 'Aeroflex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDCJOHPC@Taiyo?5Yuden?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BG@BDCJOHPC@Taiyo?5Yuden?5Co?4?0?5Ltd?4@ DB 'Taiyo Yuden Co., Ltd.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GAPKJOJF@Elka?5International?5Ltd?4@
CONST	SEGMENT
??_C@_0BI@GAPKJOJF@Elka?5International?5Ltd?4@ DB 'Elka International Ltd'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBGCMNLB@Ericsson?5AB@
CONST	SEGMENT
??_C@_0M@PBGCMNLB@Ericsson?5AB@ DB 'Ericsson AB', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OODBLDMG@Realtek?5Semiconductor?5Corp?4@
CONST	SEGMENT
??_C@_0BM@OODBLDMG@Realtek?5Semiconductor?5Corp?4@ DB 'Realtek Semiconduc'
	DB	'tor Corp.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PKPGHPEE@Seagate?5Technology?5LLC@
CONST	SEGMENT
??_C@_0BH@PKPGHPEE@Seagate?5Technology?5LLC@ DB 'Seagate Technology LLC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JGDEFBDO@Murata?5Manufacturing?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@JGDEFBDO@Murata?5Manufacturing?5Co?4?0?5Ltd?4@ DB 'Murata Manuf'
	DB	'acturing Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBGBIANO@ASIX?5Electronics?5Corporation@
CONST	SEGMENT
??_C@_0BN@DBGBIANO@ASIX?5Electronics?5Corporation@ DB 'ASIX Electronics C'
	DB	'orporation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DICOBJHO@Maxim?5Integrated?5Products@
CONST	SEGMENT
??_C@_0BK@DICOBJHO@Maxim?5Integrated?5Products@ DB 'Maxim Integrated Prod'
	DB	'ucts', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IGCLCEEO@Sinbon?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@IGCLCEEO@Sinbon?5Electronics?5Co?4?0?5Ltd?4@ DB 'Sinbon Electro'
	DB	'nics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MJIIIHDL@Musical?5Electronics?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@MJIIIHDL@Musical?5Electronics?5Ltd?4@ DB 'Musical Electronics L'
	DB	'td.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IGDJFEE@Pan?9Asia?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@IGDJFEE@Pan?9Asia?5Electronics?5Co?4?0?5Ltd?4@ DB 'Pan-Asia Ele'
	DB	'ctronics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KKOFHFLP@Yokogawa?5Electric?5Corporation@
CONST	SEGMENT
??_C@_0BO@KKOFHFLP@Yokogawa?5Electric?5Corporation@ DB 'Yokogawa Electric'
	DB	' Corporation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HEOGBEPO@ASUSTek?5Computer?5Inc?4@
CONST	SEGMENT
??_C@_0BG@HEOGBEPO@ASUSTek?5Computer?5Inc?4@ DB 'ASUSTek Computer Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MFIELINC@Allion?5Labs?0?5Inc?4@
CONST	SEGMENT
??_C@_0BC@MFIELINC@Allion?5Labs?0?5Inc?4@ DB 'Allion Labs, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HMAJKJ@Vimicro?5Corporation@
CONST	SEGMENT
??_C@_0BE@HMAJKJ@Vimicro?5Corporation@ DB 'Vimicro Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EIBHCLN@SANYO?5Semiconductor?5Company?5Mic@
CONST	SEGMENT
??_C@_0CC@EIBHCLN@SANYO?5Semiconductor?5Company?5Mic@ DB 'SANYO Semicondu'
	DB	'ctor Company Micro', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IKBKKFPF@Rohde?5?$CG?5Schwarz?5GmbH?5?$CG?5Co?4?5KG@
CONST	SEGMENT
??_C@_0BO@IKBKKFPF@Rohde?5?$CG?5Schwarz?5GmbH?5?$CG?5Co?4?5KG@ DB 'Rohde '
	DB	'& Schwarz GmbH & Co. KG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KFMMGOHA@Wincor?5Nixdorf?5GmbH?5?$CG?5Co?5KG@
CONST	SEGMENT
??_C@_0BM@KFMMGOHA@Wincor?5Nixdorf?5GmbH?5?$CG?5Co?5KG@ DB 'Wincor Nixdor'
	DB	'f GmbH & Co KG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BPGMFHBM@Young?5Chang?5Co?4?5Ltd?4@
CONST	SEGMENT
??_C@_0BF@BPGMFHBM@Young?5Chang?5Co?4?5Ltd?4@ DB 'Young Chang Co. Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BLIFGEAH@Japan?5Aviation?5Electronics?5Indu@
CONST	SEGMENT
??_C@_0CP@BLIFGEAH@Japan?5Aviation?5Electronics?5Indu@ DB 'Japan Aviation'
	DB	' Electronics Industry Ltd. (JAE)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IJFMHNNO@Green?5House?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BG@IJFMHNNO@Green?5House?5Co?4?0?5Ltd?4@ DB 'Green House Co., Ltd.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBOGHGP@Broadcom?5Corp?4@
CONST	SEGMENT
??_C@_0P@KBOGHGP@Broadcom?5Corp?4@ DB 'Broadcom Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FBNECLJJ@Mimaki?5Engineering?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@FBNECLJJ@Mimaki?5Engineering?5Co?4?0?5Ltd?4@ DB 'Mimaki Enginee'
	DB	'ring Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LHJHCFAG@COMPUTEX?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BD@LHJHCFAG@COMPUTEX?5Co?4?0?5Ltd?4@ DB 'COMPUTEX Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IKEGAKKP@Hirose?5Electric?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BK@IKEGAKKP@Hirose?5Electric?5Co?4?0?5Ltd?4@ DB 'Hirose Electric C'
	DB	'o., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EKKNDOHK@Physio?9Control?0?5Inc?4@
CONST	SEGMENT
??_C@_0BF@EKKNDOHK@Physio?9Control?0?5Inc?4@ DB 'Physio-Control, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HPCCBBBB@HOYA?5Corporation@
CONST	SEGMENT
??_C@_0BB@HPCCBBBB@HOYA?5Corporation@ DB 'HOYA Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HOMOCJPC@Cambridge?5Silicon?5Radio?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@HOMOCJPC@Cambridge?5Silicon?5Radio?5Ltd?4@ DB 'Cambridge Silico'
	DB	'n Radio Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06NEOADGIL@Altera@
CONST	SEGMENT
??_C@_06NEOADGIL@Altera@ DB 'Altera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LAHNEDCJ@A?9FOUR?5TECH?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BG@LAHNEDCJ@A?9FOUR?5TECH?5CO?4?0?5LTD?4@ DB 'A-FOUR TECH CO., LTD'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HNEJNPKP@Electronics?5Testing?5Center?0?5Tai@
CONST	SEGMENT
??_C@_0CD@HNEJNPKP@Electronics?5Testing?5Center?0?5Tai@ DB 'Electronics T'
	DB	'esting Center, Taiwan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJFDPOOK@Workbit?5Corporation@
CONST	SEGMENT
??_C@_0BE@OJFDPOOK@Workbit?5Corporation@ DB 'Workbit Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JHLIIJEE@NISCA?5Corporation@
CONST	SEGMENT
??_C@_0BC@JHLIIJEE@NISCA?5Corporation@ DB 'NISCA Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OHPOFJEM@Japan?5Cash?5Machine?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BN@OHPOFJEM@Japan?5Cash?5Machine?5Co?4?0?5Ltd?4@ DB 'Japan Cash Ma'
	DB	'chine Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PGLGBHIA@Intersil?5Corporation@
CONST	SEGMENT
??_C@_0BF@PGLGBHIA@Intersil?5Corporation@ DB 'Intersil Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NGELPCKK@Lin?5Shiung?5Enterprise?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@NGELPCKK@Lin?5Shiung?5Enterprise?5Co?4?0?5Ltd?4@ DB 'Lin Shiung'
	DB	' Enterprise Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NHOGNCFH@Contech?5Research?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@NHOGNCFH@Contech?5Research?0?5Inc?4@ DB 'Contech Research, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LKCCNLNO@Polycom?0?5Inc?4@
CONST	SEGMENT
??_C@_0O@LKCCNLNO@Polycom?0?5Inc?4@ DB 'Polycom, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DIONPOBP@Medialogic?5Corporation@
CONST	SEGMENT
??_C@_0BH@DIONPOBP@Medialogic?5Corporation@ DB 'Medialogic Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLPBIJLK@Agilent?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BL@KLPBIJLK@Agilent?5Technologies?0?5Inc?4@ DB 'Agilent Technologi'
	DB	'es, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06HLMMPIBG@NVIDIA@
CONST	SEGMENT
??_C@_06HLMMPIBG@NVIDIA@ DB 'NVIDIA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LKMMOGNE@Kingston?5Technology?5Company@
CONST	SEGMENT
??_C@_0BM@LKMMOGNE@Kingston?5Technology?5Company@ DB 'Kingston Technology'
	DB	' Company', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PLHGNMC@J?4S?4T?4?5Mfg?4?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BG@PLHGNMC@J?4S?4T?4?5Mfg?4?5Co?4?0?5Ltd?4@ DB 'J.S.T. Mfg. Co., L'
	DB	'td.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DPPDGGNF@Plextor?5LLC@
CONST	SEGMENT
??_C@_0M@DPPDGGNF@Plextor?5LLC@ DB 'Plextor LLC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FDMCHING@Pixart?5Imaging?0?5Inc?4@
CONST	SEGMENT
??_C@_0BF@FDMCHING@Pixart?5Imaging?0?5Inc?4@ DB 'Pixart Imaging, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JMAMIBAH@Toshiba?5Corporation@
CONST	SEGMENT
??_C@_0BE@JMAMIBAH@Toshiba?5Corporation@ DB 'Toshiba Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCKCLCDJ@Garmin?5International@
CONST	SEGMENT
??_C@_0BF@OCKCLCDJ@Garmin?5International@ DB 'Garmin International', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNPBHCJB@Silicon?5Motion?0?5Inc?4?5?9?5Taiwan@
CONST	SEGMENT
??_C@_0BO@BNPBHCJB@Silicon?5Motion?0?5Inc?4?5?9?5Taiwan@ DB 'Silicon Moti'
	DB	'on, Inc. - Taiwan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DGGIOLK@Audio?9Technica?5Corp?4@
CONST	SEGMENT
??_C@_0BF@DGGIOLK@Audio?9Technica?5Corp?4@ DB 'Audio-Technica Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DEEADHEC@FARADAY?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BJ@DEEADHEC@FARADAY?5Technology?5Corp?4@ DB 'FARADAY Technology Co'
	DB	'rp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMFIDNE@Gemalto?5SA@
CONST	SEGMENT
??_C@_0L@NMFIDNE@Gemalto?5SA@ DB 'Gemalto SA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PMKDDGDC@Pioneer?5Corporation@
CONST	SEGMENT
??_C@_0BE@PMKDDGDC@Pioneer?5Corporation@ DB 'Pioneer Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BEPEDALH@Spyrus?5Inc?4@
CONST	SEGMENT
??_C@_0M@BEPEDALH@Spyrus?5Inc?4@ DB 'Spyrus Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JNLBBKDI@TAI?5TWUN?5ENTERPRISE?5CO?4?0?5LTD?4@
CONST	SEGMENT
??_C@_0BO@JNLBBKDI@TAI?5TWUN?5ENTERPRISE?5CO?4?0?5LTD?4@ DB 'TAI TWUN ENT'
	DB	'ERPRISE CO., LTD.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIMBAIC@RadioShack?5Corporation@
CONST	SEGMENT
??_C@_0BH@CFIMBAIC@RadioShack?5Corporation@ DB 'RadioShack Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNBHHOAN@Icron?5Technologies?5Corporation@
CONST	SEGMENT
??_C@_0BP@PNBHHOAN@Icron?5Technologies?5Corporation@ DB 'Icron Technologi'
	DB	'es Corporation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EMBEKEAB@Lauterbach?5GmbH@
CONST	SEGMENT
??_C@_0BA@EMBEKEAB@Lauterbach?5GmbH@ DB 'Lauterbach GmbH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEKEIHLM@MEC?5IMEX?5INC?1HPT@
CONST	SEGMENT
??_C@_0BB@CEKEIHLM@MEC?5IMEX?5INC?1HPT@ DB 'MEC IMEX INC/HPT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@COHJMHME@Wipro?5Limited@
CONST	SEGMENT
??_C@_0O@COHJMHME@Wipro?5Limited@ DB 'Wipro Limited', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@POAJBKGF@Action?5Star?5Enterprise?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0CB@POAJBKGF@Action?5Star?5Enterprise?5Co?4?0?5Ltd@ DB 'Action Star'
	DB	' Enterprise Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAINGGKC@Evermuch?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@CAINGGKC@Evermuch?5Technology?5Co?4?0?5Ltd?4@ DB 'Evermuch Tech'
	DB	'nology Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OPFGKFFJ@Century?5Corporation@
CONST	SEGMENT
??_C@_0BE@OPFGKFFJ@Century?5Corporation@ DB 'Century Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNLONGOH@David?5Electronics?5Company?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@BNLONGOH@David?5Electronics?5Company?0?5Ltd?4@ DB 'David Electr'
	DB	'onics Company, Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ODMCNPPD@Arasan?5Chip?5Systems?5Inc?4@
CONST	SEGMENT
??_C@_0BJ@ODMCNPPD@Arasan?5Chip?5Systems?5Inc?4@ DB 'Arasan Chip Systems '
	DB	'Inc.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JKHOIPCI@Casio?5Computer?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@JKHOIPCI@Casio?5Computer?5Co?4?0?5Ltd?4@ DB 'Casio Computer Co.'
	DB	', Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FNDINGLK@Carry?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@FNDINGLK@Carry?5Technology?5Co?4?0?5Ltd?4@ DB 'Carry Technology'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EGFACLDP@AVerMedia?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BN@EGFACLDP@AVerMedia?5Technologies?0?5Inc?4@ DB 'AVerMedia Techno'
	DB	'logies, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGBHEDBN@TIME?5Interconnect?5Ltd?4@
CONST	SEGMENT
??_C@_0BH@MGBHEDBN@TIME?5Interconnect?5Ltd?4@ DB 'TIME Interconnect Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NJLEDFOB@OLYMPUS?5CORPORATION@
CONST	SEGMENT
??_C@_0BE@NJLEDFOB@OLYMPUS?5CORPORATION@ DB 'OLYMPUS CORPORATION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OCMFCBHB@Plustek?0?5Inc?4@
CONST	SEGMENT
??_C@_0O@OCMFCBHB@Plustek?0?5Inc?4@ DB 'Plustek, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MPFKAMGD@National?5Technical?5Systems@
CONST	SEGMENT
??_C@_0BL@MPFKAMGD@National?5Technical?5Systems@ DB 'National Technical S'
	DB	'ystems', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LGBOFDFN@Copartner?5Technology?5Corporatio@
CONST	SEGMENT
??_C@_0CB@LGBOFDFN@Copartner?5Technology?5Corporatio@ DB 'Copartner Techn'
	DB	'ology Corporation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KACIGGGG@SanDisk?5Corporation@
CONST	SEGMENT
??_C@_0BE@KACIGGGG@SanDisk?5Corporation@ DB 'SanDisk Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OBNCJIEM@Fairchild?5Semiconductor@
CONST	SEGMENT
??_C@_0BI@OBNCJIEM@Fairchild?5Semiconductor@ DB 'Fairchild Semiconductor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FCBANMAL@HID?5Global?5GmbH@
CONST	SEGMENT
??_C@_0BA@FCBANMAL@HID?5Global?5GmbH@ DB 'HID Global GmbH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFGLNKOO@Jess?9Link?5Products?5Co?4?0?5Ltd?4?5?$CIJ@
CONST	SEGMENT
??_C@_0CD@HFGLNKOO@Jess?9Link?5Products?5Co?4?0?5Ltd?4?5?$CIJ@ DB 'Jess-L'
	DB	'ink Products Co., Ltd. (JPC)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PCICHEDF@Cyber?5Power?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BK@PCICHEDF@Cyber?5Power?5Systems?0?5Inc?4@ DB 'Cyber Power System'
	DB	's, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PJBMJABB@Lorom?5Industrial?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@PJBMJABB@Lorom?5Industrial?5Co?4?0?5Ltd?4@ DB 'Lorom Industrial'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IFGJOCOG@Sunix?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BA@IFGJOCOG@Sunix?5Co?4?0?5Ltd?4@ DB 'Sunix Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NNOCEOFA@Imation?5Corp?4@
CONST	SEGMENT
??_C@_0O@NNOCEOFA@Imation?5Corp?4@ DB 'Imation Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JCFMJDGG@Magic?5Control?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BP@JCFMJDGG@Magic?5Control?5Technology?5Corp?4@ DB 'Magic Control '
	DB	'Technology Corp.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JIAGMEHO@Comoss?5Electronic?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BM@JIAGMEHO@Comoss?5Electronic?5Co?4?0?5Ltd?4@ DB 'Comoss Electron'
	DB	'ic Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MKILJNBK@Oki?5Electric?5Industry?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@MKILJNBK@Oki?5Electric?5Industry?5Co?4?0?5Ltd?4@ DB 'Oki Electr'
	DB	'ic Industry Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BIPBCEJB@Heisei?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BM@BIPBCEJB@Heisei?5Technology?5Co?4?0?5Ltd?4@ DB 'Heisei Technolo'
	DB	'gy Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FPPDHAGC@Mitsubishi?5Electric?5Corporation@
CONST	SEGMENT
??_C@_0CA@FPPDHAGC@Mitsubishi?5Electric?5Corporation@ DB 'Mitsubishi Elec'
	DB	'tric Corporation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OJHCGLE@Synaptics?5Inc?4@
CONST	SEGMENT
??_C@_0P@OJHCGLE@Synaptics?5Inc?4@ DB 'Synaptics Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGNPDHHH@SIIG?0?5Inc?4@
CONST	SEGMENT
??_C@_0L@IGNPDHHH@SIIG?0?5Inc?4@ DB 'SIIG, Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IAMJELKE@Bizlink?5Technology?0?5Inc?4@
CONST	SEGMENT
??_C@_0BJ@IAMJELKE@Bizlink?5Technology?0?5Inc?4@ DB 'Bizlink Technology, '
	DB	'Inc.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PBNHDNIB@Leoco?5Corporation@
CONST	SEGMENT
??_C@_0BC@PBNHDNIB@Leoco?5Corporation@ DB 'Leoco Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KBMIOCIB@Oki?5Data?5Corporation@
CONST	SEGMENT
??_C@_0BF@KBMIOCIB@Oki?5Data?5Corporation@ DB 'Oki Data Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFHNCDAI@Pixela?5Corporation@
CONST	SEGMENT
??_C@_0BD@MFHNCDAI@Pixela?5Corporation@ DB 'Pixela Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFEICALO@Testronic?5Labs@
CONST	SEGMENT
??_C@_0P@DFEICALO@Testronic?5Labs@ DB 'Testronic Labs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NHGJCBNO@Greatland?5Electronics?5Taiwan?5Lt@
CONST	SEGMENT
??_C@_0CC@NHGJCBNO@Greatland?5Electronics?5Taiwan?5Lt@ DB 'Greatland Elec'
	DB	'tronics Taiwan Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EMAGANPI@Tektronix?0?5Inc?4@
CONST	SEGMENT
??_C@_0BA@EMAGANPI@Tektronix?0?5Inc?4@ DB 'Tektronix, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LFPCEBHN@Golden?5Bridge?5Electech?5Inc?4@
CONST	SEGMENT
??_C@_0BM@LFPCEBHN@Golden?5Bridge?5Electech?5Inc?4@ DB 'Golden Bridge Ele'
	DB	'ctech Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JOKCKELG@Dell?5Inc?4@
CONST	SEGMENT
??_C@_09JOKCKELG@Dell?5Inc?4@ DB 'Dell Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PDKHMLGO@Prolific?5Technology?0?5Inc?4@
CONST	SEGMENT
??_C@_0BK@PDKHMLGO@Prolific?5Technology?0?5Inc?4@ DB 'Prolific Technology'
	DB	', Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BPDLABPC@Total?5Technologies?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@BPDLABPC@Total?5Technologies?0?5Ltd?4@ DB 'Total Technologies, '
	DB	'Ltd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKNBNCAJ@Hamamatsu?5Photonics?5K?4K?4@
CONST	SEGMENT
??_C@_0BJ@PKNBNCAJ@Hamamatsu?5Photonics?5K?4K?4@ DB 'Hamamatsu Photonics '
	DB	'K.K.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PAFBBAIH@TSAY?9E?5?$CIBVI?$CJ?5International?5Inc?4@
CONST	SEGMENT
??_C@_0CA@PAFBBAIH@TSAY?9E?5?$CIBVI?$CJ?5International?5Inc?4@ DB 'TSAY-E'
	DB	' (BVI) International Inc.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@MJJJJEAM@Good?5Way?5Technology?5Co?4?0?5Ltd?4?5?$CG@
CONST	SEGMENT
??_C@_0DD@MJJJJEAM@Good?5Way?5Technology?5Co?4?0?5Ltd?4?5?$CG@ DB 'Good W'
	DB	'ay Technology Co., Ltd. & GWC technology Inc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DBNMJIBL@Sigma?5Designs?0?5Inc?4@
CONST	SEGMENT
??_C@_0BE@DBNMJIBL@Sigma?5Designs?0?5Inc?4@ DB 'Sigma Designs, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HLMOOHDB@Tekcon?5Electronics?5Corp?4@
CONST	SEGMENT
??_C@_0BJ@HLMOOHDB@Tekcon?5Electronics?5Corp?4@ DB 'Tekcon Electronics Co'
	DB	'rp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JPOIGLAH@Glory?5Mark?5Electronic?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@JPOIGLAH@Glory?5Mark?5Electronic?5Ltd?4@ DB 'Glory Mark Electro'
	DB	'nic Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BBNBDGIM@Space?5Shuttle?5Hi?9Tech?5Co?4?0Ltd?4@
CONST	SEGMENT
??_C@_0BP@BBNBDGIM@Space?5Shuttle?5Hi?9Tech?5Co?4?0Ltd?4@ DB 'Space Shutt'
	DB	'le Hi-Tech Co.,Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBOMJHJG@Suyin?5Corporation@
CONST	SEGMENT
??_C@_0BC@HBOMJHJG@Suyin?5Corporation@ DB 'Suyin Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EBDNAMPI@Ji?9Haw?5Industrial?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0BL@EBDNAMPI@Ji?9Haw?5Industrial?5Co?4?0?5Ltd@ DB 'Ji-Haw Industria'
	DB	'l Co., Ltd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PMGKCBAF@Analog?5Devices?0?5Inc?4?5Developmen@
CONST	SEGMENT
??_C@_0CH@PMGKCBAF@Analog?5Devices?0?5Inc?4?5Developmen@ DB 'Analog Devic'
	DB	'es, Inc. Development Tools', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAMNDPPF@Chrontel?0?5Inc?4@
CONST	SEGMENT
??_C@_0P@GAMNDPPF@Chrontel?0?5Inc?4@ DB 'Chrontel, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EBACAFBC@JPC?1MAIN?5SUPER?5Inc?4@
CONST	SEGMENT
??_C@_0BE@EBACAFBC@JPC?1MAIN?5SUPER?5Inc?4@ DB 'JPC/MAIN SUPER Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OFHNPHHH@Seiko?5Instruments?5Inc?4@
CONST	SEGMENT
??_C@_0BH@OFHNPHHH@Seiko?5Instruments?5Inc?4@ DB 'Seiko Instruments Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BNDJFIFN@TransAct?5Technologies?5Incorpora@
CONST	SEGMENT
??_C@_0CD@BNDJFIFN@TransAct?5Technologies?5Incorpora@ DB 'TransAct Techno'
	DB	'logies Incorporated', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IBGJKEKA@Joinsoon?5Electronics?5Mfg?4?5Co?4?0?5@
CONST	SEGMENT
??_C@_0CE@IBGJKEKA@Joinsoon?5Electronics?5Mfg?4?5Co?4?0?5@ DB 'Joinsoon E'
	DB	'lectronics Mfg. Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJAJLGJE@SMK?5Manufacturing?5Inc?4@
CONST	SEGMENT
??_C@_0BH@LJAJLGJE@SMK?5Manufacturing?5Inc?4@ DB 'SMK Manufacturing Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HAMNADII@Novatek?5Microelectronics?5Corp?4@
CONST	SEGMENT
??_C@_0BP@HAMNADII@Novatek?5Microelectronics?5Corp?4@ DB 'Novatek Microel'
	DB	'ectronics Corp.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJDPEADK@LeCroy?5Corporation@
CONST	SEGMENT
??_C@_0BD@PJDPEADK@LeCroy?5Corporation@ DB 'LeCroy Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPONFABH@Datalogic?5ADC@
CONST	SEGMENT
??_C@_0O@FPONFABH@Datalogic?5ADC@ DB 'Datalogic ADC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NBAANMIA@Unixtar?5Technology?5Inc?4@
CONST	SEGMENT
??_C@_0BI@NBAANMIA@Unixtar?5Technology?5Inc?4@ DB 'Unixtar Technology Inc'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KBGKOOGJ@Fuji?5Electric?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BI@KBGKOOGJ@Fuji?5Electric?5Co?4?0?5Ltd?4@ DB 'Fuji Electric Co., '
	DB	'Ltd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKIEML@Genesys?5Logic?0?5Inc?4@
CONST	SEGMENT
??_C@_0BE@CKIEML@Genesys?5Logic?0?5Inc?4@ DB 'Genesys Logic, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JPKFBBCH@Symbol?5Technologies@
CONST	SEGMENT
??_C@_0BE@JPKFBBCH@Symbol?5Technologies@ DB 'Symbol Technologies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OADDMKLB@Microtek?5International?5Inc?4@
CONST	SEGMENT
??_C@_0BM@OADDMKLB@Microtek?5International?5Inc?4@ DB 'Microtek Internati'
	DB	'onal Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DNOMCPDN@Ricoh?5Company?5Ltd?4@
CONST	SEGMENT
??_C@_0BD@DNOMCPDN@Ricoh?5Company?5Ltd?4@ DB 'Ricoh Company Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IMDHJGED@Foxlink?1Cheng?5Uei?5Precision?5Ind@
CONST	SEGMENT
??_C@_0CP@IMDHJGED@Foxlink?1Cheng?5Uei?5Precision?5Ind@ DB 'Foxlink/Cheng'
	DB	' Uei Precision Industry Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JJANANCF@Qualcomm?0?5Inc@
CONST	SEGMENT
??_C@_0O@JJANANCF@Qualcomm?0?5Inc@ DB 'Qualcomm, Inc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ILGCAFHO@Kawasaki?5Microelectronics?0?5Inc?4@
CONST	SEGMENT
??_C@_0CA@ILGCAFHO@Kawasaki?5Microelectronics?0?5Inc?4@ DB 'Kawasaki Micr'
	DB	'oelectronics, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GPJFFKGK@Tyco?5Electronics?5Corp?4?0?5a?5TE?5Co@
CONST	SEGMENT
??_C@_0DH@GPJFFKGK@Tyco?5Electronics?5Corp?4?0?5a?5TE?5Co@ DB 'Tyco Elect'
	DB	'ronics Corp., a TE Connectivity Ltd. company', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BEKADALE@Y?4C?4?5Cable?5U?4S?4A?4?0?5Inc@
CONST	SEGMENT
??_C@_0BH@BEKADALE@Y?4C?4?5Cable?5U?4S?4A?4?0?5Inc@ DB 'Y.C. Cable U.S.A.'
	DB	', Inc', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05EBJDGKGA@Apple@
CONST	SEGMENT
??_C@_05EBJDGKGA@Apple@ DB 'Apple', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PALNNPFJ@OmniVision?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BO@PALNNPFJ@OmniVision?5Technologies?0?5Inc?4@ DB 'OmniVision Tech'
	DB	'nologies, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EENIFCCI@LaCie@
CONST	SEGMENT
??_C@_05EENIFCCI@LaCie@ DB 'LaCie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LGOLJEOJ@OMRON?5Corporation@
CONST	SEGMENT
??_C@_0BC@LGOLJEOJ@OMRON?5Corporation@ DB 'OMRON Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKEFINHN@Alcor?5Micro?0?5Corp?4@
CONST	SEGMENT
??_C@_0BD@CKEFINHN@Alcor?5Micro?0?5Corp?4@ DB 'Alcor Micro, Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PNCFOBBM@RATOC?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BE@PNCFOBBM@RATOC?5Systems?0?5Inc?4@ DB 'RATOC Systems, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CDPILELF@Roland?5Corporation@
CONST	SEGMENT
??_C@_0BD@CDPILELF@Roland?5Corporation@ DB 'Roland Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DBEKGGBP@AVM?5GmbH@
CONST	SEGMENT
??_C@_08DBEKGGBP@AVM?5GmbH@ DB 'AVM GmbH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLENFJNK@Y?9E?5Data?0?5Inc?4@
CONST	SEGMENT
??_C@_0P@DLENFJNK@Y?9E?5Data?0?5Inc?4@ DB 'Y-E Data, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JDHIHHMP@BAFO?1Quality?5Computer?5Accessori@
CONST	SEGMENT
??_C@_0CC@JDHIHHMP@BAFO?1Quality?5Computer?5Accessori@ DB 'BAFO/Quality C'
	DB	'omputer Accessories', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BPNCPPJL@Conexant?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@BPNCPPJL@Conexant?5Systems?0?5Inc?4@ DB 'Conexant Systems, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBOBFJIK@Elecom?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BB@LBOBFJIK@Elecom?5Co?4?0?5Ltd?4@ DB 'Elecom Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OEOLOEBO@EIZO?5Corporation@
CONST	SEGMENT
??_C@_0BB@OEOLOEBO@EIZO?5Corporation@ DB 'EIZO Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PCAMLHGM@WACOM?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BA@PCAMLHGM@WACOM?5Co?4?0?5Ltd?4@ DB 'WACOM Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LLCBPJLE@Cadence?5Design?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BN@LLCBPJLE@Cadence?5Design?5Systems?0?5Inc?4@ DB 'Cadence Design '
	DB	'Systems, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FGPDBDMF@ATEN?5International?5Co?4?5Ltd?4@
CONST	SEGMENT
??_C@_0BM@FGPDBDMF@ATEN?5International?5Co?4?5Ltd?4@ DB 'ATEN Internation'
	DB	'al Co. Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BLKLAKEJ@Fuji?5Xerox?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BF@BLKLAKEJ@Fuji?5Xerox?5Co?4?0?5Ltd?4@ DB 'Fuji Xerox Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FOPBDEC@Sony?5Corporation@
CONST	SEGMENT
??_C@_0BB@FOPBDEC@Sony?5Corporation@ DB 'Sony Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMAENH@Synopsys?0?5Inc?4@
CONST	SEGMENT
??_C@_0P@JMAENH@Synopsys?0?5Inc?4@ DB 'Synopsys, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OKBFFENA@Wacom?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BH@OKBFFENA@Wacom?5Technology?5Corp?4@ DB 'Wacom Technology Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OEIMDHJB@PLX?5Technology?0?5Inc?4@
CONST	SEGMENT
??_C@_0BF@OEIMDHJB@PLX?5Technology?0?5Inc?4@ DB 'PLX Technology, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MPHIFDML@ACON?0?5Advanced?9Connectek?0?5Inc?4@
CONST	SEGMENT
??_C@_0BP@MPHIFDML@ACON?0?5Advanced?9Connectek?0?5Inc?4@ DB 'ACON, Advanc'
	DB	'ed-Connectek, Inc.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IKHGDMKC@Taiwan?5Semiconductor?5Manufactur@
CONST	SEGMENT
??_C@_0CH@IKHGDMKC@Taiwan?5Semiconductor?5Manufactur@ DB 'Taiwan Semicond'
	DB	'uctor Manufacturing Co.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CJECLAIC@American?5Power?5Conversion@
CONST	SEGMENT
??_C@_0BK@CJECLAIC@American?5Power?5Conversion@ DB 'American Power Conver'
	DB	'sion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IEJECICL@Star?5Micronics?5Co?4?0?5LTD@
CONST	SEGMENT
??_C@_0BI@IEJECICL@Star?5Micronics?5Co?4?0?5LTD@ DB 'Star Micronics Co., '
	DB	'LTD', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MHMGALMF@Longwell?5Electronics?1Longwell?5C@
CONST	SEGMENT
??_C@_0CG@MHMGALMF@Longwell?5Electronics?1Longwell?5C@ DB 'Longwell Elect'
	DB	'ronics/Longwell Company', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EOOICECH@Belkin?5International?0?5Inc?4@
CONST	SEGMENT
??_C@_0BL@EOOICECH@Belkin?5International?0?5Inc?4@ DB 'Belkin Internation'
	DB	'al, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OMIFCFDP@Hosiden?5Corporation@
CONST	SEGMENT
??_C@_0BE@OMIFCFDP@Hosiden?5Corporation@ DB 'Hosiden Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IBNCPFMK@Acer?0?5Inc?4@
CONST	SEGMENT
??_C@_0L@IBNCPFMK@Acer?0?5Inc?4@ DB 'Acer, Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPKDLJPE@Fujikura?1DDK@
CONST	SEGMENT
??_C@_0N@HPKDLJPE@Fujikura?1DDK@ DB 'Fujikura/DDK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LAOEDIBA@PFU?5Limited@
CONST	SEGMENT
??_C@_0M@LAOEDIBA@PFU?5Limited@ DB 'PFU Limited', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LIIOOGBH@Brother?5Industries?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@LIIOOGBH@Brother?5Industries?0?5Ltd?4@ DB 'Brother Industries, '
	DB	'Ltd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JIJDPPMO@Newnex?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BI@JIJDPPMO@Newnex?5Technology?5Corp?4@ DB 'Newnex Technology Corp'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DEPAFADD@Chicony?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@DEPAFADD@Chicony?5Electronics?5Co?4?0?5Ltd?4@ DB 'Chicony Elect'
	DB	'ronics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EFCPDDGG@Tokyo?5Electron?5Device?5Limited@
CONST	SEGMENT
??_C@_0BO@EFCPDDGG@Tokyo?5Electron?5Device?5Limited@ DB 'Tokyo Electron D'
	DB	'evice Limited', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CGAOADOO@Samsung?5Electronics?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@CGAOADOO@Samsung?5Electronics?5Co?4?0?5Ltd?4@ DB 'Samsung Elect'
	DB	'ronics Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGMMMEDN@Identive?5Group?5Inc?4@
CONST	SEGMENT
??_C@_0BE@OGMMMEDN@Identive?5Group?5Inc?4@ DB 'Identive Group Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFOEADKM@Exar?5Corporation@
CONST	SEGMENT
??_C@_0BB@LFOEADKM@Exar?5Corporation@ DB 'Exar Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGIIFMHF@Sharp?5Corporation@
CONST	SEGMENT
??_C@_0BC@NGIIFMHF@Sharp?5Corporation@ DB 'Sharp Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HPBJICLA@Panasonic?5Corporation@
CONST	SEGMENT
??_C@_0BG@HPBJICLA@Panasonic?5Corporation@ DB 'Panasonic Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BJMPMCDF@Holtek?5Semiconductor?0?5Inc?4@
CONST	SEGMENT
??_C@_0BL@BJMPMCDF@Holtek?5Semiconductor?0?5Inc?4@ DB 'Holtek Semiconduct'
	DB	'or, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GLLPJAAH@Microchip?5Technology?5Inc?4@
CONST	SEGMENT
??_C@_0BK@GLLPJAAH@Microchip?5Technology?5Inc?4@ DB 'Microchip Technology'
	DB	' Inc.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIJNEFLL@Mentor?5Graphics@
CONST	SEGMENT
??_C@_0BA@BIJNEFLL@Mentor?5Graphics@ DB 'Mentor Graphics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIDIGMJE@ST?9Ericsson@
CONST	SEGMENT
??_C@_0M@CIDIGMJE@ST?9Ericsson@ DB 'ST-Ericsson', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DGJHAIHG@FUJIFILM?5Corporation@
CONST	SEGMENT
??_C@_0BF@DGJHAIHG@FUJIFILM?5Corporation@ DB 'FUJIFILM Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MFGIPGKK@Fujitsu?5Ltd?4@
CONST	SEGMENT
??_C@_0N@MFGIPGKK@Fujitsu?5Ltd?4@ DB 'Fujitsu Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NAOBNEME@I?9O?5Data?5Device?0?5Inc?4@
CONST	SEGMENT
??_C@_0BG@NAOBNEME@I?9O?5Data?5Device?0?5Inc?4@ DB 'I-O Data Device, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LODEJCJJ@Seiko?5Epson?5Corp?4@
CONST	SEGMENT
??_C@_0BC@LODEJCJJ@Seiko?5Epson?5Corp?4@ DB 'Seiko Epson Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IBBFBLCL@Compal?5Electronics?0?5Inc?4@
CONST	SEGMENT
??_C@_0BJ@IBBFBLCL@Compal?5Electronics?0?5Inc?4@ DB 'Compal Electronics, '
	DB	'Inc.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@POFNKNIM@ROHM?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0P@POFNKNIM@ROHM?5Co?4?0?5Ltd?4@ DB 'ROHM Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FGCLJBBL@Cypress?5Semiconductor@
CONST	SEGMENT
??_C@_0BG@FGCLJBBL@Cypress?5Semiconductor@ DB 'Cypress Semiconductor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HJPMHLJH@Pan?5International@
CONST	SEGMENT
??_C@_0BC@HJPMHLJH@Pan?5International@ DB 'Pan International', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GNNADKEG@Nikon?5Corporation@
CONST	SEGMENT
??_C@_0BC@GNNADKEG@Nikon?5Corporation@ DB 'Nikon Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GLDEECEB@Canon?5Inc?4@
CONST	SEGMENT
??_C@_0L@GLDEECEB@Canon?5Inc?4@ DB 'Canon Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OEADKIBB@Visioneer@
CONST	SEGMENT
??_C@_09OEADKIBB@Visioneer@ DB 'Visioneer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EDCNNFOI@Hitachi?0?5Ltd?4@
CONST	SEGMENT
??_C@_0O@EDCNNFOI@Hitachi?0?5Ltd?4@ DB 'Hitachi, Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LBNNEMMM@Yamaha?5Corporation@
CONST	SEGMENT
??_C@_0BD@LBNNEMMM@Yamaha?5Corporation@ DB 'Yamaha Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKEBEEJL@Samsung?5Semiconductor?0?5Inc?4@
CONST	SEGMENT
??_C@_0BM@FKEBEEJL@Samsung?5Semiconductor?0?5Inc?4@ DB 'Samsung Semicondu'
	DB	'ctor, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KONCBIDB@ITE?5Tech?5Inc?4@
CONST	SEGMENT
??_C@_0O@KONCBIDB@ITE?5Tech?5Inc?4@ DB 'ITE Tech Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OEHDDJBP@Foxconn?5?1?5Hon?5Hai@
CONST	SEGMENT
??_C@_0BC@OEHDDJBP@Foxconn?5?1?5Hon?5Hai@ DB 'Foxconn / Hon Hai', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KBJBCOHP@STMicroelectronics@
CONST	SEGMENT
??_C@_0BD@KBJBCOHP@STMicroelectronics@ DB 'STMicroelectronics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OKFLBHJF@Kyocera?5Corporation@
CONST	SEGMENT
??_C@_0BE@OKFLBHJF@Kyocera?5Corporation@ DB 'Kyocera Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKCENOI@Plantronics?0?5Inc?4@
CONST	SEGMENT
??_C@_0BC@JKCENOI@Plantronics?0?5Inc?4@ DB 'Plantronics, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JMLOFGEB@LSI?5Corporation@
CONST	SEGMENT
??_C@_0BA@JMLOFGEB@LSI?5Corporation@ DB 'LSI Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FBFHEDN@Semtech?5Corporation@
CONST	SEGMENT
??_C@_0BE@FBFHEDN@Semtech?5Corporation@ DB 'Semtech Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMJDEFAN@Logitech?5Inc?4@
CONST	SEGMENT
??_C@_0O@NMJDEFAN@Logitech?5Inc?4@ DB 'Logitech Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JEFPHDAK@American?5Megatrends@
CONST	SEGMENT
??_C@_0BE@JEFPHDAK@American?5Megatrends@ DB 'American Megatrends', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JJGMGNMK@Wieson?5Technologies?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BO@JJGMGNMK@Wieson?5Technologies?5Co?4?0?5Ltd?4@ DB 'Wieson Techno'
	DB	'logies Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFGIIEPJ@EATON@
CONST	SEGMENT
??_C@_05CFGIIEPJ@EATON@ DB 'EATON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CABKABLN@Primax?5Electronics@
CONST	SEGMENT
??_C@_0BD@CABKABLN@Primax?5Electronics@ DB 'Primax Electronics', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EOBPLLNH@Microsoft?5Corporation@
CONST	SEGMENT
??_C@_0BG@EOBPLLNH@Microsoft?5Corporation@ DB 'Microsoft Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EAFCJGLH@Renesas?5Electronics?5Corp?4@
CONST	SEGMENT
??_C@_0BK@EAFCJGLH@Renesas?5Electronics?5Corp?4@ DB 'Renesas Electronics '
	DB	'Corp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CIDHCDNI@KYE?5Systems?5Corp?4@
CONST	SEGMENT
??_C@_0BC@CIDHCDNI@KYE?5Systems?5Corp?4@ DB 'KYE Systems Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JOFOMFLH@Silicon?5Integrated?5Systems?5Corp@
CONST	SEGMENT
??_C@_0CB@JOFOMFLH@Silicon?5Integrated?5Systems?5Corp@ DB 'Silicon Integr'
	DB	'ated Systems Corp.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NEDOGEDE@Texas?5Instruments@
CONST	SEGMENT
??_C@_0BC@NEDOGEDE@Texas?5Instruments@ DB 'Texas Instruments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LOPMEJIG@Alps?5Electric?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BI@LOPMEJIG@Alps?5Electric?5Co?4?0?5Ltd?4@ DB 'Alps Electric Co., '
	DB	'Ltd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KCFEHCNK@Lexmark?5International?5Inc?4@
CONST	SEGMENT
??_C@_0BL@KCFEHCNK@Lexmark?5International?5Inc?4@ DB 'Lexmark Internation'
	DB	'al Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PDGAJDKJ@Advanced?5Micro?5Devices@
CONST	SEGMENT
??_C@_0BH@PDGAJDKJ@Advanced?5Micro?5Devices@ DB 'Advanced Micro Devices', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BGJHIBOH@Fujitsu?5Component?5Limited@
CONST	SEGMENT
??_C@_0BK@BGJHIBOH@Fujitsu?5Component?5Limited@ DB 'Fujitsu Component Lim'
	DB	'ited', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JMLDMEEO@Molex?5Inc?4@
CONST	SEGMENT
??_C@_0L@JMLDMEEO@Molex?5Inc?4@ DB 'Molex Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CCJOOIOC@HANRICO?5ANFU?5ELECTRONICS?5CO?4?0?5L@
CONST	SEGMENT
??_C@_0CD@CCJOOIOC@HANRICO?5ANFU?5ELECTRONICS?5CO?4?0?5L@ DB 'HANRICO ANF'
	DB	'U ELECTRONICS CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IOJGIKGH@Shenzhen?5Jiali?5Asia?5Industry?5Co@
CONST	SEGMENT
??_C@_0CH@IOJGIKGH@Shenzhen?5Jiali?5Asia?5Industry?5Co@ DB 'Shenzhen Jial'
	DB	'i Asia Industry Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OCAFANDG@TazTag@
CONST	SEGMENT
??_C@_06OCAFANDG@TazTag@ DB 'TazTag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIDEGHFG@Canopy?5Co?4@
CONST	SEGMENT
??_C@_0L@LIDEGHFG@Canopy?5Co?4@ DB 'Canopy Co.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MCBAPFNP@Silicon?5Works@
CONST	SEGMENT
??_C@_0O@MCBAPFNP@Silicon?5Works@ DB 'Silicon Works', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PHPIBLMN@IMBEL?5?9?5Industria?5de?5Material?5B@
CONST	SEGMENT
??_C@_0CP@PHPIBLMN@IMBEL?5?9?5Industria?5de?5Material?5B@ DB 'IMBEL - Ind'
	DB	'ustria de Material Belico do Brasil', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DABAPGE@TOPTICA?5Photonics?5AG@
CONST	SEGMENT
??_C@_0BF@DABAPGE@TOPTICA?5Photonics?5AG@ DB 'TOPTICA Photonics AG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONPNMHGL@X?4O?4Ware?0?5Inc?4@
CONST	SEGMENT
??_C@_0P@ONPNMHGL@X?4O?4Ware?0?5Inc?4@ DB 'X.O.Ware, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MGMHGHJM@Gowin?5Technology?5International?5@
CONST	SEGMENT
??_C@_0DA@MGMHGHJM@Gowin?5Technology?5International?5@ DB 'Gowin Technolo'
	DB	'gy International Holdings Limited', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PABKADHE@PN?5Devices?5Int?8l?5Limited@
CONST	SEGMENT
??_C@_0BJ@PABKADHE@PN?5Devices?5Int?8l?5Limited@ DB 'PN Devices Int''l Li'
	DB	'mited', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BLMGKMKN@Shenzhen?5Carbetter?5Technology?5C@
CONST	SEGMENT
??_C@_0CI@BLMGKMKN@Shenzhen?5Carbetter?5Technology?5C@ DB 'Shenzhen Carbe'
	DB	'tter Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIPFEPEC@Canova?5Tech@
CONST	SEGMENT
??_C@_0M@HIPFEPEC@Canova?5Tech@ DB 'Canova Tech', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DOJBOOAF@Dongguan?5Haitai?5Precision?5Elect@
CONST	SEGMENT
??_C@_0DH@DOJBOOAF@Dongguan?5Haitai?5Precision?5Elect@ DB 'Dongguan Haita'
	DB	'i Precision Electronic Technology Co Ltd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KBLAAA@The?5Eye?5Tribe@
CONST	SEGMENT
??_C@_0O@KBLAAA@The?5Eye?5Tribe@ DB 'The Eye Tribe', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BMMLIJOO@Tekinvest?5Holding?5Ltd?4@
CONST	SEGMENT
??_C@_0BH@BMMLIJOO@Tekinvest?5Holding?5Ltd?4@ DB 'Tekinvest Holding Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NHGMKJBI@Union?5Electric?5Plug?5?$CG?5Connector@
CONST	SEGMENT
??_C@_0CG@NHGMKJBI@Union?5Electric?5Plug?5?$CG?5Connector@ DB 'Union Elec'
	DB	'tric Plug & Connector Corp.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HIFLHKGA@MESTEC?5Technologies@
CONST	SEGMENT
??_C@_0BE@HIFLHKGA@MESTEC?5Technologies@ DB 'MESTEC Technologies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NGPFIJGG@WINTOUCH?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BD@NGPFIJGG@WINTOUCH?5Co?4?0?5Ltd?4@ DB 'WINTOUCH Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMJCOJDA@Unwired?5Technology@
CONST	SEGMENT
??_C@_0BD@FMJCOJDA@Unwired?5Technology@ DB 'Unwired Technology', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OGFEGMLJ@Choy?8s?5Import@
CONST	SEGMENT
??_C@_0O@OGFEGMLJ@Choy?8s?5Import@ DB 'Choy''s Import', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ENHANOON@ADPlaus?5Technology?5Limited@
CONST	SEGMENT
??_C@_0BL@ENHANOON@ADPlaus?5Technology?5Limited@ DB 'ADPlaus Technology L'
	DB	'imited', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NLOPDBDL@SHIGA?5MEC?5Company?5Limited@
CONST	SEGMENT
??_C@_0BK@NLOPDBDL@SHIGA?5MEC?5Company?5Limited@ DB 'SHIGA MEC Company Li'
	DB	'mited', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JPDEBJJP@Singeen?5Electronics?5Technologie@
CONST	SEGMENT
??_C@_0DG@JPDEBJJP@Singeen?5Electronics?5Technologie@ DB 'Singeen Electro'
	DB	'nics Technologies (Dongguan) Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HMOEOKL@DUALO@
CONST	SEGMENT
??_C@_05HMOEOKL@DUALO@ DB 'DUALO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@CKMMCADD@Shenzhen?5DTEC?5Electronic?5Techno@
CONST	SEGMENT
??_C@_0CO@CKMMCADD@Shenzhen?5DTEC?5Electronic?5Techno@ DB 'Shenzhen DTEC '
	DB	'Electronic Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DPKKEBHA@Krypton?5Solutions@
CONST	SEGMENT
??_C@_0BC@DPKKEBHA@Krypton?5Solutions@ DB 'Krypton Solutions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CMDOPKDP@HashFast?5Technologies?5LLC@
CONST	SEGMENT
??_C@_0BK@CMDOPKDP@HashFast?5Technologies?5LLC@ DB 'HashFast Technologies'
	DB	' LLC', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FECCLEDH@Williams?5Sound?0?5LLC@
CONST	SEGMENT
??_C@_0BE@FECCLEDH@Williams?5Sound?0?5LLC@ DB 'Williams Sound, LLC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JDKPEMPD@Imaging?5Solutions?5Group?5of?5NY?0?5@
CONST	SEGMENT
??_C@_0CE@JDKPEMPD@Imaging?5Solutions?5Group?5of?5NY?0?5@ DB 'Imaging Sol'
	DB	'utions Group of NY, Inc.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MAEFHCII@Shenzhen?5Zowee?5Technology?5Co?4?0?5@
CONST	SEGMENT
??_C@_0CE@MAEFHCII@Shenzhen?5Zowee?5Technology?5Co?4?0?5@ DB 'Shenzhen Zo'
	DB	'wee Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFHEPOBE@COMOTA?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BB@HFHEPOBE@COMOTA?5Co?4?0?5Ltd?4@ DB 'COMOTA Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JMLEHFBM@Printrbot?0?5Inc?4@
CONST	SEGMENT
??_C@_0BA@JMLEHFBM@Printrbot?0?5Inc?4@ DB 'Printrbot, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHFHJJHL@Xacti?5Corporation@
CONST	SEGMENT
??_C@_0BC@CHFHJJHL@Xacti?5Corporation@ DB 'Xacti Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GMINFFHN@Nitero?0?5Inc?4@
CONST	SEGMENT
??_C@_0N@GMINFFHN@Nitero?0?5Inc?4@ DB 'Nitero, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IDFAGKLM@FingerQ?5Macao?5Commercial?5Offsho@
CONST	SEGMENT
??_C@_0CK@IDFAGKLM@FingerQ?5Macao?5Commercial?5Offsho@ DB 'FingerQ Macao '
	DB	'Commercial Offshore Limited', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KKEBBLNP@Wilocity?5Ltd?4@
CONST	SEGMENT
??_C@_0O@KKEBBLNP@Wilocity?5Ltd?4@ DB 'Wilocity Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLMBFEFA@Miselu?5Inc?4@
CONST	SEGMENT
??_C@_0M@PLMBFEFA@Miselu?5Inc?4@ DB 'Miselu Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MCIOINLF@Power?5Probe?0?5Inc?4@
CONST	SEGMENT
??_C@_0BC@MCIOINLF@Power?5Probe?0?5Inc?4@ DB 'Power Probe, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBJGGOPP@Tecvox?5Connectivity?0?5LLC@
CONST	SEGMENT
??_C@_0BJ@PBJGGOPP@Tecvox?5Connectivity?0?5LLC@ DB 'Tecvox Connectivity, '
	DB	'LLC', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KPGMCBHJ@Britelite?5Enterprises@
CONST	SEGMENT
??_C@_0BG@KPGMCBHJ@Britelite?5Enterprises@ DB 'Britelite Enterprises', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IOJCEKJ@ENERMAX?5TECHNOLOGY?5CORPORATION@
CONST	SEGMENT
??_C@_0BP@IOJCEKJ@ENERMAX?5TECHNOLOGY?5CORPORATION@ DB 'ENERMAX TECHNOLOG'
	DB	'Y CORPORATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNIHDIBM@Inuitive@
CONST	SEGMENT
??_C@_08DNIHDIBM@Inuitive@ DB 'Inuitive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KBNIJBFJ@OBSIDIAN?5RESEARCH?5CORPORATION@
CONST	SEGMENT
??_C@_0BO@KBNIJBFJ@OBSIDIAN?5RESEARCH?5CORPORATION@ DB 'OBSIDIAN RESEARCH'
	DB	' CORPORATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NMHMOMNM@Dollar?5Connection?5Ltd?4@
CONST	SEGMENT
??_C@_0BH@NMHMOMNM@Dollar?5Connection?5Ltd?4@ DB 'Dollar Connection Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OMCAGFMI@SHIH?5HUA?5TECHNOLOGY?5LTD?4@
CONST	SEGMENT
??_C@_0BJ@OMCAGFMI@SHIH?5HUA?5TECHNOLOGY?5LTD?4@ DB 'SHIH HUA TECHNOLOGY '
	DB	'LTD.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EKMIGECI@Cellwise?5Holding?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@EKMIGECI@Cellwise?5Holding?5Co?4?0?5Ltd?4@ DB 'Cellwise Holding'
	DB	' Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LCIDFNGP@Terminus?5Circuits?5Pvt?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@LCIDFNGP@Terminus?5Circuits?5Pvt?5Ltd?4@ DB 'Terminus Circuits '
	DB	'Pvt Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LOIKONEK@Nokia?5Corporation@
CONST	SEGMENT
??_C@_0BC@LOIKONEK@Nokia?5Corporation@ DB 'Nokia Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBHONFCE@ZAGG?5Inc?4@
CONST	SEGMENT
??_C@_09BBHONFCE@ZAGG?5Inc?4@ DB 'ZAGG Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DLJLHDNK@SoftLab?5?9?5NSK@
CONST	SEGMENT
??_C@_0O@DLJLHDNK@SoftLab?5?9?5NSK@ DB 'SoftLab - NSK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NNFPJDN@Sanofi?9Aventis?5Deutschland?5GmbH@
CONST	SEGMENT
??_C@_0CA@NNFPJDN@Sanofi?9Aventis?5Deutschland?5GmbH@ DB 'Sanofi-Aventis '
	DB	'Deutschland GmbH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IJLFKJJB@Shenzhen?5Yiwanda?5Electronics?5Co@
CONST	SEGMENT
??_C@_0CH@IJLFKJJB@Shenzhen?5Yiwanda?5Electronics?5Co@ DB 'Shenzhen Yiwan'
	DB	'da Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BLAKEMMK@The?5SmarTV?5Company@
CONST	SEGMENT
??_C@_0BD@BLAKEMMK@The?5SmarTV?5Company@ DB 'The SmarTV Company', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMELJLJG@Tmax?5Digital?5Inc?4@
CONST	SEGMENT
??_C@_0BC@FMELJLJG@Tmax?5Digital?5Inc?4@ DB 'Tmax Digital Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCPHKEHG@LEAP?5Motion@
CONST	SEGMENT
??_C@_0M@MCPHKEHG@LEAP?5Motion@ DB 'LEAP Motion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LCOLLFLN@Nanjing?5Magewell?5Electronics?5Co@
CONST	SEGMENT
??_C@_0CH@LCOLLFLN@Nanjing?5Magewell?5Electronics?5Co@ DB 'Nanjing Magewe'
	DB	'll Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KLIICOHE@Peraso?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BK@KLIICOHE@Peraso?5Technologies?0?5Inc?4@ DB 'Peraso Technologies'
	DB	', Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KKIKDNPF@Jolla?5Ltd?4@
CONST	SEGMENT
??_C@_0L@KKIKDNPF@Jolla?5Ltd?4@ DB 'Jolla Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MJLLIIHL@Ineda?5Systems?5Inc?4@
CONST	SEGMENT
??_C@_0BD@MJLLIIHL@Ineda?5Systems?5Inc?4@ DB 'Ineda Systems Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HOAFENMH@Wellitec?5Development?5Limited@
CONST	SEGMENT
??_C@_0BN@HOAFENMH@Wellitec?5Development?5Limited@ DB 'Wellitec Developme'
	DB	'nt Limited', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CBINLKCB@GENUSION?0?5Inc?4@
CONST	SEGMENT
??_C@_0P@CBINLKCB@GENUSION?0?5Inc?4@ DB 'GENUSION, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CDIDDBG@Creative?5Labs@
CONST	SEGMENT
??_C@_0O@CDIDDBG@Creative?5Labs@ DB 'Creative Labs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEANDNHK@Vprime@
CONST	SEGMENT
??_C@_06LEANDNHK@Vprime@ DB 'Vprime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NHBBDDIH@Dongguan?5Digi?9in?5Digital?5Techno@
CONST	SEGMENT
??_C@_0CO@NHBBDDIH@Dongguan?5Digi?9in?5Digital?5Techno@ DB 'Dongguan Digi'
	DB	'-in Digital Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MMCLOPLO@Shanghai?5DynamiCode?5Company?5Ltd@
CONST	SEGMENT
??_C@_0CB@MMCLOPLO@Shanghai?5DynamiCode?5Company?5Ltd@ DB 'Shanghai Dynam'
	DB	'iCode Company Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KGCDNOHK@Research?5?$CG?5Development?5Center?5?5@
CONST	SEGMENT
??_C@_0CL@KGCDNOHK@Research?5?$CG?5Development?5Center?5?5@ DB 'Research '
	DB	'& Development Center  ELVEES OJSC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ENAAKLLF@Oceanwing?5International?5Co?4?0?5Lt@
CONST	SEGMENT
??_C@_0CC@ENAAKLLF@Oceanwing?5International?5Co?4?0?5Lt@ DB 'Oceanwing In'
	DB	'ternational Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HPLDADLK@Pan?5Xin?5Precision?5Electronics?5C@
CONST	SEGMENT
??_C@_0CI@HPLDADLK@Pan?5Xin?5Precision?5Electronics?5C@ DB 'Pan Xin Preci'
	DB	'sion Electronics Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JALGBKPD@Yota?5Devices?5Ltd?4@
CONST	SEGMENT
??_C@_0BC@JALGBKPD@Yota?5Devices?5Ltd?4@ DB 'Yota Devices Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CJNOHFGM@Sage?5Microelectronics?5Corp?4@
CONST	SEGMENT
??_C@_0BM@CJNOHFGM@Sage?5Microelectronics?5Corp?4@ DB 'Sage Microelectron'
	DB	'ics Corp.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CKJDNNGP@Kent?5Displays?5Inc?4@
CONST	SEGMENT
??_C@_0BD@CKJDNNGP@Kent?5Displays?5Inc?4@ DB 'Kent Displays Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JGPKGMHA@Teladin?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BC@JGPKGMHA@Teladin?5Co?4?0?5Ltd?4@ DB 'Teladin Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DOPCHCHO@Fugoo?5Inc?4@
CONST	SEGMENT
??_C@_0L@DOPCHCHO@Fugoo?5Inc?4@ DB 'Fugoo Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HIEOMNPE@IBCONN?5Technologies?5?$CIShenzhen?$CJ?5@
CONST	SEGMENT
??_C@_0CJ@HIEOMNPE@IBCONN?5Technologies?5?$CIShenzhen?$CJ?5@ DB 'IBCONN T'
	DB	'echnologies (Shenzhen) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIIGLOJL@Active?5Mind?5Technology@
CONST	SEGMENT
??_C@_0BH@PIIGLOJL@Active?5Mind?5Technology@ DB 'Active Mind Technology', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LNMEEJMI@Shenzhen?5Sen5?5Technology?5Co?4?0?5L@
CONST	SEGMENT
??_C@_0CD@LNMEEJMI@Shenzhen?5Sen5?5Technology?5Co?4?0?5L@ DB 'Shenzhen Se'
	DB	'n5 Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ICLJDKCA@Mimetics?5Inc?4@
CONST	SEGMENT
??_C@_0O@ICLJDKCA@Mimetics?5Inc?4@ DB 'Mimetics Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JGINGPIL@Masimo?5Corporation@
CONST	SEGMENT
??_C@_0BD@JGINGPIL@Masimo?5Corporation@ DB 'Masimo Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GLGOEHJJ@iDea?5USA?5Products?5Inc?4@
CONST	SEGMENT
??_C@_0BH@GLGOEHJJ@iDea?5USA?5Products?5Inc?4@ DB 'iDea USA Products Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BOMOIKOC@Charon?5Technologies?5LLC@
CONST	SEGMENT
??_C@_0BI@BOMOIKOC@Charon?5Technologies?5LLC@ DB 'Charon Technologies LLC'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GPHCMPGC@MIRAENANOTECH@
CONST	SEGMENT
??_C@_0O@GPHCMPGC@MIRAENANOTECH@ DB 'MIRAENANOTECH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HNBOMKEI@Marquardt?5Mechatronik?5GmbH@
CONST	SEGMENT
??_C@_0BL@HNBOMKEI@Marquardt?5Mechatronik?5GmbH@ DB 'Marquardt Mechatroni'
	DB	'k GmbH', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JLOLHNCB@Shin?5Hwa?5Contech?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BL@JLOLHNCB@Shin?5Hwa?5Contech?5Co?4?0?5Ltd?4@ DB 'Shin Hwa Contec'
	DB	'h Co., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DMBLDCEB@iProtoXi?5Oy@
CONST	SEGMENT
??_C@_0M@DMBLDCEB@iProtoXi?5Oy@ DB 'iProtoXi Oy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NCPGFKEN@Sonoma?5Wire?5Works@
CONST	SEGMENT
??_C@_0BC@NCPGFKEN@Sonoma?5Wire?5Works@ DB 'Sonoma Wire Works', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MBFKODKB@SHEN?5ZHEN?5SHI?5YUAN?5AI?5HARDWARE?5@
CONST	SEGMENT
??_C@_0DE@MBFKODKB@SHEN?5ZHEN?5SHI?5YUAN?5AI?5HARDWARE?5@ DB 'SHEN ZHEN S'
	DB	'HI YUAN AI HARDWARE ELECTRONIC CO., LTD.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IOFNGFIH@Dongguan?5City?5Guangye?5Electroni@
CONST	SEGMENT
??_C@_0CL@IOFNGFIH@Dongguan?5City?5Guangye?5Electroni@ DB 'Dongguan City '
	DB	'Guangye Electronic Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KAAEKANB@Glyph?5Production?5Technologies@
CONST	SEGMENT
??_C@_0BO@KAAEKANB@Glyph?5Production?5Technologies@ DB 'Glyph Production '
	DB	'Technologies', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGAHHGKD@BIAMP?5SYSTEMS@
CONST	SEGMENT
??_C@_0O@FGAHHGKD@BIAMP?5SYSTEMS@ DB 'BIAMP SYSTEMS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FIAKBIJJ@MEP?5TECH@
CONST	SEGMENT
??_C@_08FIAKBIJJ@MEP?5TECH@ DB 'MEP TECH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DHPPNOKD@Apollo?5Electrical?5Technology?5Co@
CONST	SEGMENT
??_C@_0CH@DHPPNOKD@Apollo?5Electrical?5Technology?5Co@ DB 'Apollo Electri'
	DB	'cal Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PBJBEILB@Surplus?5Electronic?5Technology?5C@
CONST	SEGMENT
??_C@_0CI@PBJBEILB@Surplus?5Electronic?5Technology?5C@ DB 'Surplus Electr'
	DB	'onic Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BBLEBCKI@Nuvoton?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BJ@BBLEBCKI@Nuvoton?5Technology?5Corp?4@ DB 'Nuvoton Technology Co'
	DB	'rp.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIFILODO@G?4SKILL?5Int?8l?5Enterprice?5Co?4?0?5L@
CONST	SEGMENT
??_C@_0CD@DIFILODO@G?4SKILL?5Int?8l?5Enterprice?5Co?4?0?5L@ DB 'G.SKILL I'
	DB	'nt''l Enterprice Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KMAMPINN@Shenzhen?5Ourconn?5Technology?5Co?4@
CONST	SEGMENT
??_C@_0CG@KMAMPINN@Shenzhen?5Ourconn?5Technology?5Co?4@ DB 'Shenzhen Ourc'
	DB	'onn Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMDKKJBN@Panda?5Ocean?5Inc?4@
CONST	SEGMENT
??_C@_0BB@HMDKKJBN@Panda?5Ocean?5Inc?4@ DB 'Panda Ocean Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@COFMCAMA@Tekron?5International@
CONST	SEGMENT
??_C@_0BF@COFMCAMA@Tekron?5International@ DB 'Tekron International', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CAKHPFKP@Electrogamez?5USA?5Inc?4@
CONST	SEGMENT
??_C@_0BG@CAKHPFKP@Electrogamez?5USA?5Inc?4@ DB 'Electrogamez USA Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DBDKKFKI@Golden?5Transmart?5International?5@
CONST	SEGMENT
??_C@_0CJ@DBDKKFKI@Golden?5Transmart?5International?5@ DB 'Golden Transma'
	DB	'rt International Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BCGCCHNK@FTK?5Corporation@
CONST	SEGMENT
??_C@_0BA@BCGCCHNK@FTK?5Corporation@ DB 'FTK Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EONFGNA@Changzhou?5Shi?5Wujin?5Miqi?5East?5E@
CONST	SEGMENT
??_C@_0DD@EONFGNA@Changzhou?5Shi?5Wujin?5Miqi?5East?5E@ DB 'Changzhou Shi'
	DB	' Wujin Miqi East Electronic Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OGAADAEC@SMARTMATIC?5INTERNATIONAL?5CORP?4@
CONST	SEGMENT
??_C@_0BP@OGAADAEC@SMARTMATIC?5INTERNATIONAL?5CORP?4@ DB 'SMARTMATIC INTE'
	DB	'RNATIONAL CORP.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CCPKGHJO@DongGuan?5City?5DHE?5Wire?5?$CG?5Cable?5@
CONST	SEGMENT
??_C@_0CJ@CCPKGHJO@DongGuan?5City?5DHE?5Wire?5?$CG?5Cable?5@ DB 'DongGuan'
	DB	' City DHE Wire & Cable Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNCLHBIA@ULTRACHIP?5Inc?4@
CONST	SEGMENT
??_C@_0P@DNCLHBIA@ULTRACHIP?5Inc?4@ DB 'ULTRACHIP Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EJPGPDCC@Giga?9Byte?5Technology?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BP@EJPGPDCC@Giga?9Byte?5Technology?5Co?4?0?5Ltd?4@ DB 'Giga-Byte T'
	DB	'echnology Co., Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PGCKDINF@ShenZhen?5Innovate?9link?5Precisio@
CONST	SEGMENT
??_C@_0DE@PGCKDINF@ShenZhen?5Innovate?9link?5Precisio@ DB 'ShenZhen Innov'
	DB	'ate-link Precision Hardware Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NACMFIML@Vitetech?5Int?8l?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BJ@NACMFIML@Vitetech?5Int?8l?5Co?4?0?5Ltd?4@ DB 'Vitetech Int''l C'
	DB	'o., Ltd.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HPLMDDDJ@Pleora?5Technologies?5Inc?4@
CONST	SEGMENT
??_C@_0BJ@HPLMDDDJ@Pleora?5Technologies?5Inc?4@ DB 'Pleora Technologies I'
	DB	'nc.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OLPMAFK@Sharkbay?5Technologies?5Pte?4?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@OLPMAFK@Sharkbay?5Technologies?5Pte?4?5Ltd?4@ DB 'Sharkbay Tech'
	DB	'nologies Pte. Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BHCNLHHB@Zynaptic?5Limited@
CONST	SEGMENT
??_C@_0BB@BHCNLHHB@Zynaptic?5Limited@ DB 'Zynaptic Limited', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DCMLCELG@Realta?5Entertainment?5Group@
CONST	SEGMENT
??_C@_0BL@DCMLCELG@Realta?5Entertainment?5Group@ DB 'Realta Entertainment'
	DB	' Group', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HBBMPLAJ@BUFFALO?5INC?4@
CONST	SEGMENT
??_C@_0N@HBBMPLAJ@BUFFALO?5INC?4@ DB 'BUFFALO INC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIJFGOMC@E?9SEEK?5Inc?4@
CONST	SEGMENT
??_C@_0M@EIJFGOMC@E?9SEEK?5Inc?4@ DB 'E-SEEK Inc.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CCGHLJI@Meadowlark?5Optics?5Incorporated@
CONST	SEGMENT
??_C@_0BP@CCGHLJI@Meadowlark?5Optics?5Incorporated@ DB 'Meadowlark Optics'
	DB	' Incorporated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FAMHIABA@Esselte?5Leitz?5GmbH?5?$CG?5Co?4?5KG@
CONST	SEGMENT
??_C@_0BM@FAMHIABA@Esselte?5Leitz?5GmbH?5?$CG?5Co?4?5KG@ DB 'Esselte Leit'
	DB	'z GmbH & Co. KG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FBKKDMPD@Tyrian?5Systems?0?5Inc?4@
CONST	SEGMENT
??_C@_0BF@FBKKDMPD@Tyrian?5Systems?0?5Inc?4@ DB 'Tyrian Systems, Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BBBBJNLH@Accumetrics?5Associates?0?5Inc?4@
CONST	SEGMENT
??_C@_0BN@BBBBJNLH@Accumetrics?5Associates?0?5Inc?4@ DB 'Accumetrics Asso'
	DB	'ciates, Inc.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IDHICNHG@SDJ?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@IDHICNHG@SDJ?5Technologies?0?5Inc?4@ DB 'SDJ Technologies, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@GPMPJMPK@TTAF?5Elektronik?5Sanayi?5ve?5Ticar@
CONST	SEGMENT
??_C@_0CM@GPMPJMPK@TTAF?5Elektronik?5Sanayi?5ve?5Ticar@ DB 'TTAF Elektron'
	DB	'ik Sanayi ve Ticaret Ltd. Sti.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JBDBNMBO@Hovercam@
CONST	SEGMENT
??_C@_08JBDBNMBO@Hovercam@ DB 'Hovercam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CAOGFENG@Voxx?5Accessories?5Corp?4@
CONST	SEGMENT
??_C@_0BH@CAOGFENG@Voxx?5Accessories?5Corp?4@ DB 'Voxx Accessories Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NAOLNMKN@mce?9systems?5Ltd?4@
CONST	SEGMENT
??_C@_0BB@NAOLNMKN@mce?9systems?5Ltd?4@ DB 'mce-systems Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMJKNCDK@MCCI?5Corporation@
CONST	SEGMENT
??_C@_0BB@DMJKNCDK@MCCI?5Corporation@ DB 'MCCI Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ILDBIJFO@Specwerkz@
CONST	SEGMENT
??_C@_09ILDBIJFO@Specwerkz@ DB 'Specwerkz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HBMJFDNE@Seeed?5Technology?5Limited@
CONST	SEGMENT
??_C@_0BJ@HBMJFDNE@Seeed?5Technology?5Limited@ DB 'Seeed Technology Limit'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHHADJK@Quantec?5SA@
CONST	SEGMENT
??_C@_0L@KHHADJK@Quantec?5SA@ DB 'Quantec SA', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LEHBDMGE@VIA?5Technologies?0?5Inc?4@
CONST	SEGMENT
??_C@_0BH@LEHBDMGE@VIA?5Technologies?0?5Inc?4@ DB 'VIA Technologies, Inc.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHLNPDBP@Black?5Diamond?5Video@
CONST	SEGMENT
??_C@_0BE@MHLNPDBP@Black?5Diamond?5Video@ DB 'Black Diamond Video', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PLPMOAKE@Beijing?5Jinke?5XinAn?5Technology?5@
CONST	SEGMENT
??_C@_0CJ@PLPMOAKE@Beijing?5Jinke?5XinAn?5Technology?5@ DB 'Beijing Jinke'
	DB	' XinAn Technology Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LNOFLHEK@Cabletech?5Electronics?5?$CIHong?5Kon@
CONST	SEGMENT
??_C@_0CM@LNOFLHEK@Cabletech?5Electronics?5?$CIHong?5Kon@ DB 'Cabletech E'
	DB	'lectronics (Hong Kong) Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KBADGJOK@BIOMATIQUES?5IDENTIFICATION?5SOLU@
CONST	SEGMENT
??_C@_0DF@KBADGJOK@BIOMATIQUES?5IDENTIFICATION?5SOLU@ DB 'BIOMATIQUES IDE'
	DB	'NTIFICATION SOLUTIONS PRIVATE LIMITED', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPLBOCAE@NEC?5Corporation@
CONST	SEGMENT
??_C@_0BA@KPLBOCAE@NEC?5Corporation@ DB 'NEC Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MNOLJHMM@Viconn?5Technology?5?$CIHK?$CJ?5Co?4?0?5Ltd@
CONST	SEGMENT
??_C@_0CB@MNOLJHMM@Viconn?5Technology?5?$CIHK?$CJ?5Co?4?0?5Ltd@ DB 'Vicon'
	DB	'n Technology (HK) Co., Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PKMDPELO@Quanta?5Computer?5Inc?4@
CONST	SEGMENT
??_C@_0BF@PKMDPELO@Quanta?5Computer?5Inc?4@ DB 'Quanta Computer Inc.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KGNDOHL@Full?5in?5Hope?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BH@KGNDOHL@Full?5in?5Hope?5Co?4?0?5Ltd?4@ DB 'Full in Hope Co., Lt'
	DB	'd.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LEICPGF@Yangtze?5Optical?5Fibre?5and?5Cable@
CONST	SEGMENT
??_C@_0CN@LEICPGF@Yangtze?5Optical?5Fibre?5and?5Cable@ DB 'Yangtze Optica'
	DB	'l Fibre and Cable Company Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MILEOKEB@Astronics?5Advanced?5Electronic?5S@
CONST	SEGMENT
??_C@_0CM@MILEOKEB@Astronics?5Advanced?5Electronic?5S@ DB 'Astronics Adva'
	DB	'nced Electronic Systems Corp.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GMANIEBL@HIGH?5TEK?5HARNESS?5ENTERPRISE?5CO?4@
CONST	SEGMENT
??_C@_0CG@GMANIEBL@HIGH?5TEK?5HARNESS?5ENTERPRISE?5CO?4@ DB 'HIGH TEK HAR'
	DB	'NESS ENTERPRISE CO., LTD.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FGPOPKKG@Power?5Integrations@
CONST	SEGMENT
??_C@_0BD@FGPOPKKG@Power?5Integrations@ DB 'Power Integrations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NLEDAFLA@Future?5Technology?5Devices?5Inter@
CONST	SEGMENT
??_C@_0DA@NLEDAFLA@Future?5Technology?5Devices?5Inter@ DB 'Future Technol'
	DB	'ogy Devices International Limited', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HCOKNFP@Presidium?5Instruments?5Pte?4?5Ltd?4@
CONST	SEGMENT
??_C@_0CA@HCOKNFP@Presidium?5Instruments?5Pte?4?5Ltd?4@ DB 'Presidium Ins'
	DB	'truments Pte. Ltd.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCBHMFI@Sibridge?5Tech?4@
CONST	SEGMENT
??_C@_0P@NCBHMFI@Sibridge?5Tech?4@ DB 'Sibridge Tech.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GHOGMBAO@VERTU?5Corporation?5Limited@
CONST	SEGMENT
??_C@_0BK@GHOGMBAO@VERTU?5Corporation?5Limited@ DB 'VERTU Corporation Lim'
	DB	'ited', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MEJFLCNJ@Elitegroup?5Computer?5Systems@
CONST	SEGMENT
??_C@_0BM@MEJFLCNJ@Elitegroup?5Computer?5Systems@ DB 'Elitegroup Computer'
	DB	' Systems', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LNNLJKDF@Shenzhen?5Huiding?5Technology?5Co?4@
CONST	SEGMENT
??_C@_0CF@LNNLJKDF@Shenzhen?5Huiding?5Technology?5Co?4@ DB 'Shenzhen Huid'
	DB	'ing Technology Co. Ltd.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJJMEBLG@iRobot?5Corporation@
CONST	SEGMENT
??_C@_0BD@JJJMEBLG@iRobot?5Corporation@ DB 'iRobot Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DEOCBHFP@Advantest?5Corporation@
CONST	SEGMENT
??_C@_0BG@DEOCBHFP@Advantest?5Corporation@ DB 'Advantest Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGJGOJNE@Mondokey?5Limited@
CONST	SEGMENT
??_C@_0BB@MGJGOJNE@Mondokey?5Limited@ DB 'Mondokey Limited', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FLHPAOCE@Suzhou?5WEIJU?5Electronics?5Techno@
CONST	SEGMENT
??_C@_0CO@FLHPAOCE@Suzhou?5WEIJU?5Electronics?5Techno@ DB 'Suzhou WEIJU E'
	DB	'lectronics Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FLONKIJ@Sanwin?5?$CIHK?$CJ?5Electronic?5Technolo@
CONST	SEGMENT
??_C@_0CM@FLONKIJ@Sanwin?5?$CIHK?$CJ?5Electronic?5Technolo@ DB 'Sanwin (H'
	DB	'K) Electronic Technology Co., Ltd.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NBCHGNBK@Liteconn?5Co?4?0?5Ltd?4@
CONST	SEGMENT
??_C@_0BD@NBCHGNBK@Liteconn?5Co?4?0?5Ltd?4@ DB 'Liteconn Co., Ltd.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CMFLPPM@M31?5Technology?5Corp?4@
CONST	SEGMENT
??_C@_0BF@CMFLPPM@M31?5Technology?5Corp?4@ DB 'M31 Technology Corp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GKDJMMLL@Hewlett?5Packard@
CONST	SEGMENT
??_C@_0BA@GKDJMMLL@Hewlett?5Packard@ DB 'Hewlett Packard', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LAHLPDGH@Mitsumi@
CONST	SEGMENT
??_C@_07LAHLPDGH@Mitsumi@ DB 'Mitsumi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ELLAHEBO@Atmel?5Corporation@
CONST	SEGMENT
??_C@_0BC@ELLAHEBO@Atmel?5Corporation@ DB 'Atmel Corporation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BDHNOJJE@Universal?5Electronics?5Inc?4?5?$CIDBA@
CONST	SEGMENT
??_C@_0CI@BDHNOJJE@Universal?5Electronics?5Inc?4?5?$CIDBA@ DB 'Universal '
	DB	'Electronics Inc. (DBA: TVIEW)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BBHAKCFP@FOOSUNG?5TECH@
CONST	SEGMENT
??_C@_0N@BBHAKCFP@FOOSUNG?5TECH@ DB 'FOOSUNG TECH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFCPEEHM@YUEN?5DA?5ELECTRONIC?5PRODUCTS?5FAC@
CONST	SEGMENT
??_C@_0CE@OFCPEEHM@YUEN?5DA?5ELECTRONIC?5PRODUCTS?5FAC@ DB 'YUEN DA ELECT'
	DB	'RONIC PRODUCTS FACTORY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
PUBLIC	??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Emplace_back@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Advance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@HUrandom_access_iterator_tag@0@@Z ; std::_Advance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,int>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z ; std::_Uninitialized_copy_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ; std::_Copy_memmove<void * *,void * *>
PUBLIC	??$_Copy_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Ptr_copy_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_copy_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$advance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::advance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,int>
PUBLIC	??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Distance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z ; std::_Distance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Seek_wrapped@PAX@std@@YAXAAPAPAXQAPAX@Z	; std::_Seek_wrapped<void *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAXPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX00AAV?$allocator@PAX@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<void *,void *,std::allocator<void *> >
PUBLIC	??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ; std::_Ptr_move_cat<void *,void *>
PUBLIC	??$_Get_unwrapped_n@PAXH$0A@@std@@YAPAPAXQAPAXH@Z ; std::_Get_unwrapped_n<void *,int,0>
PUBLIC	??$_Get_unwrapped@PAX@std@@YAPAPAXQAPAX@Z	; std::_Get_unwrapped<void *>
PUBLIC	??$_Zero_range@PAPAX@std@@YAPAPAXQAPAX0@Z	; std::_Zero_range<void * *>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Copy_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::_Copy_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$next@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@H@Z ; std::next<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$distance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Get_unwrapped@D@std@@YAPADQAD@Z		; std::_Get_unwrapped<char>
PUBLIC	??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
PUBLIC	?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAD0Urandom_access_iterator_tag@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	??$_Idl_distance@PAPAXPAPAX@std@@YA@ABQAPAX0@Z	; std::_Idl_distance<void * *,void * *>
PUBLIC	??$_Uninitialized_move@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX0PAPAXAAV?$allocator@PAX@0@@Z ; std::_Uninitialized_move<void * *,void * *,std::allocator<void *> >
PUBLIC	??$_Destroy_range1@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<unsigned char> >
PUBLIC	??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_value_construct_n1@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<void * *,unsigned int,std::allocator<void *> >
PUBLIC	??$_Destroy_range1@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<void *> >
PUBLIC	??$_Uninitialized_value_construct_n1@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<unsigned char *,unsigned int,std::allocator<unsigned char> >
PUBLIC	??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Adl_verify_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAXABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Adl_verify_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0ABV?$allocator@PAX@std@@$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAX@1@@Z ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1><std::allocator<void *> const &>
PUBLIC	??$forward@ABV?$allocator@PAX@std@@@std@@YAABV?$allocator@PAX@0@ABV10@@Z ; std::forward<std::allocator<void *> const &>
PUBLIC	??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
PUBLIC	??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z ; std::forward<std::allocator<unsigned char> const &>
PUBLIC	??$_UIntegral_to_buff@DK@std@@YAPADPADK@Z	; std::_UIntegral_to_buff<char,unsigned long>
PUBLIC	??$?0PADX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD0ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,void>
PUBLIC	?_Umove_if_noexcept1@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00U?$integral_constant@_N$00@2@@Z ; std::vector<void *,std::allocator<void *> >::_Umove_if_noexcept1
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Umove@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEII@Z ; std::vector<void *,std::allocator<void *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXQAPAXII@Z ; std::vector<void *,std::allocator<void *> >::_Change_array
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
PUBLIC	??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z ; std::_Pocca<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_value_construct_n@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@@Z ; std::_Uninitialized_value_construct_n<void * *,unsigned int,std::allocator<void *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z ; std::_Destroy_range<std::allocator<void *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1><>
PUBLIC	??$_Uninitialized_value_construct_n@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<unsigned char *,unsigned int,std::allocator<unsigned char> >
PUBLIC	??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void>
PUBLIC	??$move@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
PUBLIC	??$assign@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::assign<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,void>
PUBLIC	??$addressof@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@ABV10@@Z ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >
PUBLIC	??$?0ABV?$allocator@PAX@std@@X@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > ><std::allocator<void *> const &,void>
PUBLIC	??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>
PUBLIC	??$construct@PAXABQAX@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@QAPAXABQAX@Z ; std::_Default_allocator_traits<std::allocator<void *> >::construct<void *,void * const &>
PUBLIC	??$_Unfancy@PAX@std@@YAPAPAXPAPAX@Z		; std::_Unfancy<void *>
PUBLIC	??$forward@ABQAX@std@@YAABQAXABQAX@Z		; std::forward<void * const &>
PUBLIC	??$?0ABV?$allocator@E@std@@X@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > ><std::allocator<unsigned char> const &,void>
PUBLIC	??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z	; std::_Unfancy_maybe_null<unsigned char>
PUBLIC	??$move@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z ; std::move<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &>
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z ; std::_Integral_to_string<char,unsigned long>
PUBLIC	??$end@D$0BF@@std@@YAPADAAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z	; std::_Adl_verify_range<char *,char *>
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$allocator@PAX@2@XZ ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_first
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$allocator@PAX@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z ; std::_Default_allocator_traits<std::allocator<void *> >::max_size
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_second
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$allocator@E@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
PUBLIC	?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXAAV12@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Swap_all
PUBLIC	?deallocate@?$allocator@PAX@std@@QAEXQAPAXI@Z	; std::allocator<void *>::deallocate
PUBLIC	?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z	; std::allocator<void *>::allocate
PUBLIC	?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
PUBLIC	?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
PUBLIC	?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xlength
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myend
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$allocator@PAX@2@XZ ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_first
PUBLIC	?deallocate@?$allocator@E@std@@QAEXQAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$allocator@E@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
PUBLIC	?_Move_from@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_from
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Copy_alloc
PUBLIC	?_Has_unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@ABE_NXZ ; std::vector<void *,std::allocator<void *> >::_Has_unused_capacity
PUBLIC	?_Udefault@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAXI@Z ; std::vector<void *,std::allocator<void *> >::_Udefault
PUBLIC	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy
PUBLIC	?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE_NI@Z ; std::vector<void *,std::allocator<void *> >::_Buy
PUBLIC	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy
PUBLIC	?_Xrange@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xrange
PUBLIC	?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Orphan_range
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$allocator@PAX@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Mylast
PUBLIC	?_Udefault@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Udefault
PUBLIC	?_Buy@?$vector@EV?$allocator@E@std@@@std@@AAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=
PUBLIC	?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
PUBLIC	?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
PUBLIC	?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
PUBLIC	??0?$allocator@PAX@std@@QAE@XZ			; std::allocator<void *>::allocator<void *>
PUBLIC	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
PUBLIC	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
PUBLIC	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE@ABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_back_with_unused_capacity<void * const &>
PUBLIC	??$emplace_back@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABQAX@Z ; std::vector<void *,std::allocator<void *> >::emplace_back<void * const &>
PUBLIC	?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ; std::vector<void *,std::allocator<void *> >::push_back
PUBLIC	?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ; std::vector<void *,std::allocator<void *> >::clear
PUBLIC	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
PUBLIC	??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ; std::vector<void *,std::allocator<void *> >::operator[]
PUBLIC	?at@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ; std::vector<void *,std::allocator<void *> >::at
PUBLIC	??0?$allocator@E@std@@QAE@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::data
PUBLIC	_WinMain@16
PUBLIC	?AdjustProcessRights@@YAXXZ			; AdjustProcessRights
PUBLIC	?ModifyPrivilege@@YA_NPBD_N@Z			; ModifyPrivilege
PUBLIC	?GetWMIStatus@@YAXXZ				; GetWMIStatus
PUBLIC	?ThreadWMISystemVolumes@@YGIPAX@Z		; ThreadWMISystemVolumes
PUBLIC	?ThreadWMIHardwareSensor@@YGIPAX@Z		; ThreadWMIHardwareSensor
PUBLIC	?ThreadWMISystemPerformance@@YGIPAX@Z		; ThreadWMISystemPerformance
PUBLIC	?GetSystemStatusChanges@@YAXXZ			; GetSystemStatusChanges
PUBLIC	?GetSystemStatus@@YAXXZ				; GetSystemStatus
PUBLIC	?GetSystemDetails@@YAXXZ			; GetSystemDetails
PUBLIC	?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z	; GetSystemIPAddresses
PUBLIC	?PrinterInfo@@YGIPAX@Z				; PrinterInfo
PUBLIC	?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z ; GetMediaTypeList
PUBLIC	?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z ; GetPaperList
PUBLIC	?GetDeviceMode@@YAPAU_devicemodeA@@PBD0@Z	; GetDeviceMode
PUBLIC	?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z	; GetBinList
PUBLIC	?GetPrintersList@@YAHXZ				; GetPrintersList
PUBLIC	?PerformanceInfo@@YGIPAX@Z			; PerformanceInfo
PUBLIC	?DeviceDrivers@@YGIPAX@Z			; DeviceDrivers
PUBLIC	?SystemLogicalProcessorInforamtion@@YGIPAX@Z	; SystemLogicalProcessorInforamtion
PUBLIC	?CountSetBits@@YAKK@Z				; CountSetBits
PUBLIC	?SystemDirs@@YGIPAX@Z				; SystemDirs
PUBLIC	?LogicalDrives@@YGIPAX@Z			; LogicalDrives
PUBLIC	?DriverTypeName@@YAPADK@Z			; DriverTypeName
PUBLIC	?SystemTimes@@YGIPAX@Z				; SystemTimes
PUBLIC	?SystemMemory@@YGIPAX@Z				; SystemMemory
PUBLIC	?OSInfo@@YGIPAX@Z				; OSInfo
PUBLIC	?SystemInfo@@YGIPAX@Z				; SystemInfo
PUBLIC	?CurrentProcessorNumber@@YAKXZ			; CurrentProcessorNumber
PUBLIC	?ProcessorSpeedCalc@@YAMXZ			; ProcessorSpeedCalc
PUBLIC	?HwProfile@@YGIPAX@Z				; HwProfile
PUBLIC	?ProcessInfo@@YGIPAX@Z				; ProcessInfo
PUBLIC	??_GUSB@@QAEPAXI@Z				; USB::`scalar deleting destructor'
PUBLIC	?ThreadUSB@@YGIPAX@Z				; ThreadUSB
PUBLIC	?ThreadMessage@@YGIPAX@Z			; ThreadMessage
PUBLIC	?WndProcMessage@@YGJPAUHWND__@@IIJ@Z		; WndProcMessage
PUBLIC	?EndPendingThread@@YAXPAX@Z			; EndPendingThread
PUBLIC	?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
PUBLIC	?SetThreadName@@YAXPBDK@Z			; SetThreadName
PUBLIC	?LogElapsedTime@@YAXK_KPBD@Z			; LogElapsedTime
PUBLIC	?CalcElapsedTime@@YAX_KAA_KAAN1@Z		; CalcElapsedTime
PUBLIC	?SysTick@@YA_KXZ				; SysTick
PUBLIC	?GetWinVer@@YAKXZ				; GetWinVer
PUBLIC	?WideStrToMultiStr@@YAPADPA_W@Z			; WideStrToMultiStr
PUBLIC	?AppUnhandledExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; AppUnhandledExceptionFilter
PUBLIC	?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z	; CreateMiniDump
PUBLIC	?RedirectSetUnhandledExceptionFilter@@YAHXZ	; RedirectSetUnhandledExceptionFilter
PUBLIC	?ReportAttemptsToSetUnhandledExceptionFilter@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ; ReportAttemptsToSetUnhandledExceptionFilter
PUBLIC	?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ; parseNullTerminatedStrings
PUBLIC	?GUID2Str@@YAPADPAU_GUID@@PADI@Z		; GUID2Str
PUBLIC	?USBTraceInfo@@YAXPAD0@Z			; USBTraceInfo
PUBLIC	?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
PUBLIC	?CheckLogFileSize@@YAXK@Z			; CheckLogFileSize
PUBLIC	?DebugStringToFile@@YAXPADH@Z			; DebugStringToFile
PUBLIC	?_thGetInt@@YAHPAH@Z				; _thGetInt
PUBLIC	?_thSetInt@@YAXPAHH@Z				; _thSetInt
PUBLIC	?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ; std::chrono::steady_clock::now
PUBLIC	?IsChanged@MonitorIPs@@QAE_NXZ			; MonitorIPs::IsChanged
PUBLIC	?GetIPs@MonitorIPs@@QAEXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; MonitorIPs::GetIPs
PUBLIC	??1MonitorIPs@@QAE@XZ				; MonitorIPs::~MonitorIPs
PUBLIC	??0MonitorIPs@@QAE@XZ				; MonitorIPs::MonitorIPs
PUBLIC	?GetVendorString@USB@@SAPADG@Z			; USB::GetVendorString
PUBLIC	??1USB@@QAE@XZ					; USB::~USB
PUBLIC	??0USB@@QAE@XZ					; USB::USB
PUBLIC	?_clear@PBuffer@@QAEXXZ				; PBuffer::_clear
PUBLIC	?_allocMem@PBuffer@@QAEPAEI@Z			; PBuffer::_allocMem
PUBLIC	??1PBuffer@@QAE@XZ				; PBuffer::~PBuffer
PUBLIC	??0PBuffer@@QAE@XZ				; PBuffer::PBuffer
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z ; std::to_string
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
PUBLIC	_sprintf
PUBLIC	__vsprintf_l
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	?strstr@@YAPADQADQBD@Z				; strstr
PUBLIC	?strchr@@YAPADQADH@Z				; strchr
PUBLIC	?Log@@YAXHHPBDZZ				; Log
PUBLIC	?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A ; PendingThreads
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A DB 0cH DUP (?) ; PendingThreads
_BSS	ENDS
CRT$XCU	SEGMENT
?PendingThreads$initializer$@@3P6AXXZA DD FLAT:??__EPendingThreads@@YAXXZ ; PendingThreads$initializer$
?USBVendorIDs@@3PAUUSBVENDORID@@A DW 02716H		; USBVendorIDs
	ORG $+2
	DD	FLAT:??_C@_0CE@OFCPEEHM@YUEN?5DA?5ELECTRONIC?5PRODUCTS?5FAC@
	DW	02722H
	ORG $+2
	DD	FLAT:??_C@_0N@BBHAKCFP@FOOSUNG?5TECH@
	DW	02726H
	ORG $+2
	DD	FLAT:??_C@_0CI@BDHNOJJE@Universal?5Electronics?5Inc?4?5?$CIDBA@
	DW	03ebH
	ORG $+2
	DD	FLAT:??_C@_0BC@ELLAHEBO@Atmel?5Corporation@
	DW	03eeH
	ORG $+2
	DD	FLAT:??_C@_07LAHLPDGH@Mitsumi@
	DW	03f0H
	ORG $+2
	DD	FLAT:??_C@_0BA@GKDJMMLL@Hewlett?5Packard@
	DW	02780H
	ORG $+2
	DD	FLAT:??_C@_0BF@CMFLPPM@M31?5Technology?5Corp?4@
	DW	02781H
	ORG $+2
	DD	FLAT:??_C@_0BD@NBCHGNBK@Liteconn?5Co?4?0?5Ltd?4@
	DW	02788H
	ORG $+2
	DD	FLAT:??_C@_0CM@FLONKIJ@Sanwin?5?$CIHK?$CJ?5Electronic?5Technolo@
	DW	02789H
	ORG $+2
	DD	FLAT:??_C@_0CO@FLHPAOCE@Suzhou?5WEIJU?5Electronics?5Techno@
	DW	027a0H
	ORG $+2
	DD	FLAT:??_C@_0BB@MGJGOJNE@Mondokey?5Limited@
	DW	027a5H
	ORG $+2
	DD	FLAT:??_C@_0BG@DEOCBHFP@Advantest?5Corporation@
	DW	027a6H
	ORG $+2
	DD	FLAT:??_C@_0BD@JJJMEBLG@iRobot?5Corporation@
	DW	027c6H
	ORG $+2
	DD	FLAT:??_C@_0CF@LNNLJKDF@Shenzhen?5Huiding?5Technology?5Co?4@
	DW	03fcH
	ORG $+2
	DD	FLAT:??_C@_0BM@MEJFLCNJ@Elitegroup?5Computer?5Systems@
	DW	027f1H
	ORG $+2
	DD	FLAT:??_C@_0BK@GHOGMBAO@VERTU?5Corporation?5Limited@
	DW	027f2H
	ORG $+2
	DD	FLAT:??_C@_0P@NCBHMFI@Sibridge?5Tech?4@
	DW	0281cH
	ORG $+2
	DD	FLAT:??_C@_0CA@HCOKNFP@Presidium?5Instruments?5Pte?4?5Ltd?4@
	DW	0403H
	ORG $+2
	DD	FLAT:??_C@_0DA@NLEDAFLA@Future?5Technology?5Devices?5Inter@
	DW	02831H
	ORG $+2
	DD	FLAT:??_C@_0BD@FGPOPKKG@Power?5Integrations@
	DW	0283cH
	ORG $+2
	DD	FLAT:??_C@_0CG@GMANIEBL@HIGH?5TEK?5HARNESS?5ENTERPRISE?5CO?4@
	DW	02849H
	ORG $+2
	DD	FLAT:??_C@_0CM@MILEOKEB@Astronics?5Advanced?5Electronic?5S@
	DW	0284aH
	ORG $+2
	DD	FLAT:??_C@_0CN@LEICPGF@Yangtze?5Optical?5Fibre?5and?5Cable@
	DW	0284cH
	ORG $+2
	DD	FLAT:??_C@_0BH@KGNDOHL@Full?5in?5Hope?5Co?4?0?5Ltd?4@
	DW	0408H
	ORG $+2
	DD	FLAT:??_C@_0BF@PKMDPELO@Quanta?5Computer?5Inc?4@
	DW	02859H
	ORG $+2
	DD	FLAT:??_C@_0CB@MNOLJHMM@Viconn?5Technology?5?$CIHK?$CJ?5Co?4?0?5Ltd@
	DW	0409H
	ORG $+2
	DD	FLAT:??_C@_0BA@KPLBOCAE@NEC?5Corporation@
	DW	02863H
	ORG $+2
	DD	FLAT:??_C@_0DF@KBADGJOK@BIOMATIQUES?5IDENTIFICATION?5SOLU@
	DW	02878H
	ORG $+2
	DD	FLAT:??_C@_0CM@LNOFLHEK@Cabletech?5Electronics?5?$CIHong?5Kon@
	DW	0287fH
	ORG $+2
	DD	FLAT:??_C@_0CJ@PLPMOAKE@Beijing?5Jinke?5XinAn?5Technology?5@
	DW	02880H
	ORG $+2
	DD	FLAT:??_C@_0BE@MHLNPDBP@Black?5Diamond?5Video@
	DW	040dH
	ORG $+2
	DD	FLAT:??_C@_0BH@LEHBDMGE@VIA?5Technologies?0?5Inc?4@
	DW	02885H
	ORG $+2
	DD	FLAT:??_C@_0L@KHHADJK@Quantec?5SA@
	DW	02886H
	ORG $+2
	DD	FLAT:??_C@_0BJ@HBMJFDNE@Seeed?5Technology?5Limited@
	DW	02887H
	ORG $+2
	DD	FLAT:??_C@_09ILDBIJFO@Specwerkz@
	DW	040eH
	ORG $+2
	DD	FLAT:??_C@_0BB@DMJKNCDK@MCCI?5Corporation@
	DW	0288eH
	ORG $+2
	DD	FLAT:??_C@_0BB@NAOLNMKN@mce?9systems?5Ltd?4@
	DW	0288fH
	ORG $+2
	DD	FLAT:??_C@_0BH@CAOGFENG@Voxx?5Accessories?5Corp?4@
	DW	02894H
	ORG $+2
	DD	FLAT:??_C@_08JBDBNMBO@Hovercam@
	DW	02896H
	ORG $+2
	DD	FLAT:??_C@_0CM@GPMPJMPK@TTAF?5Elektronik?5Sanayi?5ve?5Ticar@
	DW	02897H
	ORG $+2
	DD	FLAT:??_C@_0BH@IDHICNHG@SDJ?5Technologies?0?5Inc?4@
	DW	02898H
	ORG $+2
	DD	FLAT:??_C@_0BN@BBBBJNLH@Accumetrics?5Associates?0?5Inc?4@
	DW	0289dH
	ORG $+2
	DD	FLAT:??_C@_0BF@FBKKDMPD@Tyrian?5Systems?0?5Inc?4@
	DW	0289eH
	ORG $+2
	DD	FLAT:??_C@_0BM@FAMHIABA@Esselte?5Leitz?5GmbH?5?$CG?5Co?4?5KG@
	DW	028a2H
	ORG $+2
	DD	FLAT:??_C@_0BP@CCGHLJI@Meadowlark?5Optics?5Incorporated@
	DW	028a6H
	ORG $+2
	DD	FLAT:??_C@_0M@EIJFGOMC@E?9SEEK?5Inc?4@
	DW	0411H
	ORG $+2
	DD	FLAT:??_C@_0N@HBBMPLAJ@BUFFALO?5INC?4@
	DW	028aaH
	ORG $+2
	DD	FLAT:??_C@_0BL@DCMLCELG@Realta?5Entertainment?5Group@
	DW	028aeH
	ORG $+2
	DD	FLAT:??_C@_0BB@BHCNLHHB@Zynaptic?5Limited@
	DW	028afH
	ORG $+2
	DD	FLAT:??_C@_0CA@OLPMAFK@Sharkbay?5Technologies?5Pte?4?5Ltd?4@
	DW	028b7H
	ORG $+2
	DD	FLAT:??_C@_0BJ@HPLMDDDJ@Pleora?5Technologies?5Inc?4@
	DW	028bfH
	ORG $+2
	DD	FLAT:??_C@_0BJ@NACMFIML@Vitetech?5Int?8l?5Co?4?0?5Ltd?4@
	DW	028c5H
	ORG $+2
	DD	FLAT:??_C@_0DE@PGCKDINF@ShenZhen?5Innovate?9link?5Precisio@
	DW	0414H
	ORG $+2
	DD	FLAT:??_C@_0BP@EJPGPDCC@Giga?9Byte?5Technology?5Co?4?0?5Ltd?4@
	DW	028c8H
	ORG $+2
	DD	FLAT:??_C@_0P@DNCLHBIA@ULTRACHIP?5Inc?4@
	DW	028c9H
	ORG $+2
	DD	FLAT:??_C@_0CJ@CCPKGHJO@DongGuan?5City?5DHE?5Wire?5?$CG?5Cable?5@
	DW	028cdH
	ORG $+2
	DD	FLAT:??_C@_0BP@OGAADAEC@SMARTMATIC?5INTERNATIONAL?5CORP?4@
	DW	028ceH
	ORG $+2
	DD	FLAT:??_C@_0DD@EONFGNA@Changzhou?5Shi?5Wujin?5Miqi?5East?5E@
	DW	028d2H
	ORG $+2
	DD	FLAT:??_C@_0BA@BCGCCHNK@FTK?5Corporation@
	DW	028d3H
	ORG $+2
	DD	FLAT:??_C@_0CJ@DBDKKFKI@Golden?5Transmart?5International?5@
	DW	028d6H
	ORG $+2
	DD	FLAT:??_C@_0BG@CAKHPFKP@Electrogamez?5USA?5Inc?4@
	DW	028d7H
	ORG $+2
	DD	FLAT:??_C@_0BF@COFMCAMA@Tekron?5International@
	DW	028d8H
	ORG $+2
	DD	FLAT:??_C@_0BB@HMDKKJBN@Panda?5Ocean?5Inc?4@
	DW	028d9H
	ORG $+2
	DD	FLAT:??_C@_0CG@KMAMPINN@Shenzhen?5Ourconn?5Technology?5Co?4@
	DW	028daH
	ORG $+2
	DD	FLAT:??_C@_0CD@DIFILODO@G?4SKILL?5Int?8l?5Enterprice?5Co?4?0?5L@
	DW	0416H
	ORG $+2
	DD	FLAT:??_C@_0BJ@BBLEBCKI@Nuvoton?5Technology?5Corp?4@
	DW	028e2H
	ORG $+2
	DD	FLAT:??_C@_0CI@PBJBEILB@Surplus?5Electronic?5Technology?5C@
	DW	028e3H
	ORG $+2
	DD	FLAT:??_C@_0CH@DHPPNOKD@Apollo?5Electrical?5Technology?5Co@
	DW	028e5H
	ORG $+2
	DD	FLAT:??_C@_08FIAKBIJJ@MEP?5TECH@
	DW	028e6H
	ORG $+2
	DD	FLAT:??_C@_0O@FGAHHGKD@BIAMP?5SYSTEMS@
	DW	028e7H
	ORG $+2
	DD	FLAT:??_C@_0BO@KAAEKANB@Glyph?5Production?5Technologies@
	DW	028eaH
	ORG $+2
	DD	FLAT:??_C@_0CL@IOFNGFIH@Dongguan?5City?5Guangye?5Electroni@
	DW	028ebH
	ORG $+2
	DD	FLAT:??_C@_0DE@MBFKODKB@SHEN?5ZHEN?5SHI?5YUAN?5AI?5HARDWARE?5@
	DW	028f4H
	ORG $+2
	DD	FLAT:??_C@_0BC@NCPGFKEN@Sonoma?5Wire?5Works@
	DW	028faH
	ORG $+2
	DD	FLAT:??_C@_0M@DMBLDCEB@iProtoXi?5Oy@
	DW	028fbH
	ORG $+2
	DD	FLAT:??_C@_0BL@JLOLHNCB@Shin?5Hwa?5Contech?5Co?4?0?5Ltd?4@
	DW	028feH
	ORG $+2
	DD	FLAT:??_C@_0BL@HNBOMKEI@Marquardt?5Mechatronik?5GmbH@
	DW	028ffH
	ORG $+2
	DD	FLAT:??_C@_0O@GPHCMPGC@MIRAENANOTECH@
	DW	02904H
	ORG $+2
	DD	FLAT:??_C@_0BI@BOMOIKOC@Charon?5Technologies?5LLC@
	DW	02905H
	ORG $+2
	DD	FLAT:??_C@_0BH@GLGOEHJJ@iDea?5USA?5Products?5Inc?4@
	DW	02906H
	ORG $+2
	DD	FLAT:??_C@_0BD@JGINGPIL@Masimo?5Corporation@
	DW	02907H
	ORG $+2
	DD	FLAT:??_C@_0O@ICLJDKCA@Mimetics?5Inc?4@
	DW	02908H
	ORG $+2
	DD	FLAT:??_C@_0CD@LNMEEJMI@Shenzhen?5Sen5?5Technology?5Co?4?0?5L@
	DW	02909H
	ORG $+2
	DD	FLAT:??_C@_0BH@PIIGLOJL@Active?5Mind?5Technology@
	DW	0290dH
	ORG $+2
	DD	FLAT:??_C@_0CJ@HIEOMNPE@IBCONN?5Technologies?5?$CIShenzhen?$CJ?5@
	DW	0290eH
	ORG $+2
	DD	FLAT:??_C@_0L@DOPCHCHO@Fugoo?5Inc?4@
	DW	02913H
	ORG $+2
	DD	FLAT:??_C@_0BC@JGPKGMHA@Teladin?5Co?4?0?5Ltd?4@
	DW	02914H
	ORG $+2
	DD	FLAT:??_C@_0BD@CKJDNNGP@Kent?5Displays?5Inc?4@
	DW	02915H
	ORG $+2
	DD	FLAT:??_C@_0BM@CJNOHFGM@Sage?5Microelectronics?5Corp?4@
	DW	02916H
	ORG $+2
	DD	FLAT:??_C@_0BC@JALGBKPD@Yota?5Devices?5Ltd?4@
	DW	02917H
	ORG $+2
	DD	FLAT:??_C@_0CI@HPLDADLK@Pan?5Xin?5Precision?5Electronics?5C@
	DW	0291aH
	ORG $+2
	DD	FLAT:??_C@_0CC@ENAAKLLF@Oceanwing?5International?5Co?4?0?5Lt@
	DW	0291dH
	ORG $+2
	DD	FLAT:??_C@_0CL@KGCDNOHK@Research?5?$CG?5Development?5Center?5?5@
	DW	0291eH
	ORG $+2
	DD	FLAT:??_C@_0CB@MMCLOPLO@Shanghai?5DynamiCode?5Company?5Ltd@
	DW	02922H
	ORG $+2
	DD	FLAT:??_C@_0CO@NHBBDDIH@Dongguan?5Digi?9in?5Digital?5Techno@
	DW	02923H
	ORG $+2
	DD	FLAT:??_C@_06LEANDNHK@Vprime@
	DW	041eH
	ORG $+2
	DD	FLAT:??_C@_0O@CDIDDBG@Creative?5Labs@
	DW	0292cH
	ORG $+2
	DD	FLAT:??_C@_0P@CBINLKCB@GENUSION?0?5Inc?4@
	DW	0292dH
	ORG $+2
	DD	FLAT:??_C@_0BN@HOAFENMH@Wellitec?5Development?5Limited@
	DW	02930H
	ORG $+2
	DD	FLAT:??_C@_0BD@MJLLIIHL@Ineda?5Systems?5Inc?4@
	DW	02931H
	ORG $+2
	DD	FLAT:??_C@_0L@KKIKDNPF@Jolla?5Ltd?4@
	DW	02932H
	ORG $+2
	DD	FLAT:??_C@_0BK@KLIICOHE@Peraso?5Technologies?0?5Inc?4@
	DW	02935H
	ORG $+2
	DD	FLAT:??_C@_0CH@LCOLLFLN@Nanjing?5Magewell?5Electronics?5Co@
	DW	02936H
	ORG $+2
	DD	FLAT:??_C@_0M@MCPHKEHG@LEAP?5Motion@
	DW	02937H
	ORG $+2
	DD	FLAT:??_C@_0BC@FMELJLJG@Tmax?5Digital?5Inc?4@
	DW	0293aH
	ORG $+2
	DD	FLAT:??_C@_0BD@BLAKEMMK@The?5SmarTV?5Company@
	DW	02940H
	ORG $+2
	DD	FLAT:??_C@_0CH@IJLFKJJB@Shenzhen?5Yiwanda?5Electronics?5Co@
	DW	02941H
	ORG $+2
	DD	FLAT:??_C@_0CA@NNFPJDN@Sanofi?9Aventis?5Deutschland?5GmbH@
	DW	02942H
	ORG $+2
	DD	FLAT:??_C@_0O@DLJLHDNK@SoftLab?5?9?5NSK@
	DW	02943H
	ORG $+2
	DD	FLAT:??_C@_09BBHONFCE@ZAGG?5Inc?4@
	DW	0421H
	ORG $+2
	DD	FLAT:??_C@_0BC@LOIKONEK@Nokia?5Corporation@
	DW	0294cH
	ORG $+2
	DD	FLAT:??_C@_0BL@LCIDFNGP@Terminus?5Circuits?5Pvt?5Ltd?4@
	DW	0294dH
	ORG $+2
	DD	FLAT:??_C@_0BL@EKMIGECI@Cellwise?5Holding?5Co?4?0?5Ltd?4@
	DW	0294eH
	ORG $+2
	DD	FLAT:??_C@_0BJ@OMCAGFMI@SHIH?5HUA?5TECHNOLOGY?5LTD?4@
	DW	0294fH
	ORG $+2
	DD	FLAT:??_C@_0BH@NMHMOMNM@Dollar?5Connection?5Ltd?4@
	DW	02957H
	ORG $+2
	DD	FLAT:??_C@_0BO@KBNIJBFJ@OBSIDIAN?5RESEARCH?5CORPORATION@
	DW	02959H
	ORG $+2
	DD	FLAT:??_C@_08DNIHDIBM@Inuitive@
	DW	0295aH
	ORG $+2
	DD	FLAT:??_C@_0BP@IOJCEKJ@ENERMAX?5TECHNOLOGY?5CORPORATION@
	DW	0295eH
	ORG $+2
	DD	FLAT:??_C@_0BG@KPGMCBHJ@Britelite?5Enterprises@
	DW	0295fH
	ORG $+2
	DD	FLAT:??_C@_0BJ@PBJGGOPP@Tecvox?5Connectivity?0?5LLC@
	DW	02960H
	ORG $+2
	DD	FLAT:??_C@_0BC@MCIOINLF@Power?5Probe?0?5Inc?4@
	DW	02961H
	ORG $+2
	DD	FLAT:??_C@_0M@PLMBFEFA@Miselu?5Inc?4@
	DW	02962H
	ORG $+2
	DD	FLAT:??_C@_0O@KKEBBLNP@Wilocity?5Ltd?4@
	DW	02963H
	ORG $+2
	DD	FLAT:??_C@_0CK@IDFAGKLM@FingerQ?5Macao?5Commercial?5Offsho@
	DW	0296aH
	ORG $+2
	DD	FLAT:??_C@_0N@GMINFFHN@Nitero?0?5Inc?4@
	DW	0296bH
	ORG $+2
	DD	FLAT:??_C@_0BC@CHFHJJHL@Xacti?5Corporation@
	DW	02974H
	ORG $+2
	DD	FLAT:??_C@_0BA@JMLEHFBM@Printrbot?0?5Inc?4@
	DW	02976H
	ORG $+2
	DD	FLAT:??_C@_0BB@HFHEPOBE@COMOTA?5Co?4?0?5Ltd?4@
	DW	02977H
	ORG $+2
	DD	FLAT:??_C@_0CE@MAEFHCII@Shenzhen?5Zowee?5Technology?5Co?4?0?5@
	DW	02978H
	ORG $+2
	DD	FLAT:??_C@_0CE@JDKPEMPD@Imaging?5Solutions?5Group?5of?5NY?0?5@
	DW	02979H
	ORG $+2
	DD	FLAT:??_C@_0BE@FECCLEDH@Williams?5Sound?0?5LLC@
	DW	0297cH
	ORG $+2
	DD	FLAT:??_C@_0BK@CMDOPKDP@HashFast?5Technologies?5LLC@
	DW	0297dH
	ORG $+2
	DD	FLAT:??_C@_0BC@DPKKEBHA@Krypton?5Solutions@
	DW	0297eH
	ORG $+2
	DD	FLAT:??_C@_0CO@CKMMCADD@Shenzhen?5DTEC?5Electronic?5Techno@
	DW	02985H
	ORG $+2
	DD	FLAT:??_C@_05HMOEOKL@DUALO@
	DW	0298aH
	ORG $+2
	DD	FLAT:??_C@_0DG@JPDEBJJP@Singeen?5Electronics?5Technologie@
	DW	02990H
	ORG $+2
	DD	FLAT:??_C@_0BK@NLOPDBDL@SHIGA?5MEC?5Company?5Limited@
	DW	02993H
	ORG $+2
	DD	FLAT:??_C@_0BL@ENHANOON@ADPlaus?5Technology?5Limited@
	DW	02994H
	ORG $+2
	DD	FLAT:??_C@_0O@OGFEGMLJ@Choy?8s?5Import@
	DW	02996H
	ORG $+2
	DD	FLAT:??_C@_0BD@FMJCOJDA@Unwired?5Technology@
	DW	0299cH
	ORG $+2
	DD	FLAT:??_C@_0BD@NGPFIJGG@WINTOUCH?5Co?4?0?5Ltd?4@
	DW	0299fH
	ORG $+2
	DD	FLAT:??_C@_0BE@HIFLHKGA@MESTEC?5Technologies@
	DW	029a1H
	ORG $+2
	DD	FLAT:??_C@_0CG@NHGMKJBI@Union?5Electric?5Plug?5?$CG?5Connector@
	DW	029a7H
	ORG $+2
	DD	FLAT:??_C@_0BH@BMMLIJOO@Tekinvest?5Holding?5Ltd?4@
	DW	029abH
	ORG $+2
	DD	FLAT:??_C@_0O@KBLAAA@The?5Eye?5Tribe@
	DW	029b1H
	ORG $+2
	DD	FLAT:??_C@_0DH@DOJBOOAF@Dongguan?5Haitai?5Precision?5Elect@
	DW	029b2H
	ORG $+2
	DD	FLAT:??_C@_0M@HIPFEPEC@Canova?5Tech@
	DW	029b4H
	ORG $+2
	DD	FLAT:??_C@_0CI@BLMGKMKN@Shenzhen?5Carbetter?5Technology?5C@
	DW	029b5H
	ORG $+2
	DD	FLAT:??_C@_0BJ@PABKADHE@PN?5Devices?5Int?8l?5Limited@
	DW	029b6H
	ORG $+2
	DD	FLAT:??_C@_0DA@MGMHGHJM@Gowin?5Technology?5International?5@
	DW	029b7H
	ORG $+2
	DD	FLAT:??_C@_0P@ONPNMHGL@X?4O?4Ware?0?5Inc?4@
	DW	029baH
	ORG $+2
	DD	FLAT:??_C@_0BF@DABAPGE@TOPTICA?5Photonics?5AG@
	DW	029bcH
	ORG $+2
	DD	FLAT:??_C@_0CP@PHPIBLMN@IMBEL?5?9?5Industria?5de?5Material?5B@
	DW	029bdH
	ORG $+2
	DD	FLAT:??_C@_0O@MCBAPFNP@Silicon?5Works@
	DW	029c0H
	ORG $+2
	DD	FLAT:??_C@_0L@LIDEGHFG@Canopy?5Co?4@
	DW	029c1H
	ORG $+2
	DD	FLAT:??_C@_06OCAFANDG@TazTag@
	DW	029c6H
	ORG $+2
	DD	FLAT:??_C@_0CH@IOJGIKGH@Shenzhen?5Jiali?5Asia?5Industry?5Co@
	DW	029c7H
	ORG $+2
	DD	FLAT:??_C@_0CD@CCJOOIOC@HANRICO?5ANFU?5ELECTRONICS?5CO?4?0?5L@
	DW	042fH
	ORG $+2
	DD	FLAT:??_C@_0L@JMLDMEEO@Molex?5Inc?4@
	DW	0430H
	ORG $+2
	DD	FLAT:??_C@_0BK@BGJHIBOH@Fujitsu?5Component?5Limited@
	DW	0438H
	ORG $+2
	DD	FLAT:??_C@_0BH@PDGAJDKJ@Advanced?5Micro?5Devices@
	DW	043dH
	ORG $+2
	DD	FLAT:??_C@_0BL@KCFEHCNK@Lexmark?5International?5Inc?4@
	DW	044eH
	ORG $+2
	DD	FLAT:??_C@_0BI@LOPMEJIG@Alps?5Electric?5Co?4?0?5Ltd?4@
	DW	0451H
	ORG $+2
	DD	FLAT:??_C@_0BC@NEDOGEDE@Texas?5Instruments@
	DW	0457H
	ORG $+2
	DD	FLAT:??_C@_0CB@JOFOMFLH@Silicon?5Integrated?5Systems?5Corp@
	DW	0458H
	ORG $+2
	DD	FLAT:??_C@_0BC@CIDHCDNI@KYE?5Systems?5Corp?4@
	DW	045bH
	ORG $+2
	DD	FLAT:??_C@_0BK@EAFCJGLH@Renesas?5Electronics?5Corp?4@
	DW	045eH
	ORG $+2
	DD	FLAT:??_C@_0BG@EOBPLLNH@Microsoft?5Corporation@
	DW	0461H
	ORG $+2
	DD	FLAT:??_C@_0BD@CABKABLN@Primax?5Electronics@
	DW	0463H
	ORG $+2
	DD	FLAT:??_C@_05CFGIIEPJ@EATON@
	DW	0468H
	ORG $+2
	DD	FLAT:??_C@_0BO@JJGMGNMK@Wieson?5Technologies?5Co?4?0?5Ltd?4@
	DW	046bH
	ORG $+2
	DD	FLAT:??_C@_0BE@JEFPHDAK@American?5Megatrends@
	DW	046dH
	ORG $+2
	DD	FLAT:??_C@_0O@NMJDEFAN@Logitech?5Inc?4@
	DW	047aH
	ORG $+2
	DD	FLAT:??_C@_0BE@FBFHEDN@Semtech?5Corporation@
	DW	047eH
	ORG $+2
	DD	FLAT:??_C@_0BA@JMLOFGEB@LSI?5Corporation@
	DW	047fH
	ORG $+2
	DD	FLAT:??_C@_0BC@JKCENOI@Plantronics?0?5Inc?4@
	DW	0482H
	ORG $+2
	DD	FLAT:??_C@_0BE@OKFLBHJF@Kyocera?5Corporation@
	DW	0483H
	ORG $+2
	DD	FLAT:??_C@_0BD@KBJBCOHP@STMicroelectronics@
	DW	0489H
	ORG $+2
	DD	FLAT:??_C@_0BC@OEHDDJBP@Foxconn?5?1?5Hon?5Hai@
	DW	048dH
	ORG $+2
	DD	FLAT:??_C@_0O@KONCBIDB@ITE?5Tech?5Inc?4@
	DW	0492H
	ORG $+2
	DD	FLAT:??_C@_0BM@FKEBEEJL@Samsung?5Semiconductor?0?5Inc?4@
	DW	0499H
	ORG $+2
	DD	FLAT:??_C@_0BD@LBNNEMMM@Yamaha?5Corporation@
	DW	04a4H
	ORG $+2
	DD	FLAT:??_C@_0O@EDCNNFOI@Hitachi?0?5Ltd?4@
	DW	04a7H
	ORG $+2
	DD	FLAT:??_C@_09OEADKIBB@Visioneer@
	DW	04a9H
	ORG $+2
	DD	FLAT:??_C@_0L@GLDEECEB@Canon?5Inc?4@
	DW	04b0H
	ORG $+2
	DD	FLAT:??_C@_0BC@GNNADKEG@Nikon?5Corporation@
	DW	04b1H
	ORG $+2
	DD	FLAT:??_C@_0BC@HJPMHLJH@Pan?5International@
	DW	04b4H
	ORG $+2
	DD	FLAT:??_C@_0BG@FGCLJBBL@Cypress?5Semiconductor@
	DW	04b5H
	ORG $+2
	DD	FLAT:??_C@_0P@POFNKNIM@ROHM?5Co?4?0?5Ltd?4@
	DW	04b7H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IBBFBLCL@Compal?5Electronics?0?5Inc?4@
	DW	04b8H
	ORG $+2
	DD	FLAT:??_C@_0BC@LODEJCJJ@Seiko?5Epson?5Corp?4@
	DW	04bbH
	ORG $+2
	DD	FLAT:??_C@_0BG@NAOBNEME@I?9O?5Data?5Device?0?5Inc?4@
	DW	04c5H
	ORG $+2
	DD	FLAT:??_C@_0N@MFGIPGKK@Fujitsu?5Ltd?4@
	DW	04cbH
	ORG $+2
	DD	FLAT:??_C@_0BF@DGJHAIHG@FUJIFILM?5Corporation@
	DW	04ccH
	ORG $+2
	DD	FLAT:??_C@_0M@CIDIGMJE@ST?9Ericsson@
	DW	04d6H
	ORG $+2
	DD	FLAT:??_C@_0BA@BIJNEFLL@Mentor?5Graphics@
	DW	04d8H
	ORG $+2
	DD	FLAT:??_C@_0BK@GLLPJAAH@Microchip?5Technology?5Inc?4@
	DW	04d9H
	ORG $+2
	DD	FLAT:??_C@_0BL@BJMPMCDF@Holtek?5Semiconductor?0?5Inc?4@
	DW	04daH
	ORG $+2
	DD	FLAT:??_C@_0BG@HPBJICLA@Panasonic?5Corporation@
	DW	04ddH
	ORG $+2
	DD	FLAT:??_C@_0BC@NGIIFMHF@Sharp?5Corporation@
	DW	04e2H
	ORG $+2
	DD	FLAT:??_C@_0BB@LFOEADKM@Exar?5Corporation@
	DW	04e6H
	ORG $+2
	DD	FLAT:??_C@_0BE@OGMMMEDN@Identive?5Group?5Inc?4@
	DW	04e8H
	ORG $+2
	DD	FLAT:??_C@_0BO@CGAOADOO@Samsung?5Electronics?5Co?4?0?5Ltd?4@
	DW	04ecH
	ORG $+2
	DD	FLAT:??_C@_0BO@EFCPDDGG@Tokyo?5Electron?5Device?5Limited@
	DW	04f2H
	ORG $+2
	DD	FLAT:??_C@_0BO@DEPAFADD@Chicony?5Electronics?5Co?4?0?5Ltd?4@
	DW	04f7H
	ORG $+2
	DD	FLAT:??_C@_0BI@JIJDPPMO@Newnex?5Technology?5Corp?4@
	DW	04f9H
	ORG $+2
	DD	FLAT:??_C@_0BJ@LIIOOGBH@Brother?5Industries?0?5Ltd?4@
	DW	04feH
	ORG $+2
	DD	FLAT:??_C@_0M@LAOEDIBA@PFU?5Limited@
	DW	0501H
	ORG $+2
	DD	FLAT:??_C@_0N@HPKDLJPE@Fujikura?1DDK@
	DW	0502H
	ORG $+2
	DD	FLAT:??_C@_0L@IBNCPFMK@Acer?0?5Inc?4@
	DW	0507H
	ORG $+2
	DD	FLAT:??_C@_0BE@OMIFCFDP@Hosiden?5Corporation@
	DW	050dH
	ORG $+2
	DD	FLAT:??_C@_0BL@EOOICECH@Belkin?5International?0?5Inc?4@
	DW	0516H
	ORG $+2
	DD	FLAT:??_C@_0CG@MHMGALMF@Longwell?5Electronics?1Longwell?5C@
	DW	0519H
	ORG $+2
	DD	FLAT:??_C@_0BI@IEJECICL@Star?5Micronics?5Co?4?0?5LTD@
	DW	051dH
	ORG $+2
	DD	FLAT:??_C@_0BK@CJECLAIC@American?5Power?5Conversion@
	DW	0520H
	ORG $+2
	DD	FLAT:??_C@_0CH@IKHGDMKC@Taiwan?5Semiconductor?5Manufactur@
	DW	0522H
	ORG $+2
	DD	FLAT:??_C@_0BP@MPHIFDML@ACON?0?5Advanced?9Connectek?0?5Inc?4@
	DW	0525H
	ORG $+2
	DD	FLAT:??_C@_0BF@OEIMDHJB@PLX?5Technology?0?5Inc?4@
	DW	0531H
	ORG $+2
	DD	FLAT:??_C@_0BH@OKBFFENA@Wacom?5Technology?5Corp?4@
	DW	053fH
	ORG $+2
	DD	FLAT:??_C@_0P@JMAENH@Synopsys?0?5Inc?4@
	DW	054cH
	ORG $+2
	DD	FLAT:??_C@_0BB@FOPBDEC@Sony?5Corporation@
	DW	0550H
	ORG $+2
	DD	FLAT:??_C@_0BF@BLKLAKEJ@Fuji?5Xerox?5Co?4?0?5Ltd?4@
	DW	0557H
	ORG $+2
	DD	FLAT:??_C@_0BM@FGPDBDMF@ATEN?5International?5Co?4?5Ltd?4@
	DW	0559H
	ORG $+2
	DD	FLAT:??_C@_0BN@LLCBPJLE@Cadence?5Design?5Systems?0?5Inc?4@
	DW	056aH
	ORG $+2
	DD	FLAT:??_C@_0BA@PCAMLHGM@WACOM?5Co?4?0?5Ltd?4@
	DW	056dH
	ORG $+2
	DD	FLAT:??_C@_0BB@OEOLOEBO@EIZO?5Corporation@
	DW	056eH
	ORG $+2
	DD	FLAT:??_C@_0BB@LBOBFJIK@Elecom?5Co?4?0?5Ltd?4@
	DW	0572H
	ORG $+2
	DD	FLAT:??_C@_0BH@BPNCPPJL@Conexant?5Systems?0?5Inc?4@
	DW	0576H
	ORG $+2
	DD	FLAT:??_C@_0CC@JDHIHHMP@BAFO?1Quality?5Computer?5Accessori@
	DW	057bH
	ORG $+2
	DD	FLAT:??_C@_0P@DLENFJNK@Y?9E?5Data?0?5Inc?4@
	DW	057cH
	ORG $+2
	DD	FLAT:??_C@_08DBEKGGBP@AVM?5GmbH@
	DW	0582H
	ORG $+2
	DD	FLAT:??_C@_0BD@CDPILELF@Roland?5Corporation@
	DW	0584H
	ORG $+2
	DD	FLAT:??_C@_0BE@PNCFOBBM@RATOC?5Systems?0?5Inc?4@
	DW	058fH
	ORG $+2
	DD	FLAT:??_C@_0BD@CKEFINHN@Alcor?5Micro?0?5Corp?4@
	DW	0590H
	ORG $+2
	DD	FLAT:??_C@_0BC@LGOLJEOJ@OMRON?5Corporation@
	DW	059fH
	ORG $+2
	DD	FLAT:??_C@_05EENIFCCI@LaCie@
	DW	05a9H
	ORG $+2
	DD	FLAT:??_C@_0BO@PALNNPFJ@OmniVision?5Technologies?0?5Inc?4@
	DW	05acH
	ORG $+2
	DD	FLAT:??_C@_05EBJDGKGA@Apple@
	DW	05adH
	ORG $+2
	DD	FLAT:??_C@_0BH@BEKADALE@Y?4C?4?5Cable?5U?4S?4A?4?0?5Inc@
	DW	05beH
	ORG $+2
	DD	FLAT:??_C@_0DH@GPJFFKGK@Tyco?5Electronics?5Corp?4?0?5a?5TE?5Co@
	DW	05c1H
	ORG $+2
	DD	FLAT:??_C@_0CA@ILGCAFHO@Kawasaki?5Microelectronics?0?5Inc?4@
	DW	05c6H
	ORG $+2
	DD	FLAT:??_C@_0O@JJANANCF@Qualcomm?0?5Inc@
	DW	05c8H
	ORG $+2
	DD	FLAT:??_C@_0CP@IMDHJGED@Foxlink?1Cheng?5Uei?5Precision?5Ind@
	DW	05caH
	ORG $+2
	DD	FLAT:??_C@_0BD@DNOMCPDN@Ricoh?5Company?5Ltd?4@
	DW	05daH
	ORG $+2
	DD	FLAT:??_C@_0BM@OADDMKLB@Microtek?5International?5Inc?4@
	DW	05e0H
	ORG $+2
	DD	FLAT:??_C@_0BE@JPKFBBCH@Symbol?5Technologies@
	DW	05e3H
	ORG $+2
	DD	FLAT:??_C@_0BE@CKIEML@Genesys?5Logic?0?5Inc?4@
	DW	05e5H
	ORG $+2
	DD	FLAT:??_C@_0BI@KBGKOOGJ@Fuji?5Electric?5Co?4?0?5Ltd?4@
	DW	05f5H
	ORG $+2
	DD	FLAT:??_C@_0BI@NBAANMIA@Unixtar?5Technology?5Inc?4@
	DW	05f9H
	ORG $+2
	DD	FLAT:??_C@_0O@FPONFABH@Datalogic?5ADC@
	DW	05ffH
	ORG $+2
	DD	FLAT:??_C@_0BD@PJDPEADK@LeCroy?5Corporation@
	DW	0603H
	ORG $+2
	DD	FLAT:??_C@_0BP@HAMNADII@Novatek?5Microelectronics?5Corp?4@
	DW	0609H
	ORG $+2
	DD	FLAT:??_C@_0BH@LJAJLGJE@SMK?5Manufacturing?5Inc?4@
	DW	060fH
	ORG $+2
	DD	FLAT:??_C@_0CE@IBGJKEKA@Joinsoon?5Electronics?5Mfg?4?5Co?4?0?5@
	DW	0613H
	ORG $+2
	DD	FLAT:??_C@_0CD@BNDJFIFN@TransAct?5Technologies?5Incorpora@
	DW	0619H
	ORG $+2
	DD	FLAT:??_C@_0BH@OFHNPHHH@Seiko?5Instruments?5Inc?4@
	DW	062eH
	ORG $+2
	DD	FLAT:??_C@_0BE@EBACAFBC@JPC?1MAIN?5SUPER?5Inc?4@
	DW	0639H
	ORG $+2
	DD	FLAT:??_C@_0P@GAMNDPPF@Chrontel?0?5Inc?4@
	DW	064bH
	ORG $+2
	DD	FLAT:??_C@_0CH@PMGKCBAF@Analog?5Devices?0?5Inc?4?5Developmen@
	DW	064cH
	ORG $+2
	DD	FLAT:??_C@_0BL@EBDNAMPI@Ji?9Haw?5Industrial?5Co?4?0?5Ltd@
	DW	064eH
	ORG $+2
	DD	FLAT:??_C@_0BC@HBOMJHJG@Suyin?5Corporation@
	DW	0655H
	ORG $+2
	DD	FLAT:??_C@_0BP@BBNBDGIM@Space?5Shuttle?5Hi?9Tech?5Co?4?0Ltd?4@
	DW	0656H
	ORG $+2
	DD	FLAT:??_C@_0BL@JPOIGLAH@Glory?5Mark?5Electronic?5Ltd?4@
	DW	0657H
	ORG $+2
	DD	FLAT:??_C@_0BJ@HLMOOHDB@Tekcon?5Electronics?5Corp?4@
	DW	0658H
	ORG $+2
	DD	FLAT:??_C@_0BE@DBNMJIBL@Sigma?5Designs?0?5Inc?4@
	DW	065fH
	ORG $+2
	DD	FLAT:??_C@_0DD@MJJJJEAM@Good?5Way?5Technology?5Co?4?0?5Ltd?4?5?$CG@
	DW	0660H
	ORG $+2
	DD	FLAT:??_C@_0CA@PAFBBAIH@TSAY?9E?5?$CIBVI?$CJ?5International?5Inc?4@
	DW	0661H
	ORG $+2
	DD	FLAT:??_C@_0BJ@PKNBNCAJ@Hamamatsu?5Photonics?5K?4K?4@
	DW	066aH
	ORG $+2
	DD	FLAT:??_C@_0BJ@BPDLABPC@Total?5Technologies?0?5Ltd?4@
	DW	067bH
	ORG $+2
	DD	FLAT:??_C@_0BK@PDKHMLGO@Prolific?5Technology?0?5Inc?4@
	DW	0413cH
	ORG $+2
	DD	FLAT:??_C@_09JOKCKELG@Dell?5Inc?4@
	DW	0690H
	ORG $+2
	DD	FLAT:??_C@_0BM@LFPCEBHN@Golden?5Bridge?5Electech?5Inc?4@
	DW	0699H
	ORG $+2
	DD	FLAT:??_C@_0BA@EMAGANPI@Tektronix?0?5Inc?4@
	DW	06adH
	ORG $+2
	DD	FLAT:??_C@_0CC@NHGJCBNO@Greatland?5Electronics?5Taiwan?5Lt@
	DW	06aeH
	ORG $+2
	DD	FLAT:??_C@_0P@DFEICALO@Testronic?5Labs@
	DW	06b8H
	ORG $+2
	DD	FLAT:??_C@_0BD@MFHNCDAI@Pixela?5Corporation@
	DW	06bcH
	ORG $+2
	DD	FLAT:??_C@_0BF@KBMIOCIB@Oki?5Data?5Corporation@
	DW	06bfH
	ORG $+2
	DD	FLAT:??_C@_0BC@PBNHDNIB@Leoco?5Corporation@
	DW	06c4H
	ORG $+2
	DD	FLAT:??_C@_0BJ@IAMJELKE@Bizlink?5Technology?0?5Inc?4@
	DW	06c8H
	ORG $+2
	DD	FLAT:??_C@_0L@IGNPDHHH@SIIG?0?5Inc?4@
	DW	06cbH
	ORG $+2
	DD	FLAT:??_C@_0P@OJHCGLE@Synaptics?5Inc?4@
	DW	06d3H
	ORG $+2
	DD	FLAT:??_C@_0CA@FPPDHAGC@Mitsubishi?5Electric?5Corporation@
	DW	06deH
	ORG $+2
	DD	FLAT:??_C@_0BM@BIPBCEJB@Heisei?5Technology?5Co?4?0?5Ltd?4@
	DW	070aH
	ORG $+2
	DD	FLAT:??_C@_0CA@MKILJNBK@Oki?5Electric?5Industry?5Co?4?0?5Ltd?4@
	DW	070dH
	ORG $+2
	DD	FLAT:??_C@_0BM@JIAGMEHO@Comoss?5Electronic?5Co?4?0?5Ltd?4@
	DW	0711H
	ORG $+2
	DD	FLAT:??_C@_0BP@JCFMJDGG@Magic?5Control?5Technology?5Corp?4@
	DW	0718H
	ORG $+2
	DD	FLAT:??_C@_0O@NNOCEOFA@Imation?5Corp?4@
	DW	072eH
	ORG $+2
	DD	FLAT:??_C@_0BA@IFGJOCOG@Sunix?5Co?4?0?5Ltd?4@
	DW	0736H
	ORG $+2
	DD	FLAT:??_C@_0BL@PJBMJABB@Lorom?5Industrial?5Co?4?0?5Ltd?4@
	DW	0764H
	ORG $+2
	DD	FLAT:??_C@_0BK@PCICHEDF@Cyber?5Power?5Systems?0?5Inc?4@
	DW	0766H
	ORG $+2
	DD	FLAT:??_C@_0CD@HFGLNKOO@Jess?9Link?5Products?5Co?4?0?5Ltd?4?5?$CIJ@
	DW	076bH
	ORG $+2
	DD	FLAT:??_C@_0BA@FCBANMAL@HID?5Global?5GmbH@
	DW	0779H
	ORG $+2
	DD	FLAT:??_C@_0BI@OBNCJIEM@Fairchild?5Semiconductor@
	DW	0781H
	ORG $+2
	DD	FLAT:??_C@_0BE@KACIGGGG@SanDisk?5Corporation@
	DW	0791H
	ORG $+2
	DD	FLAT:??_C@_0CB@LGBOFDFN@Copartner?5Technology?5Corporatio@
	DW	07a2H
	ORG $+2
	DD	FLAT:??_C@_0BL@MPFKAMGD@National?5Technical?5Systems@
	DW	07b3H
	ORG $+2
	DD	FLAT:??_C@_0O@OCMFCBHB@Plustek?0?5Inc?4@
	DW	07b4H
	ORG $+2
	DD	FLAT:??_C@_0BE@NJLEDFOB@OLYMPUS?5CORPORATION@
	DW	07b7H
	ORG $+2
	DD	FLAT:??_C@_0BH@MGBHEDBN@TIME?5Interconnect?5Ltd?4@
	DW	07caH
	ORG $+2
	DD	FLAT:??_C@_0BN@EGFACLDP@AVerMedia?5Technologies?0?5Inc?4@
	DW	07ccH
	ORG $+2
	DD	FLAT:??_C@_0BL@FNDINGLK@Carry?5Technology?5Co?4?0?5Ltd?4@
	DW	07cfH
	ORG $+2
	DD	FLAT:??_C@_0BJ@JKHOIPCI@Casio?5Computer?5Co?4?0?5Ltd?4@
	DW	07daH
	ORG $+2
	DD	FLAT:??_C@_0BJ@ODMCNPPD@Arasan?5Chip?5Systems?5Inc?4@
	DW	07dfH
	ORG $+2
	DD	FLAT:??_C@_0CA@BNLONGOH@David?5Electronics?5Company?0?5Ltd?4@
	DW	07f7H
	ORG $+2
	DD	FLAT:??_C@_0BE@OPFGKFFJ@Century?5Corporation@
	DW	080aH
	ORG $+2
	DD	FLAT:??_C@_0BO@CAINGGKC@Evermuch?5Technology?5Co?4?0?5Ltd?4@
	DW	0835H
	ORG $+2
	DD	FLAT:??_C@_0CB@POAJBKGF@Action?5Star?5Enterprise?5Co?4?0?5Ltd@
	DW	084aH
	ORG $+2
	DD	FLAT:??_C@_0O@COHJMHME@Wipro?5Limited@
	DW	086fH
	ORG $+2
	DD	FLAT:??_C@_0BB@CEKEIHLM@MEC?5IMEX?5INC?1HPT@
	DW	0897H
	ORG $+2
	DD	FLAT:??_C@_0BA@EMBEKEAB@Lauterbach?5GmbH@
	DW	089dH
	ORG $+2
	DD	FLAT:??_C@_0BP@PNBHHOAN@Icron?5Technologies?5Corporation@
	DW	08b9H
	ORG $+2
	DD	FLAT:??_C@_0BH@CFIMBAIC@RadioShack?5Corporation@
	DW	08c7H
	ORG $+2
	DD	FLAT:??_C@_0BO@JNLBBKDI@TAI?5TWUN?5ENTERPRISE?5CO?4?0?5LTD?4@
	DW	08dfH
	ORG $+2
	DD	FLAT:??_C@_0M@BEPEDALH@Spyrus?5Inc?4@
	DW	08e4H
	ORG $+2
	DD	FLAT:??_C@_0BE@PMKDDGDC@Pioneer?5Corporation@
	DW	08e6H
	ORG $+2
	DD	FLAT:??_C@_0L@NMFIDNE@Gemalto?5SA@
	DW	0906H
	ORG $+2
	DD	FLAT:??_C@_0BJ@DEEADHEC@FARADAY?5Technology?5Corp?4@
	DW	0909H
	ORG $+2
	DD	FLAT:??_C@_0BF@DGGIOLK@Audio?9Technica?5Corp?4@
	DW	090cH
	ORG $+2
	DD	FLAT:??_C@_0BO@BNPBHCJB@Silicon?5Motion?0?5Inc?4?5?9?5Taiwan@
	DW	091eH
	ORG $+2
	DD	FLAT:??_C@_0BF@OCKCLCDJ@Garmin?5International@
	DW	0930H
	ORG $+2
	DD	FLAT:??_C@_0BE@JMAMIBAH@Toshiba?5Corporation@
	DW	093aH
	ORG $+2
	DD	FLAT:??_C@_0BF@FDMCHING@Pixart?5Imaging?0?5Inc?4@
	DW	093bH
	ORG $+2
	DD	FLAT:??_C@_0M@DPPDGGNF@Plextor?5LLC@
	DW	093eH
	ORG $+2
	DD	FLAT:??_C@_0BG@PLHGNMC@J?4S?4T?4?5Mfg?4?5Co?4?0?5Ltd?4@
	DW	0951H
	ORG $+2
	DD	FLAT:??_C@_0BM@LKMMOGNE@Kingston?5Technology?5Company@
	DW	0955H
	ORG $+2
	DD	FLAT:??_C@_06HLMMPIBG@NVIDIA@
	DW	0957H
	ORG $+2
	DD	FLAT:??_C@_0BL@KLPBIJLK@Agilent?5Technologies?0?5Inc?4@
	DW	095bH
	ORG $+2
	DD	FLAT:??_C@_0BH@DIONPOBP@Medialogic?5Corporation@
	DW	095dH
	ORG $+2
	DD	FLAT:??_C@_0O@LKCCNLNO@Polycom?0?5Inc?4@
	DW	09a4H
	ORG $+2
	DD	FLAT:??_C@_0BH@NHOGNCFH@Contech?5Research?0?5Inc?4@
	DW	09a8H
	ORG $+2
	DD	FLAT:??_C@_0CA@NGELPCKK@Lin?5Shiung?5Enterprise?5Co?4?0?5Ltd?4@
	DW	09aaH
	ORG $+2
	DD	FLAT:??_C@_0BF@PGLGBHIA@Intersil?5Corporation@
	DW	09abH
	ORG $+2
	DD	FLAT:??_C@_0BN@OHPOFJEM@Japan?5Cash?5Machine?5Co?4?0?5Ltd?4@
	DW	09c2H
	ORG $+2
	DD	FLAT:??_C@_0BC@JHLIIJEE@NISCA?5Corporation@
	DW	09ccH
	ORG $+2
	DD	FLAT:??_C@_0BE@OJFDPOOK@Workbit?5Corporation@
	DW	09cfH
	ORG $+2
	DD	FLAT:??_C@_0CD@HNEJNPKP@Electronics?5Testing?5Center?0?5Tai@
	DW	09daH
	ORG $+2
	DD	FLAT:??_C@_0BG@LAHNEDCJ@A?9FOUR?5TECH?5CO?4?0?5LTD?4@
	DW	09fbH
	ORG $+2
	DD	FLAT:??_C@_06NEOADGIL@Altera@
	DW	0a12H
	ORG $+2
	DD	FLAT:??_C@_0BN@HOMOCJPC@Cambridge?5Silicon?5Radio?5Ltd?4@
	DW	0a17H
	ORG $+2
	DD	FLAT:??_C@_0BB@HPCCBBBB@HOYA?5Corporation@
	DW	0a21H
	ORG $+2
	DD	FLAT:??_C@_0BF@EKKNDOHK@Physio?9Control?0?5Inc?4@
	DW	0a47H
	ORG $+2
	DD	FLAT:??_C@_0BK@IKEGAKKP@Hirose?5Electric?5Co?4?0?5Ltd?4@
	DW	0a4cH
	ORG $+2
	DD	FLAT:??_C@_0BD@LHJHCFAG@COMPUTEX?5Co?4?0?5Ltd?4@
	DW	0a50H
	ORG $+2
	DD	FLAT:??_C@_0BN@FBNECLJJ@Mimaki?5Engineering?5Co?4?0?5Ltd?4@
	DW	0a5cH
	ORG $+2
	DD	FLAT:??_C@_0P@KBOGHGP@Broadcom?5Corp?4@
	DW	0a6bH
	ORG $+2
	DD	FLAT:??_C@_0BG@IJFMHNNO@Green?5House?5Co?4?0?5Ltd?4@
	DW	0a8eH
	ORG $+2
	DD	FLAT:??_C@_0CP@BLIFGEAH@Japan?5Aviation?5Electronics?5Indu@
	DW	0a8fH
	ORG $+2
	DD	FLAT:??_C@_0BF@BPGMFHBM@Young?5Chang?5Co?4?5Ltd?4@
	DW	0aa7H
	ORG $+2
	DD	FLAT:??_C@_0BM@KFMMGOHA@Wincor?5Nixdorf?5GmbH?5?$CG?5Co?5KG@
	DW	0aadH
	ORG $+2
	DD	FLAT:??_C@_0BO@IKBKKFPF@Rohde?5?$CG?5Schwarz?5GmbH?5?$CG?5Co?4?5KG@
	DW	0ac3H
	ORG $+2
	DD	FLAT:??_C@_0CC@EIBHCLN@SANYO?5Semiconductor?5Company?5Mic@
	DW	0ac8H
	ORG $+2
	DD	FLAT:??_C@_0BE@HMAJKJ@Vimicro?5Corporation@
	DW	0ae3H
	ORG $+2
	DD	FLAT:??_C@_0BC@MFIELINC@Allion?5Labs?0?5Inc?4@
	DW	0b05H
	ORG $+2
	DD	FLAT:??_C@_0BG@HEOGBEPO@ASUSTek?5Computer?5Inc?4@
	DW	0b21H
	ORG $+2
	DD	FLAT:??_C@_0BO@KKOFHFLP@Yokogawa?5Electric?5Corporation@
	DW	0b23H
	ORG $+2
	DD	FLAT:??_C@_0BP@IGDJFEE@Pan?9Asia?5Electronics?5Co?4?0?5Ltd?4@
	DW	0b4eH
	ORG $+2
	DD	FLAT:??_C@_0BJ@MJIIIHDL@Musical?5Electronics?5Ltd?4@
	DW	0b54H
	ORG $+2
	DD	FLAT:??_C@_0BN@IGCLCEEO@Sinbon?5Electronics?5Co?4?0?5Ltd?4@
	DW	0b6aH
	ORG $+2
	DD	FLAT:??_C@_0BK@DICOBJHO@Maxim?5Integrated?5Products@
	DW	0b95H
	ORG $+2
	DD	FLAT:??_C@_0BN@DBGBIANO@ASIX?5Electronics?5Corporation@
	DW	0bb5H
	ORG $+2
	DD	FLAT:??_C@_0BP@JGDEFBDO@Murata?5Manufacturing?5Co?4?0?5Ltd?4@
	DW	0bc2H
	ORG $+2
	DD	FLAT:??_C@_0BH@PKPGHPEE@Seagate?5Technology?5LLC@
	DW	0bdaH
	ORG $+2
	DD	FLAT:??_C@_0BM@OODBLDMG@Realtek?5Semiconductor?5Corp?4@
	DW	0bdbH
	ORG $+2
	DD	FLAT:??_C@_0M@PBGCMNLB@Ericsson?5AB@
	DW	0be4H
	ORG $+2
	DD	FLAT:??_C@_0BI@GAPKJOJF@Elka?5International?5Ltd?4@
	DW	0c24H
	ORG $+2
	DD	FLAT:??_C@_0BG@BDCJOHPC@Taiyo?5Yuden?5Co?4?0?5Ltd?4@
	DW	0c39H
	ORG $+2
	DD	FLAT:??_C@_08EDJBOCE@Aeroflex@
	DW	0c45H
	ORG $+2
	DD	FLAT:??_C@_0BL@IIBBHDLP@Sonix?5Technology?5Co?4?0?5Ltd?4@
	DW	0c59H
	ORG $+2
	DD	FLAT:??_C@_0CA@KMAKLJKD@Dong?5Guan?5Shinko?5Wire?5Co?4?0?5Ltd?4@
	DW	0c62H
	ORG $+2
	DD	FLAT:??_C@_0BH@FHGKBINA@Chant?5Sincere?5Co?4?0?5Ltd@
	DW	0c68H
	ORG $+2
	DD	FLAT:??_C@_0BN@KANEMGNF@Whanam?5Electronics?5Co?4?0?5Ltd?4@
	DW	0c76H
	ORG $+2
	DD	FLAT:??_C@_0BN@PNHCHLDH@Solid?5State?5System?5Co?4?0?5Ltd?4@
	DW	0c89H
	ORG $+2
	DD	FLAT:??_C@_0BN@KPNGPOOH@Honda?5Tsushin?5Kogyo?5Co?4?0?5Ltd@
	DW	0cadH
	ORG $+2
	DD	FLAT:??_C@_0BD@PCKEPBKO@Motorola?5Solutions@
	DW	0cb7H
	ORG $+2
	DD	FLAT:??_C@_0BO@DKFGFGHA@Singatron?5Enterprise?5Co?4?5Ltd?4@
	DW	0cc4H
	ORG $+2
	DD	FLAT:??_C@_0BM@NGPEIKDH@emsys?5Embedded?5Systems?5GmbH@
	DW	08086H
	ORG $+2
	DD	FLAT:??_C@_0BC@ECMAKMHG@Intel?5Corporation@
	DW	0cdeH
	ORG $+2
	DD	FLAT:??_C@_0L@OACAMJJG@Z?9Com?5INC?4@
	DW	0cf1H
	ORG $+2
	DD	FLAT:??_C@_0BM@OOCFEMN@e?9CONN?5ELECTRONIC?5CO?4?0?5LTD?4@
	DW	0cf2H
	ORG $+2
	DD	FLAT:??_C@_0BE@KPNEJJKA@ENE?5Technology?5Inc?4@
	DW	0d17H
	ORG $+2
	DD	FLAT:??_C@_0N@IDKBGBCG@NALTEC?0?5Inc?4@
	DW	0d4aH
	ORG $+2
	DD	FLAT:??_C@_0P@MAHCGCHE@NF?5Corporation@
	DW	0d4bH
	ORG $+2
	DD	FLAT:??_C@_0BD@KEPOILEK@Grape?5Systems?5Inc?4@
	DW	0d51H
	ORG $+2
	DD	FLAT:??_C@_0BF@GHDJEHFK@Volex?5?$CIAsia?$CJ?5Pte?5Ltd@
	DW	0d61H
	ORG $+2
	DD	FLAT:??_C@_0CH@DILBGHLF@MEILU?5ELECTRONICS?5?$CISHENZHEN?$CJ?5CO@
	DW	0d71H
	ORG $+2
	DD	FLAT:??_C@_0BH@JNDMIFOJ@Hirakawa?5Hewtech?5Corp?4@
	DW	0d7cH
	ORG $+2
	DD	FLAT:??_C@_0CF@DEKDBPDL@Taiwan?5Line?5Tek?5Electronic?5Co?4?0@
	DW	0d87H
	ORG $+2
	DD	FLAT:??_C@_0BI@BKFMOADO@Dolby?5Laboratories?5Inc?4@
	DW	0d8cH
	ORG $+2
	DD	FLAT:??_C@_0BJ@ICKBMN@C?9MEDIA?5ELECTRONICS?5INC?4@
	DW	0d90H
	ORG $+2
	DD	FLAT:??_C@_0CB@CBEHKKIA@Sure?9Fire?5Electrical?5Corporatio@
	DW	0da7H
	ORG $+2
	DD	FLAT:??_C@_0N@BBFDLJEL@IOGEAR?0?5Inc?4@
	DW	0db0H
	ORG $+2
	DD	FLAT:??_C@_0CD@LDGCJJON@Micro?9Star?5International?5Co?4?0?5L@
	DW	0dd1H
	ORG $+2
	DD	FLAT:??_C@_0BN@MEJNGPFO@Contek?5Electronics?5Co?4?0?5Ltd?4@
	DW	0dd2H
	ORG $+2
	DD	FLAT:??_C@_0CH@HKHHADBM@Power?5Quotient?5International?5Co@
	DW	0dd4H
	ORG $+2
	DD	FLAT:??_C@_0BH@JAOPMIJP@Custom?5Engineering?5SPA@
	DW	0e23H
	ORG $+2
	DD	FLAT:??_C@_0BO@MECAJMAF@Liou?5Yuane?5International?5Ltd?4@
	DW	0e39H
	ORG $+2
	DD	FLAT:??_C@_0CB@BNIAIBOP@Smart?5Modular?5Technologies?0?5Inc@
	DW	0e4aH
	ORG $+2
	DD	FLAT:??_C@_0DB@OJLHPIE@Shenzhen?5Bao?5Hing?5Electric?5Wire@
	DW	0e5dH
	ORG $+2
	DD	FLAT:??_C@_0BN@DKLMDFEK@Neltron?5Industrial?5Co?4?0?5Ltd?4@
	DW	0e6aH
	ORG $+2
	DD	FLAT:??_C@_0BN@PNJNPPHF@Megawin?5Technology?5Co?4?0?5Ltd?4@
	DW	0e72H
	ORG $+2
	DD	FLAT:??_C@_0BP@FIEIALAE@Hsi?9Chin?5Electronics?5Co?4?0?5Ltd?4@
	DW	0e8dH
	ORG $+2
	DD	FLAT:??_C@_0O@DBHJNIK@MediaTek?5Inc?4@
	DW	0e90H
	ORG $+2
	DD	FLAT:??_C@_03PPOOIEPP@CRU@
	DW	0e9bH
	ORG $+2
	DD	FLAT:??_C@_0BC@PLHJNEDE@ADTEC?5CORPORATION@
	DW	0ea0H
	ORG $+2
	DD	FLAT:??_C@_0BF@LFNPLID@Ours?5Technology?5Inc?4@
	DW	0eb2H
	ORG $+2
	DD	FLAT:??_C@_0BJ@FFOINCNP@Y?9S?5ELECTRONIC?5CO?4?0?5LTD?4@
	DW	0ec2H
	ORG $+2
	DD	FLAT:??_C@_0BJ@EEJFEJAC@Sweetray?5Industrial?5Ltd?4@
	DW	0ec3H
	ORG $+2
	DD	FLAT:??_C@_0BC@NLMJJEGP@Axell?5Corporation@
	DW	0ec6H
	ORG $+2
	DD	FLAT:??_C@_0BO@HGLIFDP@InnoVISION?5Multimedia?5Limited@
	DW	0eceH
	ORG $+2
	DD	FLAT:??_C@_0BN@LAJGACMM@TaiSol?5Electronics?5Co?4?0?5Ltd?4@
	DW	0ee4H
	ORG $+2
	DD	FLAT:??_C@_0BP@OLFMJOLO@Sunrich?5Technology?5?$CIH?4K?4?$CJ?5Ltd?4@
	DW	0f08H
	ORG $+2
	DD	FLAT:??_C@_0CE@LHKAEIDJ@CSL?5Wire?5?$CG?5Plug?5?$CIShen?5Zhen?$CJ?5Com@
	DW	0f1cH
	ORG $+2
	DD	FLAT:??_C@_0BJ@BFCEICOB@Funai?5Electric?5Co?4?0?5Ltd?4@
	DW	0f2eH
	ORG $+2
	DD	FLAT:??_C@_0BF@HHKPOBJN@Good?5Man?5Corporation@
	DW	0f32H
	ORG $+2
	DD	FLAT:??_C@_0CA@JKBEBDIB@YFC?9BonEagle?5Electric?5Co?4?0?5Ltd?4@
	DW	0f38H
	ORG $+2
	DD	FLAT:??_C@_0BJ@KJGCCIGG@Nien?9Yi?5Industrial?5Corp?4@
	DW	0f4cH
	ORG $+2
	DD	FLAT:??_C@_0BL@PCHAGLHO@WORLDWIDE?5CABLE?5OPTO?5CORP?4@
	DW	0f53H
	ORG $+2
	DD	FLAT:??_C@_0CA@JJBCDJBC@Taiyo?5Cable?5?$CIDongguan?$CJ?5Co?4?5Ltd?4@
	DW	0f54H
	ORG $+2
	DD	FLAT:??_C@_0CJ@GLJCMOOM@Kawai?5Musical?5Instruments?5Mfg?4?5@
	DW	0f60H
	ORG $+2
	DD	FLAT:??_C@_0DE@KCDILGEE@GuangZhou?5Chief?5Tech?5Electronic@
	DW	0f68H
	ORG $+2
	DD	FLAT:??_C@_0N@CHAEBCC@UQUEST?0?5LTD?4@
	DW	0f8bH
	ORG $+2
	DD	FLAT:??_C@_0BD@KEDKNNLF@Yazaki?5Corporation@
	DW	0f97H
	ORG $+2
	DD	FLAT:??_C@_0BD@NPCAKEK@CviLux?5Corporation@
	DW	0fceH
	ORG $+2
	DD	FLAT:??_C@_0BL@OGPLHBON@Sony?5Mobile?5Communications@
	DW	0ff7H
	ORG $+2
	DD	FLAT:??_C@_0CJ@MNOHKIGC@CHI?5SHING?5COMPUTER?5ACCESSORIES?5@
	DW	01000H
	ORG $+2
	DD	FLAT:??_C@_0BB@FNNKEBO@Speed?5Tech?5Corp?4@
	DW	01004H
	ORG $+2
	DD	FLAT:??_C@_0BE@PPCAGGEP@LG?5Electronics?5Inc?4@
	DW	01026H
	ORG $+2
	DD	FLAT:??_C@_0BC@KLMPEDJE@Newly?5Corporation@
	DW	0102fH
	ORG $+2
	DD	FLAT:??_C@_0CB@MAFJOCHL@WENZHOU?5YIHUA?5CONNECTOR?5CO?4?0LTD@
	DW	01048H
	ORG $+2
	DD	FLAT:??_C@_0BL@DIDNCHDM@Targus?5Group?5International@
	DW	01057H
	ORG $+2
	DD	FLAT:??_C@_0BB@MCAPDOMI@ON?5Semiconductor@
	DW	01058H
	ORG $+2
	DD	FLAT:??_C@_0CD@OEFJDFLG@Western?5Digital?5Technologies?0?5I@
	DW	0105cH
	ORG $+2
	DD	FLAT:??_C@_0DF@EJNCJCJN@Freeway?5Electronic?5Wire?5?$CG?5Cable@
	DW	01083H
	ORG $+2
	DD	FLAT:??_C@_0BH@GGINDOFM@CANON?5ELECTRONICS?5INC?4@
	DW	01084H
	ORG $+2
	DD	FLAT:??_C@_0BC@JLIOEOBP@PANTECH?5CO?4?0?5LTD?4@
	DW	0108bH
	ORG $+2
	DD	FLAT:??_C@_0BP@HEECLKMJ@Grand?9tek?5Technology?5Co?4?0?5Ltd?4@
	DW	0108cH
	ORG $+2
	DD	FLAT:??_C@_0BC@MMEHCLPH@Robert?5Bosch?5GmbH@
	DW	0108eH
	ORG $+2
	DD	FLAT:??_C@_0BA@JBGEKCBJ@Lotes?5Co?4?0?5Ltd?4@
	DW	010aaH
	ORG $+2
	DD	FLAT:??_C@_0N@MADBCNBC@Cables?5To?5Go@
	DW	010abH
	ORG $+2
	DD	FLAT:??_C@_0DB@OABIDDLN@Universal?5Global?5Scientific?5Ind@
	DW	010aeH
	ORG $+2
	DD	FLAT:??_C@_0BL@GMIJPDAF@Princeton?5Technology?5Corp?4@
	DW	010c4H
	ORG $+2
	DD	FLAT:??_C@_0BL@BEPCHFBK@Silicon?5Laboratories?0?5Inc?4@
	DW	010cdH
	ORG $+2
	DD	FLAT:??_C@_0L@BEMBIFEP@Kycon?5Inc?4@
	DW	010d6H
	ORG $+2
	DD	FLAT:??_C@_0CA@BFJDJKMK@Actions?5Semiconductor?5Co?4?0?5Ltd?4@
	DW	0110aH
	ORG $+2
	DD	FLAT:??_C@_09GOLPFLPD@Moxa?5Inc?4@
	DW	01112H
	ORG $+2
	DD	FLAT:??_C@_0DF@NDHMOMGK@Golden?5Bright?5?$CISichuan?$CJ?5Electro@
	DW	0111eH
	ORG $+2
	DD	FLAT:??_C@_0BK@DEMMBJPB@VSO?5ELECTRONICS?5CO?4?0?5LTD?4@
	DW	0112eH
	ORG $+2
	DD	FLAT:??_C@_0CO@HLACDLIC@Master?5Hill?5Electric?5Wire?5and?5C@
	DW	01130H
	ORG $+2
	DD	FLAT:??_C@_0BG@JFAAFJPO@Tenx?5Technology?0?5Inc?4@
	DW	0114dH
	ORG $+2
	DD	FLAT:??_C@_0BP@NKCLDENL@Alpha?5Imaging?5Technology?5Corp?4@
	DW	01175H
	ORG $+2
	DD	FLAT:??_C@_0CB@BGNNABKD@Sheng?5Yih?5Technologies?5Co?4?0?5Ltd@
	DW	01199H
	ORG $+2
	DD	FLAT:??_C@_0BF@FDIEEFFD@Sierra?5Wireless?5Inc?4@
	DW	0119aH
	ORG $+2
	DD	FLAT:??_C@_0CG@JCFADKIE@DONG?5GUAN?5JALINK?5ELECTRONICES?5C@
	DW	011aaH
	ORG $+2
	DD	FLAT:??_C@_0BH@LNLMLHPJ@GlobalMedia?5Group?0?5LLC@
	DW	011b0H
	ORG $+2
	DD	FLAT:??_C@_0BH@HFAICOFB@ATECH?5FLASH?5TECHNOLOGY@
	DW	01223H
	ORG $+2
	DD	FLAT:??_C@_0BO@MNCEAPFD@SKYCABLE?5ENTERPRISE?5CO?4?0?5LTD?4@
	DW	0124bH
	ORG $+2
	DD	FLAT:??_C@_0BI@KKGDFIOD@NYKO?5Technologies?0?5Inc?4@
	DW	0125fH
	ORG $+2
	DD	FLAT:??_C@_0BL@FCGNNKPJ@ADATA?5Technology?5Co?4?0?5Ltd?4@
	DW	0126cH
	ORG $+2
	DD	FLAT:??_C@_0BI@BANJHMOB@Aristocrat?5Technologies@
	DW	0126dH
	ORG $+2
	DD	FLAT:??_C@_0M@HPCCHOFJ@Bel?5Stewart@
	DW	01286H
	ORG $+2
	DD	FLAT:??_C@_0BM@FDHCJPEM@MARVELL?5SEMICONDUCTOR?0?5INC?4@
	DW	01294H
	ORG $+2
	DD	FLAT:??_C@_0BC@CDINJBKA@RISO?5KAGAKU?5CORP?4@
	DW	012abH
	ORG $+2
	DD	FLAT:??_C@_0BO@JGPGOHBM@Honey?5Bee?5?$CIHong?5Kong?$CJ?5Limited@
	DW	012b8H
	ORG $+2
	DD	FLAT:??_C@_0CP@OPCIAOPO@Zhejiang?5Xinya?5Electronic?5Techn@
	DW	012d2H
	ORG $+2
	DD	FLAT:??_C@_0BP@JPNNFCKE@LINE?5TECH?5INDUSTRIAL?5CO?4?0?5LTD?4@
	DW	012d7H
	ORG $+2
	DD	FLAT:??_C@_0BN@DKNOJINI@Better?5Holdings?5?$CIHK?$CJ?5Limited@
	DW	0132bH
	ORG $+2
	DD	FLAT:??_C@_0BF@FPEFMCEM@Konica?5Minolta?0?5Inc?4@
	DW	01348H
	ORG $+2
	DD	FLAT:??_C@_0BP@ODBMNHOP@Katsuragawa?5Electric?5Co?4?0?5Ltd?4@
	DW	01370H
	ORG $+2
	DD	FLAT:??_C@_0M@IPAHGEJP@Swissbit?5AG@
	DW	0137dH
	ORG $+2
	DD	FLAT:??_C@_0BM@DKMEKHIM@Pericom?5Semiconductor?5Corp?4@
	DW	013caH
	ORG $+2
	DD	FLAT:??_C@_0CG@BGIJPEKA@JyeTai?5Precision?5Industrial?5Co?4@
	DW	013d3H
	ORG $+2
	DD	FLAT:??_C@_0BN@BNPLLCII@AzureWave?5Technologies?0?5Inc?4@
	DW	013dcH
	ORG $+2
	DD	FLAT:??_C@_0O@EADKLFFK@ALEREON?0?5INC?4@
	DW	013fdH
	ORG $+2
	DD	FLAT:??_C@_0BD@MJPGJJIB@Initio?5Corporation@
	DW	013feH
	ORG $+2
	DD	FLAT:??_C@_0BJ@PODMPDKE@Phison?5Electronics?5Corp?4@
	DW	0140eH
	ORG $+2
	DD	FLAT:??_C@_0BA@EBAJJPHC@Telechips?0?5Inc?4@
	DW	01419H
	ORG $+2
	DD	FLAT:??_C@_0BN@KECIKNAF@ABILITY?5ENTERPRISE?5CO?4?0?5LTD?4@
	DW	01421H
	ORG $+2
	DD	FLAT:??_C@_0BM@KIAEGNEO@Sensor?5Technology?5Co?4?0?5Ltd?4@
	DW	01487H
	ORG $+2
	DD	FLAT:??_C@_0BA@EJBEDMD@DSP?5Group?0?5Ltd?4@
	DW	0148eH
	ORG $+2
	DD	FLAT:??_C@_0N@JLOFKNJM@EVATRONIX?5SA@
	DW	01497H
	ORG $+2
	DD	FLAT:??_C@_0BH@BDFMJCOJ@Panstrong?5Company?5Ltd?4@
	DW	014adH
	ORG $+2
	DD	FLAT:??_C@_0BA@GIDLPKMM@CTK?5Corporation@
	DW	014afH
	ORG $+2
	DD	FLAT:??_C@_0BF@POKLDLPA@ATP?5Electronics?5Inc?4@
	DW	014b0H
	ORG $+2
	DD	FLAT:??_C@_0BC@LNFIEHCE@StarTech?4com?5Ltd?4@
	DW	014cdH
	ORG $+2
	DD	FLAT:??_C@_0BN@OBOFFJMJ@MOAI?5ELECTRONICS?5CORPORATION@
	DW	01500H
	ORG $+2
	DD	FLAT:??_C@_07HKBKGGAL@Ellisys@
	DW	01516H
	ORG $+2
	DD	FLAT:??_C@_0BE@MEIKBKHJ@Skymedi?5Corporation@
	DW	0151cH
	ORG $+2
	DD	FLAT:??_C@_0BP@NFMNNPJJ@VeriSilicon?5Holdings?5Co?4?0?5Ltd?4@
	DW	0152dH
	ORG $+2
	DD	FLAT:??_C@_0BJ@NNBEAIKI@JMicron?5Technology?5Corp?4@
	DW	0152eH
	ORG $+2
	DD	FLAT:??_C@_0CF@KFFNHPKK@HLDS?5?$CIHitachi?9LG?5Data?5Storage?0?5@
	DW	01540H
	ORG $+2
	DD	FLAT:??_C@_0BN@PJAMMHJM@Phihong?5Technology?5Co?4?0?5Ltd?4@
	DW	0154bH
	ORG $+2
	DD	FLAT:??_C@_0BG@FDFFBPKH@PNY?5Technologies?5Inc?4@
	DW	0154dH
	ORG $+2
	DD	FLAT:??_C@_0CI@PJGLCGBH@Rapid?5Conn?0?5Connect?5County?5Hold@
	DW	0154eH
	ORG $+2
	DD	FLAT:??_C@_0BF@KCLHJFIN@D?5?$CG?5M?5Holdings?0?5Inc?4@
	DW	01568H
	ORG $+2
	DD	FLAT:??_C@_0BM@MLLCLJKN@Sunf?5Pu?5Technology?5Co?4?0?5Ltd@
	DW	01570H
	ORG $+2
	DD	FLAT:??_C@_0BM@PJFBNPPK@ALLTOP?5TECHNOLOGY?5CO?4?0?5LTD?4@
	DW	01586H
	ORG $+2
	DD	FLAT:??_C@_0BN@MGGPMLNL@Palconn?5Technology?5Co?4?0?5Ltd?4@
	DW	01598H
	ORG $+2
	DD	FLAT:??_C@_0CE@PGJPGLLG@Kunshan?5Guoji?5Electronics?5Co?4?0?5@
	DW	015a2H
	ORG $+2
	DD	FLAT:??_C@_0BO@KPCEMMAE@Freescale?5Semiconductor?0?5Inc?4@
	DW	015a8H
	ORG $+2
	DD	FLAT:??_C@_0CL@HBACFJJO@Shen?5Zhen?5Teamspower?5Electronic@
	DW	015d9H
	ORG $+2
	DD	FLAT:??_C@_0BO@HKNGFKOP@Apexone?5Microelectronics?5Inc?4@
	DW	015e0H
	ORG $+2
	DD	FLAT:??_C@_0BO@FIJNAGLJ@Seong?5Ji?5Industrial?5Co?4?0?5Ltd?4@
	DW	0160dH
	ORG $+2
	DD	FLAT:??_C@_06DGDFLKMM@Samtec@
	DW	01612H
	ORG $+2
	DD	FLAT:??_C@_0N@GNFMIBKN@Soft?5DB?5Inc?4@
	DW	0163eH
	ORG $+2
	DD	FLAT:??_C@_0BO@CCKIBDCK@HongLin?5Electronics?5Co?4?0?5Ltd?4@
	DW	01679H
	ORG $+2
	DD	FLAT:??_C@_0M@OMFDOLIG@Total?5Phase@
	DW	016a5H
	ORG $+2
	DD	FLAT:??_C@_0CI@LPNLCPKP@Shenzhen?5Zhengerya?5Technology?5C@
	DW	016acH
	ORG $+2
	DD	FLAT:??_C@_0CK@GHEMOGNO@Dongguan?5ChingLung?5Wire?5?$CG?5Cable@
	DW	016ccH
	ORG $+2
	DD	FLAT:??_C@_0BH@EKGKEMKL@silex?5technology?0?5Inc?4@
	DW	01736H
	ORG $+2
	DD	FLAT:??_C@_0BL@MBCLBNK@CANON?5IMAGING?5SYSTEMS?5INC?4@
	DW	0173aH
	ORG $+2
	DD	FLAT:??_C@_0BC@LFEKPOAD@Roche?5Diagnostics@
	DW	01748H
	ORG $+2
	DD	FLAT:??_C@_0BF@BACBMICM@MQP?5Electronics?5Ltd?4@
	DW	0174cH
	ORG $+2
	DD	FLAT:??_C@_0BI@EFCFBFPB@ASMedia?5Technology?5Inc?4@
	DW	0176eH
	ORG $+2
	DD	FLAT:??_C@_0BE@LLHADAIP@UD?5electronic?5corp?4@
	DW	01771H
	ORG $+2
	DD	FLAT:??_C@_0CC@KBPLCNPO@Shenzhen?5Alex?5Connector?5Co?4?0?5Lt@
	DW	01772H
	ORG $+2
	DD	FLAT:??_C@_0BN@MGLGHCII@System?5Level?5Solutions?0?5Inc?4@
	DW	01782H
	ORG $+2
	DD	FLAT:??_C@_0BP@PDCKJENN@Spreadtrum?5Communications?5Inc?4@
	DW	01788H
	ORG $+2
	DD	FLAT:??_C@_0CH@GLPFKNO@ShenZhen?5Litkconn?5Technology?5Co@
	DW	017beH
	ORG $+2
	DD	FLAT:??_C@_0DI@DPFEGAEM@Dongguan?5Yangming?5Precision?5of?5@
	DW	017cfH
	ORG $+2
	DD	FLAT:??_C@_0CA@FKGCAAGK@Hip?5Hing?5Cable?5?$CG?5Plug?5Mfy?4?5Ltd?4@
	DW	017e9H
	ORG $+2
	DD	FLAT:??_C@_0BG@PLILAAEO@DisplayLink?5?$CIUK?$CJ?5Ltd?4@
	DW	017efH
	ORG $+2
	DD	FLAT:??_C@_06EOFPOMJG@Lenovo@
	DW	017f5H
	ORG $+2
	DD	FLAT:??_C@_0L@IGMLMAAK@K?4K?4?5Rocky@
	DW	01829H
	ORG $+2
	DD	FLAT:??_C@_0CF@KAKIFJIN@Dongguan?5YuQiu?5Electronics?5Co?4?0@
	DW	01831H
	ORG $+2
	DD	FLAT:??_C@_0BO@DPMJHMBK@Gwo?5Jinn?5Industries?5Co?4?0?5Ltd?4@
	DW	01852H
	ORG $+2
	DD	FLAT:??_C@_0BF@MMEONNIC@Galaxy?5Far?5East?5Corp@
	DW	01899H
	ORG $+2
	DD	FLAT:??_C@_0BC@HBKKPCPF@Linkiss?5Co?4?0?5Ltd?4@
	DW	018d1H
	ORG $+2
	DD	FLAT:??_C@_0M@INPJKDFM@Google?5Inc?4@
	DW	018e3H
	ORG $+2
	DD	FLAT:??_C@_0CF@DABKNPLD@Fitilink?5Integrated?5Technology?0@
	DW	01915H
	ORG $+2
	DD	FLAT:??_C@_0BJ@FNMFPLIK@Nordic?5Semiconductor?5ASA@
	DW	01930H
	ORG $+2
	DD	FLAT:??_C@_0CF@NLNPHLHC@Shenzhen?5Xianhe?5Technology?5Co?4?0@
	DW	01931H
	ORG $+2
	DD	FLAT:??_C@_0CJ@FJMLIAEB@Ningbo?5Broad?5Telecommunication?5@
	DW	01946H
	ORG $+2
	DD	FLAT:??_C@_0BB@PCAKKDFD@Irisguard?5UK?5Ltd@
	DW	01949H
	ORG $+2
	DD	FLAT:??_C@_06CHAGPIBB@Lab126@
	DW	01957H
	ORG $+2
	DD	FLAT:??_C@_0BB@PPNLBENA@BIOS?5Corporation@
	DW	01989H
	ORG $+2
	DD	FLAT:??_C@_0BI@EPIBIIDM@Nuconn?5Technology?5Corp?4@
	DW	0199dH
	ORG $+2
	DD	FLAT:??_C@_0BC@LGPAAFDD@Dexxon?5Data?5Media@
	DW	019e8H
	ORG $+2
	DD	FLAT:??_C@_0CJ@HAKCLNCA@Industrial?5Technology?5Research?5@
	DW	019efH
	ORG $+2
	DD	FLAT:??_C@_0CJ@GONBANIC@Pak?5Heng?5Technology?5?$CIShenzhen?$CJ?5@
	DW	019ffH
	ORG $+2
	DD	FLAT:??_C@_0BE@PPEHNAPN@Best?5Buy?5China?5Ltd?4@
	DW	01a0aH
	ORG $+2
	DD	FLAT:??_C@_0BE@BIONMJOM@USB?9IF?5non?9workshop@
	DW	01a25H
	ORG $+2
	DD	FLAT:??_C@_0BI@PPNCKFLJ@Amphenol?5East?5Asia?5Ltd?4@
	DW	01a35H
	ORG $+2
	DD	FLAT:??_C@_0O@OPAGGINC@Astec?5America@
	DW	01a36H
	ORG $+2
	DD	FLAT:??_C@_0BL@EKBPAFBH@Topdisk?5Technology?5Limited@
	DW	01a40H
	ORG $+2
	DD	FLAT:??_C@_0BJ@KAKHDDLA@TERMINUS?5TECHNOLOGY?5INC?4@
	DW	01a6eH
	ORG $+2
	DD	FLAT:??_C@_0BF@IBCFPAGK@Global?5Unichip?5Corp?4@
	DW	01a79H
	ORG $+2
	DD	FLAT:??_C@_0BG@IOFCBCHK@Bayer?5Health?5Care?5LLC@
	DW	01a82H
	ORG $+2
	DD	FLAT:??_C@_0BN@GMHKDAOP@Proconn?5Technology?5Co?4?0?5Ltd?4@
	DW	01a8aH
	ORG $+2
	DD	FLAT:??_C@_0BH@HJFKHBGL@Simula?5Technology?5Inc?4@
	DW	01a8bH
	ORG $+2
	DD	FLAT:??_C@_0BA@KBMPMKDN@SGS?5Taiwan?5Ltd?4@
	DW	01a98H
	ORG $+2
	DD	FLAT:??_C@_0BA@GPGHJPOJ@Leica?5Camera?5AG@
	DW	01a99H
	ORG $+2
	DD	FLAT:??_C@_0CJ@FEGEHHGG@Asia?5Tai?5Technology?5?$CIDongguan?$CJ?5@
	DW	01aaeH
	ORG $+2
	DD	FLAT:??_C@_0CJ@EENODCNA@Johnson?5Component?5?$CG?5Equipments?5@
	DW	01acbH
	ORG $+2
	DD	FLAT:??_C@_0M@BNPJBJHO@Salcomp?5Plc@
	DW	01aedH
	ORG $+2
	DD	FLAT:??_C@_0CI@ENEIOO@High?5Top?5Precision?5Electronic?5C@
	DW	01aeeH
	ORG $+2
	DD	FLAT:??_C@_0CD@KCEJLGKF@SHEN?5ZHEN?5REX?5TECHNOLOGY?5CO?4?0?5L@
	DW	01aefH
	ORG $+2
	DD	FLAT:??_C@_0BI@BAHHJBOM@Octekconn?5Incorporation@
	DW	01b36H
	ORG $+2
	DD	FLAT:??_C@_0BD@DPNOIOGL@ViXS?5Systems?0?5Inc?4@
	DW	01b48H
	ORG $+2
	DD	FLAT:??_C@_0BN@ODKKJGBD@Plastron?5Precision?5Co?4?0?5Ltd?4@
	DW	01b65H
	ORG $+2
	DD	FLAT:??_C@_0DA@EOOOBNLE@The?5Hong?5Kong?5Standards?5and?5Tes@
	DW	01b88H
	ORG $+2
	DD	FLAT:??_C@_0CI@GNFBMNPP@ShenMing?5Electron?5?$CIDong?5Guan?$CJ?5C@
	DW	01b8eH
	ORG $+2
	DD	FLAT:??_C@_0O@IPLHGMF@Amlogic?0?5Inc?4@
	DW	01b99H
	ORG $+2
	DD	FLAT:??_C@_0BO@IHCMPCEB@Shenzhen?5Yuanchuan?5Electronic@
	DW	01bc4H
	ORG $+2
	DD	FLAT:??_C@_0P@JGHIOJAI@Ford?5Motor?5Co?4@
	DW	01bceH
	ORG $+2
	DD	FLAT:??_C@_0CA@FCJOHAEE@Contac?5Cable?5Industrial?5Limited@
	DW	01bcfH
	ORG $+2
	DD	FLAT:??_C@_0CD@HFOIMFJ@Sunplus?5Innovation?5Technology?5I@
	DW	01bf6H
	ORG $+2
	DD	FLAT:??_C@_0CH@KIMIGBPK@Orient?5Semiconductor?5Electronic@
	DW	01c10H
	ORG $+2
	DD	FLAT:??_C@_0BO@IHAPHGGJ@Lanterra?5Industrial?5Co?4?0?5Ltd?4@
	DW	01c27H
	ORG $+2
	DD	FLAT:??_C@_0CC@GEFGPOJP@SHENZHEN?5DNS?5INDUSTRIES?5CO?4?0?5LT@
	DW	01c31H
	ORG $+2
	DD	FLAT:??_C@_08PDBDCLGF@LS?5Mtron@
	DW	01c3dH
	ORG $+2
	DD	FLAT:??_C@_0BD@DCHINJIL@NONIN?5MEDICAL?5INC?4@
	DW	01c6bH
	ORG $+2
	DD	FLAT:??_C@_0DA@PPLCBMMB@Philips?5?$CG?5Lite?9ON?5Digital?5Solut@
	DW	01c98H
	ORG $+2
	DD	FLAT:??_C@_0BJ@GEGPHPDK@ALPINE?5ELECTRONICS?0?5INC?4@
	DW	01cb0H
	ORG $+2
	DD	FLAT:??_C@_0P@BICMBKIN@LEGRAND?5FRANCE@
	DW	01cb3H
	ORG $+2
	DD	FLAT:??_C@_0BL@CHCFPHFA@Aces?5Electronics?5Co?4?0?5Ltd?4@
	DW	01cb4H
	ORG $+2
	DD	FLAT:??_C@_0BB@EIGDHDFJ@OPEX?5CORPORATION@
	DW	01cdeH
	ORG $+2
	DD	FLAT:??_C@_0DA@BKKOBFJG@Telecommunications?5Technology?5A@
	DW	01d08H
	ORG $+2
	DD	FLAT:??_C@_0CL@OJLMBANN@NINGBO?5HENTEK?5DRAGON?5ELECTRONIC@
	DW	01d0aH
	ORG $+2
	DD	FLAT:??_C@_0BH@GIIFDIFG@Johnson?5Controls?0?5Inc?4@
	DW	01d29H
	ORG $+2
	DD	FLAT:??_C@_0CA@GDMPIAIK@Horng?5Tong?5Enterprise?5Co?4?0?5Ltd?4@
	DW	01d42H
	ORG $+2
	DD	FLAT:??_C@_0BD@JJOGFDJ@DRAGON?5JOY?5LIMITED@
	DW	01d45H
	ORG $+2
	DD	FLAT:??_C@_0BC@KIFIHBOP@Qisda?5Corporation@
	DW	01d4dH
	ORG $+2
	DD	FLAT:??_C@_0BF@EEHMEIJP@Pegatron?5Corporation@
	DW	01d5cH
	ORG $+2
	DD	FLAT:??_C@_0BC@HAMMCKPN@Fresco?5Logic?5Inc?4@
	DW	01d5dH
	ORG $+2
	DD	FLAT:??_C@_0BL@MMCBELAO@QIXING?5INDUSTRIAL?5?$CIHK?$CJ?5CO?4@
	DW	01d69H
	ORG $+2
	DD	FLAT:??_C@_0BL@NKBOOFNF@Walta?5Electronic?5Co?4?0?5Ltd?4@
	DW	01d77H
	ORG $+2
	DD	FLAT:??_C@_0DE@IMGLKMI@Yueqing?5Changling?5Electronic?5In@
	DW	01d79H
	ORG $+2
	DD	FLAT:??_C@_0CH@EKHHMHEC@Shenzhen?5My?9Power?5Technology?5Co@
	DW	01d85H
	ORG $+2
	DD	FLAT:??_C@_0DD@IDOJMHNI@NINGBO?5SHUNSHENG?5COMMUNICATION?5@
	DW	01da0H
	ORG $+2
	DD	FLAT:??_C@_0BK@FNCNBIIF@Parade?5Technologies?0?5Inc?4@
	DW	01dccH
	ORG $+2
	DD	FLAT:??_C@_0CE@EGHGGAJG@Document?5Capture?5Technologies?0?5@
	DW	01ddfH
	ORG $+2
	DD	FLAT:??_C@_0BH@NMLKIBDM@GDA?5Technologies?0?5Inc?4@
	DW	01de1H
	ORG $+2
	DD	FLAT:??_C@_0CD@BBLGIHKL@Actions?5Microelectronics?5Co?4?0?5L@
	DW	01df2H
	ORG $+2
	DD	FLAT:??_C@_0CK@INFLCDIC@Telecommunication?5Metrology?5Cen@
	DW	01df4H
	ORG $+2
	DD	FLAT:??_C@_0CO@IHINPAOL@SHEN?5ZHEN?5FORMAN?5PRECISION?5INDU@
	DW	01e10H
	ORG $+2
	DD	FLAT:??_C@_0BJ@FEMBFAJG@Point?5Grey?5Research?5Inc?4@
	DW	01e33H
	ORG $+2
	DD	FLAT:??_C@_0BD@LIIMMKIN@KOBIAN?5CANADA?5INC?4@
	DW	01e47H
	ORG $+2
	DD	FLAT:??_C@_0CB@BKOLJNN@HUNG?5TA?5H?4T?4ENTERPRISE?5CO?4?0?5LTD@
	DW	01e4eH
	ORG $+2
	DD	FLAT:??_C@_0BH@JAAJJDAF@Etron?5Technology?0?5Inc?4@
	DW	01e73H
	ORG $+2
	DD	FLAT:??_C@_0BO@OPAJPFGF@COMLINK?5ELECTRONICS?5CO?4?0?5LTD?4@
	DW	01e8aH
	ORG $+2
	DD	FLAT:??_C@_0CH@JAHIBMAB@HIBEST?5Electronic?5?$CIDongGuan?$CJ?5Co@
	DW	01e91H
	ORG $+2
	DD	FLAT:??_C@_0BG@EHNBGDFF@Other?5World?5Computing@
	DW	01ea3H
	ORG $+2
	DD	FLAT:??_C@_0BL@BINCEHIC@Concraft?5Holding?5Co?4?0?5Ltd?4@
	DW	01eb7H
	ORG $+2
	DD	FLAT:??_C@_0CH@IFPLLPOK@WIN?5WIN?5PRECISION?5INDUSTRIAL?5CO@
	DW	01ec7H
	ORG $+2
	DD	FLAT:??_C@_0L@PIBOCPGJ@Gefen?5Inc?4@
	DW	01edaH
	ORG $+2
	DD	FLAT:??_C@_0BK@LCFIOKDG@AIRTIES?5WIRELESS?5NETWORKS@
	DW	01ef3H
	ORG $+2
	DD	FLAT:??_C@_0CD@IALAEKLI@JIANGXI?5SHIP?5ELECTRONICS?5CO?4?0?5L@
	DW	01f28H
	ORG $+2
	DD	FLAT:??_C@_0CG@LKIHKKAD@Cal?9Comp?5Electronics?5?$CG?5Communic@
	DW	01f3cH
	ORG $+2
	DD	FLAT:??_C@_0CE@MEDMJIF@Chang?5Yang?5Electronics?5Company?5@
	DW	01f75H
	ORG $+2
	DD	FLAT:??_C@_0BD@GGCBPHPK@Innostor?5Co?4?0?5Ltd?4@
	DW	01f89H
	ORG $+2
	DD	FLAT:??_C@_0CI@NHHBKKBH@Dongguan?5Goldconn?5Electronics?5C@
	DW	01f8aH
	ORG $+2
	DD	FLAT:??_C@_0CC@LPIGCLDE@Morning?5Star?5Industrial?5Co?4?0?5Lt@
	DW	01fb4H
	ORG $+2
	DD	FLAT:??_C@_0CB@EHEKJNGP@Owl?5Computing?5Technologies?0?5Inc@
	DW	01fb5H
	ORG $+2
	DD	FLAT:??_C@_0BE@KDFCKAEG@Unify?5GmbH?5?$CG?5Co?4?5KG@
	DW	01fc9H
	ORG $+2
	DD	FLAT:??_C@_0BD@GMPBKEIC@NXP?5Semiconductors@
	DW	01fecH
	ORG $+2
	DD	FLAT:??_C@_0CA@CAPPIABK@NIAN?5YEONG?5ENTERPRISE?5CO?4?0?5LTD?4@
	DW	01ff5H
	ORG $+2
	DD	FLAT:??_C@_0DB@KONADFN@Changzhou?5Wujin?5BEST?5Electronic@
	DW	02001H
	ORG $+2
	DD	FLAT:??_C@_0BD@BJBLIGAM@D?9Link?5Corporation@
	DW	0200dH
	ORG $+2
	DD	FLAT:??_C@_0CI@GOBPPKNF@Belkin?5Electronic?5?$CIChangzhou?$CJ?5C@
	DW	0201cH
	ORG $+2
	DD	FLAT:??_C@_0CF@DHGBCKNB@Freeport?5Resources?5Enterprises?5@
	DW	02028H
	ORG $+2
	DD	FLAT:??_C@_0BG@PIIFGLBL@DETAS?5TECHNOLOGY?5LTD?4@
	DW	0205cH
	ORG $+2
	DD	FLAT:??_C@_0CI@FBHBCILE@Shenzhen?5Tronixin?5Electronics?5C@
	DW	02066H
	ORG $+2
	DD	FLAT:??_C@_0CJ@OEPJLPBL@Unicorn?5Electronics?5Components?5@
	DW	0207dH
	ORG $+2
	DD	FLAT:??_C@_0BK@DJALMDKA@CESI?5Technology?5Co?4?0?5Ltd?4@
	DW	0208eH
	ORG $+2
	DD	FLAT:??_C@_0N@JJLIGBFN@Luxshare?9ICT@
	DW	02095H
	ORG $+2
	DD	FLAT:??_C@_0BA@CFCNDLPN@CE?5LINK?5LIMITED@
	DW	02096H
	ORG $+2
	DD	FLAT:??_C@_0BP@FNHFFJPK@Microconn?5Electronic?5Co?4?0?5Ltd?4@
	DW	020afH
	ORG $+2
	DD	FLAT:??_C@_0CF@MCDKIGNK@Shenzhen?5CARVE?5Electronics?5Co?4?0@
	DW	020c0H
	ORG $+2
	DD	FLAT:??_C@_0BK@EIBNNPGD@FENGHUA?5KINGSUN?5CO?4?0?5LTD?4@
	DW	020c2H
	ORG $+2
	DD	FLAT:??_C@_0DE@EMOPPBDG@Sumitomo?5Electric?5Ind?4?0?5Ltd?4?0?5O@
	DW	020f7H
	ORG $+2
	DD	FLAT:??_C@_0N@DAENHNHN@XIMEA?5s?4r?4o?4@
	DW	02109H
	ORG $+2
	DD	FLAT:??_C@_0P@GBIKBMAL@VIA?5Labs?0?5Inc?4@
	DW	0212cH
	ORG $+2
	DD	FLAT:??_C@_0CF@GAGJPPB@Shenzhen?5Linoya?5Electronic?5Co?4?0@
	DW	0212dH
	ORG $+2
	DD	FLAT:??_C@_0CK@LALHIFNG@Dong?5Guan?5City?5Wanhong?5Electric@
	DW	0212eH
	ORG $+2
	DD	FLAT:??_C@_0CJ@CNOJBLBI@Amphenol?5AssembleTech?5?$CIXiamen?$CJ?5@
	DW	0214cH
	ORG $+2
	DD	FLAT:??_C@_0BD@LDDEGFID@Y?5Soft?5Corporation@
	DW	02166H
	ORG $+2
	DD	FLAT:??_C@_0BI@FBCKNBLM@JVC?5KENWOOD?5Corporation@
	DW	02174H
	ORG $+2
	DD	FLAT:??_C@_0BM@BKHGEKPK@Transcend?5Information?0?5Inc?4@
	DW	02176H
	ORG $+2
	DD	FLAT:??_C@_0BF@BAPBHHHN@TMC?1Allion?5Test?5Labs@
	DW	02188H
	ORG $+2
	DD	FLAT:??_C@_08EPBIMIG@CalDigit@
	DW	021b3H
	ORG $+2
	DD	FLAT:??_C@_0DB@LAFBKCJH@Dongguan?5Teconn?5Electronics?5Tec@
	DW	021c4H
	ORG $+2
	DD	FLAT:??_C@_0BP@PBMDMJMJ@Netcom?5Technology?5?$CIHK?$CJ?5Limited@
	DW	021d3H
	ORG $+2
	DD	FLAT:??_C@_0BP@FAJGPKNC@Compupack?5Technology?5Co?4?0?5Ltd?4@
	DW	021f7H
	ORG $+2
	DD	FLAT:??_C@_0CG@OHNMOHEM@Wuerth?9Elektronik?5eiSos?5GmbH?5?$CG?5@
	DW	02203H
	ORG $+2
	DD	FLAT:??_C@_0BE@BEMCGCHG@Shin?5Shin?5Co?4?0?5Ltd?4@
	DW	02205H
	ORG $+2
	DD	FLAT:??_C@_0CB@CHMCCAAM@3eYamaichi?5Electronics?5Co?4?0?5Ltd@
	DW	02206H
	ORG $+2
	DD	FLAT:??_C@_0CG@NEPAELKJ@Wiretek?5International?5Investmen@
	DW	02230H
	ORG $+2
	DD	FLAT:??_C@_0BG@FFGBANPN@Plugable?5Technologies@
	DW	02234H
	ORG $+2
	DD	FLAT:??_C@_0BN@DJPOBBOH@T?9CONN?5PRECISION?5CORPORATION@
	DW	0227fH
	ORG $+2
	DD	FLAT:??_C@_0BD@PEIOBOIA@Granite?5River?5Labs@
	DW	02288H
	ORG $+2
	DD	FLAT:??_C@_0BG@JFNFEMAF@Digital?5EMC?5Co?4?0?5Ltd?4@
	DW	02289H
	ORG $+2
	DD	FLAT:??_C@_0CO@GPGEJOEG@Sun?5Fair?5Electric?5Wire?5?$CG?5Cable?5@
	DW	0228aH
	ORG $+2
	DD	FLAT:??_C@_0CH@JIBHMNOD@Hotron?5Precision?5Electronic?5Ind@
	DW	022abH
	ORG $+2
	DD	FLAT:??_C@_0BN@LAOLKJDB@Trigence?5Semiconductor?0?5Inc?4@
	DW	022b8H
	ORG $+2
	DD	FLAT:??_C@_0BH@JCNJIDNH@Motorola?5Mobility?5Inc?4@
	DW	022c8H
	ORG $+2
	DD	FLAT:??_C@_0CI@KOHELOKO@Karming?5Electronic?5?$CIShenzhen?$CJ?5C@
	DW	022dbH
	ORG $+2
	DD	FLAT:??_C@_0O@PFEHLJC@Phase?5One?5A?1S@
	DW	022fdH
	ORG $+2
	DD	FLAT:??_C@_0O@LJFFELIC@Miltope?5Corp?4@
	DW	02313H
	ORG $+2
	DD	FLAT:??_C@_0CF@DNEMFNPO@Kunshan?5Jiahua?5Electronics?5Co?4?0@
	DW	02315H
	ORG $+2
	DD	FLAT:??_C@_0BL@CONNOJEO@Avery?5Design?5Systems?0?5Inc?4@
	DW	02317H
	ORG $+2
	DD	FLAT:??_C@_0BI@LPLOPAA@Huawei?5Device?5Co?4?0?5Ltd?4@
	DW	02330H
	ORG $+2
	DD	FLAT:??_C@_09GCGEMCFF@Tensorcom@
	DW	0234cH
	ORG $+2
	DD	FLAT:??_C@_0O@DNELPEDJ@Zenverge?5Inc?4@
	DW	02359H
	ORG $+2
	DD	FLAT:??_C@_0CM@MLMJGOMM@Shenzhen?5Autone?9Tronic?5Technolo@
	DW	0235bH
	ORG $+2
	DD	FLAT:??_C@_0BP@GJOKBILK@KangXiang?5Electronic?5Co?4?0?5Ltd?4@
	DW	023aaH
	ORG $+2
	DD	FLAT:??_C@_0BP@CBFBKCKO@IXT?5Systems?5International?5Ltd?4@
	DW	023acH
	ORG $+2
	DD	FLAT:??_C@_0BJ@OHNJGPJN@Marunix?5Electron?5Limited@
	DW	023d6H
	ORG $+2
	DD	FLAT:??_C@_0CH@GCMJJPNA@DONGGUAN?5LICHENG?5ELECTRONICS?5CO@
	DW	023e0H
	ORG $+2
	DD	FLAT:??_C@_0CF@CFJNEAJP@BitifEye?5Digital?5Test?5Solutions@
	DW	02400H
	ORG $+2
	DD	FLAT:??_C@_0CN@EJBOGONI@ChuangYi?5Hardware?5Precision?5Mou@
	DW	02406H
	ORG $+2
	DD	FLAT:??_C@_0O@BNIKCMOM@INSIDE?5Secure@
	DW	02407H
	ORG $+2
	DD	FLAT:??_C@_0BH@KJMMFBKI@Incasolution?5Co?4?0?5Ltd?4@
	DW	0241aH
	ORG $+2
	DD	FLAT:??_C@_0BM@GMFHMCEF@The?5Silanna?5Group?5Pty?4?5Ltd?4@
	DW	0241bH
	ORG $+2
	DD	FLAT:??_C@_0CK@PEDMBLOK@Dongguan?5City?5Qirui?5Electronics@
	DW	0244cH
	ORG $+2
	DD	FLAT:??_C@_0BC@MIHCGNOI@Minebea?5Co?4?0?5Ltd?4@
	DW	02453H
	ORG $+2
	DD	FLAT:??_C@_06HHAPBGEJ@BAANTO@
	DW	02454H
	ORG $+2
	DD	FLAT:??_C@_0BL@LPJGBHEM@Velosti?5Technology?5Limited@
	DW	02455H
	ORG $+2
	DD	FLAT:??_C@_0BC@FEINIIOM@Anton?1Bauer?0?5Inc?4@
	DW	0247aH
	ORG $+2
	DD	FLAT:??_C@_0CE@BAFKLNDB@WuJiang?5XinYa?5Electronics?5Co?4?0?5@
	DW	0247cH
	ORG $+2
	DD	FLAT:??_C@_0BH@EHAGJFEE@Fullconn?5Industry?5Inc?4@
	DW	0248bH
	ORG $+2
	DD	FLAT:??_C@_0BK@CFHJHDDG@SYNCONN?5INTERCONNECT?5INC?4@
	DW	024a6H
	ORG $+2
	DD	FLAT:??_C@_0CH@IDDOGDKP@Shenzhen?5Pangngai?5Industrial?5Co@
	DW	024ceH
	ORG $+2
	DD	FLAT:??_C@_0CE@JOMBCIJH@Shenzhen?5Deren?5Electronic?5Co?4?0?5@
	DW	024cfH
	ORG $+2
	DD	FLAT:??_C@_0M@NMCNEDLC@Lytro?0?5Inc?4@
	DW	024d0H
	ORG $+2
	DD	FLAT:??_C@_0BL@DEJKGIMK@Smith?5Micro?5Software?0?5Inc?4@
	DW	024edH
	ORG $+2
	DD	FLAT:??_C@_0BO@ONHDIMLP@ZEN?5FACTORY?5GROUP?5?$CIASIA?$CJ?5LTD?4@
	DW	02509H
	ORG $+2
	DD	FLAT:??_C@_0BO@KGBBCJH@Chain?9In?5Electronic?5Co?4?0?5Ltd?4@
	DW	0252bH
	ORG $+2
	DD	FLAT:??_C@_0CN@BNJPCKEF@TOP?5Exactitude?5Industry?5?$CIShenZh@
	DW	02535H
	ORG $+2
	DD	FLAT:??_C@_0CP@FBCGPDBL@ShenZhen?5Hogend?5Precision?5Techn@
	DW	02537H
	ORG $+2
	DD	FLAT:??_C@_0BD@PLHJJNHE@Norel?5Systems?5Ltd?4@
	DW	02554H
	ORG $+2
	DD	FLAT:??_C@_0O@KMBODLJH@ASSA?5ABLOY?5AB@
	DW	02567H
	ORG $+2
	DD	FLAT:??_C@_0CG@NMMKCBIB@DongGuan?5LongTao?5Electronic?5Co?4@
	DW	02575H
	ORG $+2
	DD	FLAT:??_C@_0BI@MHBLLANG@Weida?5Hi?9Tech?5Co?4?0?5Ltd?4@
	DW	02579H
	ORG $+2
	DD	FLAT:??_C@_0CI@CBMJJLAP@Dongguan?5Wisechamp?5Electronic?5C@
	DW	0258dH
	ORG $+2
	DD	FLAT:??_C@_0BH@NLMAPGEN@Sequans?5Communications@
	DW	025a4H
	ORG $+2
	DD	FLAT:??_C@_0P@GGHEMJJH@ALGOLTEK?0?5INC?4@
	DW	025aaH
	ORG $+2
	DD	FLAT:??_C@_0CC@LNBMPCHG@Top?5Victory?5Investments?5Ltd?4?5?$CIH@
	DW	025b3H
	ORG $+2
	DD	FLAT:??_C@_0CF@LHOCOHOF@DongGuan?5Elinke?5Industrial?5Co?4?0@
	DW	025cfH
	ORG $+2
	DD	FLAT:??_C@_0BK@DKIKJOEB@Corning?5Cable?5Systems?5LLC@
	DW	025d3H
	ORG $+2
	DD	FLAT:??_C@_0CI@EJBKCNKI@Zhe?5Jiang?5Huasheng?5Technology?5C@
	DW	025f2H
	ORG $+2
	DD	FLAT:??_C@_0CG@OAMKINAC@Dongguan?5Jinyue?5Electronics?5Co?4@
	DW	025fbH
	ORG $+2
	DD	FLAT:??_C@_0BM@BOLFLJP@RICOH?5IMAGING?5COMPANY?0?5LTD?4@
	DW	0260eH
	ORG $+2
	DD	FLAT:??_C@_0CC@GLDMKJH@DongGuan?5HYX?5Industrial?5Co?4?0?5Lt@
	DW	02619H
	ORG $+2
	DD	FLAT:??_C@_0BE@HOIKDMEJ@Advanced?5Silicon?5SA@
	DW	0261bH
	ORG $+2
	DD	FLAT:??_C@_0BJ@FPNGMFON@INTELLIGENT?5ENERGY?0?5LTD?4@
	DW	0261cH
	ORG $+2
	DD	FLAT:??_C@_0O@KCHFFECA@EISST?5Limited@
	DW	0262bH
	ORG $+2
	DD	FLAT:??_C@_0CO@FNFDMCAN@JXT?5Precision?5Electronics?5Techn@
	DW	02633H
	ORG $+2
	DD	FLAT:??_C@_0CA@PHDNLNGC@Inno?5Audio?5?$CG?5Video?5?$CIHK?$CJ?5Limited@
	DW	02650H
	ORG $+2
	DD	FLAT:??_C@_0BO@PHCBCBDD@Electronics?5For?5Imaging?0?5Inc?4@
	DW	02668H
	ORG $+2
	DD	FLAT:??_C@_0DB@HNELJFDJ@Shenzhen?5Yuwenfa?5Electronic?5Tec@
	DW	02671H
	ORG $+2
	DD	FLAT:??_C@_0BB@LEBIHPBN@Innovative?5Logic@
	DW	02676H
	ORG $+2
	DD	FLAT:??_C@_09BGJCNJFM@Basler?5AG@
	DW	02679H
	ORG $+2
	DD	FLAT:??_C@_0CG@INIEIBBC@BESTMEDIA?5CD?9Recordable?5GmbH?5?$CG?5@
	DW	026a8H
	ORG $+2
	DD	FLAT:??_C@_0BD@LIHAOBJB@UNIREX?5CORPORATION@
	DW	026b0H
	ORG $+2
	DD	FLAT:??_C@_0CF@IPDEOKJG@Zhejiang?5Senda?5Electronics?5Co?4?0@
	DW	026bdH
	ORG $+2
	DD	FLAT:??_C@_0BF@BKLIFGG@Integral?5Memory?5Plc?4@
	DW	026bfH
	ORG $+2
	DD	FLAT:??_C@_0BG@BKPEFBBD@Broadway?5System?0?5Inc?4@
	DW	026f5H
	ORG $+2
	DD	FLAT:??_C@_0CJ@EHDKCLMM@Morning?5Star?5Digital?5Connector?5@
	DW	02700H
	ORG $+2
	DD	FLAT:??_C@_0BC@EBEJIPHO@MITACHI?5CO?4?0?5LTD?4@
	DW	0270cH
	ORG $+2
	DD	FLAT:??_C@_0BJ@FPADBEEC@Inhon?5Computer?5Co?4?0?5Ltd?4@
	DW	0270fH
	ORG $+2
	DD	FLAT:??_C@_0CA@HMOFPNPP@HGST?0?5a?5Western?5Digital?5Company@
	DW	00H
	ORG $+2
	DD	FLAT:??_C@_07NFANNNEC@UNKNOWN@
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@QBD@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0exception@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1exception@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Gexception@std@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Gruntime_error@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gruntime_error@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??_Gruntime_error@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gruntime_error@std@@UAEPAXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1runtime_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1runtime_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??1runtime_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1runtime_error@std@@UAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0USB@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0USB@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0USB@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0USB@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1USB@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1USB@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??1USB@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1USB@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0MonitorIPs@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MonitorIPs@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0MonitorIPs@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MonitorIPs@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1MonitorIPs@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MonitorIPs@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??1MonitorIPs@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MonitorIPs@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GUSB@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GUSB@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
__unwindtable$??_GUSB@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GUSB@@QAEPAXI@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z$2
__catchsym$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z$2
__catchsym$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	04H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z$2
__catchsym$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z$0
__ehfuncinfo$_WinMain@16 DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$_WinMain@16
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$_WinMain@16 DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$2
	DD	03H
	DD	FLAT:__unwindfunclet$_WinMain@16$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_WinMain@16$5
__ehfuncinfo$?AdjustProcessRights@@YAXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?AdjustProcessRights@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?AdjustProcessRights@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?AdjustProcessRights@@YAXXZ DD 00H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$?AdjustProcessRights@@YAXXZ$8
__unwindtable$?AdjustProcessRights@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?AdjustProcessRights@@YAXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?AdjustProcessRights@@YAXXZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?AdjustProcessRights@@YAXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?AdjustProcessRights@@YAXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?AdjustProcessRights@@YAXXZ$6
	DD	03H
	DD	FLAT:__unwindfunclet$?AdjustProcessRights@@YAXXZ$7
	DD	0ffffffffH
	DD	00H
__catchsym$?AdjustProcessRights@@YAXXZ$8 DD 09H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	0ffffff50H
	DD	FLAT:__catch$?AdjustProcessRights@@YAXXZ$0
__ehfuncinfo$?ModifyPrivilege@@YA_NPBD_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ModifyPrivilege@@YA_NPBD_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?ModifyPrivilege@@YA_NPBD_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ModifyPrivilege@@YA_NPBD_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ModifyPrivilege@@YA_NPBD_N@Z$1
__ehfuncinfo$?GetWMIStatus@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetWMIStatus@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetWMIStatus@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWMIStatus@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWMIStatus@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWMIStatus@@YAXXZ$2
__ehfuncinfo$?GetSystemStatusChanges@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetSystemStatusChanges@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetSystemStatusChanges@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$3
__ehfuncinfo$?GetSystemStatus@@YAXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetSystemStatus@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetSystemStatus@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatus@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatus@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatus@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemStatus@@YAXXZ$3
__ehfuncinfo$?GetSystemDetails@@YAXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetSystemDetails@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetSystemDetails@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemDetails@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemDetails@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemDetails@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemDetails@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemDetails@@YAXXZ$4
__ehfuncinfo$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z$0
__ehfuncinfo$?PrinterInfo@@YGIPAX@Z DD 019930522H
	DD	013H
	DD	FLAT:__unwindtable$?PrinterInfo@@YGIPAX@Z
	DD	03H
	DD	FLAT:__tryblocktable$?PrinterInfo@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?PrinterInfo@@YGIPAX@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?PrinterInfo@@YGIPAX@Z$19
	DD	05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$?PrinterInfo@@YGIPAX@Z$20
	DD	0dH
	DD	0dH
	DD	0eH
	DD	01H
	DD	FLAT:__catchsym$?PrinterInfo@@YGIPAX@Z$21
__unwindtable$?PrinterInfo@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$14
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?PrinterInfo@@YGIPAX@Z$18
__catchsym$?PrinterInfo@@YGIPAX@Z$19 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?PrinterInfo@@YGIPAX@Z$0
__catchsym$?PrinterInfo@@YGIPAX@Z$20 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?PrinterInfo@@YGIPAX@Z$2
__catchsym$?PrinterInfo@@YGIPAX@Z$21 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?PrinterInfo@@YGIPAX@Z$4
__ehfuncinfo$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$3
__ehfuncinfo$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$4
__ehfuncinfo$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$3
__ehfuncinfo$?GetPrintersList@@YAHXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetPrintersList@@YAHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetPrintersList@@YAHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPrintersList@@YAHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPrintersList@@YAHXZ$1
__ehfuncinfo$?PerformanceInfo@@YGIPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PerformanceInfo@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?PerformanceInfo@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PerformanceInfo@@YGIPAX@Z$0
__ehfuncinfo$?DeviceDrivers@@YGIPAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DeviceDrivers@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?DeviceDrivers@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeviceDrivers@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DeviceDrivers@@YGIPAX@Z$1
__ehfuncinfo$?SystemLogicalProcessorInforamtion@@YGIPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SystemLogicalProcessorInforamtion@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?SystemLogicalProcessorInforamtion@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SystemLogicalProcessorInforamtion@@YGIPAX@Z$0
__ehfuncinfo$?LogicalDrives@@YGIPAX@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogicalDrives@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?LogicalDrives@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogicalDrives@@YGIPAX@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LogicalDrives@@YGIPAX@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LogicalDrives@@YGIPAX@Z$0
__ehfuncinfo$?OSInfo@@YGIPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OSInfo@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?OSInfo@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OSInfo@@YGIPAX@Z$0
__ehfuncinfo$?HwProfile@@YGIPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?HwProfile@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?HwProfile@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HwProfile@@YGIPAX@Z$0
__ehfuncinfo$?ProcessInfo@@YGIPAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ProcessInfo@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?ProcessInfo@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessInfo@@YGIPAX@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessInfo@@YGIPAX@Z$1
__ehfuncinfo$?ThreadUSB@@YGIPAX@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ThreadUSB@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?ThreadUSB@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadUSB@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ThreadUSB@@YGIPAX@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadUSB@@YGIPAX@Z$2
__ehfuncinfo$?ThreadMessage@@YGIPAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ThreadMessage@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?ThreadMessage@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadMessage@@YGIPAX@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ThreadMessage@@YGIPAX@Z$1
__ehfuncinfo$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z$0
__sehtable$?SetThreadName@@YAXPBDK@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc8H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN12@SetThreadN
	DD	FLAT:$LN6@SetThreadN
__ehfuncinfo$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z$0
__ehfuncinfo$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1
__ehfuncinfo$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$2
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_dwBytesWritten$1 = -6100				; size = 4
_stLocalTime$2 = -6096					; size = 16
_logFile$3 = -6080					; size = 1024
_buffer$ = -5056					; size = 2048
_message$ = -3008					; size = 3000
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_id$ = 12						; size = 4
_format$ = 16						; size = 4
?Log@@YAXHHPBDZZ PROC					; Log

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	b8 d8 17 00 00	 mov	 eax, 6104		; 000017d8H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	89 84 24 d4 17
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+6104], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi

; 170  :     char message[3000] = { 0 };

  00020	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  00025	8d 84 24 24 0c
	00 00		 lea	 eax, DWORD PTR _message$[esp+6116]
  0002c	6a 00		 push	 0
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  :     char buffer[2048] = { 0 };

  00037	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+6112]
  0003e	68 00 08 00 00	 push	 2048			; 00000800H
  00043	6a 00		 push	 0
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _memset
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 172  :     va_list	argptr;
; 173  : 
; 174  :     HANDLE hdTh = CreateMutex(NULL, FALSE, "SysStatus_Log");

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHDHJHFN@SysStatus_Log@
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0005d	8b f8		 mov	 edi, eax

; 175  :     WaitForSingleObject(hdTh, INFINITE);

  0005f	6a ff		 push	 -1
  00061	57		 push	 edi
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00068	8d 45 14	 lea	 eax, DWORD PTR _format$[ebp+4]
  0006b	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00070	50		 push	 eax
  00071	51		 push	 ecx
  00072	ff 75 10	 push	 DWORD PTR _format$[ebp]
  00075	8d 8c 24 2c 04
	00 00		 lea	 ecx, DWORD PTR _buffer$[esp+6124]
  0007c	e8 00 00 00 00	 call	 __vsnprintf_l
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 183  :     if (type == LOG_HEADER)

  00081	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 183  :     if (type == LOG_HEADER)

  00087	83 f8 02	 cmp	 eax, 2
  0008a	75 74		 jne	 SHORT $LN2@Log

; 184  :     {
; 185  :         SYSTEMTIME stLocalTime = { 0 };
; 186  :         GetLocalTime(&stLocalTime);

  0008c	8d 44 24 10	 lea	 eax, DWORD PTR _stLocalTime$2[esp+6112]
  00090	0f 57 c0	 xorps	 xmm0, xmm0
  00093	50		 push	 eax
  00094	0f 29 44 24 14	 movaps	 XMMWORD PTR _stLocalTime$2[esp+6116], xmm0
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 187  : 
; 188  :         _snprintf(message, sizeof(message), "\r\n%.4d-%.2d-%.2d %.2d:%.2d:%.2d.%.3d PID %.5lu TID %.5lu ID %.5i\r\n%s\r\n",

  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  000a5	8b f0		 mov	 esi, eax
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  000ad	8d 8c 24 20 04
	00 00		 lea	 ecx, DWORD PTR _buffer$[esp+6112]
  000b4	51		 push	 ecx
  000b5	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  000b8	56		 push	 esi
  000b9	50		 push	 eax
  000ba	0f b7 44 24 2e	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6142]
  000bf	50		 push	 eax
  000c0	0f b7 44 24 30	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6144]
  000c5	50		 push	 eax
  000c6	0f b7 44 24 32	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6146]
  000cb	50		 push	 eax
  000cc	0f b7 44 24 34	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6148]
  000d1	50		 push	 eax
  000d2	0f b7 44 24 36	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6150]
  000d7	50		 push	 eax
  000d8	0f b7 44 24 36	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6150]
  000dd	50		 push	 eax
  000de	0f b7 44 24 38	 movzx	 eax, WORD PTR _stLocalTime$2[esp+6152]
  000e3	50		 push	 eax
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@MFNKNCE@?$AN?6?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d@
  000e9	8d 84 24 50 0c
	00 00		 lea	 eax, DWORD PTR _message$[esp+6160]
  000f0	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 __snprintf
  000fb	83 c4 38	 add	 esp, 56			; 00000038H

; 189  :             stLocalTime.wYear, stLocalTime.wMonth, stLocalTime.wDay, stLocalTime.wHour,
; 190  :             stLocalTime.wMinute, stLocalTime.wSecond, stLocalTime.wMilliseconds,
; 191  :             GetCurrentProcessId(), GetCurrentThreadId(), id, buffer);
; 192  :     }
; 193  :     if (type == LOG_MESSAGE)

  000fe	eb 27		 jmp	 SHORT $LN14@Log
$LN2@Log:
  00100	83 f8 01	 cmp	 eax, 1
  00103	75 25		 jne	 SHORT $LN3@Log

; 194  :     {
; 195  : 
; 196  :         _snprintf(message, sizeof(message), "\t%s\r\n", buffer);

  00105	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+6112]
  0010c	50		 push	 eax
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_05OLKONLEL@?7?$CFs?$AN?6@
  00112	8d 84 24 28 0c
	00 00		 lea	 eax, DWORD PTR _message$[esp+6120]
  00119	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 __snprintf
  00124	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@Log:

; 197  :     }
; 198  : 
; 199  :     //if not debug, trace in the file
; 200  :     if (!(type&LOG_DEBUG_ALL))

  00127	8b 45 08	 mov	 eax, DWORD PTR _type$[ebp]
$LN3@Log:
  0012a	a8 70		 test	 al, 112			; 00000070H
  0012c	0f 85 9e 00 00
	00		 jne	 $LN13@Log

; 201  :     {
; 202  :         DWORD dwBytesWritten = 0;
; 203  :         char logFile[1024] = { 0 };

  00132	68 00 04 00 00	 push	 1024			; 00000400H
  00137	8d 44 24 24	 lea	 eax, DWORD PTR _logFile$3[esp+6116]
  0013b	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _dwBytesWritten$1[esp+6116], 0
  00143	6a 00		 push	 0
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 _memset
  0014b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  :         _snprintf(logFile, sizeof(logFile), "%s.log", gszLogFilePrefix);

  0014e	8d 44 24 20	 lea	 eax, DWORD PTR _logFile$3[esp+6112]
  00152	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_06BEJGOBHG@?$CFs?4log@
  0015c	68 00 04 00 00	 push	 1024			; 00000400H
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 __snprintf
  00167	83 c4 10	 add	 esp, 16			; 00000010H

; 205  :         HANDLE hTraceFile = CreateFile(logFile,

  0016a	8d 44 24 20	 lea	 eax, DWORD PTR _logFile$3[esp+6112]
  0016e	6a 00		 push	 0
  00170	68 80 00 00 00	 push	 128			; 00000080H
  00175	6a 04		 push	 4
  00177	6a 00		 push	 0
  00179	6a 03		 push	 3
  0017b	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00180	50		 push	 eax
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00187	8b f0		 mov	 esi, eax

; 206  :             GENERIC_READ | GENERIC_WRITE,
; 207  :             FILE_SHARE_READ | FILE_SHARE_WRITE,
; 208  :             NULL,
; 209  :             OPEN_ALWAYS,
; 210  :             FILE_ATTRIBUTE_NORMAL,
; 211  :             NULL);
; 212  :         if (hTraceFile != INVALID_HANDLE_VALUE)

  00189	83 fe ff	 cmp	 esi, -1
  0018c	74 42		 je	 SHORT $LN13@Log

; 213  :         {
; 214  :             //Set position o the end of the file
; 215  :             SetFilePointer(hTraceFile, 0, NULL, FILE_END);

  0018e	6a 02		 push	 2
  00190	6a 00		 push	 0
  00192	6a 00		 push	 0
  00194	56		 push	 esi
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 216  :             WriteFile(hTraceFile, message, strlen(message), &dwBytesWritten, NULL);

  0019b	8d 8c 24 20 0c
	00 00		 lea	 ecx, DWORD PTR _message$[esp+6112]
  001a2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL11@Log:
  001a5	8a 01		 mov	 al, BYTE PTR [ecx]
  001a7	41		 inc	 ecx
  001a8	84 c0		 test	 al, al
  001aa	75 f9		 jne	 SHORT $LL11@Log
  001ac	6a 00		 push	 0
  001ae	8d 44 24 10	 lea	 eax, DWORD PTR _dwBytesWritten$1[esp+6116]
  001b2	2b ca		 sub	 ecx, edx
  001b4	50		 push	 eax
  001b5	51		 push	 ecx
  001b6	8d 84 24 2c 0c
	00 00		 lea	 eax, DWORD PTR _message$[esp+6124]
  001bd	50		 push	 eax
  001be	56		 push	 esi
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 217  :             CloseHandle(hTraceFile);

  001c5	56		 push	 esi
  001c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  001cc	ff d6		 call	 esi
  001ce	eb 06		 jmp	 SHORT $LN5@Log
$LN13@Log:

; 218  :         }
; 219  :     }
; 220  :     _snprintf(message, sizeof(message), "TID %.5lu ID %.5i %s\r\n", GetCurrentThreadId(), id, buffer);

  001d0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
$LN5@Log:
  001d6	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR _buffer$[esp+6112]
  001dd	50		 push	 eax
  001de	ff 75 0c	 push	 DWORD PTR _id$[ebp]
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  001e7	50		 push	 eax
  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NMAKEFMG@TID?5?$CF?45lu?5ID?5?$CF?45i?5?$CFs?$AN?6@
  001ed	8d 84 24 30 0c
	00 00		 lea	 eax, DWORD PTR _message$[esp+6128]
  001f4	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 __snprintf
  001ff	83 c4 18	 add	 esp, 24			; 00000018H

; 221  : 
; 222  :     ReleaseMutex(hdTh);

  00202	57		 push	 edi
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 223  :     CloseHandle(hdTh);

  00209	57		 push	 edi
  0020a	ff d6		 call	 esi

; 224  : 
; 225  :     //Trace on debug view
; 226  :     DebugStringToFile(message, type);

  0020c	ff 75 08	 push	 DWORD PTR _type$[ebp]
  0020f	8d 84 24 24 0c
	00 00		 lea	 eax, DWORD PTR _message$[esp+6116]
  00216	50		 push	 eax
  00217	e8 00 00 00 00	 call	 ?DebugStringToFile@@YAXPADH@Z ; DebugStringToFile

; 227  : }

  0021c	8b 8c 24 e4 17
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+6120]
  00223	83 c4 08	 add	 esp, 8
  00226	5f		 pop	 edi
  00227	5e		 pop	 esi
  00228	33 cc		 xor	 ecx, esp
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
?Log@@YAXHHPBDZZ ENDP					; Log
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
;	COMDAT ?strchr@@YAPADQADH@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADQADH@Z PROC				; strchr, COMDAT

; 505  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 507  :     }

  00003	5d		 pop	 ebp

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  00004	e9 00 00 00 00	 jmp	 _strchr
?strchr@@YAPADQADH@Z ENDP				; strchr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT
; __String$ = ecx
; __SubString$ = edx

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00000	52		 push	 edx
  00001	51		 push	 ecx
  00002	e8 00 00 00 00	 call	 _strstr
  00007	83 c4 08	 add	 esp, 8

; 525  :     }

  0000a	c3		 ret	 0
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 55   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0exception@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx

; 56   :         __std_exception_data _InitData = { _Message, true };

  00028	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0002b	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  0002e	89 45 ec	 mov	 DWORD PTR __InitData$[ebp], eax
  00031	0f 57 c0	 xorps	 xmm0, xmm0

; 57   :         __std_exception_copy(&_InitData, &_Data);

  00034	52		 push	 edx
  00035	8d 45 ec	 lea	 eax, DWORD PTR __InitData$[ebp]
  00038	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003e	50		 push	 eax
  0003f	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00043	c6 45 f0 01	 mov	 BYTE PTR __InitData$[ebp+4], 1
  00047	e8 00 00 00 00	 call	 ___std_exception_copy
  0004c	83 c4 08	 add	 esp, 8

; 58   :     }

  0004f	8b c6		 mov	 eax, esi
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5e		 pop	 esi
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@QBD@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@QBD@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 68   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0exception@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 67   :         : _Data()

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 68   :     {

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0002e	0f 57 c0	 xorps	 xmm0, xmm0

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

  00031	50		 push	 eax
  00032	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00036	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00039	83 c0 04	 add	 eax, 4
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ___std_exception_copy
  00042	83 c4 08	 add	 esp, 8

; 70   :     }

  00045	8b c6		 mov	 eax, esi
  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0exception@std@@QAE@ABV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0exception@std@@QAE@ABV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 85   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1exception@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 86   :         __std_exception_destroy(&_Data);

  00022	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00025	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00031	83 c4 04	 add	 esp, 4

; 87   :     }

  00034	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00037	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003e	59		 pop	 ecx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1exception@std@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1exception@std@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 92   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gexception@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 86   :         __std_exception_destroy(&_Data);

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ___std_exception_destroy
  00034	83 c4 04	 add	 esp, 4
  00037	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0003b	74 0b		 je	 SHORT $LN6@scalar
  0003d	6a 0c		 push	 12			; 0000000cH
  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00048	8b c6		 mov	 eax, esi
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	5e		 pop	 esi
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Gexception@std@@UAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gexception@std@@UAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vsprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	ff 75 0c	 push	 DWORD PTR __ArgList$[ebp]
  00006	51		 push	 ecx
  00007	52		 push	 edx
  00008	83 ca ff	 or	 edx, -1
  0000b	e8 00 00 00 00	 call	 __vsnprintf_l
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	83 ca ff	 or	 edx, -1
  00009	50		 push	 eax
  0000a	51		 push	 ecx
  0000b	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 __vsnprintf_l
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);
; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);
; 1792 :         return _Result;
; 1793 :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$dead$ = ecx

; 47   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$2 = -24					; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 165  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0002b	8b 55 08	 mov	 edx, DWORD PTR __Message$[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0002e	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00032	72 02		 jb	 SHORT $LN11@runtime_er
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00034	8b 12		 mov	 edx, DWORD PTR [edx]
$LN11@runtime_er:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h

; 54   :         : _Data()

  00036	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 55   :     {

  00039	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003f	0f 57 c0	 xorps	 xmm0, xmm0

; 56   :         __std_exception_data _InitData = { _Message, true };

  00042	89 55 e8	 mov	 DWORD PTR __InitData$2[ebp], edx

; 57   :         __std_exception_copy(&_InitData, &_Data);

  00045	50		 push	 eax
  00046	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0004a	8d 45 e8	 lea	 eax, DWORD PTR __InitData$2[ebp]
  0004d	50		 push	 eax
  0004e	c6 45 ec 01	 mov	 BYTE PTR __InitData$2[ebp+4], 1
  00052	e8 00 00 00 00	 call	 ___std_exception_copy
  00057	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\stdexcept

; 164  : 		: _Mybase(_Message.c_str())

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 165  : 		{	// construct from message string

  00061	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 166  : 		}

  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	8b c6		 mov	 eax, esi
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	5e		 pop	 esi
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gruntime_error@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 86   :         __std_exception_destroy(&_Data);

  00030	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00033	50		 push	 eax
  00034	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0003a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003f	83 c4 04	 add	 esp, 4
  00042	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00046	74 0b		 je	 SHORT $LN9@scalar
  00048	6a 0c		 push	 12			; 0000000cH
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00050	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00053	8b c6		 mov	 eax, esi
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gruntime_error@std@@UAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??_Gruntime_error@std@@UAEPAXI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gruntime_error@std@@UAEPAXI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1runtime_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 86   :         __std_exception_destroy(&_Data);

  0002d	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00030	50		 push	 eax
  00031	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00037	e8 00 00 00 00	 call	 ___std_exception_destroy
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1runtime_error@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??1runtime_error@std@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1runtime_error@std@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 67   :         : _Data()

  00029	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 68   :     {

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00032	0f 57 c0	 xorps	 xmm0, xmm0

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

  00035	50		 push	 eax
  00036	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ___std_exception_copy
  00046	83 c4 08	 add	 esp, 8
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
  00056	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005d	8b c6		 mov	 eax, esi
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	5e		 pop	 esi
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -52				; size = 4
___$ReturnUdt$ = -48					; size = 4
$T2 = -44						; size = 4
__Buff$3 = -40						; size = 21
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z PROC ; std::to_string, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 567  : 	{	// convert unsigned long to string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b da		 mov	 ebx, edx
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 7d d0	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  00032	89 7d cc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi
  00035	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 568  : 	return (_Integral_to_string<char>(_Val));

  0003c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 519  : 		_RNext = _UIntegral_to_buff(_RNext, _UVal);

  00043	8d 75 ed	 lea	 esi, DWORD PTR __Buff$3[ebp+21]
$LL32@to_string:

; 496  : 		*--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  00046	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0004b	4e		 dec	 esi
  0004c	f7 e3		 mul	 ebx
  0004e	c1 ea 03	 shr	 edx, 3
  00051	8a c2		 mov	 al, dl
  00053	c0 e0 02	 shl	 al, 2
  00056	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00059	02 c9		 add	 cl, cl
  0005b	2a d9		 sub	 bl, cl
  0005d	80 c3 30	 add	 bl, 48			; 00000030H
  00060	88 1e		 mov	 BYTE PTR [esi], bl

; 497  : 		_UVal_trunc /= 10;

  00062	8b da		 mov	 ebx, edx

; 498  : 		}
; 499  : 	while (_UVal_trunc != 0);

  00064	85 db		 test	 ebx, ebx
  00066	75 de		 jne	 SHORT $LL32@to_string
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  00068	8d 45 ed	 lea	 eax, DWORD PTR __Buff$3[ebp+21]

; 3976 : 		_My_data._Mysize = 0;

  0006b	89 57 10	 mov	 DWORD PTR [edi+16], edx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006e	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00075	88 17		 mov	 BYTE PTR [edi], dl
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  00077	3b f0		 cmp	 esi, eax
  00079	74 0b		 je	 SHORT $LN64@to_string

; 2253 : 			{
; 2254 : 			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  0007b	2b c6		 sub	 eax, esi
  0007d	8b cf		 mov	 ecx, edi
  0007f	50		 push	 eax
  00080	56		 push	 esi
  00081	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN64@to_string:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string

; 568  : 	return (_Integral_to_string<char>(_Val));

  00086	b9 02 00 00 00	 mov	 ecx, 2

; 521  : 	return (basic_string<_Elem>(_RNext, _Buff_end));

  0008b	c7 45 d4 02 00
	00 00		 mov	 DWORD PTR $T2[ebp], 2

; 568  : 	return (_Integral_to_string<char>(_Val));

  00092	89 4d d4	 mov	 DWORD PTR $T2[ebp], ecx
  00095	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00098	89 4d d4	 mov	 DWORD PTR $T2[ebp], ecx
  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a2	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  000a9	8b c7		 mov	 eax, edi

; 569  : 	}

  000ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b5	59		 pop	 ecx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	33 cd		 xor	 ecx, ebp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z$1:
  00000	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 02	 and	 eax, 2
  00006	0f 84 0c 00 00
	00		 je	 $LN10@to_string
  0000c	83 65 d4 fd	 and	 DWORD PTR $T2[ebp], -3	; fffffffdH
  00010	8b 4d cc	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@to_string:
  00018	c3		 ret	 0
__unwindfunclet$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z$0:
  00019	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	0f 84 0c 00 00
	00		 je	 $LN4@to_string
  00025	83 65 d4 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00029	8b 4d cc	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@to_string:
  00031	c3		 ret	 0
__ehhandler$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z:
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00046	33 c8		 xor	 ecx, eax
  00048	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z
  00052	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@K@Z ENDP ; std::to_string
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
;	COMDAT ??0PBuffer@@QAE@XZ
_TEXT	SEGMENT
??0PBuffer@@QAE@XZ PROC					; PBuffer::PBuffer, COMDAT
; _this$ = ecx

; 109  :     {
; 110  :         pMem = nullptr;

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 111  :         lMem = 0;
; 112  :     };

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0PBuffer@@QAE@XZ ENDP					; PBuffer::PBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
;	COMDAT ??1PBuffer@@QAE@XZ
_TEXT	SEGMENT
??1PBuffer@@QAE@XZ PROC					; PBuffer::~PBuffer, COMDAT
; _this$ = ecx

; 114  :     {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 164  :         if (pMem)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN6@PBuffer

; 165  :         {
; 166  :             delete[] pMem;

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000f	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN6@PBuffer:

; 115  :         _clear();
; 116  :     };

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
??1PBuffer@@QAE@XZ ENDP					; PBuffer::~PBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
;	COMDAT ?_allocMem@PBuffer@@QAEPAEI@Z
_TEXT	SEGMENT
_len$ = 8						; size = 4
?_allocMem@PBuffer@@QAEPAEI@Z PROC			; PBuffer::_allocMem, COMDAT
; _this$ = ecx

; 124  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 125  :         if (len > lMem)

  00007	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000a	8b 06		 mov	 eax, DWORD PTR [esi]
  0000c	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0000f	76 28		 jbe	 SHORT $LN2@allocMem

; 126  :         {
; 127  :             if (pMem)

  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN3@allocMem

; 128  :                 delete[] pMem;

  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001b	83 c4 04	 add	 esp, 4
$LN3@allocMem:

; 129  :             lMem = len;
; 130  :             pMem = new byte[lMem];

  0001e	57		 push	 edi
  0001f	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00022	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  00027	ff 76 04	 push	 DWORD PTR [esi+4]
  0002a	89 06		 mov	 DWORD PTR [esi], eax
  0002c	6a 00		 push	 0
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset

; 132  :         }
; 133  :         return pMem;

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@allocMem:

; 134  :     };

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_allocMem@PBuffer@@QAEPAEI@Z ENDP			; PBuffer::_allocMem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
;	COMDAT ?_clear@PBuffer@@QAEXXZ
_TEXT	SEGMENT
?_clear@PBuffer@@QAEXXZ PROC				; PBuffer::_clear, COMDAT
; _this$ = ecx

; 163  :     {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 164  :         if (pMem)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $LN4@clear

; 165  :         {
; 166  :             delete[] pMem;

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000f	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN4@clear:

; 168  :         }
; 169  :         lMem = 0;
; 170  :     }

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
?_clear@PBuffer@@QAEXXZ ENDP				; PBuffer::_clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
;	COMDAT ??0USB@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0USB@@QAE@XZ PROC					; USB::USB, COMDAT
; _this$ = ecx

; 142  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0USB@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 134  :         wPortsNumber(0),

  00029	33 c0		 xor	 eax, eax
  0002b	66 89 06	 mov	 WORD PTR [esi], ax

; 135  :         ulTotalDevicesConnected(0),

  0002e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 136  :         NestedLevel(0),

  00031	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00034	89 86 0c 02 00
	00		 mov	 DWORD PTR [esi+524], eax

; 390  : 		_Mylast(),

  0003a	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax

; 391  : 		_Myend()

  00040	89 86 14 02 00
	00		 mov	 DWORD PTR [esi+532], eax
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 142  :     {

  00046	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax

; 143  :         memset(buf,0x00,sizeof(buf));

  00049	68 00 02 00 00	 push	 512			; 00000200H
  0004e	50		 push	 eax
  0004f	89 86 18 02 00
	00		 mov	 DWORD PTR [esi+536], eax
  00055	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
  0005b	89 86 20 02 00
	00		 mov	 DWORD PTR [esi+544], eax
  00061	89 86 24 02 00
	00		 mov	 DWORD PTR [esi+548], eax
  00067	89 86 28 02 00
	00		 mov	 DWORD PTR [esi+552], eax
  0006d	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00076	8b 96 10 02 00
	00		 mov	 edx, DWORD PTR [esi+528]
  0007c	83 c4 08	 add	 esp, 8
  0007f	8b 8e 0c 02 00
	00		 mov	 ecx, DWORD PTR [esi+524]
  00085	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0008a	8b 86 0c 02 00
	00		 mov	 eax, DWORD PTR [esi+524]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00090	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00093	89 86 10 02 00
	00		 mov	 DWORD PTR [esi+528], eax
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 145  :     };

  00099	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5e		 pop	 esi
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0USB@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??0USB@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0USB@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0USB@@QAE@XZ ENDP					; USB::USB
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
;	COMDAT ??1USB@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1USB@@QAE@XZ PROC					; USB::~USB, COMDAT
; _this$ = ecx

; 147  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1USB@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 148  :         usbDevDetails.clear();

  0002e	8d b1 0c 02 00
	00		 lea	 esi, DWORD PTR [ecx+524]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	51		 push	 ecx
  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0003f	8b 06		 mov	 eax, DWORD PTR [esi]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00041	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00044	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 149  :     };

  00047	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  0004e	8b ce		 mov	 ecx, esi
  00050	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 149  :     };

  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1USB@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??1USB@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1USB@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1USB@@QAE@XZ ENDP					; USB::~USB
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
;	COMDAT ?GetVendorString@USB@@SAPADG@Z
_TEXT	SEGMENT
?GetVendorString@USB@@SAPADG@Z PROC			; USB::GetVendorString, COMDAT
; _idVendor$ = cx

; 160  :     {

  00000	56		 push	 esi
  00001	66 8b f1	 mov	 si, cx

; 161  :         if (idVendor != 0x0000)

  00004	66 85 f6	 test	 si, si
  00007	74 2a		 je	 SHORT $LN3@GetVendorS

; 162  :         {
; 163  :             PUSBVENDORID vendorID{};
; 164  :             vendorID = USBVendorIDs;
; 165  :             while (vendorID->usVendorID != 0x0000)

  00009	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?USBVendorIDs@@3PAUUSBVENDORID@@A
  0000f	ba 00 00 00 00	 mov	 edx, OFFSET ?USBVendorIDs@@3PAUUSBVENDORID@@A
  00014	66 85 c0	 test	 ax, ax
  00017	74 1a		 je	 SHORT $LN3@GetVendorS
  00019	0f b7 c8	 movzx	 ecx, ax
  0001c	0f 1f 40 00	 npad	 4
$LL2@GetVendorS:

; 166  :             {
; 167  :                 if (vendorID->usVendorID == idVendor)

  00020	66 3b ce	 cmp	 cx, si
  00023	74 12		 je	 SHORT $LN8@GetVendorS

; 170  :                 }
; 171  :                 vendorID++;

  00025	0f b7 42 08	 movzx	 eax, WORD PTR [edx+8]
  00029	83 c2 08	 add	 edx, 8
  0002c	8b c8		 mov	 ecx, eax
  0002e	66 85 c0	 test	 ax, ax
  00031	75 ed		 jne	 SHORT $LL2@GetVendorS
$LN3@GetVendorS:

; 172  :             }
; 173  :         }
; 174  :         return nullptr;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 175  :     }

  00036	c3		 ret	 0
$LN8@GetVendorS:

; 168  :                 {
; 169  :                     return (vendorID->szVendor);

  00037	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003a	5e		 pop	 esi

; 175  :     }

  0003b	c3		 ret	 0
?GetVendorString@USB@@SAPADG@Z ENDP			; USB::GetVendorString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
;	COMDAT ??0MonitorIPs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0MonitorIPs@@QAE@XZ PROC				; MonitorIPs::MonitorIPs, COMDAT
; _this$ = ecx

; 43   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0MonitorIPs@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 42   :     MonitorIPs() : m_hSync(nullptr), m_hWait(nullptr), m_changed(false)

  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00036	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 390  : 		_Mylast(),

  0003d	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 391  : 		_Myend()

  00044	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 43   :     {

  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 44   :         Log(LOG_DEBUG, __LINE__, ">> MonIPs");

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_09BAECPDM@?$DO?$DO?5MonIPs@
  00057	6a 2c		 push	 44			; 0000002cH
  00059	6a 10		 push	 16			; 00000010H
  0005b	c6 46 28 00	 mov	 BYTE PTR [esi+40], 0
  0005f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00064	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00067	83 c4 08	 add	 esp, 8
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 45   :         ZeroMemory(&m_o, sizeof(m_o));

  0006a	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
  0006e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00075	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  00078	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0007b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00080	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00083	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00086	89 46 20	 mov	 DWORD PTR [esi+32], eax
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 47   :     }

  00089	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00090	8b c6		 mov	 eax, esi
  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5e		 pop	 esi
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MonitorIPs@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??0MonitorIPs@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0MonitorIPs@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0MonitorIPs@@QAE@XZ ENDP				; MonitorIPs::MonitorIPs
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
;	COMDAT ??1MonitorIPs@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1MonitorIPs@@QAE@XZ PROC				; MonitorIPs::~MonitorIPs, COMDAT
; _this$ = ecx

; 55   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1MonitorIPs@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 56   :         if (m_hWait) static_cast<void>(UnregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE));

  00030	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00033	85 c0		 test	 eax, eax
  00035	74 09		 je	 SHORT $LN2@MonitorIPs
  00037	6a ff		 push	 -1
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterWaitEx@8
$LN2@MonitorIPs:

; 57   :         if (m_o.hEvent) CloseHandle(m_o.hEvent);

  00040	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00043	85 c0		 test	 eax, eax
  00045	74 07		 je	 SHORT $LN3@MonitorIPs
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN3@MonitorIPs:

; 58   :         if (m_hSync) CloseHandle(m_hSync);

  0004e	8b 06		 mov	 eax, DWORD PTR [esi]
  00050	85 c0		 test	 eax, eax
  00052	74 07		 je	 SHORT $LN4@MonitorIPs
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN4@MonitorIPs:

; 59   : 
; 60   :         Log(LOG_DEBUG, __LINE__, "<< MonIPs");

  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_09CLAHNHIH@?$DM?$DM?5MonIPs@
  00060	6a 3c		 push	 60			; 0000003cH
  00062	6a 10		 push	 16			; 00000010H
  00064	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   :     }

  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00076	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 61   :     }

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5e		 pop	 esi
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1MonitorIPs@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??1MonitorIPs@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1MonitorIPs@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1MonitorIPs@@QAE@XZ ENDP				; MonitorIPs::~MonitorIPs
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
;	COMDAT ?GetIPs@MonitorIPs@@QAEXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
_ips$ = 8						; size = 4
?GetIPs@MonitorIPs@@QAEXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; MonitorIPs::GetIPs, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 67   :         WaitForSingleObject(m_hSync, MINUTE);

  00006	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0000b	ff 36		 push	 DWORD PTR [esi]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1400 : 		if (this != _STD addressof(_Right))

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _ips$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 69   :         ips = m_ips;

  00016	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1400 : 		if (this != _STD addressof(_Right))

  00019	3b c8		 cmp	 ecx, eax
  0001b	74 0d		 je	 SHORT $LN4@GetIPs

; 1390 : 		_Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0001d	ff 75 08	 push	 DWORD PTR $T1[ebp]
  00020	ff 70 04	 push	 DWORD PTR [eax+4]
  00023	ff 30		 push	 DWORD PTR [eax]
  00025	e8 00 00 00 00	 call	 ??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN4@GetIPs:
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 71   :         ReleaseMutex(m_hSync);

  0002a	ff 36		 push	 DWORD PTR [esi]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  00032	5e		 pop	 esi

; 72   :     }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?GetIPs@MonitorIPs@@QAEXAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; MonitorIPs::GetIPs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
;	COMDAT ?IsChanged@MonitorIPs@@QAE_NXZ
_TEXT	SEGMENT
?IsChanged@MonitorIPs@@QAE_NXZ PROC			; MonitorIPs::IsChanged, COMDAT
; _this$ = ecx

; 75   :     {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 76   :         WaitForSingleObject(m_hSync, MINUTE);

  00004	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :         bool ret = m_changed;

  00011	8a 5e 28	 mov	 bl, BYTE PTR [esi+40]

; 79   :         m_changed = false;
; 80   : 
; 81   :         ReleaseMutex(m_hSync);

  00014	ff 36		 push	 DWORD PTR [esi]
  00016	c6 46 28 00	 mov	 BYTE PTR [esi+40], 0
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 82   :         return ret;

  00020	5e		 pop	 esi
  00021	8a c3		 mov	 al, bl
  00023	5b		 pop	 ebx

; 83   :     }

  00024	c3		 ret	 0
?IsChanged@MonitorIPs@@QAE_NXZ ENDP			; MonitorIPs::IsChanged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
;	COMDAT ?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$1$ = -24					; size = 4
tv212 = -20						; size = 4
__Freq$2$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ PROC ; std::chrono::steady_clock::now, COMDAT
; ___$ReturnUdt$ = ecx

; 799  : 		{	// get current time

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d e8	 mov	 DWORD PTR ___$ReturnUdt$1$[ebp], ecx

; 800  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

  0002b	e8 00 00 00 00	 call	 __Query_perf_frequency
  00030	8b d8		 mov	 ebx, eax
  00032	8b fa		 mov	 edi, edx
  00034	89 5d f0	 mov	 DWORD PTR __Freq$2$[ebp], ebx

; 801  : 		const long long _Ctr = _Query_perf_counter();

  00037	e8 00 00 00 00	 call	 __Query_perf_counter

; 802  : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 803  : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 804  : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

  0003c	53		 push	 ebx
  0003d	57		 push	 edi
  0003e	53		 push	 ebx
  0003f	52		 push	 edx
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 __alldvrm
  00046	8b f3		 mov	 esi, ebx
  00048	5b		 pop	 ebx
  00049	6a 00		 push	 0
  0004b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00050	56		 push	 esi
  00051	51		 push	 ecx
  00052	89 45 ec	 mov	 DWORD PTR tv212[ebp], eax
  00055	8b da		 mov	 ebx, edx
  00057	e8 00 00 00 00	 call	 __allmul
  0005c	57		 push	 edi
  0005d	ff 75 f0	 push	 DWORD PTR __Freq$2$[ebp]
  00060	52		 push	 edx
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 __alldiv
  00067	6a 00		 push	 0
  00069	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0006e	53		 push	 ebx
  0006f	ff 75 ec	 push	 DWORD PTR tv212[ebp]
  00072	8b f0		 mov	 esi, eax
  00074	8b fa		 mov	 edi, edx
  00076	e8 00 00 00 00	 call	 __allmul

; 805  : 		return (time_point(duration(_Whole + _Part)));

  0007b	03 f0		 add	 esi, eax

; 210  : 		: _MyDur(_Other)

  0007d	8b 45 e8	 mov	 eax, DWORD PTR ___$ReturnUdt$1$[ebp]

; 805  : 		return (time_point(duration(_Whole + _Part)));

  00080	13 fa		 adc	 edi, edx

; 210  : 		: _MyDur(_Other)

  00082	89 30		 mov	 DWORD PTR [eax], esi
  00084	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 806  : 		}

  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?now@steady_clock@chrono@std@@SA?AV?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@23@XZ ENDP ; std::chrono::steady_clock::now
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
;	COMDAT ??__EPendingThreads@@YAXXZ
text$di	SEGMENT
??__EPendingThreads@@YAXXZ PROC				; `dynamic initializer for 'PendingThreads'', COMDAT

; 42   : std::vector<HANDLE> PendingThreads;

  00000	68 00 00 00 00	 push	 OFFSET ??__FPendingThreads@@YAXXZ ; `dynamic atexit destructor for 'PendingThreads''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__EPendingThreads@@YAXXZ ENDP				; `dynamic initializer for 'PendingThreads''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??__FPendingThreads@@YAXXZ
text$yd	SEGMENT
??__FPendingThreads@@YAXXZ PROC				; `dynamic atexit destructor for 'PendingThreads'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00005	85 c0		 test	 eax, eax
  00007	74 4d		 je	 SHORT $LN6@dynamic

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8
  0000f	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN82@dynamic

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 2b		 ja	 SHORT $LN79@dynamic

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN82@dynamic:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00038	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A, 0

; 1919 : 			this->_Mylast() = pointer();

  00042	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, 0

; 1920 : 			this->_Myend() = pointer();

  0004c	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, 0
$LN6@dynamic:
  00056	c3		 ret	 0
$LN79@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??__FPendingThreads@@YAXXZ ENDP				; `dynamic atexit destructor for 'PendingThreads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_sMember$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?_thSetInt@@YAXPAHH@Z PROC				; _thSetInt
; _piProtectedVar$ = ecx
; _iValue$ = edx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 54   :     if (!piProtectedVar)
; 55   :         return;
; 56   : 
; 57   :     char sMember[100] = { 0 };

  00013	6a 64		 push	 100			; 00000064H
  00015	8d 45 98	 lea	 eax, DWORD PTR _sMember$[ebp]
  00018	8b da		 mov	 ebx, edx
  0001a	6a 00		 push	 0
  0001c	50		 push	 eax
  0001d	8b f9		 mov	 edi, ecx
  0001f	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00024	57		 push	 edi
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0002a	8d 45 98	 lea	 eax, DWORD PTR _sMember$[ebp]
  0002d	6a 63		 push	 99			; 00000063H
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 __snprintf
  00035	83 c4 1c	 add	 esp, 28			; 0000001cH

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00038	8d 45 98	 lea	 eax, DWORD PTR _sMember$[ebp]
  0003b	50		 push	 eax
  0003c	6a 00		 push	 0
  0003e	6a 00		 push	 0
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00046	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  00048	6a ff		 push	 -1
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  00051	56		 push	 esi
  00052	89 1f		 mov	 DWORD PTR [edi], ebx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 65   :     CloseHandle(hdTh);

  0005a	56		 push	 esi
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 66   : }

  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	33 cd		 xor	 ecx, ebp
  00068	5b		 pop	 ebx
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?_thSetInt@@YAXPAHH@Z ENDP				; _thSetInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_sMember$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?_thGetInt@@YAHPAH@Z PROC				; _thGetInt
; _piProtectedVar$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 70   :     if (!piProtectedVar)
; 71   :         return 0;
; 72   : 
; 73   :     char sMember[100] = { 0 };

  00012	6a 64		 push	 100			; 00000064H
  00014	8d 45 98	 lea	 eax, DWORD PTR _sMember$[ebp]
  00017	8b f1		 mov	 esi, ecx
  00019	6a 00		 push	 0
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00021	56		 push	 esi
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00027	8d 45 98	 lea	 eax, DWORD PTR _sMember$[ebp]
  0002a	6a 63		 push	 99			; 00000063H
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __snprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00035	8d 45 98	 lea	 eax, DWORD PTR _sMember$[ebp]
  00038	50		 push	 eax
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00043	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00045	6a ff		 push	 -1
  00047	57		 push	 edi
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0004e	8b 36		 mov	 esi, DWORD PTR [esi]

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00050	57		 push	 edi
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  00057	57		 push	 edi
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 82   : 
; 83   :     return iRetVal;
; 84   : }

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00061	8b c6		 mov	 eax, esi
  00063	5f		 pop	 edi
  00064	33 cd		 xor	 ecx, ebp
  00066	5e		 pop	 esi
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?_thGetInt@@YAHPAH@Z ENDP				; _thGetInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_extension$1 = -5088					; size = 4
_dwBytesWritten$2 = -5084				; size = 4
_hdTh$1$ = -5080					; size = 4
_message$GSCopy$1$ = -5076				; size = 4
_stLocalTime$3 = -5072					; size = 16
_oldFile$4 = -5056					; size = 1024
_logFile$5 = -4032					; size = 1024
_line$6 = -3008						; size = 3000
__$ArrayPad$ = -4					; size = 4
_message$ = 8						; size = 4
_typeDebug$ = 12					; size = 4
?DebugStringToFile@@YAXPADH@Z PROC			; DebugStringToFile

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	b8 e8 13 00 00	 mov	 eax, 5096		; 000013e8H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	89 84 24 e4 13
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+5096], eax

; 91   :     if (typeDebug&LOG_DEBUG_ALL)

  0001e	f6 45 0c 70	 test	 BYTE PTR _typeDebug$[ebp], 112 ; 00000070H
  00022	56		 push	 esi
  00023	8b 75 08	 mov	 esi, DWORD PTR _message$[ebp]
  00026	57		 push	 edi
  00027	89 74 24 1c	 mov	 DWORD PTR _message$GSCopy$1$[esp+5104], esi
  0002b	0f 84 f7 01 00
	00		 je	 $LN4@DebugStrin

; 92   :     {
; 93   :         HANDLE hdTh = CreateMutex(NULL, FALSE, "SysStatus_Trace");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GBPLBEEL@SysStatus_Trace@
  00036	6a 00		 push	 0
  00038	6a 00		 push	 0
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12

; 94   :         WaitForSingleObject(hdTh, INFINITE);

  00040	6a ff		 push	 -1
  00042	50		 push	 eax
  00043	89 44 24 20	 mov	 DWORD PTR _hdTh$1$[esp+5112], eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 95   : 
; 96   :         char line[3000] = { 0 };

  0004d	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  00052	8d 84 24 34 08
	00 00		 lea	 eax, DWORD PTR _line$6[esp+5108]
  00059	6a 00		 push	 0
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 _memset

; 97   :         char extension[4] = { 0 };
; 98   : 
; 99   :         if (typeDebug&LOG_DEBUG)

  00061	8b 45 0c	 mov	 eax, DWORD PTR _typeDebug$[ebp]
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _extension$1[esp+5104], 0
  0006f	a8 10		 test	 al, 16			; 00000010H
  00071	74 09		 je	 SHORT $LN5@DebugStrin

; 100  :         {
; 101  :             strncpy(extension, "dbg", 3);

  00073	6a 03		 push	 3
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_03LBAKCJJ@dbg@
  0007a	eb 18		 jmp	 SHORT $LN18@DebugStrin
$LN5@DebugStrin:

; 102  :         }
; 103  :         else if (typeDebug&LOG_DEBUG_WND)

  0007c	a8 20		 test	 al, 32			; 00000020H
  0007e	74 09		 je	 SHORT $LN7@DebugStrin

; 104  :         {
; 105  :             strncpy(extension, "wnd", 3);

  00080	6a 03		 push	 3
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_03GLILPAEP@wnd@
  00087	eb 0b		 jmp	 SHORT $LN18@DebugStrin
$LN7@DebugStrin:

; 106  :         }
; 107  :         else if (typeDebug&LOG_DEBUG_WMI)

  00089	a8 40		 test	 al, 64			; 00000040H
  0008b	74 14		 je	 SHORT $LN9@DebugStrin

; 108  :         {
; 109  :             strncpy(extension, "wmi", 3);

  0008d	6a 03		 push	 3
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_03NMGDDAFL@wmi@
$LN18@DebugStrin:

; 110  :         }
; 111  : 
; 112  :         SYSTEMTIME stLocalTime = { 0 };

  00094	8d 44 24 18	 lea	 eax, DWORD PTR _extension$1[esp+5112]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _strncpy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@DebugStrin:

; 113  :         GetLocalTime(&stLocalTime);

  000a1	8d 44 24 20	 lea	 eax, DWORD PTR _stLocalTime$3[esp+5104]
  000a5	0f 57 c0	 xorps	 xmm0, xmm0
  000a8	50		 push	 eax
  000a9	0f 29 44 24 24	 movaps	 XMMWORD PTR _stLocalTime$3[esp+5108], xmm0
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 114  : 
; 115  :         _snprintf(line, sizeof(line), "%.4d-%.2d-%.2d %.2d:%.2d:%.2d.%.3d PID %.5u %s",

  000b4	56		 push	 esi
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  000bb	50		 push	 eax
  000bc	0f b7 44 24 36	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5126]
  000c1	50		 push	 eax
  000c2	0f b7 44 24 38	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5128]
  000c7	50		 push	 eax
  000c8	0f b7 44 24 3a	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5130]
  000cd	50		 push	 eax
  000ce	0f b7 44 24 3c	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5132]
  000d3	50		 push	 eax
  000d4	0f b7 44 24 3e	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5134]
  000d9	50		 push	 eax
  000da	0f b7 44 24 3e	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5134]
  000df	50		 push	 eax
  000e0	0f b7 44 24 40	 movzx	 eax, WORD PTR _stLocalTime$3[esp+5136]
  000e5	50		 push	 eax
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@CLGPPHLF@?$CF?44d?9?$CF?42d?9?$CF?42d?5?$CF?42d?3?$CF?42d?3?$CF?42d?4?$CF@
  000eb	8d 84 24 58 08
	00 00		 lea	 eax, DWORD PTR _line$6[esp+5144]
  000f2	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 __snprintf

; 116  :             stLocalTime.wYear, stLocalTime.wMonth, stLocalTime.wDay, stLocalTime.wHour,
; 117  :             stLocalTime.wMinute, stLocalTime.wSecond, stLocalTime.wMilliseconds,
; 118  :             GetCurrentProcessId(), message);
; 119  : 
; 120  :         DWORD dwBytesWritten = 0;
; 121  :         char logFile[1024] = { 0 };

  000fd	68 00 04 00 00	 push	 1024			; 00000400H
  00102	8d 84 24 64 04
	00 00		 lea	 eax, DWORD PTR _logFile$5[esp+5156]
  00109	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR _dwBytesWritten$2[esp+5156], 0
  00111	6a 00		 push	 0
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 _memset
  00119	83 c4 3c	 add	 esp, 60			; 0000003cH

; 122  :         _snprintf(logFile, sizeof(logFile), "%s.%s.log", gszLogFilePrefix, extension);

  0011c	8d 44 24 10	 lea	 eax, DWORD PTR _extension$1[esp+5104]
  00120	50		 push	 eax
  00121	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_09OGNGBBJO@?$CFs?4?$CFs?4log@
  0012b	8d 84 24 3c 04
	00 00		 lea	 eax, DWORD PTR _logFile$5[esp+5116]
  00132	68 00 04 00 00	 push	 1024			; 00000400H
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 __snprintf
  0013d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  00143	83 c4 14	 add	 esp, 20			; 00000014H
$LL2@DebugStrin:

; 123  : 
; 124  :         while (true)
; 125  :         {
; 126  :             HANDLE hTraceFile = CreateFile(logFile,

  00146	6a 00		 push	 0
  00148	68 80 00 00 00	 push	 128			; 00000080H
  0014d	6a 04		 push	 4
  0014f	6a 00		 push	 0
  00151	6a 03		 push	 3
  00153	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00158	8d 84 24 48 04
	00 00		 lea	 eax, DWORD PTR _logFile$5[esp+5128]
  0015f	50		 push	 eax
  00160	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00166	8b f0		 mov	 esi, eax

; 127  :                 GENERIC_READ | GENERIC_WRITE,
; 128  :                 FILE_SHARE_READ | FILE_SHARE_WRITE,
; 129  :                 NULL,
; 130  :                 OPEN_ALWAYS,
; 131  :                 FILE_ATTRIBUTE_NORMAL,
; 132  :                 NULL);
; 133  :             if (hTraceFile != INVALID_HANDLE_VALUE)

  00168	83 fe ff	 cmp	 esi, -1
  0016b	74 d9		 je	 SHORT $LL2@DebugStrin

; 134  :             {
; 135  :                 //Set position o the end of the file
; 136  :                 DWORD dwFileSize = GetFileSize(hTraceFile, NULL);

  0016d	6a 00		 push	 0
  0016f	56		 push	 esi
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8

; 137  :                 if (dwFileSize > (MBYTES * 9))

  00176	3d 00 00 90 00	 cmp	 eax, 9437184		; 00900000H
  0017b	76 5f		 jbe	 SHORT $LN11@DebugStrin

; 138  :                 {
; 139  :                     CloseHandle(hTraceFile);

  0017d	56		 push	 esi
  0017e	ff d7		 call	 edi

; 140  :                     hTraceFile = INVALID_HANDLE_VALUE;
; 141  : 
; 142  :                     char oldFile[1024] = { 0 };

  00180	68 00 04 00 00	 push	 1024			; 00000400H
  00185	8d 44 24 34	 lea	 eax, DWORD PTR _oldFile$4[esp+5108]
  00189	6a 00		 push	 0
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 _memset
  00191	83 c4 0c	 add	 esp, 12			; 0000000cH

; 143  :                     _snprintf(oldFile, sizeof(oldFile), "%s.%s_old", gszLogFilePrefix, extension);

  00194	8d 44 24 10	 lea	 eax, DWORD PTR _extension$1[esp+5104]
  00198	50		 push	 eax
  00199	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_09BJLKJKJF@?$CFs?4?$CFs_old@
  001a3	8d 44 24 3c	 lea	 eax, DWORD PTR _oldFile$4[esp+5116]
  001a7	68 00 04 00 00	 push	 1024			; 00000400H
  001ac	50		 push	 eax
  001ad	e8 00 00 00 00	 call	 __snprintf
  001b2	83 c4 14	 add	 esp, 20			; 00000014H

; 144  : 
; 145  :                     //remove old file
; 146  :                     static_cast<void>(remove((const char*)oldFile));

  001b5	8d 44 24 30	 lea	 eax, DWORD PTR _oldFile$4[esp+5104]
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 _remove
  001bf	83 c4 04	 add	 esp, 4

; 147  :                     static_cast<void>(rename((const char*)logFile, (const char*)oldFile));

  001c2	8d 44 24 30	 lea	 eax, DWORD PTR _oldFile$4[esp+5104]
  001c6	50		 push	 eax
  001c7	8d 84 24 34 04
	00 00		 lea	 eax, DWORD PTR _logFile$5[esp+5108]
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 _rename
  001d4	83 c4 08	 add	 esp, 8

; 154  :                     break;      //exit loop
; 155  :                 }
; 156  :             }
; 157  :         }

  001d7	e9 6a ff ff ff	 jmp	 $LL2@DebugStrin
$LN11@DebugStrin:

; 148  :                 }
; 149  :                 else
; 150  :                 {
; 151  :                     SetFilePointer(hTraceFile, 0, NULL, FILE_END);

  001dc	6a 02		 push	 2
  001de	6a 00		 push	 0
  001e0	6a 00		 push	 0
  001e2	56		 push	 esi
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 152  :                     WriteFile(hTraceFile, line, strlen(line), &dwBytesWritten, NULL);

  001e9	8d 8c 24 30 08
	00 00		 lea	 ecx, DWORD PTR _line$6[esp+5104]
  001f0	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL17@DebugStrin:
  001f3	8a 01		 mov	 al, BYTE PTR [ecx]
  001f5	41		 inc	 ecx
  001f6	84 c0		 test	 al, al
  001f8	75 f9		 jne	 SHORT $LL17@DebugStrin
  001fa	6a 00		 push	 0
  001fc	8d 44 24 18	 lea	 eax, DWORD PTR _dwBytesWritten$2[esp+5108]
  00200	2b ca		 sub	 ecx, edx
  00202	50		 push	 eax
  00203	51		 push	 ecx
  00204	8d 84 24 3c 08
	00 00		 lea	 eax, DWORD PTR _line$6[esp+5116]
  0020b	50		 push	 eax
  0020c	56		 push	 esi
  0020d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 153  :                     CloseHandle(hTraceFile);

  00213	56		 push	 esi
  00214	ff d7		 call	 edi

; 158  : 
; 159  :         ReleaseMutex(hdTh);

  00216	8b 74 24 18	 mov	 esi, DWORD PTR _hdTh$1$[esp+5104]
  0021a	56		 push	 esi
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 160  :         CloseHandle(hdTh);

  00221	56		 push	 esi
  00222	ff d7		 call	 edi
  00224	8b 74 24 1c	 mov	 esi, DWORD PTR _message$GSCopy$1$[esp+5104]
$LN4@DebugStrin:

; 161  :     }   //END: if(bDebug)
; 162  :     OutputDebugString(message);

  00228	56		 push	 esi
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OutputDebugStringA@4

; 163  : }

  0022f	8b 8c 24 ec 13
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+5104]
  00236	5f		 pop	 edi
  00237	5e		 pop	 esi
  00238	33 cc		 xor	 ecx, esp
  0023a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023f	8b e5		 mov	 esp, ebp
  00241	5d		 pop	 ebp
  00242	c3		 ret	 0
?DebugStringToFile@@YAXPADH@Z ENDP			; DebugStringToFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_hdTh$1$ = -1564					; size = 4
_temp$1 = -1560						; size = 260
_newFile$2 = -1296					; size = 260
_oldFile$3 = -1032					; size = 260
_logFile$4 = -1032					; size = 1024
__$ArrayPad$ = -4					; size = 4
?CheckLogFileSize@@YAXK@Z PROC				; CheckLogFileSize
; _dwMaxSize$ = ecx

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 1c 06 00
	00		 sub	 esp, 1564		; 0000061cH
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 18 06
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1564], eax
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	8b f9		 mov	 edi, ecx

; 234  :     HANDLE hTraceFile = NULL;
; 235  :     DWORD dwFileSize = 0;
; 236  : 
; 237  :     Log(LOG_DEBUG, __LINE__, ">> ChkLogFileSz, %u", dwMaxSize);

  0001f	57		 push	 edi
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GIEOINGB@?$DO?$DO?5ChkLogFileSz?0?5?$CFu@
  00025	68 ed 00 00 00	 push	 237			; 000000edH
  0002a	6a 10		 push	 16			; 00000010H
  0002c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 238  : 
; 239  :     HANDLE hdTh = CreateMutex(NULL, FALSE, "SysStatus_Log");

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FHDHJHFN@SysStatus_Log@
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12

; 240  :     WaitForSingleObject(hdTh, INFINITE);

  00043	6a ff		 push	 -1
  00045	50		 push	 eax
  00046	89 44 24 14	 mov	 DWORD PTR _hdTh$1$[esp+1584], eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 241  : 
; 242  :     if (dwMaxSize > 0)

  00050	85 ff		 test	 edi, edi
  00052	0f 84 be 00 00
	00		 je	 $LN11@CheckLogFi

; 243  :     {
; 244  :         char logFile[1024] = { 0 };

  00058	68 00 04 00 00	 push	 1024			; 00000400H
  0005d	8d 84 24 24 02
	00 00		 lea	 eax, DWORD PTR _logFile$4[esp+1580]
  00064	6a 00		 push	 0
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _memset
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 245  :         _snprintf(logFile, sizeof(logFile), "%s.log", gszLogFilePrefix);

  0006f	8d 84 24 20 02
	00 00		 lea	 eax, DWORD PTR _logFile$4[esp+1576]
  00076	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_06BEJGOBHG@?$CFs?4log@
  00080	68 00 04 00 00	 push	 1024			; 00000400H
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 __snprintf

; 246  : 
; 247  :         Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, Opng %s", logFile);

  0008b	8d 84 24 30 02
	00 00		 lea	 eax, DWORD PTR _logFile$4[esp+1592]
  00092	50		 push	 eax
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LGJHGBPF@?9?9?5ChkLogFileSz?0?5Opng?5?$CFs@
  00098	68 f7 00 00 00	 push	 247			; 000000f7H
  0009d	6a 10		 push	 16			; 00000010H
  0009f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000a4	83 c4 20	 add	 esp, 32			; 00000020H

; 248  :         hTraceFile = CreateFile(logFile,

  000a7	8d 84 24 20 02
	00 00		 lea	 eax, DWORD PTR _logFile$4[esp+1576]
  000ae	6a 00		 push	 0
  000b0	68 80 00 00 00	 push	 128			; 00000080H
  000b5	6a 03		 push	 3
  000b7	6a 00		 push	 0
  000b9	6a 03		 push	 3
  000bb	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000c0	50		 push	 eax
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000c7	8b d8		 mov	 ebx, eax

; 249  :             GENERIC_READ | GENERIC_WRITE,
; 250  :             FILE_SHARE_READ | FILE_SHARE_WRITE,
; 251  :             NULL,
; 252  :             OPEN_EXISTING,
; 253  :             FILE_ATTRIBUTE_NORMAL,
; 254  :             NULL);
; 255  :         if (hTraceFile != INVALID_HANDLE_VALUE)

  000c9	83 fb ff	 cmp	 ebx, -1
  000cc	74 40		 je	 SHORT $LN24@CheckLogFi

; 256  :         {
; 257  :             //Set position o the end of the file
; 258  :             SetFilePointer(hTraceFile, 0, NULL, FILE_END);

  000ce	6a 02		 push	 2
  000d0	6a 00		 push	 0
  000d2	6a 00		 push	 0
  000d4	53		 push	 ebx
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 259  :             dwFileSize = GetFileSize(hTraceFile, NULL);

  000db	6a 00		 push	 0
  000dd	53		 push	 ebx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  000e4	8b f0		 mov	 esi, eax

; 260  :             Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, %s Sz %u", logFile, dwFileSize);

  000e6	8d 84 24 20 02
	00 00		 lea	 eax, DWORD PTR _logFile$4[esp+1576]
  000ed	56		 push	 esi
  000ee	50		 push	 eax
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HOHICOFN@?9?9?5ChkLogFileSz?0?5?$CFs?5Sz?5?$CFu@
  000f4	68 04 01 00 00	 push	 260			; 00000104H
  000f9	6a 10		 push	 16			; 00000010H
  000fb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00100	83 c4 14	 add	 esp, 20			; 00000014H

; 261  :             CloseHandle(hTraceFile);

  00103	53		 push	 ebx
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 262  :             hTraceFile = NULL;
; 263  :         }
; 264  :     }
; 265  : 
; 266  :     //check whether the file size reached the limit
; 267  :     //or it is initialization - to start new run in new file
; 268  :     if (dwFileSize > dwMaxSize || dwMaxSize == 0)

  0010a	3b f7		 cmp	 esi, edi
  0010c	77 08		 ja	 SHORT $LN11@CheckLogFi
$LN24@CheckLogFi:
  0010e	85 ff		 test	 edi, edi
  00110	0f 85 f9 01 00
	00		 jne	 $LN10@CheckLogFi
$LN11@CheckLogFi:

; 269  :     {
; 270  :         //find the last file
; 271  :         int x;
; 272  :         for (x = 999; x >= 0; x--)

  00116	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateFileA@28
  0011c	be e7 03 00 00	 mov	 esi, 999		; 000003e7H
$LL4@CheckLogFi:

; 273  :         {
; 274  :             char temp[_MAX_PATH] = { 0 };

  00121	68 04 01 00 00	 push	 260			; 00000104H
  00126	8d 44 24 14	 lea	 eax, DWORD PTR _temp$1[esp+1580]
  0012a	6a 00		 push	 0
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _memset
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  :             _snprintf(temp, sizeof(temp), "%s.%.3d.log", gszLogFilePrefix, x);

  00135	8d 44 24 10	 lea	 eax, DWORD PTR _temp$1[esp+1576]
  00139	56		 push	 esi
  0013a	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HKKOHPEB@?$CFs?4?$CF?43d?4log@
  00144	68 04 01 00 00	 push	 260			; 00000104H
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 __snprintf
  0014f	83 c4 14	 add	 esp, 20			; 00000014H

; 276  :             Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, Trying opng %s", temp);

  00152	8d 44 24 10	 lea	 eax, DWORD PTR _temp$1[esp+1576]
  00156	50		 push	 eax
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MGCLJDML@?9?9?5ChkLogFileSz?0?5Trying?5opng?5?$CFs@
  0015c	68 14 01 00 00	 push	 276			; 00000114H
  00161	6a 10		 push	 16			; 00000010H
  00163	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00168	83 c4 10	 add	 esp, 16			; 00000010H

; 277  :             hTraceFile = CreateFile(temp, GENERIC_READ | GENERIC_WRITE,

  0016b	8d 44 24 10	 lea	 eax, DWORD PTR _temp$1[esp+1576]
  0016f	6a 00		 push	 0
  00171	68 80 00 00 00	 push	 128			; 00000080H
  00176	6a 03		 push	 3
  00178	6a 00		 push	 0
  0017a	6a 03		 push	 3
  0017c	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00181	50		 push	 eax
  00182	ff d3		 call	 ebx
  00184	8b f8		 mov	 edi, eax

; 278  :                 FILE_SHARE_READ | FILE_SHARE_WRITE,
; 279  :                 NULL,
; 280  :                 OPEN_EXISTING,
; 281  :                 FILE_ATTRIBUTE_NORMAL,
; 282  :                 NULL);
; 283  :             if (hTraceFile != INVALID_HANDLE_VALUE)

  00186	83 ff ff	 cmp	 edi, -1
  00189	75 07		 jne	 SHORT $LN17@CheckLogFi

; 269  :     {
; 270  :         //find the last file
; 271  :         int x;
; 272  :         for (x = 999; x >= 0; x--)

  0018b	83 ee 01	 sub	 esi, 1
  0018e	79 91		 jns	 SHORT $LL4@CheckLogFi

; 278  :                 FILE_SHARE_READ | FILE_SHARE_WRITE,
; 279  :                 NULL,
; 280  :                 OPEN_EXISTING,
; 281  :                 FILE_ATTRIBUTE_NORMAL,
; 282  :                 NULL);
; 283  :             if (hTraceFile != INVALID_HANDLE_VALUE)

  00190	eb 4b		 jmp	 SHORT $LN13@CheckLogFi
$LN17@CheckLogFi:

; 284  :             {
; 285  :                 Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, Last file fnd: %s", temp);

  00192	8d 44 24 10	 lea	 eax, DWORD PTR _temp$1[esp+1576]
  00196	50		 push	 eax
  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DNFINAJK@?9?9?5ChkLogFileSz?0?5Last?5file?5fnd?3@
  0019c	68 1d 01 00 00	 push	 285			; 0000011dH
  001a1	6a 10		 push	 16			; 00000010H
  001a3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001a8	83 c4 10	 add	 esp, 16			; 00000010H

; 286  :                 CloseHandle(hTraceFile);

  001ab	57		 push	 edi
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 287  :                 hTraceFile = NULL;
; 288  : 
; 289  :                 //all file were filled, removed the last one
; 290  :                 if (x == 999) {

  001b2	81 fe e7 03 00
	00		 cmp	 esi, 999		; 000003e7H
  001b8	75 23		 jne	 SHORT $LN13@CheckLogFi

; 291  :                     Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, Removing %s - oldest file", temp);

  001ba	8d 44 24 10	 lea	 eax, DWORD PTR _temp$1[esp+1576]
  001be	50		 push	 eax
  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@JDMPMEKE@?9?9?5ChkLogFileSz?0?5Removing?5?$CFs?5?9?5@
  001c4	68 23 01 00 00	 push	 291			; 00000123H
  001c9	6a 10		 push	 16			; 00000010H
  001cb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 292  :                     remove((char*)temp);

  001d0	8d 44 24 20	 lea	 eax, DWORD PTR _temp$1[esp+1592]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 _remove
  001da	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@CheckLogFi:

; 293  :                 }
; 294  : 
; 295  :                 break;      //last one was found
; 296  :             }
; 297  :         }
; 298  : 
; 299  :         //rename the last one to the previous
; 300  :         char newFile[_MAX_PATH] = { 0 };

  001dd	68 04 01 00 00	 push	 260			; 00000104H
  001e2	8d 84 24 1c 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1580]
  001e9	6a 00		 push	 0
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 _memset
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 301  :         char oldFile[_MAX_PATH] = { 0 };

  001f4	8d 84 24 20 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1576]
  001fb	68 04 01 00 00	 push	 260			; 00000104H
  00200	6a 00		 push	 0
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _memset
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  :         for (; x >= 0; x--)

  0020b	85 f6		 test	 esi, esi
  0020d	0f 88 88 00 00
	00		 js	 $LN6@CheckLogFi
$LL7@CheckLogFi:

; 303  :         {
; 304  :             //rename the <.xxx.log> to .<xxx+1.log>
; 305  :             _snprintf(newFile, sizeof(newFile), "%s.%.3d.log", gszLogFilePrefix, x + 1);

  00213	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00216	50		 push	 eax
  00217	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HKKOHPEB@?$CFs?4?$CF?43d?4log@
  00221	8d 84 24 24 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1588]
  00228	68 04 01 00 00	 push	 260			; 00000104H
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 __snprintf
  00233	83 c4 14	 add	 esp, 20			; 00000014H

; 306  :             _snprintf(oldFile, sizeof(oldFile), "%s.%.3d.log", gszLogFilePrefix, x);

  00236	8d 84 24 20 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1576]
  0023d	56		 push	 esi
  0023e	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HKKOHPEB@?$CFs?4?$CF?43d?4log@
  00248	68 04 01 00 00	 push	 260			; 00000104H
  0024d	50		 push	 eax
  0024e	e8 00 00 00 00	 call	 __snprintf
  00253	83 c4 14	 add	 esp, 20			; 00000014H

; 307  : 
; 308  :             Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, Renaming %s -> %s", oldFile, newFile);

  00256	8d 84 24 18 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1576]
  0025d	50		 push	 eax
  0025e	8d 84 24 24 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1580]
  00265	50		 push	 eax
  00266	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KIGAJNDH@?9?9?5ChkLogFileSz?0?5Renaming?5?$CFs?5?9?$DO@
  0026b	68 34 01 00 00	 push	 308			; 00000134H
  00270	6a 10		 push	 16			; 00000010H
  00272	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00277	83 c4 14	 add	 esp, 20			; 00000014H

; 309  :             static_cast<void>(rename((const char*)oldFile, (const char*)newFile));

  0027a	8d 84 24 18 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1576]
  00281	50		 push	 eax
  00282	8d 84 24 24 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1580]
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 _rename
  0028f	83 c4 08	 add	 esp, 8
  00292	83 ee 01	 sub	 esi, 1
  00295	0f 89 78 ff ff
	ff		 jns	 $LL7@CheckLogFi
$LN6@CheckLogFi:

; 310  :         }
; 311  : 
; 312  :         //rename the .log to .000.log
; 313  :         _snprintf(newFile, sizeof(newFile), "%s.000.log", gszLogFilePrefix);

  0029b	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  002a0	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HLBMFDAN@?$CFs?4000?4log@
  002a5	8d 84 24 20 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1584]
  002ac	68 04 01 00 00	 push	 260			; 00000104H
  002b1	50		 push	 eax
  002b2	e8 00 00 00 00	 call	 __snprintf

; 314  :         _snprintf(oldFile, sizeof(oldFile), "%s.log", gszLogFilePrefix);

  002b7	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  002bc	68 00 00 00 00	 push	 OFFSET ??_C@_06BEJGOBHG@?$CFs?4log@
  002c1	8d 84 24 38 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1600]
  002c8	68 04 01 00 00	 push	 260			; 00000104H
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 __snprintf

; 315  :         Log(LOG_DEBUG, __LINE__, "-- ChkLogFileSz, Remaining %s -> %s", oldFile, newFile);

  002d3	8d 84 24 38 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1608]
  002da	50		 push	 eax
  002db	8d 84 24 44 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1612]
  002e2	50		 push	 eax
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EHOHNGJO@?9?9?5ChkLogFileSz?0?5Remaining?5?$CFs?5?9@
  002e8	68 3b 01 00 00	 push	 315			; 0000013bH
  002ed	6a 10		 push	 16			; 00000010H
  002ef	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002f4	83 c4 34	 add	 esp, 52			; 00000034H

; 316  :         static_cast<void>(rename((const char*)oldFile, (const char*)newFile));

  002f7	8d 84 24 18 01
	00 00		 lea	 eax, DWORD PTR _newFile$2[esp+1576]
  002fe	50		 push	 eax
  002ff	8d 84 24 24 02
	00 00		 lea	 eax, DWORD PTR _oldFile$3[esp+1580]
  00306	50		 push	 eax
  00307	e8 00 00 00 00	 call	 _rename
  0030c	83 c4 08	 add	 esp, 8
$LN10@CheckLogFi:

; 317  :     }
; 318  : 
; 319  :     ReleaseMutex(hdTh);

  0030f	8b 74 24 0c	 mov	 esi, DWORD PTR _hdTh$1$[esp+1576]
  00313	56		 push	 esi
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 320  :     CloseHandle(hdTh);

  0031a	56		 push	 esi
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 321  :     Log(LOG_DEBUG, __LINE__, "<< ChkLogFileSz");

  00321	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GCOGCGED@?$DM?$DM?5ChkLogFileSz@
  00326	68 41 01 00 00	 push	 321			; 00000141H
  0032b	6a 10		 push	 16			; 00000010H
  0032d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 322  : }

  00332	8b 8c 24 30 06
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1588]
  00339	83 c4 0c	 add	 esp, 12			; 0000000cH
  0033c	5f		 pop	 edi
  0033d	5e		 pop	 esi
  0033e	5b		 pop	 ebx
  0033f	33 cc		 xor	 ecx, esp
  00341	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00346	8b e5		 mov	 esp, ebp
  00348	5d		 pop	 ebp
  00349	c3		 ret	 0
?CheckLogFileSize@@YAXK@Z ENDP				; CheckLogFileSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -2140				; size = 4
_hModule$1$ = -2136					; size = 4
$T2 = -2132						; size = 1
tv941 = -2132						; size = 4
___$ReturnUdt$ = -2132					; size = 4
__Result$1$ = -2128					; size = 4
_dwLastError$GSCopy$1$ = -2128				; size = 4
$T3 = -2124						; size = 4
$T4 = -2120						; size = 24
$T5 = -2120						; size = 24
_buffer$ = -2096					; size = 2049
__Buff$6 = -40						; size = 21
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z PROC ; GetLastErrorMessage
; ___$ReturnUdt$ = ecx
; _dwLastError$ = edx

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 54 08 00
	00		 sub	 esp, 2132		; 00000854H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b da		 mov	 ebx, edx
  00030	89 9d b0 f7 ff
	ff		 mov	 DWORD PTR _dwLastError$GSCopy$1$[ebp], ebx
  00036	8b f9		 mov	 edi, ecx
  00038	89 bd ac f7 ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 329  :     HMODULE hModule = nullptr; //default to system source

  00045	33 c9		 xor	 ecx, ecx

; 330  :     DWORD dwFormatFlags = FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM;
; 331  : 
; 332  :     //if dwErrorCode is in the network range, load the message source.
; 333  :     if ((dwLastError >= NERR_BASE) && (dwLastError <= MAX_NERR))

  00047	8d 83 cc f7 ff
	ff		 lea	 eax, DWORD PTR [ebx-2100]
  0004d	89 bd a4 f7 ff
	ff		 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi
  00053	c7 85 b4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0
  0005d	89 8d a8 f7 ff
	ff		 mov	 DWORD PTR _hModule$1$[ebp], ecx
  00063	3d 83 03 00 00	 cmp	 eax, 899		; 00000383H
  00068	77 16		 ja	 SHORT $LN2@GetLastErr

; 334  :         hModule = LoadLibraryEx("netmsg.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);

  0006a	6a 02		 push	 2
  0006c	51		 push	 ecx
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@MNPEAJCA@netmsg?4dll@
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryExA@12
  00078	8b c8		 mov	 ecx, eax
  0007a	89 85 a8 f7 ff
	ff		 mov	 DWORD PTR _hModule$1$[ebp], eax
$LN2@GetLastErr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00080	85 c9		 test	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

  00082	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00089	ba 00 12 00 00	 mov	 edx, 4608		; 00001200H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0008e	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00095	b8 00 1a 00 00	 mov	 eax, 6656		; 00001a00H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0009a	c6 07 00	 mov	 BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009d	6a 04		 push	 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  0009f	0f 44 c2	 cmove	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a2	8b cf		 mov	 ecx, edi
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_04KKAJCPFA@Err?5@
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  000a9	89 85 ac f7 ff
	ff		 mov	 DWORD PTR tv941[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000af	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 367  :     return msg;

  000b4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000bb	c7 85 b4 f7 ff
	ff 01 00 00 00	 mov	 DWORD PTR $T3[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string

; 568  : 	return (_Integral_to_string<char>(_Val));

  000c5	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 519  : 		_RNext = _UIntegral_to_buff(_RNext, _UVal);

  000cc	8d 75 ed	 lea	 esi, DWORD PTR __Buff$6[ebp+21]
  000cf	90		 npad	 1
$LL71@GetLastErr:

; 496  : 		*--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  000d0	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  000d5	4e		 dec	 esi
  000d6	f7 e3		 mul	 ebx
  000d8	c1 ea 03	 shr	 edx, 3
  000db	8a c2		 mov	 al, dl
  000dd	c0 e0 02	 shl	 al, 2
  000e0	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  000e3	02 c9		 add	 cl, cl
  000e5	2a d9		 sub	 bl, cl
  000e7	80 c3 30	 add	 bl, 48			; 00000030H
  000ea	88 1e		 mov	 BYTE PTR [esi], bl

; 497  : 		_UVal_trunc /= 10;

  000ec	8b da		 mov	 ebx, edx

; 498  : 		}
; 499  : 	while (_UVal_trunc != 0);

  000ee	85 db		 test	 ebx, ebx
  000f0	75 de		 jne	 SHORT $LL71@GetLastErr
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  000f2	8d 45 ed	 lea	 eax, DWORD PTR __Buff$6[ebp+21]

; 1784 : 		_Mysize(0),

  000f5	89 95 c8 f7 ff
	ff		 mov	 DWORD PTR $T5[ebp+16], edx

; 1785 : 		_Myres(0)

  000fb	89 95 cc f7 ff
	ff		 mov	 DWORD PTR $T5[ebp+20], edx

; 3976 : 		_My_data._Mysize = 0;

  00101	89 95 c8 f7 ff
	ff		 mov	 DWORD PTR $T5[ebp+16], edx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00107	c7 85 cc f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00111	88 95 b8 f7 ff
	ff		 mov	 BYTE PTR $T5[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  00117	3b f0		 cmp	 esi, eax
  00119	74 0f		 je	 SHORT $LN103@GetLastErr

; 2253 : 			{
; 2254 : 			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  0011b	2b c6		 sub	 eax, esi
  0011d	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00123	50		 push	 eax
  00124	56		 push	 esi
  00125	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN103@GetLastErr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string

; 568  : 	return (_Integral_to_string<char>(_Val));

  0012a	b8 05 00 00 00	 mov	 eax, 5

; 521  : 	return (basic_string<_Elem>(_RNext, _Buff_end));

  0012f	c7 85 b4 f7 ff
	ff 05 00 00 00	 mov	 DWORD PTR $T3[ebp], 5

; 568  : 	return (_Integral_to_string<char>(_Val));

  00139	89 85 b4 f7 ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0013f	83 e0 fb	 and	 eax, -5			; fffffffbH
  00142	89 85 b4 f7 ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00148	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2513 : 		return (append(_Right));

  0014f	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00155	50		 push	 eax
  00156	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string

; 568  : 	return (_Integral_to_string<char>(_Val));

  00158	c7 85 b4 f7 ff
	ff 03 00 00 00	 mov	 DWORD PTR $T3[ebp], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2513 : 		return (append(_Right));

  00162	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 340  :     msg += std::to_string(dwLastError);

  00167	b8 03 00 00 00	 mov	 eax, 3
  0016c	89 85 b4 f7 ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00172	83 e0 fd	 and	 eax, -3			; fffffffdH
  00175	89 85 b4 f7 ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0017b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0017f	8b 95 cc f7 ff
	ff		 mov	 edx, DWORD PTR $T5[ebp+20]
  00185	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00188	72 2f		 jb	 SHORT $LN151@GetLastErr
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0018a	8b 8d b8 f7 ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00190	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00191	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00193	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00199	72 14		 jb	 SHORT $LN150@GetLastErr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0019b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0019e	83 c2 23	 add	 edx, 35			; 00000023H
  001a1	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001a3	83 c0 fc	 add	 eax, -4			; fffffffcH
  001a6	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001a9	0f 87 10 02 00
	00		 ja	 $LN285@GetLastErr
$LN150@GetLastErr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001af	52		 push	 edx
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001b6	83 c4 08	 add	 esp, 8
$LN151@GetLastErr:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 343  :     char buffer[2049]{};

  001b9	68 01 08 00 00	 push	 2049			; 00000801H
  001be	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  001c4	c7 85 c8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 343  :     char buffer[2049]{};

  001ce	6a 00		 push	 0
  001d0	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001d1	c7 85 cc f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001db	c6 85 b8 f7 ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 343  :     char buffer[2049]{};

  001e2	e8 00 00 00 00	 call	 _memset
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 344  : 
; 345  :     //call FormatMessage() to allow for message text to be acquired
; 346  :     //from the system or from the supplied module handle.
; 347  :     if (FormatMessage(dwFormatFlags, hModule, dwLastError,

  001ea	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  001f0	6a 00		 push	 0
  001f2	68 00 08 00 00	 push	 2048			; 00000800H
  001f7	50		 push	 eax
  001f8	68 00 04 00 00	 push	 1024			; 00000400H
  001fd	ff b5 b0 f7 ff
	ff		 push	 DWORD PTR _dwLastError$GSCopy$1$[ebp]
  00203	ff b5 a8 f7 ff
	ff		 push	 DWORD PTR _hModule$1$[ebp]
  00209	ff b5 ac f7 ff
	ff		 push	 DWORD PTR tv941[ebp]
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28
  00215	85 c0		 test	 eax, eax
  00217	0f 84 73 01 00
	00		 je	 $LN256@GetLastErr

; 348  :         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //default language
; 349  :         buffer, nSize, nullptr))
; 350  :     {
; 351  :         size_t const len{ strlen(buffer) };

  0021d	8d 8d d0 f7 ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00223	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL280@GetLastErr:
  00226	8a 01		 mov	 al, BYTE PTR [ecx]
  00228	41		 inc	 ecx
  00229	84 c0		 test	 al, al
  0022b	75 f9		 jne	 SHORT $LL280@GetLastErr
  0022d	2b ca		 sub	 ecx, edx

; 352  :         if (len > 2)

  0022f	83 f9 02	 cmp	 ecx, 2
  00232	76 2d		 jbe	 SHORT $LN5@GetLastErr

; 353  :         {
; 354  :             // remove CR/LF characters
; 355  :             buffer[len - 1] = 0x00;

  00234	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00237	3d 01 08 00 00	 cmp	 eax, 2049		; 00000801H
  0023c	0f 83 87 01 00
	00		 jae	 $LN10@GetLastErr

; 356  :             buffer[len - 2] = 0x00;

  00242	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00245	c6 84 05 d0 f7
	ff ff 00	 mov	 BYTE PTR _buffer$[ebp+eax], 0
  0024d	81 f9 01 08 00
	00		 cmp	 ecx, 2049		; 00000801H
  00253	0f 83 70 01 00
	00		 jae	 $LN10@GetLastErr
  00259	c6 84 0d d0 f7
	ff ff 00	 mov	 BYTE PTR _buffer$[ebp+ecx], 0
$LN5@GetLastErr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00261	6a 05		 push	 5

; 1784 : 		_Mysize(0),

  00263	c7 85 c8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0026d	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]

; 1785 : 		_Myres(0)

  00273	c7 85 cc f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0027d	68 00 00 00 00	 push	 OFFSET ??_C@_05EIGEDBOH@?5Msg?5@

; 3976 : 		_My_data._Mysize = 0;

  00282	c7 85 c8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0028c	c7 85 cc f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00296	c6 85 b8 f7 ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0029d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 359  :         msg += std::string(" Msg ");

  002a2	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2513 : 		return (append(_Right));

  002a9	8d 85 b8 f7 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  002af	50		 push	 eax
  002b0	8b cf		 mov	 ecx, edi
  002b2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 359  :         msg += std::string(" Msg ");

  002b7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002bb	8b 95 cc f7 ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+20]
  002c1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002c4	72 2f		 jb	 SHORT $LN234@GetLastErr
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002c6	8b 8d b8 f7 ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002cc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002cd	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002cf	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002d5	72 14		 jb	 SHORT $LN233@GetLastErr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002d7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002da	83 c2 23	 add	 edx, 35			; 00000023H
  002dd	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002df	83 c0 fc	 add	 eax, -4			; fffffffcH
  002e2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002e5	0f 87 d9 00 00
	00		 ja	 $LN286@GetLastErr
$LN233@GetLastErr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  002eb	52		 push	 edx
  002ec	51		 push	 ecx
  002ed	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002f2	83 c4 08	 add	 esp, 8
$LN234@GetLastErr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  002f5	8d b5 d0 f7 ff
	ff		 lea	 esi, DWORD PTR _buffer$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  002fb	c7 85 c8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00305	c7 85 cc f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0030f	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 506  : 		_Left = _Right;

  00312	c6 85 b8 f7 ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
  00319	0f 1f 80 00 00
	00 00		 npad	 7
$LL281@GetLastErr:

; 462  : 		return (__builtin_strlen(_First));

  00320	8a 06		 mov	 al, BYTE PTR [esi]
  00322	46		 inc	 esi
  00323	84 c0		 test	 al, al
  00325	75 f9		 jne	 SHORT $LL281@GetLastErr
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2571 : 		const size_type _Old_size = _My_data._Mysize;

  00327	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0032a	2b f1		 sub	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2572 : 		if (_Count <= _My_data._Myres - _Old_size)

  0032c	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0032f	8b c1		 mov	 eax, ecx
  00331	2b c3		 sub	 eax, ebx
  00333	3b f0		 cmp	 esi, eax
  00335	77 3c		 ja	 SHORT $LN257@GetLastErr

; 1803 : 		value_type * _Result = _Bx._Buf;

  00337	89 bd b0 f7 ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edi

; 2574 : 			_My_data._Mysize = _Old_size + _Count;

  0033d	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00340	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  00343	8b c7		 mov	 eax, edi

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00345	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

  00348	72 08		 jb	 SHORT $LN264@GetLastErr
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0034a	8b 07		 mov	 eax, DWORD PTR [edi]
  0034c	89 85 b0 f7 ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN264@GetLastErr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00352	56		 push	 esi
  00353	8d 8d d0 f7 ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2576 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00359	03 c3		 add	 eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0035b	51		 push	 ecx
  0035c	50		 push	 eax
  0035d	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2577 : 			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00362	8b 85 b0 f7 ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00368	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2577 : 			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0036b	03 c6		 add	 eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0036d	c6 04 18 00	 mov	 BYTE PTR [eax+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2578 : 			return (*this);

  00371	eb 1d		 jmp	 SHORT $LN256@GetLastErr
$LN257@GetLastErr:

; 2579 : 			}
; 2580 : 
; 2581 : 		return (_Reallocate_grow_by(_Count,

  00373	56		 push	 esi
  00374	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0037a	c6 85 ac f7 ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
  00381	50		 push	 eax
  00382	ff b5 ac f7 ff
	ff		 push	 DWORD PTR $T2[ebp]
  00388	8b cf		 mov	 ecx, edi
  0038a	56		 push	 esi
  0038b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN256@GetLastErr:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 364  :     if (hModule != nullptr)

  00390	8b 85 a8 f7 ff
	ff		 mov	 eax, DWORD PTR _hModule$1$[ebp]
  00396	85 c0		 test	 eax, eax
  00398	74 07		 je	 SHORT $LN6@GetLastErr

; 365  :         FreeLibrary(hModule);

  0039a	50		 push	 eax
  0039b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN6@GetLastErr:

; 367  :     return msg;

  003a1	8b c7		 mov	 eax, edi

; 368  : }

  003a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003ad	59		 pop	 ecx
  003ae	5f		 pop	 edi
  003af	5e		 pop	 esi
  003b0	5b		 pop	 ebx
  003b1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b4	33 cd		 xor	 ecx, ebp
  003b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003bb	8b e5		 mov	 esp, ebp
  003bd	5d		 pop	 ebp
  003be	c3		 ret	 0
$LN285@GetLastErr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003bf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN286@GetLastErr:
  003c4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN10@GetLastErr:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 368  : }

  003c9	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN283@GetLastErr:
  003ce	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$0:
  00000	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00006	83 e0 01	 and	 eax, 1
  00009	0f 84 12 00 00
	00		 je	 $LN13@GetLastErr
  0000f	83 a5 b4 f7 ff
	ff fe		 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00016	8b 8d a4 f7 ff
	ff		 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN13@GetLastErr:
  00021	c3		 ret	 0
__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$3:
  00022	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00028	83 e0 02	 and	 eax, 2
  0002b	0f 84 12 00 00
	00		 je	 $LN43@GetLastErr
  00031	83 a5 b4 f7 ff
	ff fd		 and	 DWORD PTR $T3[ebp], -3	; fffffffdH
  00038	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN43@GetLastErr:
  00043	c3		 ret	 0
__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$4:
  00044	8b 85 b4 f7 ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0004a	83 e0 04	 and	 eax, 4
  0004d	0f 84 12 00 00
	00		 je	 $LN49@GetLastErr
  00053	83 a5 b4 f7 ff
	ff fb		 and	 DWORD PTR $T3[ebp], -5	; fffffffbH
  0005a	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN49@GetLastErr:
  00065	c3		 ret	 0
__unwindfunclet$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z$2:
  00066	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0006c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:
  00071	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00075	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00078	8b 8a 9c f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2148]
  0007e	33 c8		 xor	 ecx, eax
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00088	33 c8		 xor	 ecx, eax
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
  00094	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ENDP ; GetLastErrorMessage
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_pSerial$1$ = -28					; size = 4
tv478 = -24						; size = 4
_pProductID$1$ = -20					; size = 4
_vendorId$1 = -16					; size = 2
_pVendorID$1$ = -12					; size = 4
_StartString$1$ = -8					; size = 4
_pName$1$ = -4						; size = 4
?USBTraceInfo@@YAXPAD0@Z PROC				; USBTraceInfo
; _StartString$ = ecx
; _DeviceInterfaceName$ = edx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 20	 sub	 esp, 32			; 00000020H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f2		 mov	 esi, edx
  0000d	89 4c 24 20	 mov	 DWORD PTR _StartString$1$[esp+40], ecx

; 375  :     PCHAR	pVendorID = nullptr;
; 376  :     PCHAR	pProductID = nullptr;
; 377  :     PCHAR	pSerial = nullptr;

  00011	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _pSerial$1$[esp+40], 0

; 378  :     PCHAR	pTmp = nullptr;
; 379  : 
; 380  :     PCHAR pName = (PCHAR)malloc(strlen(DeviceInterfaceName) + 1);

  00019	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  0001c	0f 1f 40 00	 npad	 4
$LL44@USBTraceIn:
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	42		 inc	 edx
  00023	84 c0		 test	 al, al
  00025	75 f9		 jne	 SHORT $LL44@USBTraceIn
  00027	2b d7		 sub	 edx, edi
  00029	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _malloc
  00032	8b f8		 mov	 edi, eax
  00034	83 c4 04	 add	 esp, 4
  00037	89 7c 24 24	 mov	 DWORD PTR _pName$1$[esp+40], edi

; 381  :     if (pName)

  0003b	85 ff		 test	 edi, edi
  0003d	0f 84 5f 01 00
	00		 je	 $LN7@USBTraceIn

; 382  :     {
; 383  :         memset(pName, 0x00, (strlen(DeviceInterfaceName) + 1));

  00043	8b ce		 mov	 ecx, esi
  00045	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL45@USBTraceIn:
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	41		 inc	 ecx
  0004b	84 c0		 test	 al, al
  0004d	75 f9		 jne	 SHORT $LL45@USBTraceIn
  0004f	2b ca		 sub	 ecx, edx
  00051	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00054	50		 push	 eax
  00055	6a 00		 push	 0
  00057	57		 push	 edi
  00058	e8 00 00 00 00	 call	 _memset
  0005d	8b cf		 mov	 ecx, edi
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	2b ce		 sub	 ecx, esi
$LL15@USBTraceIn:

; 384  :         strcpy(pName, DeviceInterfaceName);

  00064	8a 06		 mov	 al, BYTE PTR [esi]
  00066	8d 76 01	 lea	 esi, DWORD PTR [esi+1]
  00069	88 44 31 ff	 mov	 BYTE PTR [ecx+esi-1], al
  0006d	84 c0		 test	 al, al
  0006f	75 f3		 jne	 SHORT $LL15@USBTraceIn
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  00071	6a 56		 push	 86			; 00000056H
  00073	57		 push	 edi
  00074	e8 00 00 00 00	 call	 _strchr
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 387  :         pVendorID = strchr(pName, 'V');

  00079	8b f0		 mov	 esi, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  0007b	83 c4 08	 add	 esp, 8
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 387  :         pVendorID = strchr(pName, 'V');

  0007e	8b fe		 mov	 edi, esi

; 388  :         if (pVendorID)

  00080	85 f6		 test	 esi, esi
  00082	0f 84 03 01 00
	00		 je	 $LN9@USBTraceIn

; 390  :             pVendorID += 4;

  00088	83 c6 04	 add	 esi, 4
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  0008b	6a 50		 push	 80			; 00000050H
  0008d	56		 push	 esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 390  :             pVendorID += 4;

  0008e	89 74 24 24	 mov	 DWORD PTR _pVendorID$1$[esp+48], esi
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  00092	e8 00 00 00 00	 call	 _strchr
  00097	83 c4 08	 add	 esp, 8
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 393  :             pProductID = strchr(pVendorID, 'P');

  0009a	89 44 24 14	 mov	 DWORD PTR _pProductID$1$[esp+40], eax

; 394  :             if (pProductID)

  0009e	85 c0		 test	 eax, eax
  000a0	74 3e		 je	 SHORT $LN11@USBTraceIn

; 396  :                 pProductID += 4;

  000a2	83 c0 04	 add	 eax, 4

; 397  :                 pTmp = pVendorID + 4;
; 398  :                 *pTmp = 0;

  000a5	c6 47 08 00	 mov	 BYTE PTR [edi+8], 0
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000a9	6a 23		 push	 35			; 00000023H
  000ab	50		 push	 eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 396  :                 pProductID += 4;

  000ac	89 44 24 1c	 mov	 DWORD PTR _pProductID$1$[esp+48], eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 506  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

  000b0	e8 00 00 00 00	 call	 _strchr
  000b5	83 c4 08	 add	 esp, 8
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 401  :                 pSerial = strchr(pProductID, '#');

  000b8	89 44 24 0c	 mov	 DWORD PTR _pSerial$1$[esp+40], eax

; 402  :                 if (pSerial)

  000bc	85 c0		 test	 eax, eax
  000be	74 20		 je	 SHORT $LN11@USBTraceIn

; 403  :                 {
; 404  :                     *pSerial = 0;

  000c0	c6 00 00	 mov	 BYTE PTR [eax], 0

; 405  :                     pTmp = ++pSerial;

  000c3	40		 inc	 eax
  000c4	89 44 24 0c	 mov	 DWORD PTR _pSerial$1$[esp+40], eax
  000c8	8b d0		 mov	 edx, eax

; 406  :                     while ((*pTmp) && (*pTmp != '#'))

  000ca	8a 08		 mov	 cl, BYTE PTR [eax]
  000cc	84 c9		 test	 cl, cl
  000ce	74 0d		 je	 SHORT $LN3@USBTraceIn
$LL2@USBTraceIn:
  000d0	80 f9 23	 cmp	 cl, 35			; 00000023H
  000d3	74 08		 je	 SHORT $LN3@USBTraceIn
  000d5	8a 4a 01	 mov	 cl, BYTE PTR [edx+1]

; 407  :                         pTmp++;

  000d8	42		 inc	 edx
  000d9	84 c9		 test	 cl, cl
  000db	75 f3		 jne	 SHORT $LL2@USBTraceIn
$LN3@USBTraceIn:

; 408  :                     *pTmp = 0;

  000dd	c6 02 00	 mov	 BYTE PTR [edx], 0
$LN11@USBTraceIn:

; 409  :                 }
; 410  :             }
; 411  :             USHORT vendorId = 0;

  000e0	8b d6		 mov	 edx, esi
  000e2	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _vendorId$1[esp+40], 0
  000ea	66 8b 7c 24 18	 mov	 di, WORD PTR _vendorId$1[esp+40]
  000ef	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  000f4	89 54 24 10	 mov	 DWORD PTR tv478[esp+40], edx
  000f8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@USBTraceIn:

; 412  :             for (int x = 0; x < 4; x++)
; 413  :             {
; 414  :                 USHORT us = 0;
; 415  :                 if (isdigit(pVendorID[x]))

  00100	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _isdigit
  00109	8b 54 24 14	 mov	 edx, DWORD PTR tv478[esp+44]
  0010d	83 c4 04	 add	 esp, 4
  00110	85 c0		 test	 eax, eax
  00112	66 0f be 0a	 movsx	 cx, BYTE PTR [edx]
  00116	0f b7 c9	 movzx	 ecx, cx

; 416  :                     us = (USHORT)(pVendorID[x] - 0x30);

  00119	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  0011c	75 03		 jne	 SHORT $LN47@USBTraceIn

; 417  :                 else
; 418  :                     us = (USHORT)(pVendorID[x] - 0x37);

  0011e	8d 41 c9	 lea	 eax, DWORD PTR [ecx-55]
$LN47@USBTraceIn:

; 419  :                 vendorId += (USHORT)(us << (3 - x) * 4);

  00121	8b ce		 mov	 ecx, esi
  00123	0f b7 c0	 movzx	 eax, ax
  00126	66 d3 e0	 shl	 ax, cl
  00129	42		 inc	 edx
  0012a	83 ee 04	 sub	 esi, 4
  0012d	89 54 24 10	 mov	 DWORD PTR tv478[esp+40], edx
  00131	66 03 f8	 add	 di, ax
  00134	83 fe fc	 cmp	 esi, -4			; fffffffcH
  00137	7f c7		 jg	 SHORT $LL6@USBTraceIn
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 161  :         if (idVendor != 0x0000)

  00139	66 85 ff	 test	 di, di
  0013c	74 26		 je	 SHORT $LN24@USBTraceIn

; 162  :         {
; 163  :             PUSBVENDORID vendorID{};
; 164  :             vendorID = USBVendorIDs;
; 165  :             while (vendorID->usVendorID != 0x0000)

  0013e	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?USBVendorIDs@@3PAUUSBVENDORID@@A
  00144	b9 00 00 00 00	 mov	 ecx, OFFSET ?USBVendorIDs@@3PAUUSBVENDORID@@A
  00149	66 85 c0	 test	 ax, ax
  0014c	74 16		 je	 SHORT $LN24@USBTraceIn
  0014e	0f b7 d0	 movzx	 edx, ax
$LL23@USBTraceIn:

; 166  :             {
; 167  :                 if (vendorID->usVendorID == idVendor)

  00151	66 3b d7	 cmp	 dx, di
  00154	74 47		 je	 SHORT $LN32@USBTraceIn

; 170  :                 }
; 171  :                 vendorID++;

  00156	0f b7 41 08	 movzx	 eax, WORD PTR [ecx+8]
  0015a	83 c1 08	 add	 ecx, 8
  0015d	8b d0		 mov	 edx, eax
  0015f	66 85 c0	 test	 ax, ax
  00162	75 ed		 jne	 SHORT $LL23@USBTraceIn
$LN24@USBTraceIn:

; 172  :             }
; 173  :         }
; 174  :         return nullptr;

  00164	33 c0		 xor	 eax, eax
$LN22@USBTraceIn:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 421  :             Log(LOG_MESSAGE, __LINE__, "%s [VID:%s PID:%s SN:%s] %s", StartString, pVendorID, pProductID, pSerial, USB::GetVendorString(vendorId));

  00166	50		 push	 eax
  00167	ff 74 24 10	 push	 DWORD PTR _pSerial$1$[esp+44]
  0016b	ff 74 24 1c	 push	 DWORD PTR _pProductID$1$[esp+48]
  0016f	ff 74 24 28	 push	 DWORD PTR _pVendorID$1$[esp+52]
  00173	ff 74 24 30	 push	 DWORD PTR _StartString$1$[esp+56]
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GCCDOOIB@?$CFs?5?$FLVID?3?$CFs?5PID?3?$CFs?5SN?3?$CFs?$FN?5?$CFs@
  0017c	68 a5 01 00 00	 push	 421			; 000001a5H
  00181	6a 01		 push	 1
  00183	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00188	83 c4 20	 add	 esp, 32			; 00000020H
$LN9@USBTraceIn:

; 422  :         }
; 423  :         free(pName);

  0018b	ff 74 24 24	 push	 DWORD PTR _pName$1$[esp+40]
  0018f	e8 00 00 00 00	 call	 _free
  00194	83 c4 04	 add	 esp, 4

; 428  :     }
; 429  : }

  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
$LN32@USBTraceIn:
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 169  :                     return (vendorID->szVendor);

  0019d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001a0	eb c4		 jmp	 SHORT $LN22@USBTraceIn
$LN7@USBTraceIn:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 427  :         Log(LOG_DEBUG, __LINE__, "-- New DeviceName nullptr");

  001a2	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@LNKKODAK@?9?9?5New?5DeviceName?5nullptr@
  001a7	68 ab 01 00 00	 push	 427			; 000001abH
  001ac	6a 10		 push	 16			; 00000010H
  001ae	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  :     }
; 429  : }

  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
?USBTraceInfo@@YAXPAD0@Z ENDP				; USBTraceInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_lpGuid$1$ = -4						; size = 4
_maxLength$dead$ = 8					; size = 4
?GUID2Str@@YAPADPAU_GUID@@PADI@Z PROC			; GUID2Str
; _lpGuid$ = ecx
; _lpStr$ = edx

; 436  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	8b da		 mov	 ebx, edx
  0000a	89 75 fc	 mov	 DWORD PTR _lpGuid$1$[ebp], esi

; 437  :     if (!lpGuid || !lpStr)

  0000d	85 f6		 test	 esi, esi
  0000f	0f 84 1b 01 00
	00		 je	 $LN6@GUID2Str
  00015	85 db		 test	 ebx, ebx
  00017	0f 84 13 01 00
	00		 je	 $LN6@GUID2Str

; 440  :     }
; 441  : 
; 442  :     if (maxLength < 50)
; 443  :     {
; 444  :         return nullptr;
; 445  :     }
; 446  : 
; 447  :     int x = 0, i = 0;
; 448  : 
; 449  :     lpStr[x++] = '{';

  0001d	57		 push	 edi
  0001e	c6 03 7b	 mov	 BYTE PTR [ebx], 123	; 0000007bH

; 450  :     LPBYTE data = (LPBYTE)&lpGuid->Data1;
; 451  : 
; 452  :     //cChar = ((*(lpBufBin+ulIndex)) >> 4) & 0x0f;
; 453  :     //*(lpszBufStr+2*ulIndex) = cChar + 0x30;
; 454  :     //cChar = (*(lpBufBin+ulIndex)) & 0x0f;
; 455  :     //*(lpszBufStr+2*ulIndex+1) = cChar + 0x30;
; 456  : 
; 457  :     sprintf(&lpStr[x], "%.2X", data[3]);

  00021	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00025	50		 push	 eax
  00026	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _sprintf

; 458  :     x += 2;
; 459  :     sprintf(&lpStr[x], "%.2X", data[2]);

  00034	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00038	50		 push	 eax
  00039	8d 43 03	 lea	 eax, DWORD PTR [ebx+3]
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _sprintf

; 460  :     x += 2;
; 461  :     sprintf(&lpStr[x], "%.2X", data[1]);

  00047	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  0004b	50		 push	 eax
  0004c	8d 43 05	 lea	 eax, DWORD PTR [ebx+5]
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _sprintf

; 462  :     x += 2;
; 463  :     sprintf(&lpStr[x], "%.2X", data[0]);

  0005a	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0005d	50		 push	 eax
  0005e	8d 43 07	 lea	 eax, DWORD PTR [ebx+7]
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _sprintf

; 464  :     x += 2;
; 465  :     lpStr[x++] = '-';

  0006c	c6 43 09 2d	 mov	 BYTE PTR [ebx+9], 45	; 0000002dH

; 466  : 
; 467  :     data = (LPBYTE)&lpGuid->Data2;
; 468  :     sprintf(&lpStr[x], "%.2X", data[1]);

  00070	0f b6 46 05	 movzx	 eax, BYTE PTR [esi+5]
  00074	50		 push	 eax
  00075	8d 43 0a	 lea	 eax, DWORD PTR [ebx+10]
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _sprintf

; 469  :     x += 2;
; 470  :     sprintf(&lpStr[x], "%.2X", data[0]);

  00083	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00087	50		 push	 eax
  00088	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _sprintf
  00096	83 c4 48	 add	 esp, 72			; 00000048H

; 471  :     x += 2;
; 472  :     lpStr[x++] = '-';

  00099	c6 43 0e 2d	 mov	 BYTE PTR [ebx+14], 45	; 0000002dH

; 473  : 
; 474  :     data = (LPBYTE)&lpGuid->Data3;
; 475  :     sprintf(&lpStr[x], "%.2X", data[1]);

  0009d	0f b6 46 07	 movzx	 eax, BYTE PTR [esi+7]
  000a1	50		 push	 eax
  000a2	8d 43 0f	 lea	 eax, DWORD PTR [ebx+15]
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 _sprintf

; 476  :     x += 2;
; 477  :     sprintf(&lpStr[x], "%.2X", data[0]);

  000b0	0f b6 46 06	 movzx	 eax, BYTE PTR [esi+6]
  000b4	50		 push	 eax
  000b5	8d 43 11	 lea	 eax, DWORD PTR [ebx+17]
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _sprintf

; 478  :     x += 2;
; 479  :     lpStr[x++] = '-';

  000c3	c6 43 13 2d	 mov	 BYTE PTR [ebx+19], 45	; 0000002dH

; 480  : 
; 481  :     sprintf(&lpStr[x], "%.2X", lpGuid->Data4[0]);

  000c7	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  000cb	50		 push	 eax
  000cc	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _sprintf

; 482  :     x += 2;
; 483  :     sprintf(&lpStr[x], "%.2X", lpGuid->Data4[1]);

  000da	0f b6 46 09	 movzx	 eax, BYTE PTR [esi+9]
  000de	50		 push	 eax
  000df	8d 43 16	 lea	 eax, DWORD PTR [ebx+22]
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _sprintf
  000ed	83 c4 30	 add	 esp, 48			; 00000030H

; 484  :     x += 2;
; 485  :     lpStr[x++] = '-';

  000f0	c6 43 18 2d	 mov	 BYTE PTR [ebx+24], 45	; 0000002dH
  000f4	bf 19 00 00 00	 mov	 edi, 25			; 00000019H
  000f9	be 02 00 00 00	 mov	 esi, 2
  000fe	66 90		 npad	 2
$LL4@GUID2Str:

; 486  : 
; 487  :     for (i = 2; i < 8; i++)
; 488  :     {
; 489  :         sprintf(&lpStr[x], "%.2X", lpGuid->Data4[i]);

  00100	8b 45 fc	 mov	 eax, DWORD PTR _lpGuid$1$[ebp]
  00103	0f b6 44 30 08	 movzx	 eax, BYTE PTR [eax+esi+8]
  00108	50		 push	 eax
  00109	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_04CFJMJGDJ@?$CF?42X@
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _sprintf
  00117	46		 inc	 esi

; 490  :         x += 2;

  00118	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]
  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	83 fe 08	 cmp	 esi, 8
  00121	7c dd		 jl	 SHORT $LL4@GUID2Str

; 491  :     }
; 492  :     lpStr[x++] = '}';

  00123	c6 04 1f 7d	 mov	 BYTE PTR [edi+ebx], 125	; 0000007dH

; 493  : 
; 494  :     return lpStr;

  00127	8b c3		 mov	 eax, ebx
  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi

; 495  : }

  0012b	5b		 pop	 ebx
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
$LN6@GUID2Str:
  00130	5e		 pop	 esi

; 438  :     {
; 439  :         return nullptr;

  00131	33 c0		 xor	 eax, eax

; 495  : }

  00133	5b		 pop	 ebx
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
?GUID2Str@@YAPADPAU_GUID@@PADI@Z ENDP			; GUID2Str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_input$1$ = -60						; size = 4
_possibleStringInit$1$ = -56				; size = 4
_stringsList$ = -52					; size = 12
_aux$2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z PROC ; parseNullTerminatedStrings
; _input$ = ecx

; 501  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d c4	 mov	 DWORD PTR _input$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  0002e	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _stringsList$[ebp], 0

; 390  : 		_Mylast(),

  00035	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _stringsList$[ebp+4], 0

; 391  : 		_Myend()

  0003c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _stringsList$[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 502  :     std::vector<std::string> stringsList;

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 503  :     int nullCount = 0, possibleStringInit = 0;

  0004a	33 ff		 xor	 edi, edi
  0004c	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  0004e	be 01 00 00 00	 mov	 esi, 1
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 504  :     char *p = nullptr;

  00053	33 d2		 xor	 edx, edx
$LL4@parseNullT:

; 507  :     {
; 508  :         if (input[i] == 0)

  00055	80 7c 31 ff 00	 cmp	 BYTE PTR [ecx+esi-1], 0
  0005a	0f 85 bc 00 00
	00		 jne	 $LN5@parseNullT

; 509  :         {
; 510  :             nullCount++;

  00060	47		 inc	 edi

; 511  :             possibleStringInit = i + 1;

  00061	8b c6		 mov	 eax, esi
  00063	89 45 c8	 mov	 DWORD PTR _possibleStringInit$1$[ebp], eax

; 512  :             if (p != nullptr)

  00066	85 d2		 test	 edx, edx
  00068	0f 84 aa 00 00
	00		 je	 $LN166@parseNullT
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0006e	8b c2		 mov	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00070	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _aux$2[ebp+16], 0

; 1785 : 		_Myres(0)

  00077	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _aux$2[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  0007e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _aux$2[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00085	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _aux$2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0008c	c6 45 d8 00	 mov	 BYTE PTR _aux$2[ebp], 0

; 462  : 		return (__builtin_strlen(_First));

  00090	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL188@parseNullT:
  00093	8a 08		 mov	 cl, BYTE PTR [eax]
  00095	40		 inc	 eax
  00096	84 c9		 test	 cl, cl
  00098	75 f9		 jne	 SHORT $LL188@parseNullT
  0009a	2b c3		 sub	 eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009c	8d 4d d8	 lea	 ecx, DWORD PTR _aux$2[ebp]
  0009f	50		 push	 eax
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 514  :                 std::string aux(p);

  000a6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 917  : 		if (_Has_unused_capacity())

  000aa	8d 4d d8	 lea	 ecx, DWORD PTR _aux$2[ebp]

; 1726 : 		return (this->_Myend() != this->_Mylast());

  000ad	8b 45 d0	 mov	 eax, DWORD PTR _stringsList$[ebp+4]

; 917  : 		if (_Has_unused_capacity())

  000b0	51		 push	 ecx

; 1726 : 		return (this->_Myend() != this->_Mylast());

  000b1	39 45 d4	 cmp	 DWORD PTR _stringsList$[ebp+8], eax

; 917  : 		if (_Has_unused_capacity())

  000b4	74 0d		 je	 SHORT $LN48@parseNullT
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  000b6	8b c8		 mov	 ecx, eax
  000b8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

  000bd	83 45 d0 18	 add	 DWORD PTR _stringsList$[ebp+4], 24 ; 00000018H

; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));

  000c1	eb 09		 jmp	 SHORT $LN47@parseNullT
$LN48@parseNullT:

; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

  000c3	50		 push	 eax
  000c4	8d 4d cc	 lea	 ecx, DWORD PTR _stringsList$[ebp]
  000c7	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN47@parseNullT:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 517  :             }

  000cc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000d0	8b 55 ec	 mov	 edx, DWORD PTR _aux$2[ebp+20]
  000d3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000d6	72 28		 jb	 SHORT $LN164@parseNullT
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d8	8b 4d d8	 mov	 ecx, DWORD PTR _aux$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000db	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000dc	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000de	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000e4	72 10		 jb	 SHORT $LN163@parseNullT

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000e6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000e9	83 c2 23	 add	 edx, 35			; 00000023H
  000ec	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ee	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f4	77 67		 ja	 SHORT $LN160@parseNullT
$LN163@parseNullT:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000f6	52		 push	 edx
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fd	83 c4 08	 add	 esp, 8
$LN164@parseNullT:
  00100	8b 45 c8	 mov	 eax, DWORD PTR _possibleStringInit$1$[ebp]
  00103	8b 4d c4	 mov	 ecx, DWORD PTR _input$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00106	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _aux$2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0010d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _aux$2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00114	c6 45 d8 00	 mov	 BYTE PTR _aux$2[ebp], 0
$LN166@parseNullT:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 518  :             p = nullptr;

  00118	33 d2		 xor	 edx, edx

; 519  :             continue;

  0011a	eb 09		 jmp	 SHORT $LN2@parseNullT
$LN5@parseNullT:

; 520  :         }
; 521  : 
; 522  :         if (p == nullptr)

  0011c	85 d2		 test	 edx, edx
  0011e	75 05		 jne	 SHORT $LN2@parseNullT

; 523  :         {
; 524  :             nullCount = 0;

  00120	33 ff		 xor	 edi, edi

; 525  :             p = const_cast<char*>(&input[possibleStringInit]);

  00122	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
$LN2@parseNullT:

; 505  : 
; 506  :     for (int i = 0; nullCount < 2; i++)

  00125	46		 inc	 esi
  00126	83 ff 02	 cmp	 edi, 2
  00129	0f 8c 26 ff ff
	ff		 jl	 $LL4@parseNullT

; 528  :     return std::move(stringsList);

  0012f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00136	8d 4d cc	 lea	 ecx, DWORD PTR _stringsList$[ebp]
  00139	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 528  :     return std::move(stringsList);

  0013e	8d 45 cc	 lea	 eax, DWORD PTR _stringsList$[ebp]

; 529  : }

  00141	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00144	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014b	59		 pop	 ecx
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00152	33 cd		 xor	 ecx, ebp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
$LN160@parseNullT:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0015d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN190@parseNullT:
  00162	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _stringsList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR _aux$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?parseNullTerminatedStrings@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ENDP ; parseNullTerminatedStrings
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_lpTopLevelExceptionFilter$ = 8				; size = 4
?ReportAttemptsToSetUnhandledExceptionFilter@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z PROC ; ReportAttemptsToSetUnhandledExceptionFilter

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :     Log(LOG_DEBUG, __LINE__, "-- Prevented attempt to set unhandled exception filter. lpTopLevelExceptionFilter: 0x%p", lpTopLevelExceptionFilter);

  00003	ff 75 08	 push	 DWORD PTR _lpTopLevelExceptionFilter$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@PPGABHKA@?9?9?5Prevented?5attempt?5to?5set?5unh@
  0000b	68 18 02 00 00	 push	 536			; 00000218H
  00010	6a 10		 push	 16			; 00000010H
  00012	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 537  :     return nullptr;

  0001a	33 c0		 xor	 eax, eax

; 538  : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?ReportAttemptsToSetUnhandledExceptionFilter@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ENDP ; ReportAttemptsToSetUnhandledExceptionFilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_bytesWritten$ = -108					; size = 4
_jump$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
?RedirectSetUnhandledExceptionFilter@@YAHXZ PROC	; RedirectSetUnhandledExceptionFilter

; 544  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi

; 545  :     HMODULE hKernel32 = LoadLibrary("kernel32.dll");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0001c	8b f8		 mov	 edi, eax

; 546  :     if (hKernel32 == nullptr)

  0001e	85 ff		 test	 edi, edi
  00020	74 19		 je	 SHORT $LN5@RedirectSe

; 547  :         return FALSE;
; 548  : 
; 549  :     void *pOriginalFunc = GetProcAddress(hKernel32, "SetUnhandledExceptionFilter");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EBDAABIF@SetUnhandledExceptionFilter@
  00027	57		 push	 edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0002e	8b c8		 mov	 ecx, eax

; 550  :     if (pOriginalFunc == nullptr)

  00030	85 c9		 test	 ecx, ecx
  00032	75 18		 jne	 SHORT $LN3@RedirectSe

; 551  :     {
; 552  :         FreeLibrary(hKernel32);

  00034	57		 push	 edi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN5@RedirectSe:

; 571  :     return bRet;
; 572  : }

  0003b	33 c0		 xor	 eax, eax
  0003d	5f		 pop	 edi
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00041	33 cd		 xor	 ecx, ebp
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN3@RedirectSe:

; 553  :         return FALSE;
; 554  :     }
; 555  : 
; 556  :     DWORD dwOriginalAddr = (DWORD)pOriginalFunc;
; 557  :     dwOriginalAddr += 5; // add 5 for 5 op-codes for jmp far
; 558  : 
; 559  :     void *pDecoyFunc = &ReportAttemptsToSetUnhandledExceptionFilter;
; 560  :     DWORD dwDecoyAddr = (DWORD)pDecoyFunc;
; 561  :     DWORD dwRelativeAddr = dwDecoyAddr - dwOriginalAddr;
; 562  : 
; 563  :     unsigned char jump[100];
; 564  :     jump[0] = 0xE9;  // JMP absolute
; 565  :     memcpy(&jump[1], &dwRelativeAddr, sizeof(pDecoyFunc));

  0004c	b8 00 00 00 00	 mov	 eax, OFFSET ?ReportAttemptsToSetUnhandledExceptionFilter@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ; ReportAttemptsToSetUnhandledExceptionFilter
  00051	c6 45 98 e9	 mov	 BYTE PTR _jump$[ebp], 233 ; 000000e9H
  00055	2b c1		 sub	 eax, ecx
  00057	83 e8 05	 sub	 eax, 5
  0005a	56		 push	 esi
  0005b	89 45 99	 mov	 DWORD PTR _jump$[ebp+1], eax

; 566  :     SIZE_T bytesWritten;
; 567  : 
; 568  :     BOOL bRet = WriteProcessMemory(GetCurrentProcess(), pOriginalFunc, jump, sizeof(pDecoyFunc) + 1, &bytesWritten);

  0005e	8d 45 94	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00061	50		 push	 eax
  00062	6a 05		 push	 5
  00064	8d 45 98	 lea	 eax, DWORD PTR _jump$[ebp]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20

; 569  : 
; 570  :     FreeLibrary(hKernel32);

  00076	57		 push	 edi
  00077	8b f0		 mov	 esi, eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 571  :     return bRet;
; 572  : }

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	8b c6		 mov	 eax, esi
  00084	5e		 pop	 esi
  00085	33 cd		 xor	 ecx, ebp
  00087	5f		 pop	 edi
  00088	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?RedirectSetUnhandledExceptionFilter@@YAHXZ ENDP	; RedirectSetUnhandledExceptionFilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_stMDEI$2 = -344					; size = 12
_hFile$1$ = -332					; size = 4
$T3 = -328						; size = 24
_stLocalTime$ = -304					; size = 16
_chFileName$ = -288					; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z PROC	; CreateMiniDump
; _pExceptionInfo$ = ecx

; 578  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	8b f1		 mov	 esi, ecx

; 579  :     char chFileName[MAX_PATH] = { 0 };

  00043	68 04 01 00 00	 push	 260			; 00000104H
  00048	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _chFileName$[ebp]
  0004e	6a 00		 push	 0
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _memset
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 580  :     SYSTEMTIME stLocalTime = { 0 };
; 581  :     GetLocalTime(&stLocalTime);

  00059	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _stLocalTime$[ebp]
  0005f	0f 57 c0	 xorps	 xmm0, xmm0
  00062	0f 11 85 d0 fe
	ff ff		 movups	 XMMWORD PTR _stLocalTime$[ebp], xmm0
  00069	50		 push	 eax
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 582  : 
; 583  :     _snprintf(chFileName, sizeof(chFileName) - 1, "%s_%.4d-%.2d-%.2d_%.2d-%.2d-%.2d.dmp", gszLogFilePrefix,

  00070	0f b7 85 dc fe
	ff ff		 movzx	 eax, WORD PTR _stLocalTime$[ebp+12]
  00077	50		 push	 eax
  00078	0f b7 85 da fe
	ff ff		 movzx	 eax, WORD PTR _stLocalTime$[ebp+10]
  0007f	50		 push	 eax
  00080	0f b7 85 d8 fe
	ff ff		 movzx	 eax, WORD PTR _stLocalTime$[ebp+8]
  00087	50		 push	 eax
  00088	0f b7 85 d6 fe
	ff ff		 movzx	 eax, WORD PTR _stLocalTime$[ebp+6]
  0008f	50		 push	 eax
  00090	0f b7 85 d2 fe
	ff ff		 movzx	 eax, WORD PTR _stLocalTime$[ebp+2]
  00097	50		 push	 eax
  00098	0f b7 85 d0 fe
	ff ff		 movzx	 eax, WORD PTR _stLocalTime$[ebp]
  0009f	50		 push	 eax
  000a0	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLLEOGPJ@?$CFs_?$CF?44d?9?$CF?42d?9?$CF?42d_?$CF?42d?9?$CF?42d?9?$CF?42@
  000aa	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _chFileName$[ebp]
  000b0	68 03 01 00 00	 push	 259			; 00000103H
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 __snprintf
  000bb	83 c4 28	 add	 esp, 40			; 00000028H

; 584  :         stLocalTime.wYear, stLocalTime.wMonth, stLocalTime.wDay,
; 585  :         stLocalTime.wHour, stLocalTime.wMinute, stLocalTime.wSecond);
; 586  : 
; 587  :     // Create the file first.
; 588  :     HANDLE hFile = CreateFile(chFileName, GENERIC_READ | GENERIC_WRITE,

  000be	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _chFileName$[ebp]
  000c4	6a 00		 push	 0
  000c6	68 80 00 00 00	 push	 128			; 00000080H
  000cb	6a 02		 push	 2
  000cd	6a 00		 push	 0
  000cf	6a 00		 push	 0
  000d1	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  000d6	50		 push	 eax
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  000dd	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _hFile$1$[ebp], eax

; 589  :         0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
; 590  : 
; 591  :     if (hFile != INVALID_HANDLE_VALUE)

  000e3	83 f8 ff	 cmp	 eax, -1
  000e6	0f 84 1f 01 00
	00		 je	 $LN2@CreateMini

; 592  :     {
; 593  :         MINIDUMP_EXCEPTION_INFORMATION stMDEI = { 0 };

  000ec	0f 57 c0	 xorps	 xmm0, xmm0
  000ef	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stMDEI$2[ebp+8], 0

; 594  :         MINIDUMP_EXCEPTION_INFORMATION * pMDEI = nullptr;

  000f9	33 ff		 xor	 edi, edi
  000fb	66 0f d6 85 a8
	fe ff ff	 movq	 QWORD PTR _stMDEI$2[ebp], xmm0

; 595  : 
; 596  :         if (pExceptionInfo != nullptr)

  00103	85 f6		 test	 esi, esi
  00105	74 22		 je	 SHORT $LN3@CreateMini

; 597  :         {
; 598  :             stMDEI.ThreadId = GetCurrentThreadId();

  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  0010d	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _stMDEI$2[ebp], eax

; 599  :             stMDEI.ExceptionPointers = pExceptionInfo;
; 600  :             stMDEI.ClientPointers = TRUE;
; 601  :             pMDEI = &stMDEI;

  00113	8d bd a8 fe ff
	ff		 lea	 edi, DWORD PTR _stMDEI$2[ebp]
  00119	89 b5 ac fe ff
	ff		 mov	 DWORD PTR _stMDEI$2[ebp+4], esi
  0011f	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _stMDEI$2[ebp+8], 1
$LN3@CreateMini:

; 602  :         }
; 603  : 
; 604  :         // Got the file open.  Write it.
; 605  :         BOOL bRet = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(),

  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  0012f	8b f0		 mov	 esi, eax
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00137	6a 00		 push	 0
  00139	6a 00		 push	 0
  0013b	57		 push	 edi
  0013c	8b bd b4 fe ff
	ff		 mov	 edi, DWORD PTR _hFile$1$[ebp]
  00142	68 00 02 00 00	 push	 512			; 00000200H
  00147	57		 push	 edi
  00148	56		 push	 esi
  00149	50		 push	 eax
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MiniDumpWriteDump@28

; 606  :             hFile, MiniDumpWithPrivateReadWriteMemory, pMDEI, NULL, NULL);
; 607  : 
; 608  :         if (TRUE == bRet)

  00150	83 f8 01	 cmp	 eax, 1
  00153	75 20		 jne	 SHORT $LN4@CreateMini

; 609  :         {
; 610  :             Log(LOG_HEADER, __LINE__, "CreateMiniDump, Created MiniDump file located at %s", chFileName);

  00155	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _chFileName$[ebp]
  0015b	50		 push	 eax
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KOKEPHBJ@CreateMiniDump?0?5Created?5MiniDum@
  00161	68 62 02 00 00	 push	 610			; 00000262H
  00166	6a 02		 push	 2
  00168	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0016d	83 c4 10	 add	 esp, 16			; 00000010H

; 611  :         }
; 612  :         else

  00170	e9 8f 00 00 00	 jmp	 $LN65@CreateMini
$LN4@CreateMini:

; 614  :             Log(LOG_HEADER, __LINE__, "CreateMiniDump, Failed to create MiniDump file. %s", GetLastErrorMessage(GetLastError()).c_str());

  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0017b	8b d0		 mov	 edx, eax
  0017d	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00183	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00188	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0018f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00193	72 02		 jb	 SHORT $LN15@CreateMini
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00195	8b 00		 mov	 eax, DWORD PTR [eax]
$LN15@CreateMini:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 614  :             Log(LOG_HEADER, __LINE__, "CreateMiniDump, Failed to create MiniDump file. %s", GetLastErrorMessage(GetLastError()).c_str());

  00197	50		 push	 eax
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@IPHAABKL@CreateMiniDump?0?5Failed?5to?5creat@
  0019d	68 66 02 00 00	 push	 614			; 00000266H
  001a2	6a 02		 push	 2
  001a4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001a9	83 c4 10	 add	 esp, 16			; 00000010H
  001ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001b3	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp+20]
  001b9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001bc	72 2b		 jb	 SHORT $LN63@CreateMini
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001be	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001c4	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c5	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001c7	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001cd	72 10		 jb	 SHORT $LN62@CreateMini

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001cf	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001d2	83 c2 23	 add	 edx, 35			; 00000023H
  001d5	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d7	83 c0 fc	 add	 eax, -4			; fffffffcH
  001da	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001dd	77 4a		 ja	 SHORT $LN81@CreateMini
$LN62@CreateMini:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001df	52		 push	 edx
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001e6	83 c4 08	 add	 esp, 8
$LN63@CreateMini:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  001e9	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001f3	c7 85 cc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001fd	c6 85 b8 fe ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN65@CreateMini:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 618  :         CloseHandle(hFile);

  00204	57		 push	 edi
  00205	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$LN2@CreateMini:

; 620  : }

  0020b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0020e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00215	59		 pop	 ecx
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi
  00218	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021b	33 cd		 xor	 ecx, ebp
  0021d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00222	8b e5		 mov	 esp, ebp
  00224	5d		 pop	 ebp
  00225	8b e3		 mov	 esp, ebx
  00227	5b		 pop	 ebx
  00228	c3		 ret	 0
$LN81@CreateMini:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00229	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN79@CreateMini:
  0022e	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z$0:
  00000	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a a8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-344]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z ENDP	; CreateMiniDump
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_pExceptionInfo$ = 8					; size = 4
?AppUnhandledExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC ; AppUnhandledExceptionFilter

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 627  :     Log(LOG_HEADER, __LINE__, "AppUnhndldExcptFltr, Attempt to create MiniDump file before exit proc due to unhndld exception.");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0GA@GFOAHNCA@AppUnhndldExcptFltr?0?5Attempt?5to@
  0000b	68 73 02 00 00	 push	 627			; 00000273H
  00010	6a 02		 push	 2
  00012	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 628  :     CreateMiniDump(pExceptionInfo);

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pExceptionInfo$[ebp]
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	e8 00 00 00 00	 call	 ?CreateMiniDump@@YAXPAU_EXCEPTION_POINTERS@@@Z ; CreateMiniDump

; 629  : 
; 630  :     exit(static_cast<int>(ERROR_UNHANDLED_EXCEPTION));

  00022	68 3e 02 00 00	 push	 574			; 0000023eH
  00027	e8 00 00 00 00	 call	 _exit
$LN3@AppUnhandl:
  0002c	cc		 int	 3
?AppUnhandledExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP ; AppUnhandledExceptionFilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
?WideStrToMultiStr@@YAPADPA_W@Z PROC			; WideStrToMultiStr
; _WideStr$ = ecx

; 637  : {

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 638  :     ULONG nBytes;
; 639  :     PCHAR MultiStr;
; 640  : 
; 641  :     // Get the length of the converted string
; 642  :     //
; 643  :     nBytes = WideCharToMultiByte(

  00002	6a 00		 push	 0
  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a ff		 push	 -1
  0000c	8b d9		 mov	 ebx, ecx
  0000e	53		 push	 ebx
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00019	8b f8		 mov	 edi, eax

; 644  :         CP_ACP,
; 645  :         0,
; 646  :         WideStr,
; 647  :         -1,
; 648  :         NULL,
; 649  :         0,
; 650  :         NULL,
; 651  :         NULL);
; 652  : 
; 653  :     if (nBytes == 0)

  0001b	85 ff		 test	 edi, edi
  0001d	75 03		 jne	 SHORT $LN2@WideStrToM

; 682  : }

  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
  00021	c3		 ret	 0
$LN2@WideStrToM:
  00022	56		 push	 esi

; 654  :     {
; 655  :         return NULL;
; 656  :     }
; 657  : 
; 658  :     // Allocate space to hold the converted string
; 659  :     //
; 660  :     MultiStr = (char *)malloc(nBytes);

  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 _malloc
  00029	8b f0		 mov	 esi, eax
  0002b	83 c4 04	 add	 esp, 4

; 661  :     if (MultiStr)

  0002e	85 f6		 test	 esi, esi
  00030	74 22		 je	 SHORT $LN4@WideStrToM

; 662  :     {
; 663  :         // Convert the string
; 664  :         //
; 665  :         nBytes = WideCharToMultiByte(

  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	57		 push	 edi
  00037	56		 push	 esi
  00038	6a ff		 push	 -1
  0003a	53		 push	 ebx
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 666  :             CP_ACP,
; 667  :             0,
; 668  :             WideStr,
; 669  :             -1,
; 670  :             MultiStr,
; 671  :             nBytes,
; 672  :             NULL,
; 673  :             NULL);
; 674  : 
; 675  :         if (nBytes == 0)

  00045	85 c0		 test	 eax, eax
  00047	75 0b		 jne	 SHORT $LN4@WideStrToM

; 676  :         {
; 677  :             free(MultiStr);

  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 _free
  0004f	83 c4 04	 add	 esp, 4

; 678  :             MultiStr = NULL;

  00052	33 f6		 xor	 esi, esi
$LN4@WideStrToM:

; 679  :         }
; 680  :     }
; 681  :     return MultiStr;

  00054	8b c6		 mov	 eax, esi
  00056	5e		 pop	 esi
  00057	5f		 pop	 edi

; 682  : }

  00058	5b		 pop	 ebx
  00059	c3		 ret	 0
?WideStrToMultiStr@@YAPADPA_W@Z ENDP			; WideStrToMultiStr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_osver$1 = -320						; size = 148
_osvEx$ = -168						; size = 156
__$ArrayPad$ = -4					; size = 4
?GetWinVer@@YAKXZ PROC					; GetWinVer

; 688  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 40 01 00
	00		 sub	 esp, 320		; 00000140H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 3c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+320], eax

; 689  :     OSVERSIONINFOEX osvEx = { 0 };

  0001a	68 98 00 00 00	 push	 152			; 00000098H
  0001f	8d 84 24 a0 00
	00 00		 lea	 eax, DWORD PTR _osvEx$[esp+328]
  00026	6a 00		 push	 0
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _memset
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 690  :     osvEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  00031	c7 84 24 98 00
	00 00 9c 00 00
	00		 mov	 DWORD PTR _osvEx$[esp+320], 156 ; 0000009cH

; 691  :     if (VerifyVersionInfo(&osvEx, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, 0))

  0003c	8d 84 24 98 00
	00 00		 lea	 eax, DWORD PTR _osvEx$[esp+320]
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 23		 push	 35			; 00000023H
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VerifyVersionInfoA@16
  00050	85 c0		 test	 eax, eax
  00052	74 19		 je	 SHORT $LN2@GetWinVer

; 692  :     {
; 693  :         return osvEx.dwMajorVersion;

  00054	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR _osvEx$[esp+324]

; 700  :         return osver.dwMajorVersion;
; 701  :     }
; 702  : }

  0005b	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+320]
  00062	33 cc		 xor	 ecx, esp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN2@GetWinVer:

; 694  :     }
; 695  :     else
; 696  :     {
; 697  :         OSVERSIONINFO osver = { 0 };

  0006d	68 90 00 00 00	 push	 144			; 00000090H
  00072	8d 44 24 08	 lea	 eax, DWORD PTR _osver$1[esp+328]
  00076	6a 00		 push	 0
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _memset
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 698  :         osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  00081	c7 04 24 94 00
	00 00		 mov	 DWORD PTR _osver$1[esp+320], 148 ; 00000094H

; 699  :         GetVersionEx(&osver);

  00088	8d 04 24	 lea	 eax, DWORD PTR _osver$1[esp+320]
  0008b	50		 push	 eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 700  :         return osver.dwMajorVersion;
; 701  :     }
; 702  : }

  00092	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+320]
  00099	8b 44 24 04	 mov	 eax, DWORD PTR _osver$1[esp+324]
  0009d	33 cc		 xor	 ecx, esp
  0009f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?GetWinVer@@YAKXZ ENDP					; GetWinVer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
__Freq$1$ = -8						; size = 4
tv219 = -4						; size = 4
?SysTick@@YA_KXZ PROC					; SysTick

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono

; 800  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

  0000c	e8 00 00 00 00	 call	 __Query_perf_frequency
  00011	8b d8		 mov	 ebx, eax
  00013	8b fa		 mov	 edi, edx
  00015	89 5c 24 10	 mov	 DWORD PTR __Freq$1$[esp+24], ebx

; 801  : 		const long long _Ctr = _Query_perf_counter();

  00019	e8 00 00 00 00	 call	 __Query_perf_counter

; 802  : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 803  : 		const long long _Whole = (_Ctr / _Freq) * period::den;
; 804  : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

  0001e	53		 push	 ebx
  0001f	57		 push	 edi
  00020	53		 push	 ebx
  00021	52		 push	 edx
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 __alldvrm
  00028	8b f3		 mov	 esi, ebx
  0002a	5b		 pop	 ebx
  0002b	6a 00		 push	 0
  0002d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00032	56		 push	 esi
  00033	51		 push	 ecx
  00034	89 44 24 24	 mov	 DWORD PTR tv219[esp+40], eax
  00038	8b da		 mov	 ebx, edx
  0003a	e8 00 00 00 00	 call	 __allmul
  0003f	57		 push	 edi
  00040	ff 74 24 14	 push	 DWORD PTR __Freq$1$[esp+28]
  00044	52		 push	 edx
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 __alldiv
  0004b	6a 00		 push	 0
  0004d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00052	53		 push	 ebx
  00053	ff 74 24 20	 push	 DWORD PTR tv219[esp+36]
  00057	8b f8		 mov	 edi, eax
  00059	8b f2		 mov	 esi, edx
  0005b	e8 00 00 00 00	 call	 __allmul

; 805  : 		return (time_point(duration(_Whole + _Part)));

  00060	03 f8		 add	 edi, eax

; 210  : 		: _MyDur(_Other)

  00062	8b cf		 mov	 ecx, edi

; 805  : 		return (time_point(duration(_Whole + _Part)));

  00064	13 d6		 adc	 edx, esi

; 210  : 		: _MyDur(_Other)

  00066	e8 00 00 00 00	 call	 __ltod3
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 710  :     return static_cast<uint64_t>((static_cast<double>(nanosecs) / 1'000'000) + 0.5);

  0006b	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@412e848000000000
  00073	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0007b	e8 00 00 00 00	 call	 __dtoul3

; 711  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?SysTick@@YA_KXZ ENDP					; SysTick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_tickStart$ = 8						; size = 8
_seconds$ = 16						; size = 4
?CalcElapsedTime@@YAX_KAA_KAAN1@Z PROC			; CalcElapsedTime
; _tickEnd$ = ecx
; _timeElapsed$ = edx

; 717  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b fa		 mov	 edi, edx
  00007	8b f1		 mov	 esi, ecx

; 718  :     tickEnd = SysTick();

  00009	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 719  :     timeElapsed = (static_cast<double>(tickEnd - tickStart) / static_cast<double>(SECOND));

  0000e	8b c8		 mov	 ecx, eax
  00010	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00013	2b 4d 08	 sub	 ecx, DWORD PTR _tickStart$[ebp]
  00016	89 06		 mov	 DWORD PTR [esi], eax
  00018	1b 55 0c	 sbb	 edx, DWORD PTR _tickStart$[ebp+4]
  0001b	e8 00 00 00 00	 call	 __ultod3
  00020	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  00028	f2 0f 11 07	 movsd	 QWORD PTR [edi], xmm0

; 720  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  0002c	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00034	e8 00 00 00 00	 call	 __dtoul3
  00039	8b 4d 10	 mov	 ecx, DWORD PTR _seconds$[ebp]

; 721  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	89 01		 mov	 DWORD PTR [ecx], eax
  00040	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?CalcElapsedTime@@YAX_KAA_KAAN1@Z ENDP			; CalcElapsedTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
tv294 = -28						; size = 4
tv299 = -24						; size = 4
tv298 = -20						; size = 4
_line$1$ = -16						; size = 4
_lpszAdditionalMsg$1$ = -12				; size = 4
_timeElapsed$1$ = -8					; size = 8
_tickStart$ = 8						; size = 8
?LogElapsedTime@@YAXK_KPBD@Z PROC			; LogElapsedTime
; _line$ = ecx
; _lpszAdditionalMsg$ = edx

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 54 24 34	 mov	 DWORD PTR _lpszAdditionalMsg$1$[esp+64], edx
  00010	89 4c 24 30	 mov	 DWORD PTR _line$1$[esp+64], ecx

; 718  :     tickEnd = SysTick();

  00014	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 719  :     timeElapsed = (static_cast<double>(tickEnd - tickStart) / static_cast<double>(SECOND));

  00019	2b 45 08	 sub	 eax, DWORD PTR _tickStart$[ebp]
  0001c	8b c8		 mov	 ecx, eax
  0001e	1b 55 0c	 sbb	 edx, DWORD PTR _tickStart$[ebp+4]
  00021	e8 00 00 00 00	 call	 __ultod3
  00026	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  0002e	f2 0f 11 44 24
	38		 movsd	 QWORD PTR _timeElapsed$1$[esp+64], xmm0

; 720  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  00034	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0003c	e8 00 00 00 00	 call	 __dtoul3
  00041	6a 00		 push	 0
  00043	6a 3c		 push	 60			; 0000003cH
  00045	8b fa		 mov	 edi, edx
  00047	8b d8		 mov	 ebx, eax
  00049	57		 push	 edi
  0004a	53		 push	 ebx
  0004b	e8 00 00 00 00	 call	 __aulldiv
  00050	8b c8		 mov	 ecx, eax
  00052	8b f2		 mov	 esi, edx
  00054	0f a4 ce 04	 shld	 esi, ecx, 4
  00058	6a 00		 push	 0
  0005a	c1 e1 04	 shl	 ecx, 4
  0005d	2b c8		 sub	 ecx, eax
  0005f	8b c3		 mov	 eax, ebx
  00061	68 10 0e 00 00	 push	 3600			; 00000e10H
  00066	1b f2		 sbb	 esi, edx
  00068	0f a4 ce 02	 shld	 esi, ecx, 2
  0006c	57		 push	 edi
  0006d	c1 e1 02	 shl	 ecx, 2
  00070	2b c1		 sub	 eax, ecx
  00072	89 44 24 38	 mov	 DWORD PTR tv298[esp+76], eax
  00076	8b c7		 mov	 eax, edi
  00078	1b c6		 sbb	 eax, esi
  0007a	53		 push	 ebx
  0007b	89 44 24 38	 mov	 DWORD PTR tv299[esp+80], eax
  0007f	e8 00 00 00 00	 call	 __aulldiv
  00084	8b f2		 mov	 esi, edx
  00086	89 44 24 24	 mov	 DWORD PTR tv294[esp+64], eax
  0008a	b9 10 0e 00 00	 mov	 ecx, 3600		; 00000e10H
  0008f	8b c6		 mov	 eax, esi
  00091	f7 e1		 mul	 ecx
  00093	ba 10 0e 00 00	 mov	 edx, 3600		; 00000e10H
  00098	8b c8		 mov	 ecx, eax
  0009a	8b 44 24 24	 mov	 eax, DWORD PTR tv294[esp+64]
  0009e	f7 e2		 mul	 edx
  000a0	6a 00		 push	 0
  000a2	03 ca		 add	 ecx, edx
  000a4	2b d8		 sub	 ebx, eax
  000a6	6a 3c		 push	 60			; 0000003cH
  000a8	1b f9		 sbb	 edi, ecx
  000aa	57		 push	 edi
  000ab	53		 push	 ebx
  000ac	e8 00 00 00 00	 call	 __aulldiv

; 728  :     uint64_t tickEnd{};
; 729  :     double timeElapsed{};
; 730  :     uint64_t seconds{};
; 731  :     CalcElapsedTime(tickStart, tickEnd, timeElapsed, seconds);
; 732  :     if (lpszAdditionalMsg)

  000b1	f2 0f 10 44 24
	38		 movsd	 xmm0, QWORD PTR _timeElapsed$1$[esp+64]
  000b7	83 ec 08	 sub	 esp, 8
  000ba	8b 4c 24 3c	 mov	 ecx, DWORD PTR _lpszAdditionalMsg$1$[esp+72]
  000be	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c3	ff 74 24 30	 push	 DWORD PTR tv299[esp+72]
  000c7	ff 74 24 38	 push	 DWORD PTR tv298[esp+76]
  000cb	52		 push	 edx
  000cc	50		 push	 eax
  000cd	56		 push	 esi
  000ce	ff 74 24 40	 push	 DWORD PTR tv294[esp+92]
  000d2	85 c9		 test	 ecx, ecx
  000d4	74 1b		 je	 SHORT $LN2@LogElapsed

; 733  :     {
; 734  :         Log(LOG_HEADER, line, "%s, %02llu:%02llu:%02llu, %.3f s", lpszAdditionalMsg, seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  000d6	51		 push	 ecx
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KLGENLFB@?$CFs?0?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5@
  000dc	ff 74 24 58	 push	 DWORD PTR _line$1$[esp+104]
  000e0	6a 02		 push	 2
  000e2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000e7	83 c4 30	 add	 esp, 48			; 00000030H

; 739  :     }
; 740  : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN2@LogElapsed:

; 735  :     }
; 736  :     else
; 737  :     {
; 738  :         Log(LOG_MESSAGE, line, "%02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GOPGHHGJ@?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@
  000f6	ff 74 24 54	 push	 DWORD PTR _line$1$[esp+100]
  000fa	6a 01		 push	 1
  000fc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00101	83 c4 2c	 add	 esp, 44			; 0000002cH

; 739  :     }
; 740  : }

  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?LogElapsedTime@@YAXK_KPBD@Z ENDP			; LogElapsedTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_info$ = -40						; size = 16
__$SEHRec$ = -24					; size = 24
?SetThreadName@@YAXPBDK@Z PROC				; SetThreadName
; _threadName$ = ecx
; _dwThreadID$ = edx

; 758  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?SetThreadName@@YAXPBDK@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 18	 sub	 esp, 24			; 00000018H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 759  :     THREADNAME_INFO info = { 0 };
; 760  :     info.dwType = 0x1000;

  00033	c7 45 d8 00 10
	00 00		 mov	 DWORD PTR _info$[ebp], 4096 ; 00001000H

; 761  :     info.szName = threadName;

  0003a	89 4d dc	 mov	 DWORD PTR _info$[ebp+4], ecx

; 762  :     info.dwThreadID = dwThreadID;

  0003d	89 55 e0	 mov	 DWORD PTR _info$[ebp+8], edx

; 763  :     info.dwFlags = 0;

  00040	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _info$[ebp+12], 0

; 764  : 
; 765  :     Log(LOG_DEBUG, __LINE__, "-- SetThrdName, Tp %p, Name %s, Id %u, Flags %p", info.dwType, info.szName, info.dwThreadID, info.dwFlags);

  00047	6a 00		 push	 0
  00049	52		 push	 edx
  0004a	51		 push	 ecx
  0004b	68 00 10 00 00	 push	 4096			; 00001000H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@DAMKDCLP@?9?9?5SetThrdName?0?5Tp?5?$CFp?0?5Name?5?$CFs?0@
  00055	68 fd 02 00 00	 push	 765			; 000002fdH
  0005a	6a 10		 push	 16			; 00000010H
  0005c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00061	83 c4 1c	 add	 esp, 28			; 0000001cH

; 766  : 
; 767  :     __try

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 768  :     {
; 769  :         RaiseException(MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(ULONG_PTR), (ULONG_PTR*)&info);

  0006b	8d 45 d8	 lea	 eax, DWORD PTR _info$[ebp]
  0006e	50		 push	 eax
  0006f	6a 04		 push	 4
  00071	6a 00		 push	 0
  00073	68 88 13 6d 40	 push	 1080890248		; 406d1388H
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 770  :     }

  0007e	eb 09		 jmp	 SHORT $LN10@SetThreadN
$LN5@SetThreadN:
$LN12@SetThreadN:

; 771  :     __except (EXCEPTION_EXECUTE_HANDLER)

  00080	b8 01 00 00 00	 mov	 eax, 1
$LN9@SetThreadN:
$LN7@SetThreadN:
  00085	c3		 ret	 0
$LN6@SetThreadN:
  00086	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]
$LN10@SetThreadN:

; 772  :     {
; 773  :     }
; 774  : }

  00089	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00090	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?SetThreadName@@YAXPBDK@Z ENDP				; SetThreadName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_ret$2$ = -397						; size = 1
_hThread$ = -396					; size = 4
_uiThreadId$ = -392					; size = 4
_threadData$GSCopy$1$ = -388				; size = 4
_threadFunction$GSCopy$1$ = -384			; size = 4
_pthreadHandle$GSCopy$1$ = -380				; size = 4
_sMember$1 = -376					; size = 100
_msg$2 = -272						; size = 260
__$ArrayPad$ = -4					; size = 4
_threadData$ = 8					; size = 4
_threadTimeout$ = 12					; size = 4
_pthreadHandle$ = 16					; size = 4
?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z PROC ; StartThread
; _threadName$ = ecx
; _threadFunction$ = edx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 90 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+404], eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR _pthreadHandle$[ebp]
  0001d	53		 push	 ebx
  0001e	8b d9		 mov	 ebx, ecx
  00020	89 54 24 18	 mov	 DWORD PTR _threadFunction$GSCopy$1$[esp+408], edx
  00024	56		 push	 esi
  00025	8b 75 08	 mov	 esi, DWORD PTR _threadData$[ebp]
  00028	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00029	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 780  : {

  0002d	89 74 24 1c	 mov	 DWORD PTR _threadData$GSCopy$1$[esp+416], esi
  00031	89 44 24 24	 mov	 DWORD PTR _pthreadHandle$GSCopy$1$[esp+416], eax

; 781  :     unsigned int uiThreadId = 0;

  00035	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _uiThreadId$[esp+416], 0

; 782  :     HANDLE hThread = NULL;

  0003d	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hThread$[esp+416], 0

; 783  :     bool ret = true;

  00045	c6 44 24 13 01	 mov	 BYTE PTR _ret$2$[esp+416], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1815 : 		if (_Large_string_engaged())

  0004a	72 02		 jb	 SHORT $LN147@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0004c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
$LN147@StartThrea:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 785  :     Log(LOG_DEBUG, __LINE__, ">> StartThrd, Name %s, Func %p, Dat %p, Timeout %u, pHndl %p", threadName.c_str(), threadFunction, threadData, threadTimeout, pthreadHandle);

  0004e	50		 push	 eax
  0004f	ff 75 0c	 push	 DWORD PTR _threadTimeout$[ebp]
  00052	56		 push	 esi
  00053	52		 push	 edx
  00054	51		 push	 ecx
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@OLKMHNED@?$DO?$DO?5StartThrd?0?5Name?5?$CFs?0?5Func?5?$CFp?0@
  0005a	68 11 03 00 00	 push	 785			; 00000311H
  0005f	6a 10		 push	 16			; 00000010H
  00061	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 73   :     char sMember[100] = { 0 };

  00066	6a 64		 push	 100			; 00000064H
  00068	8d 44 24 4c	 lea	 eax, DWORD PTR _sMember$1[esp+452]
  0006c	6a 00		 push	 0
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _memset
  00074	83 c4 2c	 add	 esp, 44			; 0000002cH

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00077	8d 44 24 28	 lea	 eax, DWORD PTR _sMember$1[esp+416]
  0007b	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00085	6a 63		 push	 99			; 00000063H
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 __snprintf
  0008d	83 c4 10	 add	 esp, 16			; 00000010H

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00090	8d 44 24 28	 lea	 eax, DWORD PTR _sMember$1[esp+416]
  00094	50		 push	 eax
  00095	6a 00		 push	 0
  00097	6a 00		 push	 0
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0009f	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  000a1	6a ff		 push	 -1
  000a3	57		 push	 edi
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  000aa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  000b0	57		 push	 edi
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  000b7	57		 push	 edi
  000b8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  000be	ff d7		 call	 edi

; 786  : 
; 787  :     /* Logical Drivers */
; 788  :     if (_thGetInt(&gbShutdown) == FALSE)

  000c0	85 f6		 test	 esi, esi
  000c2	0f 85 8e 00 00
	00		 jne	 $LN146@StartThrea

; 789  :     {
; 790  :         hThread = (HANDLE)_beginthreadex(NULL, 0, threadFunction, threadData, 0, &uiThreadId);

  000c8	8d 44 24 18	 lea	 eax, DWORD PTR _uiThreadId$[esp+416]
  000cc	50		 push	 eax
  000cd	56		 push	 esi
  000ce	ff 74 24 24	 push	 DWORD PTR _threadData$GSCopy$1$[esp+424]
  000d2	ff 74 24 2c	 push	 DWORD PTR _threadFunction$GSCopy$1$[esp+428]
  000d6	56		 push	 esi
  000d7	56		 push	 esi
  000d8	e8 00 00 00 00	 call	 __beginthreadex
  000dd	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  000e0	83 c4 18	 add	 esp, 24			; 00000018H
  000e3	89 44 24 14	 mov	 DWORD PTR _hThread$[esp+416], eax

; 791  :         if (hThread != NULL)

  000e7	85 c0		 test	 eax, eax
  000e9	0f 84 b9 00 00
	00		 je	 $LN3@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  000ef	8b d3		 mov	 edx, ebx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000f1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1815 : 		if (_Large_string_engaged())

  000f4	72 02		 jb	 SHORT $LN148@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000f6	8b 13		 mov	 edx, DWORD PTR [ebx]
$LN148@StartThrea:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 793  :             Log(LOG_DEBUG, __LINE__, "-- StartThrd, %s Id %u, Hnd %p", threadName.c_str(), uiThreadId, hThread);

  000f8	50		 push	 eax
  000f9	ff 74 24 1c	 push	 DWORD PTR _uiThreadId$[esp+420]
  000fd	52		 push	 edx
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FDECIAPH@?9?9?5StartThrd?0?5?$CFs?5Id?5?$CFu?0?5Hnd?5?$CFp@
  00103	68 19 03 00 00	 push	 793			; 00000319H
  00108	6a 10		 push	 16			; 00000010H
  0010a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0010f	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00112	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00116	72 02		 jb	 SHORT $LN48@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00118	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN48@StartThrea:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 794  :             SetThreadName(threadName.c_str(), uiThreadId);

  0011a	8b 54 24 18	 mov	 edx, DWORD PTR _uiThreadId$[esp+416]
  0011e	8b cb		 mov	 ecx, ebx
  00120	e8 00 00 00 00	 call	 ?SetThreadName@@YAXPBDK@Z ; SetThreadName

; 795  : 
; 796  :             //Wait thread
; 797  :             if (threadTimeout > 0)

  00125	8b 45 0c	 mov	 eax, DWORD PTR _threadTimeout$[ebp]
  00128	85 c0		 test	 eax, eax
  0012a	74 2a		 je	 SHORT $LN146@StartThrea

; 798  :             {
; 799  :                 if (WaitForSingleObject(hThread, threadTimeout) != WAIT_OBJECT_0)

  0012c	50		 push	 eax
  0012d	ff 74 24 18	 push	 DWORD PTR _hThread$[esp+420]
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  00137	85 c0		 test	 eax, eax
  00139	74 1b		 je	 SHORT $LN146@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1726 : 		return (this->_Myend() != this->_Mylast());

  0013b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00141	39 0d 08 00 00
	00		 cmp	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, ecx

; 917  : 		if (_Has_unused_capacity())

  00147	74 52		 je	 SHORT $LN57@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00149	8b 44 24 14	 mov	 eax, DWORD PTR _hThread$[esp+416]
  0014d	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

  0014f	83 05 04 00 00
	00 04		 add	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, 4
$LN146@StartThrea:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 815  :         char msg[_MAX_PATH] = { 0 };

  00156	68 04 01 00 00	 push	 260			; 00000104H
  0015b	8d 84 24 94 00
	00 00		 lea	 eax, DWORD PTR _msg$2[esp+420]
  00162	6a 00		 push	 0
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _memset

; 816  :         if (pthreadHandle)

  0016a	8b 4c 24 30	 mov	 ecx, DWORD PTR _pthreadHandle$GSCopy$1$[esp+428]
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	85 c9		 test	 ecx, ecx
  00173	74 79		 je	 SHORT $LN9@StartThrea

; 817  :         {
; 818  :             *pthreadHandle = hThread;

  00175	8b 44 24 14	 mov	 eax, DWORD PTR _hThread$[esp+416]

; 819  :             _snprintf(msg, sizeof(msg) - 1, "<< StartThrd, %p", *pthreadHandle);

  00179	50		 push	 eax
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@POKBMEDO@?$DM?$DM?5StartThrd?0?5?$CFp@
  0017f	89 01		 mov	 DWORD PTR [ecx], eax
  00181	8d 84 24 98 00
	00 00		 lea	 eax, DWORD PTR _msg$2[esp+424]
  00188	68 03 01 00 00	 push	 259			; 00000103H
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 __snprintf
  00193	83 c4 10	 add	 esp, 16			; 00000010H

; 820  :         }
; 821  :         else

  00196	e9 97 00 00 00	 jmp	 $LN10@StartThrea
$LN57@StartThrea:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

  0019b	8d 44 24 14	 lea	 eax, DWORD PTR _hThread$[esp+416]
  0019f	50		 push	 eax
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 805  :         else

  001a6	eb ae		 jmp	 SHORT $LN146@StartThrea
$LN3@StartThrea:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001a8	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1815 : 		if (_Large_string_engaged())

  001ab	72 02		 jb	 SHORT $LN138@StartThrea
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  001ad	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN138@StartThrea:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 807  :             Log(LOG_HEADER, __LINE__, "-- StartThrd, No %s thrd created", threadName.c_str());

  001af	53		 push	 ebx
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LFOPNEOO@?9?9?5StartThrd?0?5No?5?$CFs?5thrd?5create@
  001b5	68 27 03 00 00	 push	 807			; 00000327H
  001ba	6a 02		 push	 2
  001bc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 829  :     }
; 830  :     else
; 831  :     {
; 832  :         Log(LOG_DEBUG, __LINE__, "<< StartThrd, ret False");

  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EBHNNPDK@?$DM?$DM?5StartThrd?0?5ret?5False@
  001c6	68 40 03 00 00	 push	 832			; 00000340H
  001cb	6a 10		 push	 16			; 00000010H
  001cd	32 db		 xor	 bl, bl
  001cf	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001d4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 833  :     }
; 834  :     return ret;

  001d7	8a c3		 mov	 al, bl

; 835  : }

  001d9	5f		 pop	 edi
  001da	5e		 pop	 esi
  001db	5b		 pop	 ebx
  001dc	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  001e3	33 cc		 xor	 ecx, esp
  001e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ea	8b e5		 mov	 esp, ebp
  001ec	5d		 pop	 ebp
  001ed	c3		 ret	 0
$LN9@StartThrea:

; 822  :         {
; 823  :             //Close the thread handle
; 824  :             CloseHandle(hThread);

  001ee	ff 74 24 14	 push	 DWORD PTR _hThread$[esp+416]
  001f2	ff d7		 call	 edi

; 825  :             hThread = NULL;
; 826  :             strcpy(msg, "<< StartThrd, ret True");

  001f4	a1 10 00 00 00	 mov	 eax, DWORD PTR ??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@+16
  001f9	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@
  00200	8a 0d 16 00 00
	00		 mov	 cl, BYTE PTR ??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@+22
  00206	89 84 24 a0 00
	00 00		 mov	 DWORD PTR _msg$2[esp+432], eax
  0020d	66 a1 14 00 00
	00		 mov	 ax, WORD PTR ??_C@_0BH@BDJONOMH@?$DM?$DM?5StartThrd?0?5ret?5True@+20
  00213	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _hThread$[esp+416], 0
  0021b	0f 11 84 24 90
	00 00 00	 movups	 XMMWORD PTR _msg$2[esp+416], xmm0
  00223	66 89 84 24 a4
	00 00 00	 mov	 WORD PTR _msg$2[esp+436], ax
  0022b	88 8c 24 a6 00
	00 00		 mov	 BYTE PTR _msg$2[esp+438], cl
$LN10@StartThrea:

; 827  :         }
; 828  :         Log(LOG_DEBUG, __LINE__, msg);

  00232	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _msg$2[esp+416]
  00239	51		 push	 ecx
  0023a	68 3c 03 00 00	 push	 828			; 0000033cH
  0023f	6a 10		 push	 16			; 00000010H
  00241	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 835  : }

  00246	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+428]
  0024d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00250	8a 44 24 13	 mov	 al, BYTE PTR _ret$2$[esp+416]
  00254	5f		 pop	 edi
  00255	5e		 pop	 esi
  00256	5b		 pop	 ebx
  00257	33 cc		 xor	 ecx, esp
  00259	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ENDP ; StartThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_exitCode$ = -4						; size = 4
?EndPendingThread@@YAXPAX@Z PROC			; EndPendingThread
; _hThread$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx

; 842  :     Log(LOG_DEBUG, __LINE__, ">> EndPendgThrd, Hndl %p", hThread);

  0000c	56		 push	 esi
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JJOKMIHG@?$DO?$DO?5EndPendgThrd?0?5Hndl?5?$CFp@
  00012	68 4a 03 00 00	 push	 842			; 0000034aH
  00017	6a 10		 push	 16			; 00000010H
  00019	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 843  : 
; 844  :     DWORD exitCode = 0;

  00021	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR _exitCode$[esp+16], 0

; 845  :     GetExitCodeThread(hThread, &exitCode);

  00029	8d 44 24 0c	 lea	 eax, DWORD PTR _exitCode$[esp+16]
  0002d	50		 push	 eax
  0002e	56		 push	 esi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetExitCodeThread@8

; 846  : 
; 847  :     //Release thread stack
; 848  : 
; 849  :     if (GetWinVer() < 6)   //WinXP or older

  00035	e8 00 00 00 00	 call	 ?GetWinVer@@YAKXZ	; GetWinVer
  0003a	83 f8 06	 cmp	 eax, 6
  0003d	73 34		 jae	 SHORT $LN5@EndPending

; 850  :     {
; 851  :         //Used to release the thread stacker
; 852  :         typedef	VOID(WINAPI *PRtlFreeUserThreadStack)(HANDLE hProcess, HANDLE hThread);
; 853  :         PRtlFreeUserThreadStack RtlFreeUserThreadStack = NULL;
; 854  : 
; 855  :         HMODULE NTLibrary = GetModuleHandleW(L"ntdll.dll");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4
  0004a	8b f8		 mov	 edi, eax

; 856  :         if (NTLibrary)

  0004c	85 ff		 test	 edi, edi
  0004e	74 23		 je	 SHORT $LN5@EndPending

; 857  :         {
; 858  :             RtlFreeUserThreadStack = (PRtlFreeUserThreadStack)GetProcAddress(NTLibrary, "RtlFreeUserThreadStack");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FCCILLCE@RtlFreeUserThreadStack@
  00055	57		 push	 edi
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0005c	8b d8		 mov	 ebx, eax

; 859  :         }
; 860  : 
; 861  :         //Release thread stacker
; 862  :         if (RtlFreeUserThreadStack != NULL)

  0005e	85 db		 test	 ebx, ebx
  00060	74 0a		 je	 SHORT $LN4@EndPending

; 863  :             RtlFreeUserThreadStack(GetCurrentProcess(), hThread);

  00062	56		 push	 esi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00069	50		 push	 eax
  0006a	ff d3		 call	 ebx
$LN4@EndPending:

; 864  : 
; 865  :         if (NTLibrary)
; 866  :         {
; 867  :             FreeLibrary(NTLibrary);

  0006c	57		 push	 edi
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN5@EndPending:

; 868  :             NTLibrary = NULL;
; 869  :         }
; 870  :     }
; 871  : 
; 872  :     TerminateThread(hThread, exitCode);

  00073	ff 74 24 0c	 push	 DWORD PTR _exitCode$[esp+16]
  00077	56		 push	 esi
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 873  :     Log(LOG_DEBUG, __LINE__, "<< EndPendgThrd");

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OFOICJDM@?$DM?$DM?5EndPendgThrd@
  00083	68 69 03 00 00	 push	 873			; 00000369H
  00088	6a 10		 push	 16			; 00000010H
  0008a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 874  : }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?EndPendingThread@@YAXPAX@Z ENDP			; EndPendingThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_lParam$GSCopy$1$ = -412				; size = 4
tv1007 = -408						; size = 4
_hWnd$GSCopy$1$ = -404					; size = 4
_type$2 = -400						; size = 24
_szGuid$3 = -376					; size = 260
_szGuid$4 = -376					; size = 260
_sMember$5 = -116					; size = 100
_sMember$6 = -116					; size = 100
_sMember$7 = -116					; size = 100
_sMember$8 = -116					; size = 100
_sMember$9 = -116					; size = 100
_sMember$10 = -116					; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProcMessage@@YGJPAUHWND__@@IIJ@Z PROC		; WndProcMessage

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 90 01 00
	00		 sub	 esp, 400		; 00000190H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 5d 14	 mov	 ebx, DWORD PTR _lParam$[ebp]

; 881  :     POINTS lPoints = { 0 };
; 882  :     int iRet = 0;
; 883  : 
; 884  :     Log(LOG_DEBUG_WND, __LINE__, "-- WndProcMsg, Wnd %p, Msg 0x%.4X, WPrm 0x%.8X HI 0x%.4X LO 0x%.4X, LPrm 0x%.8X HI 0x%.4X LO 0x%.4X", hWnd, uMsg, wParam, HIWORD(wParam), LOWORD(wParam), lParam, HIWORD(lParam), LOWORD(lParam));

  00031	8b d3		 mov	 edx, ebx
  00033	8b 7d 10	 mov	 edi, DWORD PTR _wParam$[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00039	8b 75 0c	 mov	 esi, DWORD PTR _uMsg$[ebp]
  0003c	0f b7 c3	 movzx	 eax, bx
  0003f	50		 push	 eax
  00040	c1 ea 10	 shr	 edx, 16			; 00000010H
  00043	52		 push	 edx
  00044	53		 push	 ebx
  00045	0f b7 c7	 movzx	 eax, di
  00048	50		 push	 eax
  00049	8b c7		 mov	 eax, edi
  0004b	89 8d 6c fe ff
	ff		 mov	 DWORD PTR _hWnd$GSCopy$1$[ebp], ecx
  00051	c1 e8 10	 shr	 eax, 16			; 00000010H
  00054	50		 push	 eax
  00055	57		 push	 edi
  00056	56		 push	 esi
  00057	51		 push	 ecx
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@BJAJHKCK@?9?9?5WndProcMsg?0?5Wnd?5?$CFp?0?5Msg?50x?$CF?4@
  0005d	68 74 03 00 00	 push	 884			; 00000374H
  00062	6a 20		 push	 32			; 00000020H
  00064	89 9d 64 fe ff
	ff		 mov	 DWORD PTR _lParam$GSCopy$1$[ebp], ebx
  0006a	89 95 68 fe ff
	ff		 mov	 DWORD PTR tv1007[ebp], edx
  00070	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00075	83 c4 2c	 add	 esp, 44			; 0000002cH

; 885  : 
; 886  :     switch (uMsg)

  00078	83 fe 16	 cmp	 esi, 22			; 00000016H
  0007b	0f 87 59 01 00
	00		 ja	 $LN47@WndProcMes
  00081	0f 84 0f 01 00
	00		 je	 $LN9@WndProcMes
  00087	8b c6		 mov	 eax, esi
  00089	83 e8 02	 sub	 eax, 2
  0008c	0f 84 f7 00 00
	00		 je	 $LN43@WndProcMes
  00092	83 e8 0f	 sub	 eax, 15			; 0000000fH
  00095	74 1d		 je	 SHORT $LN8@WndProcMes
  00097	83 e8 01	 sub	 eax, 1
  0009a	0f 84 37 06 00
	00		 je	 $LN198@WndProcMes

; 1035 : 
; 1036 :     case WM_QUIT:
; 1037 :         break;
; 1038 : 
; 1039 :     default:
; 1040 :         return (LRESULT)(DefWindowProc(hWnd, uMsg, wParam, lParam));

  000a0	53		 push	 ebx
  000a1	57		 push	 edi
  000a2	56		 push	 esi
  000a3	ff b5 6c fe ff
	ff		 push	 DWORD PTR _hWnd$GSCopy$1$[ebp]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  000af	e9 25 06 00 00	 jmp	 $LN1@WndProcMes
$LN8@WndProcMes:

; 887  :     {
; 888  :     case WM_QUERYENDSESSION:    //session closure requested
; 889  :         Log(LOG_HEADER, __LINE__, "Session Closure Requested");

  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@GJJBBOEE@Session?5Closure?5Requested@
  000b9	68 79 03 00 00	 push	 889			; 00000379H
  000be	6a 02		 push	 2
  000c0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 57   :     char sMember[100] = { 0 };

  000c5	6a 64		 push	 100			; 00000064H
  000c7	8d 45 8c	 lea	 eax, DWORD PTR _sMember$10[ebp]
  000ca	6a 00		 push	 0
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  000d2	68 00 00 00 00	 push	 OFFSET ?gbTerminate@@3HA ; gbTerminate
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  000dc	8d 45 8c	 lea	 eax, DWORD PTR _sMember$10[ebp]
  000df	6a 63		 push	 99			; 00000063H
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 __snprintf
  000e7	83 c4 28	 add	 esp, 40			; 00000028H

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  000ea	8d 45 8c	 lea	 eax, DWORD PTR _sMember$10[ebp]
  000ed	50		 push	 eax
  000ee	6a 00		 push	 0
  000f0	6a 00		 push	 0
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  000f8	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  000fa	6a ff		 push	 -1
  000fc	56		 push	 esi
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  00103	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ReleaseMutex@4
  00109	56		 push	 esi
  0010a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gbTerminate@@3HA, 1 ; gbTerminate
  00114	ff d3		 call	 ebx

; 65   :     CloseHandle(hdTh);

  00116	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  0011c	56		 push	 esi
  0011d	ff d7		 call	 edi

; 57   :     char sMember[100] = { 0 };

  0011f	6a 64		 push	 100			; 00000064H
  00121	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00124	6a 00		 push	 0
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0012c	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00136	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00139	6a 63		 push	 99			; 00000063H
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 __snprintf
  00141	83 c4 1c	 add	 esp, 28			; 0000001cH

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00144	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00147	50		 push	 eax
  00148	6a 00		 push	 0
  0014a	6a 00		 push	 0
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00152	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  00154	6a ff		 push	 -1
  00156	56		 push	 esi
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  0015d	56		 push	 esi
  0015e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gbShutdown@@3HA, 1 ; gbShutdown
  00168	ff d3		 call	 ebx

; 65   :     CloseHandle(hdTh);

  0016a	56		 push	 esi
  0016b	ff d7		 call	 edi

; 890  :         _thSetInt(&gbTerminate, TRUE);
; 891  :         _thSetInt(&gbShutdown, TRUE);
; 892  :         return (LRESULT)(DefWindowProc(hWnd, uMsg, wParam, lParam));

  0016d	ff b5 64 fe ff
	ff		 push	 DWORD PTR _lParam$GSCopy$1$[ebp]
  00173	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00176	6a 11		 push	 17			; 00000011H
  00178	ff b5 6c fe ff
	ff		 push	 DWORD PTR _hWnd$GSCopy$1$[ebp]
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  00184	e9 50 05 00 00	 jmp	 $LN1@WndProcMes
$LN43@WndProcMes:

; 1025 :                     _thSetInt(&gbTerminate, TRUE);
; 1026 :                     _thSetInt(&gbShutdown, TRUE);
; 1027 :                 }
; 1028 :             }
; 1029 :         }
; 1030 :         break;
; 1031 : 
; 1032 :     case WM_DESTROY:
; 1033 :         PostQuitMessage(0);

  00189	6a 00		 push	 0
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4

; 1034 :         break;

  00191	e9 41 05 00 00	 jmp	 $LN198@WndProcMes
$LN9@WndProcMes:

; 893  :         break;
; 894  : 
; 895  :     case WM_ENDSESSION:         //session is ending
; 896  :         Log(LOG_HEADER, __LINE__, "End Session");

  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LLINGCEN@End?5Session@
  0019b	68 80 03 00 00	 push	 896			; 00000380H
  001a0	6a 02		 push	 2
  001a2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 897  :         LogElapsedTime(__LINE__, gTickStart, "SysStatus");

  001a7	ff 35 04 00 00
	00		 push	 DWORD PTR ?gTickStart@@3_KA+4
  001ad	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09KECABMHK@SysStatus@
  001b2	b9 81 03 00 00	 mov	 ecx, 897		; 00000381H
  001b7	ff 35 00 00 00
	00		 push	 DWORD PTR ?gTickStart@@3_KA
  001bd	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime
  001c2	83 c4 14	 add	 esp, 20			; 00000014H

; 898  :         return (LRESULT)(DefWindowProc(hWnd, uMsg, wParam, lParam));

  001c5	53		 push	 ebx
  001c6	57		 push	 edi
  001c7	6a 16		 push	 22			; 00000016H
  001c9	ff b5 6c fe ff
	ff		 push	 DWORD PTR _hWnd$GSCopy$1$[ebp]
  001cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  001d5	e9 ff 04 00 00	 jmp	 $LN1@WndProcMes
$LN47@WndProcMes:

; 885  : 
; 886  :     switch (uMsg)

  001da	8b c6		 mov	 eax, esi
  001dc	2d 00 02 00 00	 sub	 eax, 512		; 00000200H
  001e1	0f 84 41 03 00
	00		 je	 $LN35@WndProcMes
  001e7	83 e8 19	 sub	 eax, 25			; 00000019H
  001ea	74 14		 je	 SHORT $LN10@WndProcMes

; 1035 : 
; 1036 :     case WM_QUIT:
; 1037 :         break;
; 1038 : 
; 1039 :     default:
; 1040 :         return (LRESULT)(DefWindowProc(hWnd, uMsg, wParam, lParam));

  001ec	53		 push	 ebx
  001ed	57		 push	 edi
  001ee	56		 push	 esi
  001ef	ff b5 6c fe ff
	ff		 push	 DWORD PTR _hWnd$GSCopy$1$[ebp]
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  001fb	e9 d9 04 00 00	 jmp	 $LN1@WndProcMes
$LN10@WndProcMes:

; 57   :     char sMember[100] = { 0 };

  00200	6a 64		 push	 100			; 00000064H
  00202	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  00205	6a 00		 push	 0
  00207	50		 push	 eax
  00208	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0020d	68 00 00 00 00	 push	 OFFSET ?gbForceChecking@@3HA ; gbForceChecking
  00212	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00217	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  0021a	6a 63		 push	 99			; 00000063H
  0021c	50		 push	 eax
  0021d	e8 00 00 00 00	 call	 __snprintf
  00222	83 c4 1c	 add	 esp, 28			; 0000001cH

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00225	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  00228	50		 push	 eax
  00229	6a 00		 push	 0
  0022b	6a 00		 push	 0
  0022d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00233	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  00235	6a ff		 push	 -1
  00237	56		 push	 esi
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  0023e	56		 push	 esi
  0023f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gbForceChecking@@3HA, 1 ; gbForceChecking
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 65   :     CloseHandle(hdTh);

  0024f	56		 push	 esi
  00250	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 899  :         break;
; 900  : 
; 901  :     case WM_DEVICECHANGE:
; 902  :         _thSetInt(&gbForceChecking, TRUE);
; 903  : 
; 904  :         switch (wParam)

  00256	81 ff 00 80 00
	00		 cmp	 edi, 32768		; 00008000H
  0025c	0f 82 75 04 00
	00		 jb	 $LN198@WndProcMes
  00262	81 ff 04 80 00
	00		 cmp	 edi, 32772		; 00008004H
  00268	76 36		 jbe	 SHORT $LN13@WndProcMes
  0026a	81 ff ff ff 00
	00		 cmp	 edi, 65535		; 0000ffffH
  00270	0f 85 61 04 00
	00		 jne	 $LN198@WndProcMes

; 905  :         {
; 906  :         case DBT_USERDEFINED:
; 907  :             //device event identifies a user-defined event
; 908  :         {
; 909  :             _DEV_BROADCAST_USERDEFINED * pDevBcastUserDefined = (_DEV_BROADCAST_USERDEFINED *)lParam;
; 910  :             if (!pDevBcastUserDefined)

  00276	85 db		 test	 ebx, ebx
  00278	0f 84 59 04 00
	00		 je	 $LN198@WndProcMes

; 911  :                 break;
; 912  : 
; 913  :             Log(LOG_HEADER, __LINE__, "User Defined %s, Size %u, DevType %u", pDevBcastUserDefined->dbud_szName, pDevBcastUserDefined->dbud_dbh.dbch_size, pDevBcastUserDefined->dbud_dbh.dbch_devicetype);

  0027e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00281	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00284	ff 33		 push	 DWORD PTR [ebx]
  00286	50		 push	 eax
  00287	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OJAKBKAK@User?5Defined?5?$CFs?0?5Size?5?$CFu?0?5DevTy@
  0028c	68 91 03 00 00	 push	 913			; 00000391H
  00291	6a 02		 push	 2
  00293	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00298	83 c4 18	 add	 esp, 24			; 00000018H

; 914  :         }
; 915  :         break;

  0029b	e9 37 04 00 00	 jmp	 $LN198@WndProcMes
$LN13@WndProcMes:

; 916  : 
; 917  :         case DBT_DEVICEARRIVAL:
; 918  :         case DBT_DEVICEQUERYREMOVE:
; 919  :         case DBT_DEVICEQUERYREMOVEFAILED:
; 920  :         case DBT_DEVICEREMOVEPENDING:
; 921  :         case DBT_DEVICEREMOVECOMPLETE:
; 922  :         {
; 923  :             PDEV_BROADCAST_HDR pDevBcastHdr = (PDEV_BROADCAST_HDR)lParam;
; 924  :             if (!pDevBcastHdr)

  002a0	85 db		 test	 ebx, ebx
  002a2	0f 84 2f 04 00
	00		 je	 $LN198@WndProcMes
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002a8	6a 03		 push	 3

; 1784 : 		_Mysize(0),

  002aa	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$2[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002b4	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _type$2[ebp]

; 1785 : 		_Myres(0)

  002ba	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$2[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002c4	68 00 00 00 00	 push	 OFFSET ??_C@_03BBKEAIF@?$DP?$DP?$DP@

; 3976 : 		_My_data._Mysize = 0;

  002c9	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$2[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002d3	c7 85 84 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _type$2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  002dd	c6 85 70 fe ff
	ff 00		 mov	 BYTE PTR _type$2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002e4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 927  :             std::string type{ "???" };

  002e9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 928  :             switch (wParam)

  002f0	8d 87 00 80 ff
	ff		 lea	 eax, DWORD PTR [edi-32768]
  002f6	83 f8 04	 cmp	 eax, 4
  002f9	77 3d		 ja	 SHORT $LN6@WndProcMes
  002fb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN206@WndProcMes[eax*4]
$LN15@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00302	6a 09		 push	 9
  00304	68 00 00 00 00	 push	 OFFSET ??_C@_09LGELGNNP@?$CCArrived?$CC@
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 932  :                 break;

  00309	eb 22		 jmp	 SHORT $LN203@WndProcMes
$LN16@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0030b	6a 11		 push	 17			; 00000011H
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MMAEKGNO@?$CCRemoval?5Request?$CC@
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 935  :                 break;

  00312	eb 19		 jmp	 SHORT $LN203@WndProcMes
$LN17@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00314	6a 11		 push	 17			; 00000011H
  00316	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@ENLMBDFJ@?$CCRemoval?5Aborted?$CC@
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 938  :                 break;

  0031b	eb 10		 jmp	 SHORT $LN203@WndProcMes
$LN18@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0031d	6a 11		 push	 17			; 00000011H
  0031f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MCANMMCL@?$CCRemoval?5Pending?$CC@
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 941  :                 break;

  00324	eb 07		 jmp	 SHORT $LN203@WndProcMes
$LN19@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00326	6a 09		 push	 9
  00328	68 00 00 00 00	 push	 OFFSET ??_C@_09BCLHCEGD@?$CCRemoved?$CC@
$LN203@WndProcMes:

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0032d	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _type$2[ebp]
  00333	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@WndProcMes:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 946  :             Log(LOG_HEADER, __LINE__, "Device %s, Size %u, DevType %u", type.c_str(), pDevBcastHdr->dbch_size, pDevBcastHdr->dbch_devicetype);

  00338	ff 73 04	 push	 DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0033b	83 bd 84 fe ff
	ff 10		 cmp	 DWORD PTR _type$2[ebp+20], 16 ; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00342	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR _type$2[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 946  :             Log(LOG_HEADER, __LINE__, "Device %s, Size %u, DevType %u", type.c_str(), pDevBcastHdr->dbch_size, pDevBcastHdr->dbch_devicetype);

  00348	ff 33		 push	 DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1815 : 		if (_Large_string_engaged())

  0034a	0f 43 85 70 fe
	ff ff		 cmovae	 eax, DWORD PTR _type$2[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 946  :             Log(LOG_HEADER, __LINE__, "Device %s, Size %u, DevType %u", type.c_str(), pDevBcastHdr->dbch_size, pDevBcastHdr->dbch_devicetype);

  00351	50		 push	 eax
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PNOLPDFB@Device?5?$CFs?0?5Size?5?$CFu?0?5DevType?5?$CFu@
  00357	68 b2 03 00 00	 push	 946			; 000003b2H
  0035c	6a 02		 push	 2
  0035e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 947  :             if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)

  00363	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00366	83 c4 18	 add	 esp, 24			; 00000018H
  00369	83 f8 05	 cmp	 eax, 5
  0036c	75 65		 jne	 SHORT $LN20@WndProcMes

; 948  :             {
; 949  :                 char szGuid[_MAX_PATH] = { 0 };

  0036e	68 04 01 00 00	 push	 260			; 00000104H
  00373	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _szGuid$4[ebp]
  00379	6a 00		 push	 0
  0037b	50		 push	 eax
  0037c	e8 00 00 00 00	 call	 _memset

; 950  :                 PDEV_BROADCAST_DEVICEINTERFACE pDevBcastDevIface = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
; 951  :                 Log(LOG_MESSAGE, __LINE__, "Usb CHANGE Dev <%s GUID %s>", (LPBYTE)pDevBcastDevIface->dbcc_name, GUID2Str(&pDevBcastDevIface->dbcc_classguid, szGuid, sizeof(szGuid) - 1));

  00381	83 c4 08	 add	 esp, 8
  00384	8d 4b 0c	 lea	 ecx, DWORD PTR [ebx+12]
  00387	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _szGuid$4[ebp]
  0038d	8d 73 1c	 lea	 esi, DWORD PTR [ebx+28]
  00390	e8 00 00 00 00	 call	 ?GUID2Str@@YAPADPAU_GUID@@PADI@Z ; GUID2Str
  00395	50		 push	 eax
  00396	56		 push	 esi
  00397	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HKOFJDPP@Usb?5CHANGE?5Dev?5?$DM?$CFs?5GUID?5?$CFs?$DO@
  0039c	68 b7 03 00 00	 push	 951			; 000003b7H
  003a1	6a 01		 push	 1
  003a3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003a8	83 c4 18	 add	 esp, 24			; 00000018H

; 952  : 
; 953  :                 if (wParam == DBT_DEVICEARRIVAL)

  003ab	8b d6		 mov	 edx, esi
  003ad	81 ff 00 80 00
	00		 cmp	 edi, 32768		; 00008000H
  003b3	75 0f		 jne	 SHORT $LN22@WndProcMes

; 954  :                     USBTraceInfo("USB ARRIVAL", (PCHAR)pDevBcastDevIface->dbcc_name);

  003b5	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@FPDKOEDO@USB?5ARRIVAL@
  003ba	e8 00 00 00 00	 call	 ?USBTraceInfo@@YAXPAD0@Z ; USBTraceInfo

; 955  :                 else

  003bf	e9 03 01 00 00	 jmp	 $LN34@WndProcMes
$LN22@WndProcMes:

; 956  :                     USBTraceInfo("USB  REMOVE", (PCHAR)pDevBcastDevIface->dbcc_name);

  003c4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@ENJCMGFB@USB?5?5REMOVE@
  003c9	e8 00 00 00 00	 call	 ?USBTraceInfo@@YAXPAD0@Z ; USBTraceInfo
  003ce	e9 f4 00 00 00	 jmp	 $LN34@WndProcMes
$LN20@WndProcMes:

; 957  :             }
; 958  :             else if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_VOLUME)

  003d3	83 f8 02	 cmp	 eax, 2
  003d6	75 21		 jne	 SHORT $LN24@WndProcMes

; 959  :             {
; 960  :                 PDEV_BROADCAST_VOLUME pDevBcastVolume = (PDEV_BROADCAST_VOLUME)lParam;
; 961  :                 Log(LOG_MESSAGE, __LINE__, "Volume CHANGE <Flags %p, UnitMask %p>", pDevBcastVolume->dbcv_flags, pDevBcastVolume->dbcv_unitmask);

  003d8	ff 73 0c	 push	 DWORD PTR [ebx+12]
  003db	0f b7 43 10	 movzx	 eax, WORD PTR [ebx+16]
  003df	50		 push	 eax
  003e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OJJDNJOH@Volume?5CHANGE?5?$DMFlags?5?$CFp?0?5UnitMa@
  003e5	68 c1 03 00 00	 push	 961			; 000003c1H
  003ea	6a 01		 push	 1
  003ec	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003f1	83 c4 14	 add	 esp, 20			; 00000014H
  003f4	e9 ce 00 00 00	 jmp	 $LN34@WndProcMes
$LN24@WndProcMes:

; 962  :             }
; 963  :             else if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_OEM)

  003f9	85 c0		 test	 eax, eax
  003fb	75 1f		 jne	 SHORT $LN26@WndProcMes

; 964  :             {
; 965  :                 PDEV_BROADCAST_OEM pDevBcastOem = (PDEV_BROADCAST_OEM)lParam;
; 966  :                 Log(LOG_MESSAGE, __LINE__, "Oem CHANGE <Id %p, SuppFunc %p>", pDevBcastOem->dbco_identifier, pDevBcastOem->dbco_suppfunc);

  003fd	ff 73 10	 push	 DWORD PTR [ebx+16]
  00400	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00403	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FNGBCCOE@Oem?5CHANGE?5?$DMId?5?$CFp?0?5SuppFunc?5?$CFp?$DO@
  00408	68 c6 03 00 00	 push	 966			; 000003c6H
  0040d	6a 01		 push	 1
  0040f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00414	83 c4 14	 add	 esp, 20			; 00000014H
  00417	e9 ab 00 00 00	 jmp	 $LN34@WndProcMes
$LN26@WndProcMes:

; 967  :             }
; 968  :             else if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_DEVNODE)

  0041c	83 f8 01	 cmp	 eax, 1
  0041f	75 1b		 jne	 SHORT $LN28@WndProcMes

; 969  :             {
; 970  :                 PDEV_BROADCAST_DEVNODE pDevBcastDevNode = (PDEV_BROADCAST_DEVNODE)lParam;
; 971  :                 Log(LOG_MESSAGE, __LINE__, "DevNode CHANGE <%p>", pDevBcastDevNode->dbcd_devnode);

  00421	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00424	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@FJDGCJID@DevNode?5CHANGE?5?$DM?$CFp?$DO@
  00429	68 cb 03 00 00	 push	 971			; 000003cbH
  0042e	50		 push	 eax
  0042f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00434	83 c4 10	 add	 esp, 16			; 00000010H
  00437	e9 8b 00 00 00	 jmp	 $LN34@WndProcMes
$LN28@WndProcMes:

; 972  :             }
; 973  :             else if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_PORT)

  0043c	83 f8 03	 cmp	 eax, 3
  0043f	75 1a		 jne	 SHORT $LN30@WndProcMes

; 974  :             {
; 975  :                 PDEV_BROADCAST_PORT pDevBcastPort = (PDEV_BROADCAST_PORT)lParam;
; 976  :                 Log(LOG_MESSAGE, __LINE__, "Port CHANGE <%s>", (LPBYTE)pDevBcastPort->dbcp_name);

  00441	8d 43 0c	 lea	 eax, DWORD PTR [ebx+12]
  00444	50		 push	 eax
  00445	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LPBNHOKC@Port?5CHANGE?5?$DM?$CFs?$DO@
  0044a	68 d0 03 00 00	 push	 976			; 000003d0H
  0044f	6a 01		 push	 1
  00451	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00456	83 c4 10	 add	 esp, 16			; 00000010H
  00459	eb 6c		 jmp	 SHORT $LN34@WndProcMes
$LN30@WndProcMes:

; 977  :             }
; 978  :             else if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_NET)

  0045b	83 f8 04	 cmp	 eax, 4
  0045e	75 1c		 jne	 SHORT $LN32@WndProcMes

; 979  :             {
; 980  :                 PDEV_BROADCAST_NET pDevBcastNet = (PDEV_BROADCAST_NET)lParam;
; 981  :                 Log(LOG_MESSAGE, __LINE__, "Net CHANGE <Resource %p, Flags %p>", (LPBYTE)pDevBcastNet->dbcn_resource, pDevBcastNet->dbcn_flags);

  00460	ff 73 10	 push	 DWORD PTR [ebx+16]
  00463	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00466	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BNLENJBO@Net?5CHANGE?5?$DMResource?5?$CFp?0?5Flags?5@
  0046b	68 d5 03 00 00	 push	 981			; 000003d5H
  00470	6a 01		 push	 1
  00472	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00477	83 c4 14	 add	 esp, 20			; 00000014H
  0047a	eb 4b		 jmp	 SHORT $LN34@WndProcMes
$LN32@WndProcMes:

; 982  :             }
; 983  :             else if (pDevBcastHdr->dbch_devicetype == DBT_DEVTYP_HANDLE)

  0047c	83 f8 06	 cmp	 eax, 6
  0047f	75 46		 jne	 SHORT $LN34@WndProcMes

; 984  :             {
; 985  :                 char szGuid[_MAX_PATH] = { 0 };

  00481	68 04 01 00 00	 push	 260			; 00000104H
  00486	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _szGuid$3[ebp]
  0048c	6a 00		 push	 0
  0048e	50		 push	 eax
  0048f	e8 00 00 00 00	 call	 _memset

; 986  :                 PDEV_BROADCAST_HANDLE pDevBcastHandle = (PDEV_BROADCAST_HANDLE)lParam;
; 987  :                 Log(LOG_MESSAGE, __LINE__, "Handle CHANGE <Handle %p, NameOffset %d, Name %s, DevNotify %p, EvntGUID %s>", pDevBcastHandle->dbch_handle, pDevBcastHandle->dbch_nameoffset, (LPBYTE)pDevBcastHandle->dbch_data, pDevBcastHandle->dbch_hdevnotify, GUID2Str(&pDevBcastHandle->dbch_eventguid, szGuid, sizeof(szGuid) - 1));

  00494	83 c4 08	 add	 esp, 8
  00497	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  0049a	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR _szGuid$3[ebp]
  004a0	e8 00 00 00 00	 call	 ?GUID2Str@@YAPADPAU_GUID@@PADI@Z ; GUID2Str
  004a5	50		 push	 eax
  004a6	ff 73 10	 push	 DWORD PTR [ebx+16]
  004a9	8d 43 28	 lea	 eax, DWORD PTR [ebx+40]
  004ac	50		 push	 eax
  004ad	ff 73 24	 push	 DWORD PTR [ebx+36]
  004b0	ff 73 0c	 push	 DWORD PTR [ebx+12]
  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GBOFOCLM@Handle?5CHANGE?5?$DMHandle?5?$CFp?0?5NameO@
  004b8	68 db 03 00 00	 push	 987			; 000003dbH
  004bd	6a 01		 push	 1
  004bf	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  004c4	83 c4 24	 add	 esp, 36			; 00000024H
$LN34@WndProcMes:

; 988  :             }
; 989  :         }

  004c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  004ce	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _type$2[ebp+20]
  004d4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  004d7	72 2f		 jb	 SHORT $LN177@WndProcMes
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004d9	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _type$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  004df	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e0	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  004e2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004e8	72 14		 jb	 SHORT $LN176@WndProcMes

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  004ea	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004ed	83 c2 23	 add	 edx, 35			; 00000023H
  004f0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004f2	83 c0 fc	 add	 eax, -4			; fffffffcH
  004f5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004f8	0f 87 f9 01 00
	00		 ja	 $LN205@WndProcMes
$LN176@WndProcMes:

; 207  : 	::operator delete(_Ptr, _Bytes);

  004fe	52		 push	 edx
  004ff	51		 push	 ecx
  00500	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00505	83 c4 08	 add	 esp, 8
$LN177@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00508	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _type$2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00512	c7 85 84 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _type$2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0051c	c6 85 70 fe ff
	ff 00		 mov	 BYTE PTR _type$2[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 992  :         break;

  00523	e9 af 01 00 00	 jmp	 $LN198@WndProcMes
$LN35@WndProcMes:

; 993  : 
; 994  :     case WM_MOUSEMOVE:
; 995  :         //if mouse is moved in the window square, control key is pressed
; 996  :         //ask whether or not it should be stopped;
; 997  :         //if so, set terminate flag to stop loop processing
; 998  :         if (wParam == MK_CONTROL)

  00528	83 ff 08	 cmp	 edi, 8
  0052b	0f 85 a8 00 00
	00		 jne	 $LN36@WndProcMes

; 999  :         {
; 1000 :             lPoints = MAKEPOINTS(lParam);

  00531	66 83 fb 14	 cmp	 bx, 20			; 00000014H

; 1001 :             if (lPoints.x <= 20 && lPoints.y <= 20)

  00535	0f 8f 9c 01 00
	00		 jg	 $LN198@WndProcMes
  0053b	66 83 bd 68 fe
	ff ff 14	 cmp	 WORD PTR tv1007[ebp], 20 ; 00000014H
  00543	0f 8f 8e 01 00
	00		 jg	 $LN198@WndProcMes

; 1002 :             {
; 1003 :                 iRet = MessageBox(hWnd, "Would you like to close this application?", "SysStatus", MB_YESNO | MB_ICONQUESTION | MB_SYSTEMMODAL);

  00549	68 24 10 00 00	 push	 4132			; 00001024H
  0054e	68 00 00 00 00	 push	 OFFSET ??_C@_09KECABMHK@SysStatus@
  00553	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KDAHPGC@Would?5you?5like?5to?5close?5this?5ap@
  00558	ff b5 6c fe ff
	ff		 push	 DWORD PTR _hWnd$GSCopy$1$[ebp]
  0055e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 1004 :                 if (iRet == IDYES)

  00564	83 f8 06	 cmp	 eax, 6
  00567	0f 85 6a 01 00
	00		 jne	 $LN198@WndProcMes

; 1005 :                 {
; 1006 :                     Log(LOG_HEADER, __LINE__, "Exit Requested");

  0056d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BIPEBJDO@Exit?5Requested@
  00572	68 ee 03 00 00	 push	 1006			; 000003eeH
  00577	6a 02		 push	 2
  00579	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 57   :     char sMember[100] = { 0 };

  0057e	6a 64		 push	 100			; 00000064H
  00580	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00583	6a 00		 push	 0
  00585	50		 push	 eax
  00586	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0058b	68 00 00 00 00	 push	 OFFSET ?gbTerminate@@3HA ; gbTerminate
  00590	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00595	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00598	6a 63		 push	 99			; 00000063H
  0059a	50		 push	 eax
  0059b	e8 00 00 00 00	 call	 __snprintf
  005a0	83 c4 28	 add	 esp, 40			; 00000028H

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  005a3	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  005a6	50		 push	 eax
  005a7	6a 00		 push	 0
  005a9	6a 00		 push	 0
  005ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  005b1	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  005b3	6a ff		 push	 -1
  005b5	56		 push	 esi
  005b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  005bc	56		 push	 esi
  005bd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gbTerminate@@3HA, 1 ; gbTerminate
  005c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 65   :     CloseHandle(hdTh);

  005cd	56		 push	 esi
  005ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1007 :                     _thSetInt(&gbTerminate, TRUE);
; 1008 :                 }
; 1009 :             }
; 1010 :         }

  005d4	e9 fe 00 00 00	 jmp	 $LN198@WndProcMes
$LN36@WndProcMes:

; 1011 :         //if mouse is moved in the window square, shift key is pressed
; 1012 :         //ask whether or not it should be quickly stopped;
; 1013 :         //if so, set terminate and shutdown flags to stop loop 
; 1014 :         //processing as it would do during a end session
; 1015 :         //(shutdown, logoff, restart)
; 1016 :         else if (wParam == MK_SHIFT)

  005d9	83 ff 04	 cmp	 edi, 4
  005dc	0f 85 f5 00 00
	00		 jne	 $LN198@WndProcMes

; 1017 :         {
; 1018 :             lPoints = MAKEPOINTS(lParam);

  005e2	66 83 fb 14	 cmp	 bx, 20			; 00000014H

; 1019 :             if (lPoints.x <= 20 && lPoints.y <= 20)

  005e6	0f 8f eb 00 00
	00		 jg	 $LN198@WndProcMes
  005ec	66 83 bd 68 fe
	ff ff 14	 cmp	 WORD PTR tv1007[ebp], 20 ; 00000014H
  005f4	0f 8f dd 00 00
	00		 jg	 $LN198@WndProcMes

; 1020 :             {
; 1021 :                 iRet = MessageBox(hWnd, "Would you like to quickly close this application?", "SysStatus", MB_YESNO | MB_ICONQUESTION | MB_SYSTEMMODAL);

  005fa	68 24 10 00 00	 push	 4132			; 00001024H
  005ff	68 00 00 00 00	 push	 OFFSET ??_C@_09KECABMHK@SysStatus@
  00604	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MBHJGPCP@Would?5you?5like?5to?5quickly?5close@
  00609	ff b5 6c fe ff
	ff		 push	 DWORD PTR _hWnd$GSCopy$1$[ebp]
  0060f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16

; 1022 :                 if (iRet == IDYES)

  00615	83 f8 06	 cmp	 eax, 6
  00618	0f 85 b9 00 00
	00		 jne	 $LN198@WndProcMes

; 1023 :                 {
; 1024 :                     Log(LOG_HEADER, __LINE__, "Quick Exit Requested");

  0061e	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@CDGGKCEM@Quick?5Exit?5Requested@
  00623	68 00 04 00 00	 push	 1024			; 00000400H
  00628	6a 02		 push	 2
  0062a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 57   :     char sMember[100] = { 0 };

  0062f	6a 64		 push	 100			; 00000064H
  00631	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00634	6a 00		 push	 0
  00636	50		 push	 eax
  00637	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0063c	68 00 00 00 00	 push	 OFFSET ?gbTerminate@@3HA ; gbTerminate
  00641	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00646	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00649	6a 63		 push	 99			; 00000063H
  0064b	50		 push	 eax
  0064c	e8 00 00 00 00	 call	 __snprintf
  00651	83 c4 28	 add	 esp, 40			; 00000028H

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00654	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00657	50		 push	 eax
  00658	6a 00		 push	 0
  0065a	6a 00		 push	 0
  0065c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00662	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  00664	6a ff		 push	 -1
  00666	56		 push	 esi
  00667	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  0066d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ReleaseMutex@4
  00673	56		 push	 esi
  00674	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gbTerminate@@3HA, 1 ; gbTerminate
  0067e	ff d3		 call	 ebx

; 65   :     CloseHandle(hdTh);

  00680	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__CloseHandle@4
  00686	56		 push	 esi
  00687	ff d7		 call	 edi

; 57   :     char sMember[100] = { 0 };

  00689	6a 64		 push	 100			; 00000064H
  0068b	8d 45 8c	 lea	 eax, DWORD PTR _sMember$5[ebp]
  0068e	6a 00		 push	 0
  00690	50		 push	 eax
  00691	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00696	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  0069b	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  006a0	8d 45 8c	 lea	 eax, DWORD PTR _sMember$5[ebp]
  006a3	6a 63		 push	 99			; 00000063H
  006a5	50		 push	 eax
  006a6	e8 00 00 00 00	 call	 __snprintf
  006ab	83 c4 1c	 add	 esp, 28			; 0000001cH

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  006ae	8d 45 8c	 lea	 eax, DWORD PTR _sMember$5[ebp]
  006b1	50		 push	 eax
  006b2	6a 00		 push	 0
  006b4	6a 00		 push	 0
  006b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  006bc	8b f0		 mov	 esi, eax

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  006be	6a ff		 push	 -1
  006c0	56		 push	 esi
  006c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  006c7	56		 push	 esi
  006c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gbShutdown@@3HA, 1 ; gbShutdown
  006d2	ff d3		 call	 ebx

; 65   :     CloseHandle(hdTh);

  006d4	56		 push	 esi
  006d5	ff d7		 call	 edi
$LN198@WndProcMes:

; 1041 :     }
; 1042 :     return 0;

  006d7	33 c0		 xor	 eax, eax
$LN1@WndProcMes:

; 1043 : }

  006d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006e3	59		 pop	 ecx
  006e4	5f		 pop	 edi
  006e5	5e		 pop	 esi
  006e6	5b		 pop	 ebx
  006e7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ea	33 cd		 xor	 ecx, ebp
  006ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006f1	8b e5		 mov	 esp, ebp
  006f3	5d		 pop	 ebp
  006f4	c2 10 00	 ret	 16			; 00000010H
$LN205@WndProcMes:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006f7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN202@WndProcMes:
$LN206@WndProcMes:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1043 : }

  006fc	00 00 00 00	 DD	 $LN15@WndProcMes
  00700	00 00 00 00	 DD	 $LN16@WndProcMes
  00704	00 00 00 00	 DD	 $LN17@WndProcMes
  00708	00 00 00 00	 DD	 $LN18@WndProcMes
  0070c	00 00 00 00	 DD	 $LN19@WndProcMes
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z$0:
  00000	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR _type$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 8a 60 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-416]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?WndProcMessage@@YGJPAUHWND__@@IIJ@Z
  0002e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?WndProcMessage@@YGJPAUHWND__@@IIJ@Z ENDP		; WndProcMessage
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_WindowClass$ = -176					; size = 40
_msg$ = -136						; size = 28
_hNotifyNetHandle$1$ = -108				; size = 4
_hNotifyHubHandle$1$ = -104				; size = 4
_hNotifyDevHandle$1$ = -100				; size = 4
_bShowWindow$1$ = -93					; size = 1
_broadcastInterface$ = -92				; size = 32
_broadcastNet$ = -60					; size = 20
$T2 = -40						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 4
?ThreadMessage@@YGIPAX@Z PROC				; ThreadMessage

; 1049 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ThreadMessage@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]

; 1050 :     bool *pbShowWindow = (bool*)input;
; 1051 :     bool bShowWindow = (pbShowWindow ? *pbShowWindow : true);

  00030	85 c0		 test	 eax, eax
  00032	74 07		 je	 SHORT $LN10@ThreadMess
  00034	8a 00		 mov	 al, BYTE PTR [eax]
  00036	88 45 a3	 mov	 BYTE PTR _bShowWindow$1$[ebp], al
  00039	eb 04		 jmp	 SHORT $LN11@ThreadMess
$LN10@ThreadMess:
  0003b	c6 45 a3 01	 mov	 BYTE PTR _bShowWindow$1$[ebp], 1
$LN11@ThreadMess:

; 1052 : 
; 1053 :     MSG msg{};
; 1054 : 
; 1055 :     Log(LOG_DEBUG, __LINE__, ">> ThrdMsg");

  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EMLHDHFB@?$DO?$DO?5ThrdMsg@
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	c7 45 90 00 00
	00 00		 mov	 DWORD PTR _msg$[ebp+24], 0
  0004e	68 1f 04 00 00	 push	 1055			; 0000041fH
  00053	6a 10		 push	 16			; 00000010H
  00055	0f 11 85 78 ff
	ff ff		 movups	 XMMWORD PTR _msg$[ebp], xmm0
  0005c	66 0f d6 45 88	 movq	 QWORD PTR _msg$[ebp+16], xmm0
  00061	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1056 : 
; 1057 :     //Create application instance
; 1058 :     WNDCLASS  WindowClass = { 0 };
; 1059 : 
; 1060 :     WindowClass.style = CS_HREDRAW | CS_VREDRAW;
; 1061 :     WindowClass.lpfnWndProc = (WNDPROC)WndProcMessage;
; 1062 :     WindowClass.cbClsExtra = 0;
; 1063 :     WindowClass.cbWndExtra = 0;
; 1064 :     WindowClass.hInstance = ghInstance;

  00066	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghInstance@@3PAUHINSTANCE__@@A ; ghInstance
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	89 85 60 ff ff
	ff		 mov	 DWORD PTR _WindowClass$[ebp+16], eax
  00074	0f 57 c0	 xorps	 xmm0, xmm0

; 1065 :     WindowClass.hIcon = (HICON)NULL;
; 1066 :     WindowClass.hCursor = (HCURSOR)NULL;
; 1067 :     WindowClass.hbrBackground = (HBRUSH)NULL;
; 1068 :     WindowClass.lpszMenuName = (LPCTSTR)NULL;
; 1069 :     WindowClass.lpszClassName = "SysStatusWClass";
; 1070 : 
; 1071 :     //Register window
; 1072 :     if (!RegisterClass(&WindowClass))

  00077	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _WindowClass$[ebp]
  0007d	c7 85 50 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp], 3
  00087	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+4], OFFSET ?WndProcMessage@@YGJPAUHWND__@@IIJ@Z ; WndProcMessage
  00091	50		 push	 eax
  00092	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+8], 0
  0009c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+12], 0
  000a6	0f 11 85 64 ff
	ff ff		 movups	 XMMWORD PTR _WindowClass$[ebp+20], xmm0
  000ad	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _WindowClass$[ebp+36], OFFSET ??_C@_0BA@JDKJFHEL@SysStatusWClass@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassA@4
  000bd	66 85 c0	 test	 ax, ax
  000c0	75 72		 jne	 SHORT $LN4@ThreadMess

; 1074 :         Log(LOG_HEADER, __LINE__, "<< ThrdMsg, RegCls %s", GetLastErrorMessage(GetLastError()).c_str());

  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000c8	8b d0		 mov	 edx, eax
  000ca	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  000cd	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  000d2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000d9	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  000dd	72 02		 jb	 SHORT $LN21@ThreadMess
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000df	8b 00		 mov	 eax, DWORD PTR [eax]
$LN21@ThreadMess:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1074 :         Log(LOG_HEADER, __LINE__, "<< ThrdMsg, RegCls %s", GetLastErrorMessage(GetLastError()).c_str());

  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GPCBDAOG@?$DM?$DM?5ThrdMsg?0?5RegCls?5?$CFs@
  000e7	68 32 04 00 00	 push	 1074			; 00000432H
  000ec	6a 02		 push	 2
  000ee	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000f3	83 c4 10	 add	 esp, 16			; 00000010H
  000f6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000fd	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
  00100	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00103	0f 82 3e 02 00
	00		 jb	 $LN139@ThreadMess
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00109	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0010c	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0010d	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0010f	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00115	0f 82 22 02 00
	00		 jb	 $LN138@ThreadMess

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0011b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0011e	83 c2 23	 add	 edx, 35			; 00000023H
  00121	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00123	83 c0 fc	 add	 eax, -4			; fffffffcH
  00126	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00129	0f 87 54 02 00
	00		 ja	 $LN174@ThreadMess
  0012f	e9 09 02 00 00	 jmp	 $LN138@ThreadMess
$LN4@ThreadMess:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1080 :     ghWnd = CreateWindowEx((bShowWindow ? WS_EX_DLGMODALFRAME : 0),

  00134	8a 4d a3	 mov	 cl, BYTE PTR _bShowWindow$1$[ebp]
  00137	33 c0		 xor	 eax, eax
  00139	6a 00		 push	 0
  0013b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghInstance@@3PAUHINSTANCE__@@A ; ghInstance
  00141	84 c9		 test	 cl, cl
  00143	ba 00 00 80 80	 mov	 edx, -2139095040	; 80800000H
  00148	6a 00		 push	 0
  0014a	6a 00		 push	 0
  0014c	6a 14		 push	 20			; 00000014H
  0014e	6a 14		 push	 20			; 00000014H
  00150	6a 00		 push	 0
  00152	6a 00		 push	 0
  00154	0f 45 c2	 cmovne	 eax, edx
  00157	50		 push	 eax
  00158	33 c0		 xor	 eax, eax
  0015a	84 c9		 test	 cl, cl
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_09KECABMHK@SysStatus@
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JDKJFHEL@SysStatusWClass@
  00166	0f 95 c0	 setne	 al
  00169	50		 push	 eax
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExA@48
  00170	a3 00 00 00 00	 mov	 DWORD PTR ?ghWnd@@3PAUHWND__@@A, eax ; ghWnd

; 1081 :         (LPCSTR)"SysStatusWClass", (LPCSTR)"SysStatus",
; 1082 :         (bShowWindow ? WS_BORDER | WS_POPUP : 0),
; 1083 :         0, 0, 20, 20,
; 1084 :         (HWND)NULL, (HMENU)NULL,
; 1085 :         ghInstance, (LPVOID)NULL);
; 1086 : 
; 1087 :     if (ghWnd == NULL || IsWindow(ghWnd) == FALSE)

  00175	85 c0		 test	 eax, eax
  00177	0f 84 5f 01 00
	00		 je	 $LN6@ThreadMess
  0017d	50		 push	 eax
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00184	85 c0		 test	 eax, eax
  00186	0f 84 50 01 00
	00		 je	 $LN6@ThreadMess

; 1090 :         _endthreadex(static_cast<unsigned>(-1));
; 1091 :         return static_cast<unsigned>(-1);
; 1092 :     }
; 1093 : 
; 1094 :     //show the window application
; 1095 :     if (bShowWindow)

  0018c	80 7d a3 00	 cmp	 BYTE PTR _bShowWindow$1$[ebp], 0
  00190	74 16		 je	 SHORT $LN7@ThreadMess

; 1096 :     {
; 1097 :         ShowWindow(ghWnd, SW_SHOW);

  00192	6a 05		 push	 5
  00194	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 1098 :         Sleep(MILLISECOND * 50UL);

  001a0	6a 32		 push	 50			; 00000032H
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN7@ThreadMess:

; 1099 :     }
; 1100 : 
; 1101 :     //Register to receive notification when a USB device or hub is plugged in
; 1102 :     HDEVNOTIFY hNotifyDevHandle = nullptr;
; 1103 :     HDEVNOTIFY hNotifyHubHandle = nullptr;
; 1104 :     DEV_BROADCAST_DEVICEINTERFACE broadcastInterface{};
; 1105 : 
; 1106 :     ZeroMemory(&broadcastInterface, sizeof(broadcastInterface));
; 1107 :     broadcastInterface.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
; 1108 :     broadcastInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
; 1109 : 
; 1110 :     //Register for Device nofitications
; 1111 :     memcpy(&(broadcastInterface.dbcc_classguid), &(GUID_CLASS_USB_DEVICE), sizeof(struct _GUID));

  001a8	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR _GUID_DEVINTERFACE_USB_DEVICE

; 1112 :     hNotifyDevHandle = RegisterDeviceNotification(ghWnd, &broadcastInterface, DEVICE_NOTIFY_WINDOW_HANDLE);

  001af	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__RegisterDeviceNotificationA@12
  001b5	8d 45 a4	 lea	 eax, DWORD PTR _broadcastInterface$[ebp]
  001b8	6a 00		 push	 0
  001ba	50		 push	 eax
  001bb	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  001c1	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _broadcastInterface$[ebp+8], 0
  001c8	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _broadcastInterface$[ebp+28], 0
  001cf	c7 45 a4 20 00
	00 00		 mov	 DWORD PTR _broadcastInterface$[ebp], 32 ; 00000020H
  001d6	c7 45 a8 05 00
	00 00		 mov	 DWORD PTR _broadcastInterface$[ebp+4], 5
  001dd	0f 11 45 b0	 movups	 XMMWORD PTR _broadcastInterface$[ebp+12], xmm0
  001e1	ff d6		 call	 esi

; 1113 : 
; 1114 :     //Register for Hub notifications
; 1115 :     memcpy(&(broadcastInterface.dbcc_classguid), &(GUID_CLASS_USBHUB), sizeof(struct _GUID));

  001e3	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR _GUID_DEVINTERFACE_USB_HUB
  001ea	89 45 9c	 mov	 DWORD PTR _hNotifyDevHandle$1$[ebp], eax

; 1116 :     hNotifyHubHandle = RegisterDeviceNotification(ghWnd, &broadcastInterface, DEVICE_NOTIFY_WINDOW_HANDLE);

  001ed	8d 45 a4	 lea	 eax, DWORD PTR _broadcastInterface$[ebp]
  001f0	6a 00		 push	 0
  001f2	50		 push	 eax
  001f3	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  001f9	0f 11 45 b0	 movups	 XMMWORD PTR _broadcastInterface$[ebp+12], xmm0
  001fd	ff d6		 call	 esi
  001ff	89 45 98	 mov	 DWORD PTR _hNotifyHubHandle$1$[ebp], eax
  00202	0f 57 c0	 xorps	 xmm0, xmm0

; 1117 : 
; 1118 :     //Register to receive notification when a network component is changed
; 1119 :     HDEVNOTIFY hNotifyNetHandle = NULL;
; 1120 :     DEV_BROADCAST_NET broadcastNet;
; 1121 : 
; 1122 :     ZeroMemory(&broadcastNet, sizeof(broadcastNet));
; 1123 :     broadcastNet.dbcn_size = sizeof(DEV_BROADCAST_NET);
; 1124 :     broadcastNet.dbcn_devicetype = DBT_DEVTYP_NET;
; 1125 : 
; 1126 :     //Register for network notifications
; 1127 :     hNotifyNetHandle = RegisterDeviceNotification(ghWnd, &broadcastNet, DEVICE_NOTIFY_WINDOW_HANDLE);

  00205	6a 00		 push	 0
  00207	8d 45 c4	 lea	 eax, DWORD PTR _broadcastNet$[ebp]
  0020a	66 0f 13 45 cc	 movlpd	 QWORD PTR _broadcastNet$[ebp+8], xmm0
  0020f	50		 push	 eax
  00210	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00216	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _broadcastNet$[ebp+16], 0
  0021d	c7 45 c4 14 00
	00 00		 mov	 DWORD PTR _broadcastNet$[ebp], 20 ; 00000014H
  00224	c7 45 c8 04 00
	00 00		 mov	 DWORD PTR _broadcastNet$[ebp+4], 4
  0022b	ff d6		 call	 esi

; 1128 : 
; 1129 :     //Message loop
; 1130 :     while (GetMessage(&msg, ghWnd, 0, 0))

  0022d	6a 00		 push	 0
  0022f	6a 00		 push	 0
  00231	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00237	89 45 94	 mov	 DWORD PTR _hNotifyNetHandle$1$[ebp], eax
  0023a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00240	50		 push	 eax
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageA@16
  00247	85 c0		 test	 eax, eax
  00249	74 4e		 je	 SHORT $LN154@ThreadMess
  0024b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__TranslateMessage@4
  00251	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__DispatchMessageA@4
  00257	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@ThreadMess:

; 1131 :     {
; 1132 :         if (msg.message == TERMINATE_WINDOW_MSG)

  00260	81 bd 7c ff ff
	ff e8 07 00 00	 cmp	 DWORD PTR _msg$[ebp+4], 2024 ; 000007e8H
  0026a	74 2d		 je	 SHORT $LN154@ThreadMess

; 1133 :         {
; 1134 :             break;
; 1135 :         }
; 1136 :         TranslateMessage(&msg);

  0026c	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  00272	50		 push	 eax
  00273	ff d6		 call	 esi

; 1137 :         DispatchMessage(&msg);

  00275	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0027b	50		 push	 eax
  0027c	ff d7		 call	 edi
  0027e	6a 00		 push	 0
  00280	6a 00		 push	 0
  00282	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00288	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _msg$[ebp]
  0028e	50		 push	 eax
  0028f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetMessageA@16
  00295	85 c0		 test	 eax, eax
  00297	75 c7		 jne	 SHORT $LL2@ThreadMess
$LN154@ThreadMess:

; 1138 :     }
; 1139 : 
; 1140 :     //Unregister notifications
; 1141 :     UnregisterDeviceNotification(hNotifyDevHandle);

  00299	ff 75 9c	 push	 DWORD PTR _hNotifyDevHandle$1$[ebp]
  0029c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__UnregisterDeviceNotification@4
  002a2	ff d6		 call	 esi

; 1142 :     UnregisterDeviceNotification(hNotifyHubHandle);

  002a4	ff 75 98	 push	 DWORD PTR _hNotifyHubHandle$1$[ebp]
  002a7	ff d6		 call	 esi

; 1143 :     UnregisterDeviceNotification(hNotifyNetHandle);

  002a9	ff 75 94	 push	 DWORD PTR _hNotifyNetHandle$1$[ebp]
  002ac	ff d6		 call	 esi

; 1144 : 
; 1145 :     DestroyWindow(ghWnd);

  002ae	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  002b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4

; 1146 :     Log(LOG_DEBUG, __LINE__, "<< ThrdMsg");

  002ba	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BACOFOKN@?$DM?$DM?5ThrdMsg@
  002bf	68 7a 04 00 00	 push	 1146			; 0000047aH
  002c4	6a 10		 push	 16			; 00000010H
  002c6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1147 :     _endthreadex(0);

  002cb	6a 00		 push	 0
  002cd	e8 00 00 00 00	 call	 __endthreadex
  002d2	83 c4 10	 add	 esp, 16			; 00000010H

; 1148 :     return 0;

  002d5	33 c0		 xor	 eax, eax
  002d7	e9 8a 00 00 00	 jmp	 $LN1@ThreadMess
$LN6@ThreadMess:

; 1089 :         Log(LOG_HEADER, __LINE__, "<< ThrdMsg, CreateWnd %s", GetLastErrorMessage(GetLastError()).c_str());

  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002e2	8b d0		 mov	 edx, eax
  002e4	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  002e7	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  002ec	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002f3	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  002f7	72 02		 jb	 SHORT $LN91@ThreadMess
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  002f9	8b 00		 mov	 eax, DWORD PTR [eax]
$LN91@ThreadMess:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1089 :         Log(LOG_HEADER, __LINE__, "<< ThrdMsg, CreateWnd %s", GetLastErrorMessage(GetLastError()).c_str());

  002fb	50		 push	 eax
  002fc	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JFGPBNIN@?$DM?$DM?5ThrdMsg?0?5CreateWnd?5?$CFs@
  00301	68 41 04 00 00	 push	 1089			; 00000441H
  00306	6a 02		 push	 2
  00308	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0030d	83 c4 10	 add	 esp, 16			; 00000010H
  00310	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00317	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  0031a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0031d	72 28		 jb	 SHORT $LN139@ThreadMess
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0031f	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00322	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00323	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00325	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0032b	72 10		 jb	 SHORT $LN138@ThreadMess

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0032d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00330	83 c2 23	 add	 edx, 35			; 00000023H
  00333	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00335	83 c0 fc	 add	 eax, -4			; fffffffcH
  00338	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0033b	77 4b		 ja	 SHORT $LN175@ThreadMess
$LN138@ThreadMess:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1149 : }

  0033d	52		 push	 edx
  0033e	51		 push	 ecx
  0033f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00344	83 c4 08	 add	 esp, 8
$LN139@ThreadMess:
  00347	6a ff		 push	 -1
  00349	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
  0034d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
  00354	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0
  0035b	e8 00 00 00 00	 call	 __endthreadex
  00360	83 c4 04	 add	 esp, 4
  00363	83 c8 ff	 or	 eax, -1
$LN1@ThreadMess:
  00366	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00369	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00370	59		 pop	 ecx
  00371	5f		 pop	 edi
  00372	5e		 pop	 esi
  00373	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00376	33 cd		 xor	 ecx, ebp
  00378	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037d	8b e5		 mov	 esp, ebp
  0037f	5d		 pop	 ebp
  00380	c2 04 00	 ret	 4
$LN174@ThreadMess:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00383	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN175@ThreadMess:
  00388	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN172@ThreadMess:
  0038d	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ThreadMessage@@YGIPAX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ThreadMessage@@YGIPAX@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ThreadMessage@@YGIPAX@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThreadMessage@@YGIPAX@Z
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThreadMessage@@YGIPAX@Z ENDP				; ThreadMessage
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
$T3 = 8							; size = 4
_lpData$ = 8						; size = 4
?ThreadUSB@@YGIPAX@Z PROC				; ThreadUSB

; 1160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ThreadUSB@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1161 :     Log(LOG_DEBUG, __LINE__, ">> ThrdUSB (%p)", lpData);

  00024	ff 75 08	 push	 DWORD PTR _lpData$[ebp]
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PGPPJDLP@?$DO?$DO?5ThrdUSB?5?$CI?$CFp?$CJ@
  0002c	68 89 04 00 00	 push	 1161			; 00000489H
  00031	6a 10		 push	 16			; 00000010H
  00033	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1163 :     USB * pUsb = new USB();

  00038	68 2c 02 00 00	 push	 556			; 0000022cH
  0003d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00042	8b f8		 mov	 edi, eax
  00044	89 7d 08	 mov	 DWORD PTR $T3[ebp], edi
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 134  :         wPortsNumber(0),

  0004e	33 c0		 xor	 eax, eax

; 142  :     {

  00050	8d b7 0c 02 00
	00		 lea	 esi, DWORD PTR [edi+524]
  00056	66 89 07	 mov	 WORD PTR [edi], ax
  00059	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0005c	89 47 08	 mov	 DWORD PTR [edi+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  0005f	89 06		 mov	 DWORD PTR [esi], eax

; 390  : 		_Mylast(),

  00061	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 391  : 		_Myend()

  00064	89 46 08	 mov	 DWORD PTR [esi+8], eax
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 142  :     {

  00067	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 143  :         memset(buf,0x00,sizeof(buf));

  0006b	68 00 02 00 00	 push	 512			; 00000200H
  00070	50		 push	 eax
  00071	89 87 18 02 00
	00		 mov	 DWORD PTR [edi+536], eax
  00077	89 87 1c 02 00
	00		 mov	 DWORD PTR [edi+540], eax
  0007d	89 87 20 02 00
	00		 mov	 DWORD PTR [edi+544], eax
  00083	89 87 24 02 00
	00		 mov	 DWORD PTR [edi+548], eax
  00089	89 87 28 02 00
	00		 mov	 DWORD PTR [edi+552], eax
  0008f	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00098	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a0	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  000a5	8b 06		 mov	 eax, DWORD PTR [esi]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  000a7	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  000aa	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1163 :     USB * pUsb = new USB();

  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 1164 :     if (!pUsb)
; 1165 :     {
; 1166 :         Log(LOG_DEBUG, __LINE__, "<< ThrdUSB, New USB class null");
; 1167 :         _endthreadex(ERROR_OUTOFMEMORY);
; 1168 :         return ERROR_OUTOFMEMORY;
; 1169 :     }
; 1170 : 
; 1171 :     pUsb->EnumerateUSB();

  000b4	8b cf		 mov	 ecx, edi
  000b6	e8 00 00 00 00	 call	 ?EnumerateUSB@USB@@QAEXXZ ; USB::EnumerateUSB

; 1172 :     pUsb->USBDevicesDetails();

  000bb	8b cf		 mov	 ecx, edi
  000bd	e8 00 00 00 00	 call	 ?USBDevicesDetails@USB@@QAEXXZ ; USB::USBDevicesDetails

; 1173 : 
; 1174 :     delete pUsb;

  000c2	89 7d 08	 mov	 DWORD PTR $T2[ebp], edi
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 147  :     {

  000c5	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  000cc	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000cf	51		 push	 ecx
  000d0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000d2	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  000d7	8b 06		 mov	 eax, DWORD PTR [esi]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  000d9	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  000dc	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 149  :     };

  000df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  000e6	8b ce		 mov	 ecx, esi
  000e8	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
  000ed	68 2c 02 00 00	 push	 556			; 0000022cH
  000f2	57		 push	 edi
  000f3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1177 :     Log(LOG_DEBUG, __LINE__, "<< ThrdUSB");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FFDNLHNK@?$DM?$DM?5ThrdUSB@
  000fd	68 99 04 00 00	 push	 1177			; 00000499H
  00102	6a 10		 push	 16			; 00000010H
  00104	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1178 :     _endthreadex(0);

  00109	6a 00		 push	 0
  0010b	e8 00 00 00 00	 call	 __endthreadex
  00110	83 c4 18	 add	 esp, 24			; 00000018H

; 1179 :     return 0;

  00113	33 c0		 xor	 eax, eax

; 1180 : }

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ThreadUSB@@YGIPAX@Z$0:
  00000	68 2c 02 00 00	 push	 556			; 0000022cH
  00005	8b 45 08	 mov	 eax, DWORD PTR $T3[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?ThreadUSB@@YGIPAX@Z$1:
  00012	8b 4d 08	 mov	 ecx, DWORD PTR $T3[ebp]
  00015	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  0001b	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?ThreadUSB@@YGIPAX@Z$2:
  00020	8b 4d 08	 mov	 ecx, DWORD PTR $T2[ebp]
  00023	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  00029	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?ThreadUSB@@YGIPAX@Z:
  0002e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00032	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00035	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThreadUSB@@YGIPAX@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThreadUSB@@YGIPAX@Z ENDP				; ThreadUSB
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??_GUSB@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$dead$ = 8					; size = 4
??_GUSB@@QAEPAXI@Z PROC					; USB::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_GUSB@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 147  :     {

  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00031	8b 97 10 02 00
	00		 mov	 edx, DWORD PTR [edi+528]
  00037	51		 push	 ecx
  00038	8b 8f 0c 02 00
	00		 mov	 ecx, DWORD PTR [edi+524]
  0003e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00043	8b 87 0c 02 00
	00		 mov	 eax, DWORD PTR [edi+524]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00049	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0004c	89 87 10 02 00
	00		 mov	 DWORD PTR [edi+528], eax
; File c:\users\giulif\downloads\study\git\sysstatus\usb.h

; 149  :     };

  00052	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00059	8d 8f 0c 02 00
	00		 lea	 ecx, DWORD PTR [edi+524]
  0005f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
  00064	68 2c 02 00 00	 push	 556			; 0000022cH
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006f	83 c4 08	 add	 esp, 8
  00072	8b c7		 mov	 eax, edi
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GUSB@@QAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 02 00
	00		 add	 ecx, 524		; 0000020cH
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??_GUSB@@QAEPAXI@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_GUSB@@QAEPAXI@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_GUSB@@QAEPAXI@Z ENDP					; USB::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_CreationTime$ = -4544					; size = 8
_ExitTime$ = -4536					; size = 8
_UserTime$ = -4528					; size = 8
_KernelTime$ = -4520					; size = 8
_tickStart$2$ = -4512					; size = 4
_tickStart$1$ = -4508					; size = 4
_cProcesses$1$ = -4504					; size = 4
tv824 = -4500						; size = 4
tv820 = -4496						; size = 4
tv819 = -4492						; size = 4
_dwProcessID$1$ = -4488					; size = 4
_hProcInfo$1$ = -4484					; size = 4
_dwHandleCount$ = -4480					; size = 4
_hMod$2 = -4476						; size = 4
_cbNeeded$ = -4472					; size = 4
_tUserTime$ = -4468					; size = 16
_tKernelTime$ = -4452					; size = 16
_pmc$ = -4436						; size = 40
$T3 = -4396						; size = 24
$T4 = -4396						; size = 24
_aProcesses$ = -4372					; size = 4096
_szProcessName$5 = -276					; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?ProcessInfo@@YGIPAX@Z PROC				; ProcessInfo

; 1186 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ProcessInfo@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 b4 11 00 00	 mov	 eax, 4532		; 000011b4H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	56		 push	 esi
  00026	57		 push	 edi
  00027	50		 push	 eax
  00028	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00031	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1187 :     Log(LOG_DEBUG, __LINE__, ">> ProcInfo (%p)", lpData);

  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JFPIPLLP@?$DO?$DO?5ProcInfo?5?$CI?$CFp?$CJ@
  0003a	68 a3 04 00 00	 push	 1187			; 000004a3H
  0003f	6a 10		 push	 16			; 00000010H
  00041	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00046	0f 57 c0	 xorps	 xmm0, xmm0

; 1188 : 
; 1189 :     PROCESS_MEMORY_COUNTERS pmc = { 0 };
; 1190 : 
; 1191 :     FILETIME CreationTime = { 0 };
; 1192 :     FILETIME ExitTime = { 0 };
; 1193 :     FILETIME KernelTime = { 0 };
; 1194 :     FILETIME UserTime = { 0 };
; 1195 :     SYSTEMTIME tKernelTime = { 0 };
; 1196 :     SYSTEMTIME tUserTime = { 0 };
; 1197 : 
; 1198 :     DWORD dwHandleCount = 0;

  00049	c7 85 80 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwHandleCount$[ebp], 0

; 1199 : 
; 1200 :     DWORD aProcesses[1024] = { 0 }, cbNeeded = 0, cProcesses = 0;

  00053	68 00 10 00 00	 push	 4096			; 00001000H
  00058	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _aProcesses$[ebp]
  0005e	66 0f d6 85 cc
	ee ff ff	 movq	 QWORD PTR _pmc$[ebp+32], xmm0
  00066	6a 00		 push	 0
  00068	50		 push	 eax
  00069	0f 11 85 ac ee
	ff ff		 movups	 XMMWORD PTR _pmc$[ebp], xmm0
  00070	0f 11 85 bc ee
	ff ff		 movups	 XMMWORD PTR _pmc$[ebp+16], xmm0
  00077	66 0f 13 85 40
	ee ff ff	 movlpd	 QWORD PTR _CreationTime$[ebp], xmm0
  0007f	66 0f 13 85 48
	ee ff ff	 movlpd	 QWORD PTR _ExitTime$[ebp], xmm0
  00087	66 0f 13 85 58
	ee ff ff	 movlpd	 QWORD PTR _KernelTime$[ebp], xmm0
  0008f	66 0f 13 85 50
	ee ff ff	 movlpd	 QWORD PTR _UserTime$[ebp], xmm0
  00097	0f 11 85 9c ee
	ff ff		 movups	 XMMWORD PTR _tKernelTime$[ebp], xmm0
  0009e	0f 11 85 8c ee
	ff ff		 movups	 XMMWORD PTR _tUserTime$[ebp], xmm0
  000a5	e8 00 00 00 00	 call	 _memset
  000aa	c7 85 88 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _cbNeeded$[ebp], 0

; 1201 : 
; 1202 :     uint64_t tickStart = SysTick();

  000b4	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1203 : 
; 1204 :     //get list of process
; 1205 :     memset(aProcesses, 0x00, sizeof(aProcesses));

  000b9	68 00 10 00 00	 push	 4096			; 00001000H
  000be	89 85 60 ee ff
	ff		 mov	 DWORD PTR _tickStart$2$[ebp], eax
  000c4	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _aProcesses$[ebp]
  000ca	6a 00		 push	 0
  000cc	50		 push	 eax
  000cd	89 95 64 ee ff
	ff		 mov	 DWORD PTR _tickStart$1$[ebp], edx
  000d3	e8 00 00 00 00	 call	 _memset
  000d8	83 c4 28	 add	 esp, 40			; 00000028H

; 1206 :     cbNeeded = 0;

  000db	c7 85 88 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _cbNeeded$[ebp], 0

; 1207 :     cProcesses = 0;
; 1208 :     if (EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))

  000e5	8d 85 88 ee ff
	ff		 lea	 eax, DWORD PTR _cbNeeded$[ebp]
  000eb	50		 push	 eax
  000ec	68 00 10 00 00	 push	 4096			; 00001000H
  000f1	8d 85 ec ee ff
	ff		 lea	 eax, DWORD PTR _aProcesses$[ebp]
  000f7	50		 push	 eax
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32EnumProcesses@12
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 41 03 00
	00		 je	 $LN5@ProcessInf

; 1209 :     {
; 1210 : 
; 1211 :         //calculate how many process identifiers were returned.
; 1212 :         cProcesses = cbNeeded / sizeof(DWORD);

  00106	8b b5 88 ee ff
	ff		 mov	 esi, DWORD PTR _cbNeeded$[ebp]
  0010c	c1 ee 02	 shr	 esi, 2

; 1213 :         Log(LOG_HEADER, __LINE__, "Processes Information, Number of processes: %u", cProcesses);

  0010f	56		 push	 esi
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FFOKNKOI@Processes?5Information?0?5Number?5o@
  00115	68 bd 04 00 00	 push	 1213			; 000004bdH
  0011a	6a 02		 push	 2
  0011c	89 b5 68 ee ff
	ff		 mov	 DWORD PTR _cProcesses$1$[ebp], esi
  00122	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00127	83 c4 10	 add	 esp, 16			; 00000010H

; 1214 :         if (cProcesses > 0)        //skip from current process

  0012a	85 f6		 test	 esi, esi
  0012c	0f 84 a4 03 00
	00		 je	 $LN141@ProcessInf

; 1215 :             Log(LOG_MESSAGE, __LINE__, ">      ProcessID, Process Name, Handles, CPUTime, PagefileUsage, PeakPagefileUsage, PageFaultCount, PeakWorkingSetSize, WorkingSetSize, QuotaPeakPagedPoolUsage, QuotaPagedPoolUsage, QuotaPeakNonPagedPoolUsage, QuotaNonPagedPoolUsage");

  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0OJ@OBBIANJK@?$DO?5?5?5?5?5?5ProcessID?0?5Process?5Name?0@
  00137	68 bf 04 00 00	 push	 1215			; 000004bfH
  0013c	6a 01		 push	 1
  0013e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1216 : 
; 1217 :         for (DWORD i = 0; i < cProcesses; i++)

  00143	bf 01 00 00 00	 mov	 edi, 1
  00148	8d 8d ec ee ff
	ff		 lea	 ecx, DWORD PTR _aProcesses$[ebp]
  0014e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00151	89 bd 70 ee ff
	ff		 mov	 DWORD PTR tv820[ebp], edi
  00157	89 8d 74 ee ff
	ff		 mov	 DWORD PTR tv819[ebp], ecx
  0015d	0f 1f 00	 npad	 3
$LL4@ProcessInf:

; 1218 :         {
; 1219 :             //get a handle to the process
; 1220 :             DWORD dwProcessID = aProcesses[i];

  00160	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1221 :             HANDLE hProcInfo = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessID);

  00162	50		 push	 eax
  00163	6a 00		 push	 0
  00165	68 10 04 00 00	 push	 1040			; 00000410H
  0016a	89 85 78 ee ff
	ff		 mov	 DWORD PTR _dwProcessID$1$[ebp], eax
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  00176	8b f0		 mov	 esi, eax
  00178	89 b5 7c ee ff
	ff		 mov	 DWORD PTR _hProcInfo$1$[ebp], esi

; 1222 :             if (hProcInfo)

  0017e	85 f6		 test	 esi, esi
  00180	0f 84 e7 01 00
	00		 je	 $LN8@ProcessInf

; 1223 :             {
; 1224 :                 //get process name
; 1225 :                 HMODULE hMod = NULL;
; 1226 :                 cbNeeded = 0;
; 1227 :                 TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

  00186	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09EEKGDCPH@?$DMunknown?$DO@
  0018e	8d 85 f6 fe ff
	ff		 lea	 eax, DWORD PTR _szProcessName$5[ebp+10]
  00194	66 8b 0d 08 00
	00 00		 mov	 cx, WORD PTR ??_C@_09EEKGDCPH@?$DMunknown?$DO@+8
  0019b	68 fa 00 00 00	 push	 250			; 000000faH
  001a0	6a 00		 push	 0
  001a2	50		 push	 eax
  001a3	c7 85 84 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _hMod$2[ebp], 0
  001ad	c7 85 88 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR _cbNeeded$[ebp], 0
  001b7	66 0f d6 85 ec
	fe ff ff	 movq	 QWORD PTR _szProcessName$5[ebp], xmm0
  001bf	66 89 8d f4 fe
	ff ff		 mov	 WORD PTR _szProcessName$5[ebp+8], cx
  001c6	e8 00 00 00 00	 call	 _memset
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1228 : 
; 1229 :                 //enumerate modules
; 1230 :                 if (EnumProcessModules(hProcInfo, &hMod, sizeof(hMod), &cbNeeded))

  001ce	8d 85 88 ee ff
	ff		 lea	 eax, DWORD PTR _cbNeeded$[ebp]
  001d4	50		 push	 eax
  001d5	6a 04		 push	 4
  001d7	8d 85 84 ee ff
	ff		 lea	 eax, DWORD PTR _hMod$2[ebp]
  001dd	50		 push	 eax
  001de	56		 push	 esi
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32EnumProcessModules@16
  001e5	85 c0		 test	 eax, eax
  001e7	74 19		 je	 SHORT $LN10@ProcessInf

; 1231 :                 {
; 1232 :                     GetModuleBaseName(hProcInfo, hMod, szProcessName, sizeof(szProcessName) / sizeof(TCHAR));

  001e9	68 04 01 00 00	 push	 260			; 00000104H
  001ee	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szProcessName$5[ebp]
  001f4	50		 push	 eax
  001f5	ff b5 84 ee ff
	ff		 push	 DWORD PTR _hMod$2[ebp]
  001fb	56		 push	 esi
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetModuleBaseNameA@16
$LN10@ProcessInf:

; 1233 :                 }
; 1234 : 
; 1235 :                 //get process memory information
; 1236 :                 GetProcessMemoryInfo(hProcInfo, &pmc, sizeof(pmc));

  00202	6a 28		 push	 40			; 00000028H
  00204	8d 85 ac ee ff
	ff		 lea	 eax, DWORD PTR _pmc$[ebp]
  0020a	50		 push	 eax
  0020b	56		 push	 esi
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetProcessMemoryInfo@12

; 1237 : 
; 1238 :                 //get process time information
; 1239 :                 GetProcessTimes(hProcInfo, &CreationTime, &ExitTime, &KernelTime, &UserTime);

  00212	8d 85 50 ee ff
	ff		 lea	 eax, DWORD PTR _UserTime$[ebp]
  00218	50		 push	 eax
  00219	8d 85 58 ee ff
	ff		 lea	 eax, DWORD PTR _KernelTime$[ebp]
  0021f	50		 push	 eax
  00220	8d 85 48 ee ff
	ff		 lea	 eax, DWORD PTR _ExitTime$[ebp]
  00226	50		 push	 eax
  00227	8d 85 40 ee ff
	ff		 lea	 eax, DWORD PTR _CreationTime$[ebp]
  0022d	50		 push	 eax
  0022e	56		 push	 esi
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessTimes@20

; 1240 :                 FileTimeToSystemTime(&KernelTime, &tKernelTime);

  00235	8d 85 9c ee ff
	ff		 lea	 eax, DWORD PTR _tKernelTime$[ebp]
  0023b	50		 push	 eax
  0023c	8d 85 58 ee ff
	ff		 lea	 eax, DWORD PTR _KernelTime$[ebp]
  00242	50		 push	 eax
  00243	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToSystemTime@8

; 1241 :                 unsigned long seconds = (unsigned long)tKernelTime.wSecond + ((unsigned long)tKernelTime.wMinute * 60) + ((unsigned long)tKernelTime.wHour * 3600);

  00249	0f b7 85 a8 ee
	ff ff		 movzx	 eax, WORD PTR _tKernelTime$[ebp+12]
  00250	0f b7 b5 a4 ee
	ff ff		 movzx	 esi, WORD PTR _tKernelTime$[ebp+8]
  00257	0f b7 bd a6 ee
	ff ff		 movzx	 edi, WORD PTR _tKernelTime$[ebp+10]
  0025e	89 85 6c ee ff
	ff		 mov	 DWORD PTR tv824[ebp], eax

; 1242 :                 FileTimeToSystemTime(&UserTime, &tUserTime);

  00264	8d 85 8c ee ff
	ff		 lea	 eax, DWORD PTR _tUserTime$[ebp]
  0026a	50		 push	 eax
  0026b	8d 85 50 ee ff
	ff		 lea	 eax, DWORD PTR _UserTime$[ebp]
  00271	50		 push	 eax
  00272	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToSystemTime@8

; 1243 :                 seconds = seconds + (unsigned long)tUserTime.wSecond + ((unsigned long)tUserTime.wMinute * 60) + ((unsigned long)tUserTime.wHour * 3600);

  00278	0f b7 85 94 ee
	ff ff		 movzx	 eax, WORD PTR _tUserTime$[ebp+8]
  0027f	03 c6		 add	 eax, esi
  00281	8b c8		 mov	 ecx, eax
  00283	c1 e1 04	 shl	 ecx, 4
  00286	2b c8		 sub	 ecx, eax
  00288	0f b7 85 96 ee
	ff ff		 movzx	 eax, WORD PTR _tUserTime$[ebp+10]
  0028f	03 c7		 add	 eax, edi
  00291	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00294	8b c8		 mov	 ecx, eax
  00296	c1 e1 04	 shl	 ecx, 4
  00299	2b c8		 sub	 ecx, eax
  0029b	0f b7 85 98 ee
	ff ff		 movzx	 eax, WORD PTR _tUserTime$[ebp+12]
  002a2	03 85 6c ee ff
	ff		 add	 eax, DWORD PTR tv824[ebp]
  002a8	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]

; 1244 : 
; 1245 :                 //get process handle count
; 1246 :                 GetProcessHandleCount(hProcInfo, &dwHandleCount);

  002ab	8d 85 80 ee ff
	ff		 lea	 eax, DWORD PTR _dwHandleCount$[ebp]
  002b1	50		 push	 eax
  002b2	ff b5 7c ee ff
	ff		 push	 DWORD PTR _hProcInfo$1$[ebp]
  002b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHandleCount@8

; 1247 : 
; 1248 :                 Log(LOG_MESSAGE, __LINE__, "> %.3d, %05u, %s, %u, %02d:%02d:%02d, %u, %u, %u, %u, %u, %u, %u, %u, %u", i + 1,

  002be	ff b5 c8 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+28]
  002c4	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  002c9	ff b5 c4 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+24]
  002cf	f7 e7		 mul	 edi
  002d1	ff b5 c0 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+20]
  002d7	8b f2		 mov	 esi, edx
  002d9	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  002de	ff b5 bc ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+16]
  002e4	f7 e7		 mul	 edi
  002e6	ff b5 b8 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+12]
  002ec	c1 ea 05	 shr	 edx, 5
  002ef	8b c7		 mov	 eax, edi
  002f1	ff b5 b4 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+8]
  002f7	8b ca		 mov	 ecx, edx
  002f9	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  002fc	ff b5 b0 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+4]
  00302	c1 e1 04	 shl	 ecx, 4
  00305	ff b5 d0 ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+36]
  0030b	2b ca		 sub	 ecx, edx
  0030d	ff b5 cc ee ff
	ff		 push	 DWORD PTR _pmc$[ebp+32]
  00313	c1 e1 02	 shl	 ecx, 2
  00316	2b c1		 sub	 eax, ecx
  00318	50		 push	 eax
  00319	69 c6 10 0e 00
	00		 imul	 eax, esi, 3600
  0031f	2b f8		 sub	 edi, eax
  00321	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00326	f7 e7		 mul	 edi
  00328	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _szProcessName$5[ebp]
  0032e	c1 ea 05	 shr	 edx, 5
  00331	52		 push	 edx
  00332	56		 push	 esi
  00333	ff b5 80 ee ff
	ff		 push	 DWORD PTR _dwHandleCount$[ebp]
  00339	8b b5 78 ee ff
	ff		 mov	 esi, DWORD PTR _dwProcessID$1$[ebp]
  0033f	50		 push	 eax
  00340	8b bd 70 ee ff
	ff		 mov	 edi, DWORD PTR tv820[ebp]
  00346	56		 push	 esi
  00347	57		 push	 edi
  00348	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NBLNGMHL@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$CFs?0?5?$CFu?0?5?$CF02d?3?$CF02d@
  0034d	68 e0 04 00 00	 push	 1248			; 000004e0H
  00352	6a 01		 push	 1
  00354	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00359	83 c4 4c	 add	 esp, 76			; 0000004cH

; 1249 :                     dwProcessID, szProcessName, dwHandleCount, seconds / 3600, (seconds % 3600) / 60, seconds % 60,
; 1250 :                     pmc.PagefileUsage, pmc.PeakPagefileUsage, pmc.PageFaultCount, pmc.PeakWorkingSetSize, pmc.WorkingSetSize,
; 1251 :                     pmc.QuotaPeakPagedPoolUsage, pmc.QuotaPagedPoolUsage, pmc.QuotaPeakNonPagedPoolUsage, pmc.QuotaNonPagedPoolUsage);
; 1252 : 
; 1253 :                 //close the process handle
; 1254 :                 CloseHandle(hProcInfo);

  0035c	ff b5 7c ee ff
	ff		 push	 DWORD PTR _hProcInfo$1$[ebp]
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1255 :                 hProcInfo = NULL;
; 1256 :             }
; 1257 :             else

  00368	e9 b0 00 00 00	 jmp	 $LN2@ProcessInf
$LN8@ProcessInf:

; 1259 :                 Log(LOG_DEBUG, __LINE__, "ProcessInfo, OpenProcess(PID %lu) %s", dwProcessID, GetLastErrorMessage(GetLastError()).c_str());

  0036d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00373	8b d0		 mov	 edx, eax
  00375	8d 8d d4 ee ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0037b	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00380	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00387	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0038b	72 02		 jb	 SHORT $LN21@ProcessInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0038d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN21@ProcessInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1259 :                 Log(LOG_DEBUG, __LINE__, "ProcessInfo, OpenProcess(PID %lu) %s", dwProcessID, GetLastErrorMessage(GetLastError()).c_str());

  0038f	8b b5 78 ee ff
	ff		 mov	 esi, DWORD PTR _dwProcessID$1$[ebp]
  00395	50		 push	 eax
  00396	56		 push	 esi
  00397	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@LGHCMJEF@ProcessInfo?0?5OpenProcess?$CIPID?5?$CFl@
  0039c	68 eb 04 00 00	 push	 1259			; 000004ebH
  003a1	6a 10		 push	 16			; 00000010H
  003a3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003a8	83 c4 14	 add	 esp, 20			; 00000014H
  003ab	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003b2	8b 95 e8 ee ff
	ff		 mov	 edx, DWORD PTR $T4[ebp+20]
  003b8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  003bb	72 2f		 jb	 SHORT $LN69@ProcessInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003bd	8b 85 d4 ee ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  003c3	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003c4	8b c8		 mov	 ecx, eax

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  003c6	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003cc	72 14		 jb	 SHORT $LN68@ProcessInf

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  003ce	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  003d1	83 c2 23	 add	 edx, 35			; 00000023H
  003d4	2b c8		 sub	 ecx, eax

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003d6	83 c1 fc	 add	 ecx, -4			; fffffffcH
  003d9	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  003dc	0f 87 46 01 00
	00		 ja	 $LN65@ProcessInf
$LN68@ProcessInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  003e2	52		 push	 edx
  003e3	50		 push	 eax
  003e4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003e9	83 c4 08	 add	 esp, 8
$LN69@ProcessInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1260 :                 Log(LOG_MESSAGE, __LINE__, "> %.3d, %05u, <unknown>, ?, ??:??:??, ?, ?, ?, ?, ?, ?, ?, ?, ?", i + 1, dwProcessID);

  003ec	56		 push	 esi
  003ed	57		 push	 edi
  003ee	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@JFLIEPEA@?$DO?5?$CF?43d?0?5?$CF05u?0?5?$DMunknown?$DO?0?5?$DP?0?5?$DP?$DP?3@
  003f3	68 ec 04 00 00	 push	 1260			; 000004ecH
  003f8	6a 01		 push	 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  003fa	c7 85 e4 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00404	c7 85 e8 ee ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0040e	c6 85 d4 ee ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1260 :                 Log(LOG_MESSAGE, __LINE__, "> %.3d, %05u, <unknown>, ?, ??:??:??, ?, ?, ?, ?, ?, ?, ?, ?, ?", i + 1, dwProcessID);

  00415	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0041a	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@ProcessInf:

; 1216 : 
; 1217 :         for (DWORD i = 0; i < cProcesses; i++)

  0041d	8b 8d 74 ee ff
	ff		 mov	 ecx, DWORD PTR tv819[ebp]
  00423	47		 inc	 edi
  00424	83 c1 04	 add	 ecx, 4
  00427	89 bd 70 ee ff
	ff		 mov	 DWORD PTR tv820[ebp], edi
  0042d	89 8d 74 ee ff
	ff		 mov	 DWORD PTR tv819[ebp], ecx
  00433	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00436	3b 85 68 ee ff
	ff		 cmp	 eax, DWORD PTR _cProcesses$1$[ebp]
  0043c	0f 82 1e fd ff
	ff		 jb	 $LL4@ProcessInf
  00442	e9 8f 00 00 00	 jmp	 $LN141@ProcessInf
$LN5@ProcessInf:

; 1266 :         Log(LOG_HEADER, __LINE__, "ProcessInfo, EnumProcesses %s", GetLastErrorMessage(GetLastError()).c_str());

  00447	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0044d	8b d0		 mov	 edx, eax
  0044f	8d 8d d4 ee ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00455	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  0045a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00461	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00465	72 02		 jb	 SHORT $LN91@ProcessInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00467	8b 00		 mov	 eax, DWORD PTR [eax]
$LN91@ProcessInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1266 :         Log(LOG_HEADER, __LINE__, "ProcessInfo, EnumProcesses %s", GetLastErrorMessage(GetLastError()).c_str());

  00469	50		 push	 eax
  0046a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@MOIJAHHG@ProcessInfo?0?5EnumProcesses?5?$CFs@
  0046f	68 f2 04 00 00	 push	 1266			; 000004f2H
  00474	6a 02		 push	 2
  00476	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0047b	83 c4 10	 add	 esp, 16			; 00000010H
  0047e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00485	8b 95 e8 ee ff
	ff		 mov	 edx, DWORD PTR $T3[ebp+20]
  0048b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0048e	72 2b		 jb	 SHORT $LN139@ProcessInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00490	8b 8d d4 ee ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00496	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00497	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00499	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0049f	72 10		 jb	 SHORT $LN138@ProcessInf

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  004a1	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004a4	83 c2 23	 add	 edx, 35			; 00000023H
  004a7	2b c1		 sub	 eax, ecx

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004a9	83 c0 fc	 add	 eax, -4			; fffffffcH
  004ac	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004af	77 77		 ja	 SHORT $LN65@ProcessInf
$LN138@ProcessInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  004b1	52		 push	 edx
  004b2	51		 push	 ecx
  004b3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004b8	83 c4 08	 add	 esp, 8
$LN139@ProcessInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  004bb	c7 85 e4 ee ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  004c5	c7 85 e8 ee ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  004cf	c6 85 d4 ee ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN141@ProcessInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1269 :     LogElapsedTime(__LINE__, tickStart);

  004d6	ff b5 64 ee ff
	ff		 push	 DWORD PTR _tickStart$1$[ebp]
  004dc	33 d2		 xor	 edx, edx
  004de	b9 f5 04 00 00	 mov	 ecx, 1269		; 000004f5H
  004e3	ff b5 60 ee ff
	ff		 push	 DWORD PTR _tickStart$2$[ebp]
  004e9	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1270 : 
; 1271 :     Log(LOG_DEBUG, __LINE__, "<< ProcInfo");

  004ee	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LHLIHEIP@?$DM?$DM?5ProcInfo@
  004f3	68 f7 04 00 00	 push	 1271			; 000004f7H
  004f8	6a 10		 push	 16			; 00000010H
  004fa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1272 :     _endthreadex(0);

  004ff	6a 00		 push	 0
  00501	e8 00 00 00 00	 call	 __endthreadex
  00506	83 c4 18	 add	 esp, 24			; 00000018H

; 1273 :     return 0;

  00509	33 c0		 xor	 eax, eax

; 1274 : }

  0050b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0050e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00515	59		 pop	 ecx
  00516	5f		 pop	 edi
  00517	5e		 pop	 esi
  00518	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0051b	33 cd		 xor	 ecx, ebp
  0051d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00522	8b e5		 mov	 esp, ebp
  00524	5d		 pop	 ebp
  00525	c2 04 00	 ret	 4
$LN65@ProcessInf:
  00528	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN177@ProcessInf:
  0052d	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProcessInfo@@YGIPAX@Z$0:
  00000	8d 8d d4 ee ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ProcessInfo@@YGIPAX@Z$1:
  0000b	8d 8d d4 ee ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ProcessInfo@@YGIPAX@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 40 ee ff
	ff		 mov	 ecx, DWORD PTR [edx-4544]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessInfo@@YGIPAX@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessInfo@@YGIPAX@Z ENDP				; ProcessInfo
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_HwProfileInfo$ = -164					; size = 124
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?HwProfile@@YGIPAX@Z PROC				; HwProfile

; 1280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?HwProfile@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1281 :     Log(LOG_DEBUG, __LINE__, ">> HwProfile (%p)", lpData);

  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BGHHFGNO@?$DO?$DO?5HwProfile?5?$CI?$CFp?$CJ@
  00036	68 01 05 00 00	 push	 1281			; 00000501H
  0003b	6a 10		 push	 16			; 00000010H
  0003d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1282 : 
; 1283 :     uint64_t tickStart = SysTick();

  00042	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1284 : 
; 1285 :     //get hardware profile
; 1286 :     HW_PROFILE_INFO HwProfileInfo = { 0 };

  00047	6a 7c		 push	 124			; 0000007cH
  00049	8b f0		 mov	 esi, eax
  0004b	8b fa		 mov	 edi, edx
  0004d	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _HwProfileInfo$[ebp]
  00053	6a 00		 push	 0
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _memset
  0005b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1287 :     if (GetCurrentHwProfile(&HwProfileInfo))

  0005e	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _HwProfileInfo$[ebp]
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentHwProfileA@4
  0006b	85 c0		 test	 eax, eax
  0006d	74 27		 je	 SHORT $LN2@HwProfile

; 1288 :     {
; 1289 :         Log(LOG_HEADER, __LINE__, "Hardware Profile, DockInfo %p, GUID %s, Name %s",

  0006f	8d 45 87	 lea	 eax, DWORD PTR _HwProfileInfo$[ebp+43]
  00072	50		 push	 eax
  00073	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _HwProfileInfo$[ebp+4]
  00079	50		 push	 eax
  0007a	ff b5 5c ff ff
	ff		 push	 DWORD PTR _HwProfileInfo$[ebp]
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@OIKPBLGF@Hardware?5Profile?0?5DockInfo?5?$CFp?0?5@
  00085	68 09 05 00 00	 push	 1289			; 00000509H
  0008a	6a 02		 push	 2
  0008c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00091	83 c4 18	 add	 esp, 24			; 00000018H

; 1290 :             HwProfileInfo.dwDockInfo, HwProfileInfo.szHwProfileGuid, HwProfileInfo.szHwProfileName);
; 1291 :     }
; 1292 :     else

  00094	eb 7d		 jmp	 SHORT $LN63@HwProfile
$LN2@HwProfile:

; 1294 :         Log(LOG_HEADER, __LINE__, "HwProfile, GetCurrentHwProfile %s", GetLastErrorMessage(GetLastError()).c_str());

  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0009c	8b d0		 mov	 edx, eax
  0009e	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  000a1	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  000a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000ad	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  000b1	72 02		 jb	 SHORT $LN13@HwProfile
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000b3	8b 00		 mov	 eax, DWORD PTR [eax]
$LN13@HwProfile:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1294 :         Log(LOG_HEADER, __LINE__, "HwProfile, GetCurrentHwProfile %s", GetLastErrorMessage(GetLastError()).c_str());

  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@OJDBEDNI@HwProfile?0?5GetCurrentHwProfile?5@
  000bb	68 0e 05 00 00	 push	 1294			; 0000050eH
  000c0	6a 02		 push	 2
  000c2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
  000ca	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000d1	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  000d4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000d7	72 28		 jb	 SHORT $LN61@HwProfile
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000dc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000dd	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000df	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000e5	72 10		 jb	 SHORT $LN60@HwProfile

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000e7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000ea	83 c2 23	 add	 edx, 35			; 00000023H
  000ed	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ef	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f5	77 64		 ja	 SHORT $LN79@HwProfile
$LN60@HwProfile:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000f7	52		 push	 edx
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fe	83 c4 08	 add	 esp, 8
$LN61@HwProfile:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00101	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00108	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0010f	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
$LN63@HwProfile:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1297 :     LogElapsedTime(__LINE__, tickStart);

  00113	57		 push	 edi
  00114	56		 push	 esi
  00115	33 d2		 xor	 edx, edx
  00117	b9 11 05 00 00	 mov	 ecx, 1297		; 00000511H
  0011c	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1298 : 
; 1299 :     Log(LOG_DEBUG, __LINE__, "<< HwProfile");

  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DNDAOIDK@?$DM?$DM?5HwProfile@
  00126	68 13 05 00 00	 push	 1299			; 00000513H
  0012b	6a 10		 push	 16			; 00000010H
  0012d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1300 :     _endthreadex(0);

  00132	6a 00		 push	 0
  00134	e8 00 00 00 00	 call	 __endthreadex
  00139	83 c4 18	 add	 esp, 24			; 00000018H

; 1301 :     return 0;

  0013c	33 c0		 xor	 eax, eax

; 1302 : }

  0013e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00141	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00148	59		 pop	 ecx
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	33 cd		 xor	 ecx, ebp
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 04 00	 ret	 4
$LN79@HwProfile:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0015b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@HwProfile:
  00160	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?HwProfile@@YGIPAX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?HwProfile@@YGIPAX@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 5c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-164]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?HwProfile@@YGIPAX@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?HwProfile@@YGIPAX@Z ENDP				; HwProfile
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_nCtr$ = -40						; size = 8
_nFreq$ = -32						; size = 8
_cyclesStart$ = -24					; size = 8
_cyclesStop$ = -16					; size = 8
_nCtrStop$ = -8						; size = 8
tv90 = -4						; size = 4
?ProcessorSpeedCalc@@YAMXZ PROC				; ProcessorSpeedCalc

; 1308 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	0f 57 c0	 xorps	 xmm0, xmm0

; 1309 :     /*
; 1310 :     RdTSC: It's the Pentium instruction "ReaD Time Stamp Counter". It measures the
; 1311 :     number of clock cycles that have passed since the processor was reset, as a
; 1312 :     64-bit number. That's what the _emit lines do.*/
; 1313 : #define RdTSC __asm _emit 0x0f __asm _emit 0x31
; 1314 : 
; 1315 :     //variables for the clock-cycles
; 1316 :     __int64 cyclesStart = 0, cyclesStop = 0;
; 1317 : 
; 1318 :     //variables for the High-Res Performance Counter
; 1319 :     uint64_t nCtr = 0, nFreq = 0, nCtrStop = 0;
; 1320 : 
; 1321 :     //retrieve performance-counter frequency per second
; 1322 :     if (!QueryPerformanceFrequency((LARGE_INTEGER *)&nFreq))

  0000b	8d 45 e0	 lea	 eax, DWORD PTR _nFreq$[ebp]
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	66 0f 13 45 e8	 movlpd	 QWORD PTR _cyclesStart$[ebp], xmm0
  00015	66 0f 13 45 f0	 movlpd	 QWORD PTR _cyclesStop$[ebp], xmm0
  0001a	66 0f 13 45 d8	 movlpd	 QWORD PTR _nCtr$[ebp], xmm0
  0001f	66 0f 13 45 e0	 movlpd	 QWORD PTR _nFreq$[ebp], xmm0
  00024	66 0f 13 45 f8	 movlpd	 QWORD PTR _nCtrStop$[ebp], xmm0
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  0002f	85 c0		 test	 eax, eax
  00031	75 0a		 jne	 SHORT $LN5@ProcessorS
  00033	0f 57 c0	 xorps	 xmm0, xmm0

; 1354 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN5@ProcessorS:

; 1323 :         return 0;
; 1324 : 
; 1325 :     //retrieve the current value of the performance counter
; 1326 :     QueryPerformanceCounter((LARGE_INTEGER *)&nCtrStop);

  0003d	8d 45 f8	 lea	 eax, DWORD PTR _nCtrStop$[ebp]
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 1327 : 
; 1328 :     //add the frequency to the counter-value
; 1329 :     nCtrStop += nFreq;

  00047	8b 45 e0	 mov	 eax, DWORD PTR _nFreq$[ebp]
  0004a	01 45 f8	 add	 DWORD PTR _nCtrStop$[ebp], eax
  0004d	8b 45 e4	 mov	 eax, DWORD PTR _nFreq$[ebp+4]
  00050	11 45 fc	 adc	 DWORD PTR _nCtrStop$[ebp+4], eax

; 1332 :     {
; 1333 :         //retrieve the clock-cycles for the start value
; 1334 :         RdTSC

  00053	0f		 DB	 15			; 0000000fH
  00054	31		 DB	 49			; 00000031H

; 1335 :         mov DWORD PTR cyclesStart, eax

  00055	89 45 e8	 mov	 DWORD PTR _cyclesStart$[ebp], eax

; 1336 :         mov DWORD PTR[cyclesStart + 4], edx

  00058	89 55 ec	 mov	 DWORD PTR _cyclesStart$[ebp+4], edx

; 1330 : 
; 1331 :     _asm

  0005b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__QueryPerformanceCounter@4
$LL4@ProcessorS:

; 1337 :     }
; 1338 : 
; 1339 :     do {
; 1340 :         //retrieve the value of the performance counter until 1 sec has gone by
; 1341 :         QueryPerformanceCounter((LARGE_INTEGER *)&nCtr);

  00061	8d 45 d8	 lea	 eax, DWORD PTR _nCtr$[ebp]
  00064	50		 push	 eax
  00065	ff d6		 call	 esi

; 1342 :     } while (nCtr < nCtrStop);

  00067	8b 45 dc	 mov	 eax, DWORD PTR _nCtr$[ebp+4]
  0006a	3b 45 fc	 cmp	 eax, DWORD PTR _nCtrStop$[ebp+4]
  0006d	72 f2		 jb	 SHORT $LL4@ProcessorS
  0006f	77 08		 ja	 SHORT $LN10@ProcessorS
  00071	8b 45 d8	 mov	 eax, DWORD PTR _nCtr$[ebp]
  00074	3b 45 f8	 cmp	 eax, DWORD PTR _nCtrStop$[ebp]
  00077	72 e8		 jb	 SHORT $LL4@ProcessorS
$LN10@ProcessorS:

; 1343 : 
; 1344 :     _asm
; 1345 :     {
; 1346 :         //retrieve again the clock-cycles after 1 sec has gone by
; 1347 :         RdTSC

  00079	0f		 DB	 15			; 0000000fH
  0007a	31		 DB	 49			; 00000031H

; 1348 :         mov DWORD PTR cyclesStop, eax

  0007b	89 45 f0	 mov	 DWORD PTR _cyclesStop$[ebp], eax

; 1349 :         mov DWORD PTR[cyclesStop + 4], edx

  0007e	89 55 f4	 mov	 DWORD PTR _cyclesStop$[ebp+4], edx

; 1350 :     }
; 1351 : 
; 1352 :     //stop-start is speed in Hz divided by 1,000,000 is speed in MHz
; 1353 :     return	((float)cyclesStop - (float)cyclesStart) / MHz;

  00081	8b 55 f4	 mov	 edx, DWORD PTR _cyclesStop$[ebp+4]
  00084	8b 4d f0	 mov	 ecx, DWORD PTR _cyclesStop$[ebp]
  00087	e8 00 00 00 00	 call	 __ltod3
  0008c	8b 55 ec	 mov	 edx, DWORD PTR _cyclesStart$[ebp+4]
  0008f	8b 4d e8	 mov	 ecx, DWORD PTR _cyclesStart$[ebp]
  00092	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00096	f3 0f 11 45 fc	 movss	 DWORD PTR tv90[ebp], xmm0
  0009b	e8 00 00 00 00	 call	 __ltod3
  000a0	0f 57 c9	 xorps	 xmm1, xmm1
  000a3	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0

; 1354 : }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv90[ebp]
  000af	f3 0f 5c c1	 subss	 xmm0, xmm1
  000b3	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@49742400
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
?ProcessorSpeedCalc@@YAMXZ ENDP				; ProcessorSpeedCalc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
?CurrentProcessorNumber@@YAKXZ PROC			; CurrentProcessorNumber

; 1358 :     DWORD processor = 1;
; 1359 :     LPFN_GCPN gcpn = (LPFN_GCPN)GetProcAddress(GetModuleHandle("kernel32"), "GetCurrentProcessorNumber");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DFNBACLA@GetCurrentProcessorNumber@
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_08PNLNEKOB@kernel32@
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 1360 :     if (nullptr == gcpn)

  00017	85 c0		 test	 eax, eax
  00019	75 1a		 jne	 SHORT $LN2@CurrentPro

; 1361 :     {
; 1362 :         Log(LOG_DEBUG, __LINE__, "-- CurrentProcessorNumber, GetCurrentProcessorNumber is not supported.");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@HJFNKFOJ@?9?9?5CurrentProcessorNumber?0?5GetC@
  00020	68 52 05 00 00	 push	 1362			; 00000552H
  00025	6a 10		 push	 16			; 00000010H
  00027	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1367 :     }
; 1368 :     return processor;

  0002f	b8 01 00 00 00	 mov	 eax, 1

; 1369 : }

  00034	c3		 ret	 0
$LN2@CurrentPro:

; 1363 :     }
; 1364 :     else
; 1365 :     {
; 1366 :         processor = gcpn();

  00035	ff e0		 jmp	 eax
?CurrentProcessorNumber@@YAKXZ ENDP			; CurrentProcessorNumber
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_SystemInfo$ = -160					; size = 36
_nCtr$1 = -104						; size = 8
_nFreq$2 = -96						; size = 8
_tickStart$2$ = -84					; size = 4
_tickStart$1$ = -80					; size = 4
tv91 = -76						; size = 4
tv90 = -72						; size = 4
_dwSize$ = -68						; size = 4
_cyclesStart$3 = -64					; size = 8
_cyclesStop$4 = -56					; size = 8
_processor$1$ = -48					; size = 4
tv128 = -44						; size = 4
_nCtrStop$5 = -40					; size = 8
$T6 = -36						; size = 4
_szComputeName$ = -32					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?SystemInfo@@YGIPAX@Z PROC				; SystemInfo

; 1372 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f0	 and	 esp, -16		; fffffff0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	8b 43 08	 mov	 eax, DWORD PTR _lpData$[ebx]
  00029	56		 push	 esi
  0002a	57		 push	 edi

; 1373 :     Log(LOG_DEBUG, __LINE__, ">> SysInfo (%p)", lpData);

  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KIDPDIJO@?$DO?$DO?5SysInfo?5?$CI?$CFp?$CJ@
  00031	68 5d 05 00 00	 push	 1373			; 0000055dH
  00036	6a 10		 push	 16			; 00000010H
  00038	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 1374 : 
; 1375 :     uint64_t tickStart = SysTick();

  00040	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  00045	89 45 ac	 mov	 DWORD PTR _tickStart$2$[ebp], eax
  00048	0f 57 c0	 xorps	 xmm0, xmm0

; 1376 : 
; 1377 :     SYSTEM_INFO SystemInfo = { 0 };
; 1378 :     char szComputeName[MAX_COMPUTERNAME_LENGTH + 1] = { 0 };
; 1379 :     DWORD dwSize = MAX_COMPUTERNAME_LENGTH;
; 1380 : 
; 1381 :     //get process handle
; 1382 :     GetSystemInfo(&SystemInfo);

  0004b	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _SystemInfo$[ebp]
  00051	89 55 b0	 mov	 DWORD PTR _tickStart$1$[ebp], edx
  00054	50		 push	 eax
  00055	0f 29 85 60 ff
	ff ff		 movaps	 XMMWORD PTR _SystemInfo$[ebp], xmm0
  0005c	0f 29 85 70 ff
	ff ff		 movaps	 XMMWORD PTR _SystemInfo$[ebp+16], xmm0
  00063	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _SystemInfo$[ebp+32], 0
  0006a	0f 29 45 e0	 movaps	 XMMWORD PTR _szComputeName$[ebp], xmm0
  0006e	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _dwSize$[ebp], 15 ; 0000000fH
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 1383 : 
; 1384 :     //get computer information
; 1385 :     GetComputerName(szComputeName, &dwSize);

  0007b	8d 45 bc	 lea	 eax, DWORD PTR _dwSize$[ebp]
  0007e	50		 push	 eax
  0007f	8d 45 e0	 lea	 eax, DWORD PTR _szComputeName$[ebp]
  00082	50		 push	 eax
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetComputerNameA@8

; 1386 : 
; 1387 :     Log(LOG_HEADER, __LINE__, "Computer: %s, Processor(s) %u %f Mhz Current %u, %s, Level %u, Rev %u, Type %u; Page Size %u",

  00089	0f b7 45 82	 movzx	 eax, WORD PTR _SystemInfo$[ebp+34]
  0008d	89 45 b8	 mov	 DWORD PTR tv90[ebp], eax
  00090	0f b7 45 80	 movzx	 eax, WORD PTR _SystemInfo$[ebp+32]
  00094	89 45 b4	 mov	 DWORD PTR tv91[ebp], eax
  00097	66 8b 85 60 ff
	ff ff		 mov	 ax, WORD PTR _SystemInfo$[ebp]
  0009e	66 83 f8 09	 cmp	 ax, 9
  000a2	75 09		 jne	 SHORT $LN5@SystemInfo
  000a4	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], OFFSET ??_C@_0BD@EBOFFHEB@x64?5?$CIAMD?5or?5Intel?$CJ@
  000ab	eb 22		 jmp	 SHORT $LN4@SystemInfo
$LN5@SystemInfo:
  000ad	66 83 f8 06	 cmp	 ax, 6
  000b1	75 09		 jne	 SHORT $LN3@SystemInfo
  000b3	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], OFFSET ??_C@_0BE@BAGOKCHN@Intel?5Itanium?9based@
  000ba	eb 13		 jmp	 SHORT $LN4@SystemInfo
$LN3@SystemInfo:
  000bc	66 85 c0	 test	 ax, ax
  000bf	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_03NDFEINMN@x86@
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07NBCGADJA@Unknown@
  000c9	0f 45 f1	 cmovne	 esi, ecx
  000cc	89 75 d4	 mov	 DWORD PTR tv128[ebp], esi
$LN4@SystemInfo:

; 1359 :     LPFN_GCPN gcpn = (LPFN_GCPN)GetProcAddress(GetModuleHandle("kernel32"), "GetCurrentProcessorNumber");

  000cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@DFNBACLA@GetCurrentProcessorNumber@
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_08PNLNEKOB@kernel32@
  000d9	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _processor$1$[ebp], 1
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 1360 :     if (nullptr == gcpn)

  000ed	85 c0		 test	 eax, eax
  000ef	75 16		 jne	 SHORT $LN8@SystemInfo

; 1361 :     {
; 1362 :         Log(LOG_DEBUG, __LINE__, "-- CurrentProcessorNumber, GetCurrentProcessorNumber is not supported.");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@HJFNKFOJ@?9?9?5CurrentProcessorNumber?0?5GetC@
  000f6	68 52 05 00 00	 push	 1362			; 00000552H
  000fb	6a 10		 push	 16			; 00000010H
  000fd	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1363 :     }
; 1364 :     else

  00105	eb 05		 jmp	 SHORT $LN9@SystemInfo
$LN8@SystemInfo:

; 1365 :     {
; 1366 :         processor = gcpn();

  00107	ff d0		 call	 eax
  00109	89 45 d0	 mov	 DWORD PTR _processor$1$[ebp], eax
$LN9@SystemInfo:
  0010c	0f 57 c0	 xorps	 xmm0, xmm0

; 1322 :     if (!QueryPerformanceFrequency((LARGE_INTEGER *)&nFreq))

  0010f	8d 45 a0	 lea	 eax, DWORD PTR _nFreq$2[ebp]
  00112	50		 push	 eax
  00113	66 0f 13 45 c0	 movlpd	 QWORD PTR _cyclesStart$3[ebp], xmm0
  00118	66 0f 13 45 c8	 movlpd	 QWORD PTR _cyclesStop$4[ebp], xmm0
  0011d	66 0f 13 45 98	 movlpd	 QWORD PTR _nCtr$1[ebp], xmm0
  00122	66 0f 13 45 a0	 movlpd	 QWORD PTR _nFreq$2[ebp], xmm0
  00127	66 0f 13 45 d8	 movlpd	 QWORD PTR _nCtrStop$5[ebp], xmm0
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  00132	85 c0		 test	 eax, eax
  00134	75 05		 jne	 SHORT $LN15@SystemInfo
  00136	0f 57 c9	 xorps	 xmm1, xmm1

; 1323 :         return 0;

  00139	eb 79		 jmp	 SHORT $LN11@SystemInfo
$LN15@SystemInfo:

; 1324 : 
; 1325 :     //retrieve the current value of the performance counter
; 1326 :     QueryPerformanceCounter((LARGE_INTEGER *)&nCtrStop);

  0013b	8d 45 d8	 lea	 eax, DWORD PTR _nCtrStop$5[ebp]
  0013e	50		 push	 eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 1327 : 
; 1328 :     //add the frequency to the counter-value
; 1329 :     nCtrStop += nFreq;

  00145	8b 45 a0	 mov	 eax, DWORD PTR _nFreq$2[ebp]
  00148	01 45 d8	 add	 DWORD PTR _nCtrStop$5[ebp], eax
  0014b	8b 45 a4	 mov	 eax, DWORD PTR _nFreq$2[ebp+4]
  0014e	11 45 dc	 adc	 DWORD PTR _nCtrStop$5[ebp+4], eax

; 1386 : 
; 1387 :     Log(LOG_HEADER, __LINE__, "Computer: %s, Processor(s) %u %f Mhz Current %u, %s, Level %u, Rev %u, Type %u; Page Size %u",

  00151	0f		 DB	 15			; 0000000fH
  00152	31		 DB	 49			; 00000031H
  00153	89 45 c0	 mov	 DWORD PTR _cyclesStart$3[ebp], eax
  00156	89 55 c4	 mov	 DWORD PTR _cyclesStart$3[ebp+4], edx

; 1331 :     _asm

  00159	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__QueryPerformanceCounter@4
  0015f	90		 npad	 1
$LL14@SystemInfo:

; 1332 :     {
; 1333 :         //retrieve the clock-cycles for the start value
; 1334 :         RdTSC
; 1335 :         mov DWORD PTR cyclesStart, eax
; 1336 :         mov DWORD PTR[cyclesStart + 4], edx
; 1337 :     }
; 1338 : 
; 1339 :     do {
; 1340 :         //retrieve the value of the performance counter until 1 sec has gone by
; 1341 :         QueryPerformanceCounter((LARGE_INTEGER *)&nCtr);

  00160	8d 45 98	 lea	 eax, DWORD PTR _nCtr$1[ebp]
  00163	50		 push	 eax
  00164	ff d6		 call	 esi

; 1342 :     } while (nCtr < nCtrStop);

  00166	8b 45 9c	 mov	 eax, DWORD PTR _nCtr$1[ebp+4]
  00169	3b 45 dc	 cmp	 eax, DWORD PTR _nCtrStop$5[ebp+4]
  0016c	72 f2		 jb	 SHORT $LL14@SystemInfo
  0016e	77 08		 ja	 SHORT $LN20@SystemInfo
  00170	8b 45 98	 mov	 eax, DWORD PTR _nCtr$1[ebp]
  00173	3b 45 d8	 cmp	 eax, DWORD PTR _nCtrStop$5[ebp]
  00176	72 e8		 jb	 SHORT $LL14@SystemInfo
$LN20@SystemInfo:

; 1386 : 
; 1387 :     Log(LOG_HEADER, __LINE__, "Computer: %s, Processor(s) %u %f Mhz Current %u, %s, Level %u, Rev %u, Type %u; Page Size %u",

  00178	0f		 DB	 15			; 0000000fH
  00179	31		 DB	 49			; 00000031H
  0017a	89 45 c8	 mov	 DWORD PTR _cyclesStop$4[ebp], eax
  0017d	89 55 cc	 mov	 DWORD PTR _cyclesStop$4[ebp+4], edx

; 1353 :     return	((float)cyclesStop - (float)cyclesStart) / MHz;

  00180	8b 55 cc	 mov	 edx, DWORD PTR _cyclesStop$4[ebp+4]
  00183	8b 4d c8	 mov	 ecx, DWORD PTR _cyclesStop$4[ebp]
  00186	e8 00 00 00 00	 call	 __ltod3
  0018b	8b 55 c4	 mov	 edx, DWORD PTR _cyclesStart$3[ebp+4]
  0018e	8b 4d c0	 mov	 ecx, DWORD PTR _cyclesStart$3[ebp]
  00191	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00195	f3 0f 11 45 dc	 movss	 DWORD PTR $T6[ebp], xmm0
  0019a	e8 00 00 00 00	 call	 __ltod3
  0019f	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR $T6[ebp]
  001a4	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  001a8	f3 0f 5c c8	 subss	 xmm1, xmm0
  001ac	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@49742400
$LN11@SystemInfo:

; 1386 : 
; 1387 :     Log(LOG_HEADER, __LINE__, "Computer: %s, Processor(s) %u %f Mhz Current %u, %s, Level %u, Rev %u, Type %u; Page Size %u",

  001b4	ff b5 64 ff ff
	ff		 push	 DWORD PTR _SystemInfo$[ebp+4]
  001ba	0f 5a c1	 cvtps2pd xmm0, xmm1
  001bd	8d 45 e0	 lea	 eax, DWORD PTR _szComputeName$[ebp]
  001c0	ff b5 78 ff ff
	ff		 push	 DWORD PTR _SystemInfo$[ebp+24]
  001c6	ff 75 b8	 push	 DWORD PTR tv90[ebp]
  001c9	ff 75 b4	 push	 DWORD PTR tv91[ebp]
  001cc	ff 75 d4	 push	 DWORD PTR tv128[ebp]
  001cf	ff 75 d0	 push	 DWORD PTR _processor$1$[ebp]
  001d2	83 ec 08	 sub	 esp, 8
  001d5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001da	ff b5 74 ff ff
	ff		 push	 DWORD PTR _SystemInfo$[ebp+20]
  001e0	50		 push	 eax
  001e1	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@KGKHOIOF@Computer?3?5?$CFs?0?5Processor?$CIs?$CJ?5?$CFu?5?$CF@
  001e6	68 6b 05 00 00	 push	 1387			; 0000056bH
  001eb	6a 02		 push	 2
  001ed	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001f2	83 c4 34	 add	 esp, 52			; 00000034H

; 1388 :         szComputeName, SystemInfo.dwNumberOfProcessors, ProcessorSpeedCalc(), CurrentProcessorNumber(),
; 1389 :         (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ? "x64 (AMD or Intel)" :
; 1390 :         (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 ? "Intel Itanium-based" :
; 1391 :             (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ? "x86" : "Unknown"))),
; 1392 :         SystemInfo.wProcessorLevel, SystemInfo.wProcessorRevision, SystemInfo.dwProcessorType,
; 1393 :         SystemInfo.dwPageSize);
; 1394 : 
; 1395 :     LogElapsedTime(__LINE__, tickStart);

  001f5	33 d2		 xor	 edx, edx
  001f7	b9 73 05 00 00	 mov	 ecx, 1395		; 00000573H
  001fc	ff 75 b0	 push	 DWORD PTR _tickStart$1$[ebp]
  001ff	ff 75 ac	 push	 DWORD PTR _tickStart$2$[ebp]
  00202	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1396 : 
; 1397 :     Log(LOG_DEBUG, __LINE__, "<< SysInfo");

  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0L@EJPMBDJN@?$DM?$DM?5SysInfo@
  0020c	68 75 05 00 00	 push	 1397			; 00000575H
  00211	6a 10		 push	 16			; 00000010H
  00213	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00218	83 c4 14	 add	 esp, 20			; 00000014H

; 1398 :     _endthreadex(0);

  0021b	6a 00		 push	 0
  0021d	e8 00 00 00 00	 call	 __endthreadex

; 1399 :     return 0;
; 1400 : }

  00222	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00225	83 c4 04	 add	 esp, 4
  00228	33 cd		 xor	 ecx, ebp
  0022a	33 c0		 xor	 eax, eax
  0022c	5f		 pop	 edi
  0022d	5e		 pop	 esi
  0022e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00233	8b e5		 mov	 esp, ebp
  00235	5d		 pop	 ebp
  00236	8b e3		 mov	 esp, ebx
  00238	5b		 pop	 ebx
  00239	c2 04 00	 ret	 4
?SystemInfo@@YGIPAX@Z ENDP				; SystemInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_osverEx$ = -344					; size = 156
_osver$2 = -188						; size = 148
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?OSInfo@@YGIPAX@Z PROC					; OSInfo

; 1406 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OSInfo@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1407 :     Log(LOG_DEBUG, __LINE__, ">> OSInfo (%p)", lpData);

  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JFFCKGPB@?$DO?$DO?5OSInfo?5?$CI?$CFp?$CJ@
  00036	68 7f 05 00 00	 push	 1407			; 0000057fH
  0003b	6a 10		 push	 16			; 00000010H
  0003d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1408 : 
; 1409 :     uint64_t tickStart = SysTick();

  00042	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1410 : 
; 1411 :     //get OS version
; 1412 :     DWORD const flag = (VER_MINORVERSION | VER_MAJORVERSION | VER_BUILDNUMBER | VER_PLATFORMID |
; 1413 :                         VER_SERVICEPACKMINOR | VER_SERVICEPACKMAJOR | VER_SUITENAME | VER_PRODUCT_TYPE);
; 1414 :     OSVERSIONINFOEX osverEx = { 0 };

  00047	68 9c 00 00 00	 push	 156			; 0000009cH
  0004c	8b f0		 mov	 esi, eax
  0004e	8b fa		 mov	 edi, edx
  00050	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _osverEx$[ebp]
  00056	6a 00		 push	 0
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 _memset
  0005e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1415 :     osverEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  00061	c7 85 a8 fe ff
	ff 9c 00 00 00	 mov	 DWORD PTR _osverEx$[ebp], 156 ; 0000009cH

; 1416 :     if (VerifyVersionInfo(&osverEx, flag, 0))

  0006b	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _osverEx$[ebp]
  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	68 ff 00 00 00	 push	 255			; 000000ffH
  0007a	50		 push	 eax
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VerifyVersionInfoA@16
  00081	85 c0		 test	 eax, eax
  00083	74 73		 je	 SHORT $LN2@OSInfo

; 1417 :     {
; 1418 :         Log(LOG_HEADER, __LINE__, "OSInfo, Version %u.%u.%u, Platform %u, SP %s(%u.%u), Suite 0x%08X, %s",

  00085	8a 8d 42 ff ff
	ff		 mov	 cl, BYTE PTR _osverEx$[ebp+154]
  0008b	80 f9 02	 cmp	 cl, 2
  0008e	75 07		 jne	 SHORT $LN5@OSInfo
  00090	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@LGEIIGCP@Domain?5Controller@
  00095	eb 10		 jmp	 SHORT $LN6@OSInfo
$LN5@OSInfo:
  00097	80 f9 03	 cmp	 cl, 3
  0009a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06LGMEBDBC@Server@
  0009f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0M@CILGCIDH@Workstation@
  000a4	0f 45 c2	 cmovne	 eax, edx
$LN6@OSInfo:
  000a7	50		 push	 eax
  000a8	0f b7 85 40 ff
	ff ff		 movzx	 eax, WORD PTR _osverEx$[ebp+152]
  000af	50		 push	 eax
  000b0	0f b7 85 3e ff
	ff ff		 movzx	 eax, WORD PTR _osverEx$[ebp+150]
  000b7	50		 push	 eax
  000b8	0f b7 85 3c ff
	ff ff		 movzx	 eax, WORD PTR _osverEx$[ebp+148]
  000bf	50		 push	 eax
  000c0	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _osverEx$[ebp+20]
  000c6	50		 push	 eax
  000c7	ff b5 b8 fe ff
	ff		 push	 DWORD PTR _osverEx$[ebp+16]
  000cd	ff b5 b4 fe ff
	ff		 push	 DWORD PTR _osverEx$[ebp+12]
  000d3	ff b5 b0 fe ff
	ff		 push	 DWORD PTR _osverEx$[ebp+8]
  000d9	ff b5 ac fe ff
	ff		 push	 DWORD PTR _osverEx$[ebp+4]
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@OPOFGEHK@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@
  000e4	68 8a 05 00 00	 push	 1418			; 0000058aH
  000e9	6a 02		 push	 2
  000eb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000f0	83 c4 30	 add	 esp, 48			; 00000030H

; 1419 :             osverEx.dwMajorVersion, osverEx.dwMinorVersion, osverEx.dwBuildNumber, osverEx.dwPlatformId,
; 1420 :             osverEx.szCSDVersion, osverEx.wServicePackMajor, osverEx.wServicePackMinor, osverEx.wSuiteMask,
; 1421 :             (osverEx.wProductType == VER_NT_DOMAIN_CONTROLLER ? "Domain Controller" : (osverEx.wProductType == VER_NT_SERVER ? "Server" : "Workstation")));
; 1422 :     }
; 1423 :     else

  000f3	e9 e1 00 00 00	 jmp	 $LN3@OSInfo
$LN2@OSInfo:

; 1425 :         Log(LOG_DEBUG, __LINE__, "OSInfo, VerifyVersionInfo %s", GetLastErrorMessage(GetLastError()).c_str());

  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000fe	8b d0		 mov	 edx, eax
  00100	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00103	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00108	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0010f	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00113	72 02		 jb	 SHORT $LN15@OSInfo
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00115	8b 00		 mov	 eax, DWORD PTR [eax]
$LN15@OSInfo:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1425 :         Log(LOG_DEBUG, __LINE__, "OSInfo, VerifyVersionInfo %s", GetLastErrorMessage(GetLastError()).c_str());

  00117	50		 push	 eax
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NMBMIHHC@OSInfo?0?5VerifyVersionInfo?5?$CFs@
  0011d	68 91 05 00 00	 push	 1425			; 00000591H
  00122	6a 10		 push	 16			; 00000010H
  00124	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00129	83 c4 10	 add	 esp, 16			; 00000010H
  0012c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00133	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
  00136	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00139	72 2c		 jb	 SHORT $LN63@OSInfo
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0013b	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0013e	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0013f	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00141	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00147	72 14		 jb	 SHORT $LN62@OSInfo

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00149	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0014c	83 c2 23	 add	 edx, 35			; 00000023H
  0014f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00151	83 c0 fc	 add	 eax, -4			; fffffffcH
  00154	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00157	0f 87 c4 00 00
	00		 ja	 $LN81@OSInfo
$LN62@OSInfo:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0015d	52		 push	 edx
  0015e	51		 push	 ecx
  0015f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00164	83 c4 08	 add	 esp, 8
$LN63@OSInfo:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1427 :         OSVERSIONINFO osver = { 0 };

  00167	68 90 00 00 00	 push	 144			; 00000090H
  0016c	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _osver$2[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00172	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1427 :         OSVERSIONINFO osver = { 0 };

  00179	6a 00		 push	 0
  0017b	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0017c	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00183	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1427 :         OSVERSIONINFO osver = { 0 };

  00187	e8 00 00 00 00	 call	 _memset
  0018c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1428 :         osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  0018f	c7 85 44 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _osver$2[ebp], 148 ; 00000094H

; 1429 :         GetVersionEx(&osver);

  00199	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _osver$2[ebp]
  0019f	50		 push	 eax
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 1430 :         Log(LOG_HEADER, __LINE__, "OSInfo, Version %u.%u.%u, Platform %u, %s", osver.dwMajorVersion, osver.dwMinorVersion, osver.dwBuildNumber, osver.dwPlatformId, osver.szCSDVersion);

  001a6	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _osver$2[ebp+20]
  001ac	50		 push	 eax
  001ad	ff b5 54 ff ff
	ff		 push	 DWORD PTR _osver$2[ebp+16]
  001b3	ff b5 50 ff ff
	ff		 push	 DWORD PTR _osver$2[ebp+12]
  001b9	ff b5 4c ff ff
	ff		 push	 DWORD PTR _osver$2[ebp+8]
  001bf	ff b5 48 ff ff
	ff		 push	 DWORD PTR _osver$2[ebp+4]
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@HOFAFFOO@OSInfo?0?5Version?5?$CFu?4?$CFu?4?$CFu?0?5Platf@
  001ca	68 96 05 00 00	 push	 1430			; 00000596H
  001cf	6a 02		 push	 2
  001d1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001d6	83 c4 20	 add	 esp, 32			; 00000020H
$LN3@OSInfo:

; 1431 :     }
; 1432 : 
; 1433 :     LogElapsedTime(__LINE__, tickStart);

  001d9	57		 push	 edi
  001da	56		 push	 esi
  001db	33 d2		 xor	 edx, edx
  001dd	b9 99 05 00 00	 mov	 ecx, 1433		; 00000599H
  001e2	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1434 : 
; 1435 :     Log(LOG_DEBUG, __LINE__, "<< OSInfo");

  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_09EHLFKBJE@?$DM?$DM?5OSInfo@
  001ec	68 9b 05 00 00	 push	 1435			; 0000059bH
  001f1	6a 10		 push	 16			; 00000010H
  001f3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1436 :     _endthreadex(0);

  001f8	6a 00		 push	 0
  001fa	e8 00 00 00 00	 call	 __endthreadex
  001ff	83 c4 18	 add	 esp, 24			; 00000018H

; 1437 :     return 0;

  00202	33 c0		 xor	 eax, eax

; 1438 : }

  00204	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00207	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020e	59		 pop	 ecx
  0020f	5f		 pop	 edi
  00210	5e		 pop	 esi
  00211	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00214	33 cd		 xor	 ecx, ebp
  00216	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c2 04 00	 ret	 4
$LN81@OSInfo:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00221	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN79@OSInfo:
  00226	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?OSInfo@@YGIPAX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?OSInfo@@YGIPAX@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a a8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-344]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OSInfo@@YGIPAX@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OSInfo@@YGIPAX@Z ENDP					; OSInfo
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_Memst$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?SystemMemory@@YGIPAX@Z PROC				; SystemMemory

; 1444 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 48	 sub	 esp, 72			; 00000048H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 44	 mov	 DWORD PTR __$ArrayPad$[esp+72], eax
  00014	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  00017	56		 push	 esi
  00018	57		 push	 edi

; 1445 :     Log(LOG_DEBUG, __LINE__, ">> SysMem (%p)", lpData);

  00019	50		 push	 eax
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CFMOGLIC@?$DO?$DO?5SysMem?5?$CI?$CFp?$CJ@
  0001f	68 a5 05 00 00	 push	 1445			; 000005a5H
  00024	6a 10		 push	 16			; 00000010H
  00026	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1446 : 
; 1447 :     uint64_t tickStart = SysTick();

  0002b	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1448 : 
; 1449 :     //get system memory
; 1450 :     MEMORYSTATUSEX Memst = { 0 };

  00030	6a 40		 push	 64			; 00000040H
  00032	8b f8		 mov	 edi, eax
  00034	8b f2		 mov	 esi, edx
  00036	8d 44 24 1c	 lea	 eax, DWORD PTR _Memst$[esp+100]
  0003a	6a 00		 push	 0
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1451 :     Memst.dwLength = sizeof(Memst);

  00045	c7 44 24 08 40
	00 00 00	 mov	 DWORD PTR _Memst$[esp+80], 64 ; 00000040H

; 1452 :     GlobalMemoryStatusEx(&Memst);

  0004d	8d 44 24 08	 lea	 eax, DWORD PTR _Memst$[esp+80]
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalMemoryStatusEx@4

; 1453 : 
; 1454 :     Log(LOG_HEADER, __LINE__, "System Memory");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OAHOAHIO@System?5Memory@
  0005d	68 ae 05 00 00	 push	 1454			; 000005aeH
  00062	6a 02		 push	 2
  00064	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1455 :     Log(LOG_MESSAGE, __LINE__, "Usage: %u%% used", SIZE_MB(Memst.dwMemoryLoad));

  00069	8b 44 24 18	 mov	 eax, DWORD PTR _Memst$[esp+96]
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	c1 e8 14	 shr	 eax, 20			; 00000014H
  00073	66 0f 6e c0	 movd	 xmm0, eax
  00077	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0007b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007e	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00087	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0008f	e8 00 00 00 00	 call	 __dtoui3
  00094	50		 push	 eax
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DIEGGMCF@Usage?3?5?$CFu?$CF?$CF?5used@
  0009a	68 af 05 00 00	 push	 1455			; 000005afH
  0009f	6a 01		 push	 1
  000a1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1456 :     Log(LOG_MESSAGE, __LINE__, "Physical: %u MB used, %u MB avail", SIZE_MB(Memst.ullTotalPhys), SIZE_MB(Memst.ullAvailPhys));

  000a6	8b 4c 24 28	 mov	 ecx, DWORD PTR _Memst$[esp+112]
  000aa	83 c4 10	 add	 esp, 16			; 00000010H
  000ad	8b 54 24 1c	 mov	 edx, DWORD PTR _Memst$[esp+100]
  000b1	0f ac d1 14	 shrd	 ecx, edx, 20
  000b5	c1 ea 14	 shr	 edx, 20			; 00000014H
  000b8	e8 00 00 00 00	 call	 __ultod3
  000bd	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  000c5	e8 00 00 00 00	 call	 __dtoui3
  000ca	8b 4c 24 10	 mov	 ecx, DWORD PTR _Memst$[esp+88]
  000ce	8b 54 24 14	 mov	 edx, DWORD PTR _Memst$[esp+92]
  000d2	0f ac d1 14	 shrd	 ecx, edx, 20
  000d6	50		 push	 eax
  000d7	c1 ea 14	 shr	 edx, 20			; 00000014H
  000da	e8 00 00 00 00	 call	 __ultod3
  000df	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  000e7	e8 00 00 00 00	 call	 __dtoui3
  000ec	50		 push	 eax
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JHNBDNDC@Physical?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@
  000f2	68 b0 05 00 00	 push	 1456			; 000005b0H
  000f7	6a 01		 push	 1
  000f9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1457 :     Log(LOG_MESSAGE, __LINE__, "Pagefile: %u MB used, %u MB avail", SIZE_MB(Memst.ullTotalPageFile), SIZE_MB(Memst.ullAvailPageFile));

  000fe	8b 4c 24 3c	 mov	 ecx, DWORD PTR _Memst$[esp+132]
  00102	83 c4 14	 add	 esp, 20			; 00000014H
  00105	8b 54 24 2c	 mov	 edx, DWORD PTR _Memst$[esp+116]
  00109	0f ac d1 14	 shrd	 ecx, edx, 20
  0010d	c1 ea 14	 shr	 edx, 20			; 00000014H
  00110	e8 00 00 00 00	 call	 __ultod3
  00115	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0011d	e8 00 00 00 00	 call	 __dtoui3
  00122	8b 4c 24 20	 mov	 ecx, DWORD PTR _Memst$[esp+104]
  00126	8b 54 24 24	 mov	 edx, DWORD PTR _Memst$[esp+108]
  0012a	0f ac d1 14	 shrd	 ecx, edx, 20
  0012e	50		 push	 eax
  0012f	c1 ea 14	 shr	 edx, 20			; 00000014H
  00132	e8 00 00 00 00	 call	 __ultod3
  00137	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0013f	e8 00 00 00 00	 call	 __dtoui3
  00144	50		 push	 eax
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@PBKOHCPF@Pagefile?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5ava@
  0014a	68 b1 05 00 00	 push	 1457			; 000005b1H
  0014f	6a 01		 push	 1
  00151	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1458 :     Log(LOG_MESSAGE, __LINE__, "Virtual: %u MB used, %u MB avail, %u MB extended", SIZE_MB(Memst.ullTotalVirtual), SIZE_MB(Memst.ullAvailVirtual), SIZE_MB(Memst.ullAvailExtendedVirtual));

  00156	8b 4c 24 54	 mov	 ecx, DWORD PTR _Memst$[esp+156]
  0015a	83 c4 14	 add	 esp, 20			; 00000014H
  0015d	8b 54 24 44	 mov	 edx, DWORD PTR _Memst$[esp+140]
  00161	0f ac d1 14	 shrd	 ecx, edx, 20
  00165	c1 ea 14	 shr	 edx, 20			; 00000014H
  00168	e8 00 00 00 00	 call	 __ultod3
  0016d	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00175	e8 00 00 00 00	 call	 __dtoui3
  0017a	8b 4c 24 38	 mov	 ecx, DWORD PTR _Memst$[esp+128]
  0017e	8b 54 24 3c	 mov	 edx, DWORD PTR _Memst$[esp+132]
  00182	0f ac d1 14	 shrd	 ecx, edx, 20
  00186	50		 push	 eax
  00187	c1 ea 14	 shr	 edx, 20			; 00000014H
  0018a	e8 00 00 00 00	 call	 __ultod3
  0018f	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00197	e8 00 00 00 00	 call	 __dtoui3
  0019c	8b 4c 24 34	 mov	 ecx, DWORD PTR _Memst$[esp+124]
  001a0	8b 54 24 38	 mov	 edx, DWORD PTR _Memst$[esp+128]
  001a4	0f ac d1 14	 shrd	 ecx, edx, 20
  001a8	50		 push	 eax
  001a9	c1 ea 14	 shr	 edx, 20			; 00000014H
  001ac	e8 00 00 00 00	 call	 __ultod3
  001b1	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  001b9	e8 00 00 00 00	 call	 __dtoui3
  001be	50		 push	 eax
  001bf	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@BKHHAKDB@Virtual?3?5?$CFu?5MB?5used?0?5?$CFu?5MB?5avai@
  001c4	68 b2 05 00 00	 push	 1458			; 000005b2H
  001c9	6a 01		 push	 1
  001cb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1459 : 
; 1460 :     LogElapsedTime(__LINE__, tickStart);

  001d0	56		 push	 esi
  001d1	57		 push	 edi
  001d2	33 d2		 xor	 edx, edx
  001d4	b9 b4 05 00 00	 mov	 ecx, 1460		; 000005b4H
  001d9	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1461 : 
; 1462 :     Log(LOG_DEBUG, __LINE__, "<< SysMem");

  001de	68 00 00 00 00	 push	 OFFSET ??_C@_09CIJKANFC@?$DM?$DM?5SysMem@
  001e3	68 b6 05 00 00	 push	 1462			; 000005b6H
  001e8	6a 10		 push	 16			; 00000010H
  001ea	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1463 :     _endthreadex(0);

  001ef	6a 00		 push	 0
  001f1	e8 00 00 00 00	 call	 __endthreadex

; 1464 :     return 0;
; 1465 : }

  001f6	8b 4c 24 7c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+128]
  001fa	83 c4 30	 add	 esp, 48			; 00000030H
  001fd	33 c0		 xor	 eax, eax
  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi
  00201	33 cc		 xor	 ecx, esp
  00203	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00208	8b e5		 mov	 esp, ebp
  0020a	5d		 pop	 ebp
  0020b	c2 04 00	 ret	 4
?SystemMemory@@YGIPAX@Z ENDP				; SystemMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_nFreq$ = -128						; size = 8
_nCtr$ = -120						; size = 8
tv486 = -108						; size = 4
_tickStart$1$ = -104					; size = 4
_tickStart$2$ = -100					; size = 4
_KernelTime$ = -96					; size = 8
_UserTime$ = -88					; size = 8
_IdleTime$ = -80					; size = 8
tv505 = -72						; size = 8
_tKernelTime$ = -64					; size = 16
_tUserTime$ = -48					; size = 16
_tIdleTime$ = -32					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?SystemTimes@@YGIPAX@Z PROC				; SystemTimes

; 1471 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f0	 and	 esp, -16		; fffffff0H
  00006	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 84 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+136], eax
  0001a	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi

; 1472 :     Log(LOG_DEBUG, __LINE__, ">> SysTimes (%p)", lpData);

  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FODCFBGJ@?$DO?$DO?5SysTimes?5?$CI?$CFp?$CJ@
  00025	68 c0 05 00 00	 push	 1472			; 000005c0H
  0002a	6a 10		 push	 16			; 00000010H
  0002c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00031	0f 57 c0	 xorps	 xmm0, xmm0

; 1473 : 
; 1474 :     FILETIME ExitTime = { 0 };
; 1475 :     FILETIME KernelTime = { 0 };

  00034	66 0f 13 44 24
	40		 movlpd	 QWORD PTR _KernelTime$[esp+160], xmm0

; 1476 :     FILETIME UserTime = { 0 };

  0003a	66 0f 13 44 24
	48		 movlpd	 QWORD PTR _UserTime$[esp+160], xmm0

; 1477 :     FILETIME IdleTime = { 0 };

  00040	66 0f 13 44 24
	50		 movlpd	 QWORD PTR _IdleTime$[esp+160], xmm0

; 1478 :     SYSTEMTIME tKernelTime = { 0 };

  00046	0f 29 44 24 60	 movaps	 XMMWORD PTR _tKernelTime$[esp+160], xmm0

; 1479 :     SYSTEMTIME tUserTime = { 0 };

  0004b	0f 29 44 24 70	 movaps	 XMMWORD PTR _tUserTime$[esp+160], xmm0

; 1480 :     SYSTEMTIME tIdleTime = { 0 };

  00050	0f 29 84 24 80
	00 00 00	 movaps	 XMMWORD PTR _tIdleTime$[esp+160], xmm0

; 1481 :     unsigned long seconds = 0;
; 1482 : 
; 1483 :     uint64_t tickStart = SysTick();

  00058	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1484 : 
; 1485 :     Log(LOG_HEADER, __LINE__, "System Times");

  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HHJCFDFH@System?5Times@
  00062	68 cd 05 00 00	 push	 1485			; 000005cdH
  00067	6a 02		 push	 2
  00069	89 44 24 48	 mov	 DWORD PTR _tickStart$2$[esp+172], eax
  0006d	89 54 24 44	 mov	 DWORD PTR _tickStart$1$[esp+172], edx
  00071	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00076	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1486 : 
; 1487 :     //get system times
; 1488 :     GetSystemTimes(&IdleTime, &KernelTime, &UserTime);

  00079	8d 44 24 38	 lea	 eax, DWORD PTR _UserTime$[esp+144]
  0007d	50		 push	 eax
  0007e	8d 44 24 34	 lea	 eax, DWORD PTR _KernelTime$[esp+148]
  00082	50		 push	 eax
  00083	8d 44 24 48	 lea	 eax, DWORD PTR _IdleTime$[esp+152]
  00087	50		 push	 eax
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemTimes@12

; 1489 : 
; 1490 :     FileTimeToSystemTime(&KernelTime, &tKernelTime);

  0008e	8d 44 24 50	 lea	 eax, DWORD PTR _tKernelTime$[esp+144]
  00092	50		 push	 eax
  00093	8d 44 24 34	 lea	 eax, DWORD PTR _KernelTime$[esp+148]
  00097	50		 push	 eax
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToSystemTime@8

; 1491 :     seconds = (long)tKernelTime.wSecond + ((long)tKernelTime.wMinute * 60) + ((long)tKernelTime.wHour * 3600);

  0009e	0f b7 44 24 58	 movzx	 eax, WORD PTR _tKernelTime$[esp+152]
  000a3	8b c8		 mov	 ecx, eax
  000a5	c1 e1 04	 shl	 ecx, 4
  000a8	2b c8		 sub	 ecx, eax
  000aa	0f b7 44 24 5a	 movzx	 eax, WORD PTR _tKernelTime$[esp+154]
  000af	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000b2	8b c8		 mov	 ecx, eax
  000b4	c1 e1 04	 shl	 ecx, 4
  000b7	2b c8		 sub	 ecx, eax
  000b9	0f b7 44 24 5c	 movzx	 eax, WORD PTR _tKernelTime$[esp+156]
  000be	8d 3c 88	 lea	 edi, DWORD PTR [eax+ecx*4]

; 1492 :     Log(LOG_MESSAGE, __LINE__, "Kernel time: %02d:%02d:%02d (%u s).", seconds / 3600, (seconds % 3600) / 60, seconds % 60, seconds);

  000c1	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  000c6	f7 e7		 mul	 edi
  000c8	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  000cd	8b f2		 mov	 esi, edx
  000cf	f7 e7		 mul	 edi
  000d1	57		 push	 edi
  000d2	c1 ea 05	 shr	 edx, 5
  000d5	8b c7		 mov	 eax, edi
  000d7	8b ca		 mov	 ecx, edx
  000d9	c1 ee 0b	 shr	 esi, 11			; 0000000bH
  000dc	c1 e1 04	 shl	 ecx, 4
  000df	2b ca		 sub	 ecx, edx
  000e1	c1 e1 02	 shl	 ecx, 2
  000e4	2b c1		 sub	 eax, ecx
  000e6	50		 push	 eax
  000e7	69 c6 10 0e 00
	00		 imul	 eax, esi, 3600
  000ed	2b f8		 sub	 edi, eax
  000ef	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  000f4	f7 e7		 mul	 edi
  000f6	c1 ea 05	 shr	 edx, 5
  000f9	52		 push	 edx
  000fa	56		 push	 esi
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@PJKLEAEE@Kernel?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu@
  00100	68 d4 05 00 00	 push	 1492			; 000005d4H
  00105	6a 01		 push	 1
  00107	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0010c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1493 : 
; 1494 :     FileTimeToSystemTime(&UserTime, &tUserTime);

  0010f	8d 44 24 60	 lea	 eax, DWORD PTR _tUserTime$[esp+144]
  00113	50		 push	 eax
  00114	8d 44 24 3c	 lea	 eax, DWORD PTR _UserTime$[esp+148]
  00118	50		 push	 eax
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToSystemTime@8

; 1495 :     seconds = (long)tUserTime.wSecond + ((long)tUserTime.wMinute * 60) + ((long)tUserTime.wHour * 3600);

  0011f	0f b7 44 24 68	 movzx	 eax, WORD PTR _tUserTime$[esp+152]
  00124	8b c8		 mov	 ecx, eax
  00126	c1 e1 04	 shl	 ecx, 4
  00129	2b c8		 sub	 ecx, eax
  0012b	0f b7 44 24 6a	 movzx	 eax, WORD PTR _tUserTime$[esp+154]
  00130	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00133	8b c8		 mov	 ecx, eax
  00135	c1 e1 04	 shl	 ecx, 4
  00138	2b c8		 sub	 ecx, eax
  0013a	0f b7 44 24 6c	 movzx	 eax, WORD PTR _tUserTime$[esp+156]
  0013f	8d 34 88	 lea	 esi, DWORD PTR [eax+ecx*4]

; 1496 :     Log(LOG_MESSAGE, __LINE__, "User time: %02d:%02d:%02d (%u s).", seconds / 3600, (seconds % 3600) / 60, seconds % 60, seconds);

  00142	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  00147	f7 e6		 mul	 esi
  00149	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0014e	8b fa		 mov	 edi, edx
  00150	f7 e6		 mul	 esi
  00152	56		 push	 esi
  00153	c1 ea 05	 shr	 edx, 5
  00156	8b c6		 mov	 eax, esi
  00158	8b ca		 mov	 ecx, edx
  0015a	c1 ef 0b	 shr	 edi, 11			; 0000000bH
  0015d	c1 e1 04	 shl	 ecx, 4
  00160	2b ca		 sub	 ecx, edx
  00162	c1 e1 02	 shl	 ecx, 2
  00165	2b c1		 sub	 eax, ecx
  00167	50		 push	 eax
  00168	69 c7 10 0e 00
	00		 imul	 eax, edi, 3600
  0016e	2b f0		 sub	 esi, eax
  00170	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00175	f7 e6		 mul	 esi
  00177	c1 ea 05	 shr	 edx, 5
  0017a	52		 push	 edx
  0017b	57		 push	 edi
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@JKEHGGOG@User?5time?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s@
  00181	68 d8 05 00 00	 push	 1496			; 000005d8H
  00186	6a 01		 push	 1
  00188	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0018d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1497 : 
; 1498 :     FileTimeToSystemTime(&IdleTime, &tIdleTime);

  00190	8d 44 24 70	 lea	 eax, DWORD PTR _tIdleTime$[esp+144]
  00194	50		 push	 eax
  00195	8d 44 24 44	 lea	 eax, DWORD PTR _IdleTime$[esp+148]
  00199	50		 push	 eax
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FileTimeToSystemTime@8

; 1499 :     seconds = (long)tIdleTime.wSecond + ((long)tIdleTime.wMinute * 60) + ((long)tIdleTime.wHour * 3600);

  001a0	0f b7 44 24 78	 movzx	 eax, WORD PTR _tIdleTime$[esp+152]
  001a5	8b c8		 mov	 ecx, eax
  001a7	c1 e1 04	 shl	 ecx, 4
  001aa	2b c8		 sub	 ecx, eax
  001ac	0f b7 44 24 7a	 movzx	 eax, WORD PTR _tIdleTime$[esp+154]
  001b1	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  001b4	8b c8		 mov	 ecx, eax
  001b6	c1 e1 04	 shl	 ecx, 4
  001b9	2b c8		 sub	 ecx, eax
  001bb	0f b7 44 24 7c	 movzx	 eax, WORD PTR _tIdleTime$[esp+156]
  001c0	8d 34 88	 lea	 esi, DWORD PTR [eax+ecx*4]

; 1500 :     Log(LOG_MESSAGE, __LINE__, "Idle: %02d:%02d:%02d (%u s).", seconds / 3600, (seconds % 3600) / 60, seconds % 60, seconds);

  001c3	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  001c8	f7 e6		 mul	 esi
  001ca	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  001cf	8b fa		 mov	 edi, edx
  001d1	f7 e6		 mul	 esi
  001d3	56		 push	 esi
  001d4	c1 ea 05	 shr	 edx, 5
  001d7	8b c6		 mov	 eax, esi
  001d9	8b ca		 mov	 ecx, edx
  001db	c1 ef 0b	 shr	 edi, 11			; 0000000bH
  001de	c1 e1 04	 shl	 ecx, 4
  001e1	2b ca		 sub	 ecx, edx
  001e3	c1 e1 02	 shl	 ecx, 2
  001e6	2b c1		 sub	 eax, ecx
  001e8	50		 push	 eax
  001e9	69 c7 10 0e 00
	00		 imul	 eax, edi, 3600
  001ef	2b f0		 sub	 esi, eax
  001f1	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  001f6	f7 e6		 mul	 esi
  001f8	c1 ea 05	 shr	 edx, 5
  001fb	52		 push	 edx
  001fc	57		 push	 edi
  001fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@JFNEHINJ@Idle?3?5?$CF02d?3?$CF02d?3?$CF02d?5?$CI?$CFu?5s?$CJ?4@
  00202	68 dc 05 00 00	 push	 1500			; 000005dcH
  00207	6a 01		 push	 1
  00209	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0020e	0f 57 c0	 xorps	 xmm0, xmm0
  00211	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1501 : 
; 1502 :     //processor counts/times
; 1503 :     //retrieve performance-counter frequency per second
; 1504 :     uint64_t nCtr = 0, nFreq = 0;

  00214	66 0f 13 44 24
	18		 movlpd	 QWORD PTR _nCtr$[esp+144], xmm0
  0021a	66 0f 13 44 24
	10		 movlpd	 QWORD PTR _nFreq$[esp+144], xmm0

; 1505 :     if (QueryPerformanceFrequency((LARGE_INTEGER *)&nFreq))

  00220	8d 44 24 10	 lea	 eax, DWORD PTR _nFreq$[esp+144]
  00224	50		 push	 eax
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  0022b	85 c0		 test	 eax, eax
  0022d	0f 84 b7 00 00
	00		 je	 $LN2@SystemTime

; 1506 :     {
; 1507 :         //retrieve the current value of the performance counter
; 1508 :         QueryPerformanceCounter((LARGE_INTEGER *)&nCtr);

  00233	8d 44 24 18	 lea	 eax, DWORD PTR _nCtr$[esp+144]
  00237	50		 push	 eax
  00238	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4

; 1509 : 
; 1510 :         float processorTime = (float)(nCtr / nFreq);

  0023e	ff 74 24 14	 push	 DWORD PTR _nFreq$[esp+148]
  00242	ff 74 24 14	 push	 DWORD PTR _nFreq$[esp+148]
  00246	ff 74 24 24	 push	 DWORD PTR _nCtr$[esp+156]
  0024a	ff 74 24 24	 push	 DWORD PTR _nCtr$[esp+156]
  0024e	e8 00 00 00 00	 call	 __aulldiv
  00253	8b c8		 mov	 ecx, eax
  00255	e8 00 00 00 00	 call	 __ultod3
  0025a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0

; 1511 :         seconds = (unsigned long)(processorTime + 0.5);

  0025e	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00262	f2 0f 11 44 24
	48		 movsd	 QWORD PTR tv505[esp+144], xmm0
  00268	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00270	e8 00 00 00 00	 call	 __dtoui3
  00275	8b f8		 mov	 edi, eax

; 1512 :         Log(LOG_MESSAGE, __LINE__, "Processor: %I64u counts, %I64u counts/sec, %02d:%02d:%02d %f s", nCtr, nFreq, seconds / 3600, (seconds % 3600) / 60, seconds % 60, processorTime);

  00277	f2 0f 10 44 24
	48		 movsd	 xmm0, QWORD PTR tv505[esp+144]
  0027d	b8 c5 b3 a2 91	 mov	 eax, -1851608123	; 91a2b3c5H
  00282	83 ec 08	 sub	 esp, 8
  00285	f7 e7		 mul	 edi
  00287	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0028c	8b cf		 mov	 ecx, edi
  0028e	8b c2		 mov	 eax, edx
  00290	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00293	89 44 24 2c	 mov	 DWORD PTR tv486[esp+152], eax
  00297	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0029c	f7 e7		 mul	 edi
  0029e	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  002a3	c1 ea 05	 shr	 edx, 5
  002a6	8b f2		 mov	 esi, edx
  002a8	c1 e6 04	 shl	 esi, 4
  002ab	2b f2		 sub	 esi, edx
  002ad	c1 e6 02	 shl	 esi, 2
  002b0	2b ce		 sub	 ecx, esi
  002b2	8b 74 24 2c	 mov	 esi, DWORD PTR tv486[esp+152]
  002b6	51		 push	 ecx
  002b7	69 ce 10 0e 00
	00		 imul	 ecx, esi, 3600
  002bd	2b f9		 sub	 edi, ecx
  002bf	f7 e7		 mul	 edi
  002c1	c1 ea 05	 shr	 edx, 5
  002c4	52		 push	 edx
  002c5	56		 push	 esi
  002c6	ff 74 24 28	 push	 DWORD PTR _nFreq$[esp+168]
  002ca	ff 74 24 28	 push	 DWORD PTR _nFreq$[esp+168]
  002ce	ff 74 24 38	 push	 DWORD PTR _nCtr$[esp+176]
  002d2	ff 74 24 38	 push	 DWORD PTR _nCtr$[esp+176]
  002d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@OCMJGDEB@Processor?3?5?$CFI64u?5counts?0?5?$CFI64u?5@
  002db	68 e8 05 00 00	 push	 1512			; 000005e8H
  002e0	6a 01		 push	 1
  002e2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002e7	83 c4 30	 add	 esp, 48			; 00000030H
$LN2@SystemTime:

; 1513 :     }
; 1514 :     LogElapsedTime(__LINE__, tickStart);

  002ea	ff 74 24 28	 push	 DWORD PTR _tickStart$1$[esp+144]
  002ee	33 d2		 xor	 edx, edx
  002f0	b9 ea 05 00 00	 mov	 ecx, 1514		; 000005eaH
  002f5	ff 74 24 30	 push	 DWORD PTR _tickStart$2$[esp+148]
  002f9	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1515 : 
; 1516 :     Log(LOG_DEBUG, __LINE__, "<< SysTimes");

  002fe	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FNBLPGFN@?$DM?$DM?5SysTimes@
  00303	68 ec 05 00 00	 push	 1516			; 000005ecH
  00308	6a 10		 push	 16			; 00000010H
  0030a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1517 :     _endthreadex(0);

  0030f	6a 00		 push	 0
  00311	e8 00 00 00 00	 call	 __endthreadex

; 1518 :     return 0;
; 1519 : }

  00316	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+168]
  0031d	83 c4 18	 add	 esp, 24			; 00000018H
  00320	33 c0		 xor	 eax, eax
  00322	5f		 pop	 edi
  00323	5e		 pop	 esi
  00324	33 cc		 xor	 ecx, esp
  00326	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032b	8b e5		 mov	 esp, ebp
  0032d	5d		 pop	 ebp
  0032e	c2 04 00	 ret	 4
?SystemTimes@@YGIPAX@Z ENDP				; SystemTimes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
?DriverTypeName@@YAPADK@Z PROC				; DriverTypeName
; _driverType$ = ecx

; 1526 :     switch (driverType)

  00000	49		 dec	 ecx
  00001	83 f9 05	 cmp	 ecx, 5
  00004	77 2b		 ja	 SHORT $LN10@DriverType
  00006	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN13@DriverType[ecx*4]
$LN4@DriverType:

; 1527 :     {
; 1528 :     case DRIVE_NO_ROOT_DIR:
; 1529 :         return "NoRootDir";

  0000d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09MOKIPJGJ@NoRootDir@

; 1543 :     }
; 1544 : }

  00012	c3		 ret	 0
$LN5@DriverType:

; 1530 :     case DRIVE_REMOVABLE:
; 1531 :         return "Removable";

  00013	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_09DADBKOHO@Removable@

; 1543 :     }
; 1544 : }

  00018	c3		 ret	 0
$LN6@DriverType:

; 1532 :     case DRIVE_FIXED:
; 1533 :         return "Fixed";

  00019	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05OCBIINAK@Fixed@

; 1543 :     }
; 1544 : }

  0001e	c3		 ret	 0
$LN7@DriverType:

; 1534 :     case DRIVE_REMOTE:
; 1535 :         return "Remote";

  0001f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06MHHFENDB@Remote@

; 1543 :     }
; 1544 : }

  00024	c3		 ret	 0
$LN8@DriverType:

; 1536 :     case DRIVE_CDROM:
; 1537 :         return "CDRom";

  00025	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05JIFOIGMJ@CDRom@

; 1543 :     }
; 1544 : }

  0002a	c3		 ret	 0
$LN9@DriverType:

; 1538 :     case DRIVE_RAMDISK:
; 1539 :         return "RamDisk";

  0002b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07CPJGKNJN@RamDisk@

; 1543 :     }
; 1544 : }

  00030	c3		 ret	 0
$LN10@DriverType:

; 1540 :     case DRIVE_UNKNOWN:
; 1541 :     default:
; 1542 :         return "Unknown";

  00031	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07NBCGADJA@Unknown@

; 1543 :     }
; 1544 : }

  00036	c3		 ret	 0
  00037	90		 npad	 1
$LN13@DriverType:
  00038	00 00 00 00	 DD	 $LN4@DriverType
  0003c	00 00 00 00	 DD	 $LN5@DriverType
  00040	00 00 00 00	 DD	 $LN6@DriverType
  00044	00 00 00 00	 DD	 $LN7@DriverType
  00048	00 00 00 00	 DD	 $LN8@DriverType
  0004c	00 00 00 00	 DD	 $LN9@DriverType
?DriverTypeName@@YAPADK@Z ENDP				; DriverTypeName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_tickStart$2$ = -30112					; size = 4
_tickStart$1$ = -30108					; size = 4
_<end>$L0$1$ = -30104					; size = 4
_numDrivers$1$ = -30100					; size = 4
_drivers$ = -30096					; size = 12
_dwSectorsPerCluster$ = -30084				; size = 4
_dwBytesPerSector$ = -30080				; size = 4
_dwNumberOfFreeClusters$ = -30076			; size = 4
_dwTotalNumberOfClusters$ = -30072			; size = 4
_nVolumeSerialNumber$ = -30068				; size = 4
_nMaximumComponentLength$ = -30064			; size = 4
_nFileSystemFlags$ = -30060				; size = 4
_stringsList$2 = -30056					; size = 12
_drivers$1$ = -30044					; size = 4
_possibleStringInit$1$ = -30044				; size = 4
_aux$3 = -30040						; size = 24
_lpVolumeNameBuffer$ = -30016				; size = 10000
_lpFileSystemNameBuffer$ = -20016			; size = 10000
_temp$ = -10016						; size = 10000
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?LogicalDrives@@YGIPAX@Z PROC				; LogicalDrives

; 1547 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LogicalDrives@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 94 75 00 00	 mov	 eax, 30100		; 00007594H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1548 :     Log(LOG_DEBUG, __LINE__, ">> LogDrvs (%p)", lpData);

  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KFINEJGA@?$DO?$DO?5LogDrvs?5?$CI?$CFp?$CJ@
  0003b	68 0c 06 00 00	 push	 1548			; 0000060cH
  00040	6a 10		 push	 16			; 00000010H
  00042	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1549 : 
; 1550 :     DWORD dwSectorsPerCluster = 0,
; 1551 :         dwBytesPerSector = 0,
; 1552 :         dwNumberOfFreeClusters = 0,
; 1553 :         dwTotalNumberOfClusters = 0;
; 1554 : 
; 1555 :     char lpVolumeNameBuffer[10000] = { 0 },

  00047	68 10 27 00 00	 push	 10000			; 00002710H
  0004c	8d 85 c0 8a ff
	ff		 lea	 eax, DWORD PTR _lpVolumeNameBuffer$[ebp]
  00052	c7 85 7c 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwSectorsPerCluster$[ebp], 0
  0005c	6a 00		 push	 0
  0005e	50		 push	 eax
  0005f	c7 85 80 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwBytesPerSector$[ebp], 0
  00069	c7 85 84 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwNumberOfFreeClusters$[ebp], 0
  00073	c7 85 88 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwTotalNumberOfClusters$[ebp], 0
  0007d	e8 00 00 00 00	 call	 _memset

; 1556 :         lpFileSystemNameBuffer[10000] = { 0 };

  00082	68 10 27 00 00	 push	 10000			; 00002710H
  00087	8d 85 d0 b1 ff
	ff		 lea	 eax, DWORD PTR _lpFileSystemNameBuffer$[ebp]
  0008d	6a 00		 push	 0
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _memset

; 1557 : 
; 1558 :     DWORD nVolumeSerialNumber = 0,
; 1559 :         nMaximumComponentLength = 0,
; 1560 :         nFileSystemFlags = 0;
; 1561 : 
; 1562 :     char temp[10000] = { 0 };

  00095	68 10 27 00 00	 push	 10000			; 00002710H
  0009a	8d 85 e0 d8 ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  000a0	c7 85 8c 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _nVolumeSerialNumber$[ebp], 0
  000aa	6a 00		 push	 0
  000ac	50		 push	 eax
  000ad	c7 85 90 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _nMaximumComponentLength$[ebp], 0
  000b7	c7 85 94 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _nFileSystemFlags$[ebp], 0
  000c1	e8 00 00 00 00	 call	 _memset
  000c6	83 c4 34	 add	 esp, 52			; 00000034H

; 1563 : 
; 1564 :     uint64_t tickStart = SysTick();

  000c9	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  000ce	89 85 60 8a ff
	ff		 mov	 DWORD PTR _tickStart$2$[ebp], eax

; 1565 : 
; 1566 :     DWORD const numDrivers = GetLogicalDriveStrings(sizeof(temp), temp);

  000d4	8d 85 e0 d8 ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  000da	50		 push	 eax
  000db	68 10 27 00 00	 push	 10000			; 00002710H
  000e0	89 95 64 8a ff
	ff		 mov	 DWORD PTR _tickStart$1$[ebp], edx
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLogicalDriveStringsA@8
  000ec	89 85 6c 8a ff
	ff		 mov	 DWORD PTR _numDrivers$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  000f2	c7 85 98 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _stringsList$2[ebp], 0

; 390  : 		_Mylast(),

  000fc	c7 85 9c 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _stringsList$2[ebp+4], 0

; 391  : 		_Myend()

  00106	c7 85 a0 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _stringsList$2[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 502  :     std::vector<std::string> stringsList;

  00110	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 503  :     int nullCount = 0, possibleStringInit = 0;

  00117	33 ff		 xor	 edi, edi
  00119	33 c0		 xor	 eax, eax

; 1547 : {

  0011b	be 01 00 00 00	 mov	 esi, 1

; 504  :     char *p = nullptr;

  00120	33 d2		 xor	 edx, edx
$LL12@LogicalDri:

; 507  :     {
; 508  :         if (input[i] == 0)

  00122	80 bc 35 df d8
	ff ff 00	 cmp	 BYTE PTR _temp$[ebp+esi-1], 0
  0012a	0f 85 f3 00 00
	00		 jne	 $LN13@LogicalDri

; 509  :         {
; 510  :             nullCount++;

  00130	47		 inc	 edi

; 511  :             possibleStringInit = i + 1;

  00131	8b c6		 mov	 eax, esi
  00133	89 85 a4 8a ff
	ff		 mov	 DWORD PTR _possibleStringInit$1$[ebp], eax

; 512  :             if (p != nullptr)

  00139	85 d2		 test	 edx, edx
  0013b	0f 84 de 00 00
	00		 je	 $LN174@LogicalDri
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00141	8b c2		 mov	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00143	c7 85 b8 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _aux$3[ebp+16], 0

; 1785 : 		_Myres(0)

  0014d	c7 85 bc 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _aux$3[ebp+20], 0

; 3976 : 		_My_data._Mysize = 0;

  00157	c7 85 b8 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _aux$3[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00161	c7 85 bc 8a ff
	ff 0f 00 00 00	 mov	 DWORD PTR _aux$3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0016b	c6 85 a8 8a ff
	ff 00		 mov	 BYTE PTR _aux$3[ebp], 0

; 462  : 		return (__builtin_strlen(_First));

  00172	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
$LL403@LogicalDri:
  00175	8a 08		 mov	 cl, BYTE PTR [eax]
  00177	40		 inc	 eax
  00178	84 c9		 test	 cl, cl
  0017a	75 f9		 jne	 SHORT $LL403@LogicalDri
  0017c	2b c3		 sub	 eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0017e	8d 8d a8 8a ff
	ff		 lea	 ecx, DWORD PTR _aux$3[ebp]
  00184	50		 push	 eax
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 514  :                 std::string aux(p);

  0018b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 917  : 		if (_Has_unused_capacity())

  0018f	8d 8d a8 8a ff
	ff		 lea	 ecx, DWORD PTR _aux$3[ebp]

; 1726 : 		return (this->_Myend() != this->_Mylast());

  00195	8b 85 9c 8a ff
	ff		 mov	 eax, DWORD PTR _stringsList$2[ebp+4]

; 917  : 		if (_Has_unused_capacity())

  0019b	51		 push	 ecx

; 1726 : 		return (this->_Myend() != this->_Mylast());

  0019c	39 85 a0 8a ff
	ff		 cmp	 DWORD PTR _stringsList$2[ebp+8], eax

; 917  : 		if (_Has_unused_capacity())

  001a2	74 10		 je	 SHORT $LN56@LogicalDri
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  001a4	8b c8		 mov	 ecx, eax
  001a6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

  001ab	83 85 9c 8a ff
	ff 18		 add	 DWORD PTR _stringsList$2[ebp+4], 24 ; 00000018H

; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));

  001b2	eb 0c		 jmp	 SHORT $LN55@LogicalDri
$LN56@LogicalDri:

; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

  001b4	50		 push	 eax
  001b5	8d 8d 98 8a ff
	ff		 lea	 ecx, DWORD PTR _stringsList$2[ebp]
  001bb	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN55@LogicalDri:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 517  :             }

  001c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001c4	8b 95 bc 8a ff
	ff		 mov	 edx, DWORD PTR _aux$3[ebp+20]
  001ca	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001cd	72 2f		 jb	 SHORT $LN172@LogicalDri
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001cf	8b 8d a8 8a ff
	ff		 mov	 ecx, DWORD PTR _aux$3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001d5	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001d6	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001d8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001de	72 14		 jb	 SHORT $LN171@LogicalDri

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001e0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001e3	83 c2 23	 add	 edx, 35			; 00000023H
  001e6	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e8	83 c0 fc	 add	 eax, -4			; fffffffcH
  001eb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001ee	0f 87 ca 02 00
	00		 ja	 $LN168@LogicalDri
$LN171@LogicalDri:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001f4	52		 push	 edx
  001f5	51		 push	 ecx
  001f6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001fb	83 c4 08	 add	 esp, 8
$LN172@LogicalDri:
  001fe	8b 85 a4 8a ff
	ff		 mov	 eax, DWORD PTR _possibleStringInit$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00204	c7 85 b8 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _aux$3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0020e	c7 85 bc 8a ff
	ff 0f 00 00 00	 mov	 DWORD PTR _aux$3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00218	c6 85 a8 8a ff
	ff 00		 mov	 BYTE PTR _aux$3[ebp], 0
$LN174@LogicalDri:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 518  :             p = nullptr;

  0021f	33 d2		 xor	 edx, edx

; 519  :             continue;

  00221	eb 0e		 jmp	 SHORT $LN10@LogicalDri
$LN13@LogicalDri:

; 520  :         }
; 521  : 
; 522  :         if (p == nullptr)

  00223	85 d2		 test	 edx, edx
  00225	75 0a		 jne	 SHORT $LN10@LogicalDri

; 523  :         {
; 524  :             nullCount = 0;
; 525  :             p = const_cast<char*>(&input[possibleStringInit]);

  00227	8d 95 e0 d8 ff
	ff		 lea	 edx, DWORD PTR _temp$[ebp]
  0022d	33 ff		 xor	 edi, edi
  0022f	03 d0		 add	 edx, eax
$LN10@LogicalDri:

; 505  : 
; 506  :     for (int i = 0; nullCount < 2; i++)

  00231	46		 inc	 esi
  00232	83 ff 02	 cmp	 edi, 2
  00235	0f 8c e7 fe ff
	ff		 jl	 $LL12@LogicalDri

; 526  :         }
; 527  :     }
; 528  :     return std::move(stringsList);

  0023b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00242	8d 8d 98 8a ff
	ff		 lea	 ecx, DWORD PTR _stringsList$2[ebp]
  00248	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 765  : 		this->_Myfirst() = _Right._Myfirst();

  0024d	8b 9d 98 8a ff
	ff		 mov	 ebx, DWORD PTR _stringsList$2[ebp]

; 389  : 		: _Myfirst(),

  00253	c7 85 70 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivers$[ebp], 0

; 765  : 		this->_Myfirst() = _Right._Myfirst();

  0025d	89 9d 70 8a ff
	ff		 mov	 DWORD PTR _drivers$[ebp], ebx

; 766  : 		this->_Mylast() = _Right._Mylast();

  00263	8b bd 9c 8a ff
	ff		 mov	 edi, DWORD PTR _stringsList$2[ebp+4]

; 390  : 		_Mylast(),

  00269	c7 85 74 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivers$[ebp+4], 0

; 766  : 		this->_Mylast() = _Right._Mylast();

  00273	89 bd 74 8a ff
	ff		 mov	 DWORD PTR _drivers$[ebp+4], edi

; 767  : 		this->_Myend() = _Right._Myend();

  00279	8b 85 a0 8a ff
	ff		 mov	 eax, DWORD PTR _stringsList$2[ebp+8]

; 391  : 		_Myend()

  0027f	c7 85 78 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivers$[ebp+8], 0

; 765  : 		this->_Myfirst() = _Right._Myfirst();

  00289	89 9d a4 8a ff
	ff		 mov	 DWORD PTR _drivers$1$[ebp], ebx

; 766  : 		this->_Mylast() = _Right._Mylast();

  0028f	89 bd 68 8a ff
	ff		 mov	 DWORD PTR _<end>$L0$1$[ebp], edi

; 767  : 		this->_Myend() = _Right._Myend();

  00295	89 85 78 8a ff
	ff		 mov	 DWORD PTR _drivers$[ebp+8], eax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

  0029b	c7 85 98 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _stringsList$2[ebp], 0

; 770  : 		_Right._Mylast() = pointer();

  002a5	c7 85 9c 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _stringsList$2[ebp+4], 0

; 771  : 		_Right._Myend() = pointer();

  002af	c7 85 a0 8a ff
	ff 00 00 00 00	 mov	 DWORD PTR _stringsList$2[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1568 :     std::vector<std::string> drivers = parseNullTerminatedStrings(temp);

  002b9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 1570 :     Log(LOG_HEADER, __LINE__, "Logical Drivers %u(%u) (0x%.8X)", drivers.size(), numDrivers, GetLogicalDrives());

  002c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLogicalDrives@0
  002c6	50		 push	 eax
  002c7	ff b5 6c 8a ff
	ff		 push	 DWORD PTR _numDrivers$1$[ebp]
  002cd	8b cf		 mov	 ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  002cf	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1570 :     Log(LOG_HEADER, __LINE__, "Logical Drivers %u(%u) (0x%.8X)", drivers.size(), numDrivers, GetLogicalDrives());

  002d4	2b cb		 sub	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  002d6	f7 e9		 imul	 ecx
  002d8	c1 fa 02	 sar	 edx, 2
  002db	8b ca		 mov	 ecx, edx
  002dd	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002e0	03 ca		 add	 ecx, edx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1570 :     Log(LOG_HEADER, __LINE__, "Logical Drivers %u(%u) (0x%.8X)", drivers.size(), numDrivers, GetLogicalDrives());

  002e2	51		 push	 ecx
  002e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BGDEGNDO@Logical?5Drivers?5?$CFu?$CI?$CFu?$CJ?5?$CI0x?$CF?48X?$CJ@
  002e8	68 22 06 00 00	 push	 1570			; 00000622H
  002ed	6a 02		 push	 2
  002ef	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1679 : 		return (this->_Myfirst());

  002f4	8b b5 a4 8a ff
	ff		 mov	 esi, DWORD PTR _drivers$1$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1570 :     Log(LOG_HEADER, __LINE__, "Logical Drivers %u(%u) (0x%.8X)", drivers.size(), numDrivers, GetLogicalDrives());

  002fa	83 c4 18	 add	 esp, 24			; 00000018H

; 1571 : 
; 1572 :     size_t x{};

  002fd	33 db		 xor	 ebx, ebx

; 1573 :     for (auto const& driver : drivers)

  002ff	3b f7		 cmp	 esi, edi
  00301	0f 84 3c 01 00
	00		 je	 $LN3@LogicalDri
$LL4@LogicalDri:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00307	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0030b	8b fe		 mov	 edi, esi

; 1815 : 		if (_Large_string_engaged())

  0030d	72 02		 jb	 SHORT $LN317@LogicalDri
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0030f	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN317@LogicalDri:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1578 :         driverType = GetDriveType(strdrv);

  00311	57		 push	 edi
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDriveTypeA@4

; 1579 :         Log(LOG_MESSAGE, __LINE__, ">> %.3d, %s: Type %s(%u)", ++x, strdrv, DriverTypeName(driverType), driverType);

  00318	43		 inc	 ebx

; 1526 :     switch (driverType)

  00319	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  0031c	83 f9 05	 cmp	 ecx, 5
  0031f	77 31		 ja	 SHORT $LN332@LogicalDri
  00321	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN407@LogicalDri[ecx*4]
$LN326@LogicalDri:

; 1527 :     {
; 1528 :     case DRIVE_NO_ROOT_DIR:
; 1529 :         return "NoRootDir";

  00328	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09MOKIPJGJ@NoRootDir@
  0032d	eb 28		 jmp	 SHORT $LN323@LogicalDri
$LN327@LogicalDri:

; 1530 :     case DRIVE_REMOVABLE:
; 1531 :         return "Removable";

  0032f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09DADBKOHO@Removable@
  00334	eb 21		 jmp	 SHORT $LN323@LogicalDri
$LN328@LogicalDri:

; 1532 :     case DRIVE_FIXED:
; 1533 :         return "Fixed";

  00336	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05OCBIINAK@Fixed@
  0033b	eb 1a		 jmp	 SHORT $LN323@LogicalDri
$LN329@LogicalDri:

; 1534 :     case DRIVE_REMOTE:
; 1535 :         return "Remote";

  0033d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_06MHHFENDB@Remote@
  00342	eb 13		 jmp	 SHORT $LN323@LogicalDri
$LN330@LogicalDri:

; 1536 :     case DRIVE_CDROM:
; 1537 :         return "CDRom";

  00344	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05JIFOIGMJ@CDRom@
  00349	eb 0c		 jmp	 SHORT $LN323@LogicalDri
$LN331@LogicalDri:

; 1538 :     case DRIVE_RAMDISK:
; 1539 :         return "RamDisk";

  0034b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07CPJGKNJN@RamDisk@
  00350	eb 05		 jmp	 SHORT $LN323@LogicalDri
$LN332@LogicalDri:

; 1540 :     case DRIVE_UNKNOWN:
; 1541 :     default:
; 1542 :         return "Unknown";

  00352	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07NBCGADJA@Unknown@
$LN323@LogicalDri:

; 1579 :         Log(LOG_MESSAGE, __LINE__, ">> %.3d, %s: Type %s(%u)", ++x, strdrv, DriverTypeName(driverType), driverType);

  00357	50		 push	 eax
  00358	51		 push	 ecx
  00359	57		 push	 edi
  0035a	53		 push	 ebx
  0035b	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@BENIJAPK@?$DO?$DO?5?$CF?43d?0?5?$CFs?3?5Type?5?$CFs?$CI?$CFu?$CJ@
  00360	68 2b 06 00 00	 push	 1579			; 0000062bH
  00365	6a 01		 push	 1
  00367	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0036c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1580 : 
; 1581 :         if (GetVolumeInformation(strdrv, lpVolumeNameBuffer, sizeof(lpVolumeNameBuffer), &nVolumeSerialNumber, &nMaximumComponentLength, &nFileSystemFlags, lpFileSystemNameBuffer, sizeof(lpFileSystemNameBuffer)))

  0036f	8d 85 d0 b1 ff
	ff		 lea	 eax, DWORD PTR _lpFileSystemNameBuffer$[ebp]
  00375	68 10 27 00 00	 push	 10000			; 00002710H
  0037a	50		 push	 eax
  0037b	8d 85 94 8a ff
	ff		 lea	 eax, DWORD PTR _nFileSystemFlags$[ebp]
  00381	50		 push	 eax
  00382	8d 85 90 8a ff
	ff		 lea	 eax, DWORD PTR _nMaximumComponentLength$[ebp]
  00388	50		 push	 eax
  00389	8d 85 8c 8a ff
	ff		 lea	 eax, DWORD PTR _nVolumeSerialNumber$[ebp]
  0038f	50		 push	 eax
  00390	68 10 27 00 00	 push	 10000			; 00002710H
  00395	8d 85 c0 8a ff
	ff		 lea	 eax, DWORD PTR _lpVolumeNameBuffer$[ebp]
  0039b	50		 push	 eax
  0039c	57		 push	 edi
  0039d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32
  003a3	85 c0		 test	 eax, eax
  003a5	0f 84 87 00 00
	00		 je	 $LN2@LogicalDri

; 1582 :         {
; 1583 :             Log(LOG_MESSAGE, __LINE__, "   VolumeInfo, Name %s, SerialNumber %u, MaxComponentLength %u, FileSysflags 0x%08X, FileSysName %s",

  003ab	8d 85 d0 b1 ff
	ff		 lea	 eax, DWORD PTR _lpFileSystemNameBuffer$[ebp]
  003b1	50		 push	 eax
  003b2	ff b5 94 8a ff
	ff		 push	 DWORD PTR _nFileSystemFlags$[ebp]
  003b8	8d 85 c0 8a ff
	ff		 lea	 eax, DWORD PTR _lpVolumeNameBuffer$[ebp]
  003be	ff b5 90 8a ff
	ff		 push	 DWORD PTR _nMaximumComponentLength$[ebp]
  003c4	ff b5 8c 8a ff
	ff		 push	 DWORD PTR _nVolumeSerialNumber$[ebp]
  003ca	50		 push	 eax
  003cb	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@JMDLMJNN@?5?5?5VolumeInfo?0?5Name?5?$CFs?0?5SerialN@
  003d0	68 2f 06 00 00	 push	 1583			; 0000062fH
  003d5	6a 01		 push	 1
  003d7	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003dc	83 c4 20	 add	 esp, 32			; 00000020H

; 1584 :                 lpVolumeNameBuffer, nVolumeSerialNumber, nMaximumComponentLength, nFileSystemFlags, lpFileSystemNameBuffer);
; 1585 :             if (GetDiskFreeSpace(strdrv, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))

  003df	8d 85 88 8a ff
	ff		 lea	 eax, DWORD PTR _dwTotalNumberOfClusters$[ebp]
  003e5	50		 push	 eax
  003e6	8d 85 84 8a ff
	ff		 lea	 eax, DWORD PTR _dwNumberOfFreeClusters$[ebp]
  003ec	50		 push	 eax
  003ed	8d 85 80 8a ff
	ff		 lea	 eax, DWORD PTR _dwBytesPerSector$[ebp]
  003f3	50		 push	 eax
  003f4	8d 85 7c 8a ff
	ff		 lea	 eax, DWORD PTR _dwSectorsPerCluster$[ebp]
  003fa	50		 push	 eax
  003fb	57		 push	 edi
  003fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDiskFreeSpaceA@20
  00402	85 c0		 test	 eax, eax
  00404	74 2c		 je	 SHORT $LN2@LogicalDri

; 1586 :             {
; 1587 :                 Log(LOG_MESSAGE, __LINE__, "   FreeSpace, SectorsPerCluster %u, BytesPerSector %u, NumberOfFreeClusters %u, TotalNumberOfClusters %u",

  00406	ff b5 88 8a ff
	ff		 push	 DWORD PTR _dwTotalNumberOfClusters$[ebp]
  0040c	ff b5 84 8a ff
	ff		 push	 DWORD PTR _dwNumberOfFreeClusters$[ebp]
  00412	ff b5 80 8a ff
	ff		 push	 DWORD PTR _dwBytesPerSector$[ebp]
  00418	ff b5 7c 8a ff
	ff		 push	 DWORD PTR _dwSectorsPerCluster$[ebp]
  0041e	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@NOKMBBI@?5?5?5FreeSpace?0?5SectorsPerCluster@
  00423	68 33 06 00 00	 push	 1587			; 00000633H
  00428	6a 01		 push	 1
  0042a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0042f	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN2@LogicalDri:

; 1573 :     for (auto const& driver : drivers)

  00432	8b bd 68 8a ff
	ff		 mov	 edi, DWORD PTR _<end>$L0$1$[ebp]
  00438	83 c6 18	 add	 esi, 24			; 00000018H
  0043b	3b f7		 cmp	 esi, edi
  0043d	0f 85 c4 fe ff
	ff		 jne	 $LL4@LogicalDri
$LN3@LogicalDri:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00443	8b 9d a4 8a ff
	ff		 mov	 ebx, DWORD PTR _drivers$1$[ebp]
  00449	8b d7		 mov	 edx, edi
  0044b	51		 push	 ecx
  0044c	8b cb		 mov	 ecx, ebx
  0044e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1595 :     LogElapsedTime(__LINE__, tickStart);

  00453	ff b5 64 8a ff
	ff		 push	 DWORD PTR _tickStart$1$[ebp]
  00459	33 d2		 xor	 edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0045b	89 9d 74 8a ff
	ff		 mov	 DWORD PTR _drivers$[ebp+4], ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1595 :     LogElapsedTime(__LINE__, tickStart);

  00461	ff b5 60 8a ff
	ff		 push	 DWORD PTR _tickStart$2$[ebp]
  00467	b9 3b 06 00 00	 mov	 ecx, 1595		; 0000063bH
  0046c	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1596 : 
; 1597 :     Log(LOG_DEBUG, __LINE__, "<< LogDrvs");

  00471	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GICAALNI@?$DM?$DM?5LogDrvs@
  00476	68 3d 06 00 00	 push	 1597			; 0000063dH
  0047b	6a 10		 push	 16			; 00000010H
  0047d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1598 :     _endthreadex(0);

  00482	6a 00		 push	 0
  00484	e8 00 00 00 00	 call	 __endthreadex
  00489	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1599 :     return 0;

  0048c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00493	8d 8d 70 8a ff
	ff		 lea	 ecx, DWORD PTR _drivers$[ebp]
  00499	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1599 :     return 0;

  0049e	33 c0		 xor	 eax, eax

; 1600 : }

  004a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004aa	59		 pop	 ecx
  004ab	5f		 pop	 edi
  004ac	5e		 pop	 esi
  004ad	5b		 pop	 ebx
  004ae	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b1	33 cd		 xor	 ecx, ebp
  004b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004b8	8b e5		 mov	 esp, ebp
  004ba	5d		 pop	 ebp
  004bb	c2 04 00	 ret	 4
$LN168@LogicalDri:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004be	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN405@LogicalDri:
  004c3	90		 npad	 1
$LN407@LogicalDri:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1600 : }

  004c4	00 00 00 00	 DD	 $LN326@LogicalDri
  004c8	00 00 00 00	 DD	 $LN327@LogicalDri
  004cc	00 00 00 00	 DD	 $LN328@LogicalDri
  004d0	00 00 00 00	 DD	 $LN329@LogicalDri
  004d4	00 00 00 00	 DD	 $LN330@LogicalDri
  004d8	00 00 00 00	 DD	 $LN331@LogicalDri
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LogicalDrives@@YGIPAX@Z$1:
  00000	8d 8d 98 8a ff
	ff		 lea	 ecx, DWORD PTR _stringsList$2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?LogicalDrives@@YGIPAX@Z$2:
  0000b	8d 8d a8 8a ff
	ff		 lea	 ecx, DWORD PTR _aux$3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LogicalDrives@@YGIPAX@Z$0:
  00016	8d 8d 70 8a ff
	ff		 lea	 ecx, DWORD PTR _drivers$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?LogicalDrives@@YGIPAX@Z:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 5c 8a ff
	ff		 mov	 ecx, DWORD PTR [edx-30116]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LogicalDrives@@YGIPAX@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LogicalDrives@@YGIPAX@Z ENDP				; LogicalDrives
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_temp$ = -10008						; size = 10000
__$ArrayPad$ = -4					; size = 4
_lpData$ = 8						; size = 4
?SystemDirs@@YGIPAX@Z PROC				; SystemDirs

; 1606 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	b8 18 27 00 00	 mov	 eax, 10008		; 00002718H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00015	33 c4		 xor	 eax, esp
  00017	89 84 24 14 27
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+10008], eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]
  00021	56		 push	 esi
  00022	57		 push	 edi

; 1607 :     Log(LOG_DEBUG, __LINE__, ">> SysDirs (%p)", lpData);

  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GBCPBHIM@?$DO?$DO?5SysDirs?5?$CI?$CFp?$CJ@
  00029	68 47 06 00 00	 push	 1607			; 00000647H
  0002e	6a 10		 push	 16			; 00000010H
  00030	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1608 : 
; 1609 :     char temp[10000];
; 1610 : 
; 1611 :     uint64_t tickStart = SysTick();

  00035	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1612 : 
; 1613 :     Log(LOG_HEADER, __LINE__, "System Directories");

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OAHOLNHD@System?5Directories@
  0003f	68 4d 06 00 00	 push	 1613			; 0000064dH
  00044	6a 02		 push	 2
  00046	8b f8		 mov	 edi, eax
  00048	8b f2		 mov	 esi, edx
  0004a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1614 : 
; 1615 :     memset(temp, 0x00, sizeof(temp));

  0004f	68 10 27 00 00	 push	 10000			; 00002710H
  00054	8d 44 24 28	 lea	 eax, DWORD PTR _temp$[esp+10048]
  00058	6a 00		 push	 0
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _memset
  00060	83 c4 28	 add	 esp, 40			; 00000028H

; 1616 :     GetSystemDirectory(temp, sizeof(temp));

  00063	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  00067	68 10 27 00 00	 push	 10000			; 00002710H
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8

; 1617 :     Log(LOG_MESSAGE, __LINE__, "SysDir %s", temp);

  00073	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  00077	50		 push	 eax
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_09LGICPEGI@SysDir?5?$CFs@
  0007d	68 51 06 00 00	 push	 1617			; 00000651H
  00082	6a 01		 push	 1
  00084	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1618 : 
; 1619 :     memset(temp, 0x00, sizeof(temp));

  00089	68 10 27 00 00	 push	 10000			; 00002710H
  0008e	8d 44 24 1c	 lea	 eax, DWORD PTR _temp$[esp+10036]
  00092	6a 00		 push	 0
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _memset
  0009a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1620 :     GetTempPath(sizeof(temp), temp);

  0009d	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  000a1	50		 push	 eax
  000a2	68 10 27 00 00	 push	 10000			; 00002710H
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTempPathA@8

; 1621 :     Log(LOG_MESSAGE, __LINE__, "TempPath %s", temp);

  000ad	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  000b1	50		 push	 eax
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JFNOOIEA@TempPath?5?$CFs@
  000b7	68 55 06 00 00	 push	 1621			; 00000655H
  000bc	6a 01		 push	 1
  000be	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1622 : 
; 1623 :     memset(temp, 0x00, sizeof(temp));

  000c3	68 10 27 00 00	 push	 10000			; 00002710H
  000c8	8d 44 24 1c	 lea	 eax, DWORD PTR _temp$[esp+10036]
  000cc	6a 00		 push	 0
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _memset
  000d4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1624 :     GetWindowsDirectory(temp, sizeof(temp));

  000d7	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  000db	68 10 27 00 00	 push	 10000			; 00002710H
  000e0	50		 push	 eax
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowsDirectoryA@8

; 1625 :     Log(LOG_MESSAGE, __LINE__, "WinDir %s", temp);

  000e7	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  000eb	50		 push	 eax
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_09PEBHDCJJ@WinDir?5?$CFs@
  000f1	68 59 06 00 00	 push	 1625			; 00000659H
  000f6	6a 01		 push	 1
  000f8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1626 : 
; 1627 :     memset(temp, 0x00, sizeof(temp));

  000fd	68 10 27 00 00	 push	 10000			; 00002710H
  00102	8d 44 24 1c	 lea	 eax, DWORD PTR _temp$[esp+10036]
  00106	6a 00		 push	 0
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memset
  0010e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1628 :     GetSystemWindowsDirectory(temp, sizeof(temp));

  00111	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  00115	68 10 27 00 00	 push	 10000			; 00002710H
  0011a	50		 push	 eax
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemWindowsDirectoryA@8

; 1629 :     Log(LOG_MESSAGE, __LINE__, "WinSysDir %s", temp);

  00121	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+10016]
  00125	50		 push	 eax
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JJNMAABC@WinSysDir?5?$CFs@
  0012b	68 5d 06 00 00	 push	 1629			; 0000065dH
  00130	6a 01		 push	 1
  00132	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1630 : 
; 1631 :     LogElapsedTime(__LINE__, tickStart);

  00137	56		 push	 esi
  00138	57		 push	 edi
  00139	33 d2		 xor	 edx, edx
  0013b	b9 5f 06 00 00	 mov	 ecx, 1631		; 0000065fH
  00140	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1632 : 
; 1633 :     Log(LOG_DEBUG, __LINE__, "<< SysDirs");

  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NBODLJGE@?$DM?$DM?5SysDirs@
  0014a	68 61 06 00 00	 push	 1633			; 00000661H
  0014f	6a 10		 push	 16			; 00000010H
  00151	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1634 :     _endthreadex(0);

  00156	6a 00		 push	 0
  00158	e8 00 00 00 00	 call	 __endthreadex

; 1635 :     return 0;
; 1636 : }

  0015d	8b 8c 24 44 27
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+10056]
  00164	83 c4 28	 add	 esp, 40			; 00000028H
  00167	33 c0		 xor	 eax, eax
  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	33 cc		 xor	 ecx, esp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c2 04 00	 ret	 4
?SystemDirs@@YGIPAX@Z ENDP				; SystemDirs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
tv152 = -4						; size = 4
?CountSetBits@@YAKK@Z PROC				; CountSetBits
; _bitMask$ = ecx

; 1643 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1644 :     DWORD LSHIFT = sizeof(ULONG_PTR) * 8 - 1;
; 1645 :     DWORD bitSetCount = 0;

  00007	33 f6		 xor	 esi, esi

; 1646 :     ULONG_PTR bitTest = (ULONG_PTR)1 << LSHIFT;

  00009	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR tv152[ebp], 16 ; 00000010H
  00010	8b d9		 mov	 ebx, ecx
  00012	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H

; 1647 :     DWORD i;
; 1648 : 
; 1649 :     for (i = 0; i <= LSHIFT; ++i)

  00017	33 ff		 xor	 edi, edi
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@CountSetBi:

; 1650 :     {
; 1651 :         bitSetCount += ((bitMask & bitTest) ? 1 : 0);

  00020	8b c2		 mov	 eax, edx
  00022	23 c3		 and	 eax, ebx
  00024	f7 d8		 neg	 eax
  00026	1b c0		 sbb	 eax, eax

; 1652 :         bitTest /= 2;

  00028	d1 ea		 shr	 edx, 1
  0002a	f7 d8		 neg	 eax
  0002c	8b ca		 mov	 ecx, edx
  0002e	23 cb		 and	 ecx, ebx
  00030	03 f0		 add	 esi, eax
  00032	f7 d9		 neg	 ecx
  00034	1b c9		 sbb	 ecx, ecx
  00036	d1 ea		 shr	 edx, 1
  00038	f7 d9		 neg	 ecx
  0003a	03 f9		 add	 edi, ecx
  0003c	83 6d fc 01	 sub	 DWORD PTR tv152[ebp], 1
  00040	75 de		 jne	 SHORT $LL4@CountSetBi

; 1653 :     }
; 1654 : 
; 1655 :     return bitSetCount;

  00042	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx

; 1656 : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?CountSetBits@@YAKK@Z ENDP				; CountSetBits
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_tickStart$2$ = -92					; size = 4
_tickStart$1$ = -88					; size = 4
tv660 = -84						; size = 4
_buffer$1$ = -80					; size = 4
tv663 = -76						; size = 4
_numaNodeCount$1$ = -72					; size = 4
_processorL3CacheCount$1$ = -68				; size = 4
_logicalProcessorCount$1$ = -64				; size = 4
_processorCoreCount$1$ = -60				; size = 4
_processorPackageCount$1$ = -56				; size = 4
_processorL2CacheCount$1$ = -52				; size = 4
_processorL1CacheCount$1$ = -48				; size = 4
_returnLength$ = -44					; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?SystemLogicalProcessorInforamtion@@YGIPAX@Z PROC	; SystemLogicalProcessorInforamtion

; 1659 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SystemLogicalProcessorInforamtion@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1660 :     Log(LOG_DEBUG, __LINE__, ">> SysLogProcInfo (%p)", lpData);

  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MFPGFEAK@?$DO?$DO?5SysLogProcInfo?5?$CI?$CFp?$CJ@
  00034	68 7c 06 00 00	 push	 1660			; 0000067cH
  00039	6a 10		 push	 16			; 00000010H
  0003b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00040	83 c4 10	 add	 esp, 16			; 00000010H

; 1661 : 
; 1662 :     BOOL done = FALSE;
; 1663 :     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;

  00043	33 f6		 xor	 esi, esi
  00045	89 75 b0	 mov	 DWORD PTR _buffer$1$[ebp], esi

; 1664 :     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = NULL;
; 1665 :     DWORD returnLength = 0;

  00048	89 75 d4	 mov	 DWORD PTR _returnLength$[ebp], esi

; 1666 :     PCACHE_DESCRIPTOR Cache;
; 1667 : 
; 1668 :     uint64_t const tickStart = SysTick();

  0004b	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1669 : 
; 1670 :     LPFN_GLPI glpi = (LPFN_GLPI)GetProcAddress(GetModuleHandle("kernel32"), "GetLogicalProcessorInformation");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@KHGALBC@GetLogicalProcessorInformation@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_08PNLNEKOB@kernel32@
  0005a	89 45 a4	 mov	 DWORD PTR _tickStart$2$[ebp], eax
  0005d	89 55 a8	 mov	 DWORD PTR _tickStart$1$[ebp], edx
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0006d	8b f8		 mov	 edi, eax

; 1671 :     if (nullptr == glpi)

  0006f	85 ff		 test	 edi, edi
  00071	75 23		 jne	 SHORT $LN131@SystemLogi

; 1672 :     {
; 1673 :         Log(LOG_DEBUG, __LINE__, "<< SysLogProcInfo, Out, Unsupp GetLogicalProcessorInformation");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@CNICBAHJ@?$DM?$DM?5SysLogProcInfo?0?5Out?0?5Unsupp?5@
  00078	68 89 06 00 00	 push	 1673			; 00000689H
  0007d	6a 10		 push	 16			; 00000010H
  0007f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1674 :         _endthreadex(ERROR_NOT_SUPPORTED);

  00084	6a 32		 push	 50			; 00000032H
  00086	e8 00 00 00 00	 call	 __endthreadex
  0008b	83 c4 10	 add	 esp, 16			; 00000010H

; 1675 :         return ERROR_NOT_SUPPORTED;

  0008e	8d 46 32	 lea	 eax, DWORD PTR [esi+50]
  00091	e9 81 02 00 00	 jmp	 $LN1@SystemLogi
$LN131@SystemLogi:
  00096	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetLastError@0
  0009c	0f 1f 40 00	 npad	 4
$LL2@SystemLogi:

; 1676 :     }
; 1677 : 
; 1678 :     while (!done)
; 1679 :     {
; 1680 :         DWORD rc = glpi(buffer, &returnLength);

  000a0	8d 45 d4	 lea	 eax, DWORD PTR _returnLength$[ebp]
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	ff d7		 call	 edi

; 1681 : 
; 1682 :         if (FALSE == rc)

  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 c1 00 00
	00		 jne	 $LN117@SystemLogi

; 1683 :         {
; 1684 :             DWORD const dwLastError = GetLastError();

  000af	ff d3		 call	 ebx

; 1685 :             if (dwLastError == ERROR_INSUFFICIENT_BUFFER)

  000b1	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  000b4	75 3a		 jne	 SHORT $LN11@SystemLogi

; 1686 :             {
; 1687 :                 if (buffer)

  000b6	85 f6		 test	 esi, esi
  000b8	74 09		 je	 SHORT $LN13@SystemLogi

; 1688 :                     free(buffer);

  000ba	56		 push	 esi
  000bb	e8 00 00 00 00	 call	 _free
  000c0	83 c4 04	 add	 esp, 4
$LN13@SystemLogi:

; 1689 : 
; 1690 :                 buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(returnLength);

  000c3	ff 75 d4	 push	 DWORD PTR _returnLength$[ebp]
  000c6	e8 00 00 00 00	 call	 _malloc
  000cb	8b f0		 mov	 esi, eax
  000cd	83 c4 04	 add	 esp, 4
  000d0	89 75 b0	 mov	 DWORD PTR _buffer$1$[ebp], esi

; 1691 :                 if (nullptr == buffer)

  000d3	85 f6		 test	 esi, esi
  000d5	75 c9		 jne	 SHORT $LL2@SystemLogi

; 1692 :                 {
; 1693 :                     Log(LOG_DEBUG, __LINE__, "-- SysLogProcInfo, Allocation failure");

  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@LHEIAGGO@?9?9?5SysLogProcInfo?0?5Allocation?5f@
  000dc	68 9d 06 00 00	 push	 1693			; 0000069dH
  000e1	6a 10		 push	 16			; 00000010H
  000e3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :                     break;

  000eb	e9 f8 01 00 00	 jmp	 $LN15@SystemLogi
$LN11@SystemLogi:

; 1699 :                 Log(LOG_DEBUG, __LINE__, "-- SysLogProcInfo, GLPI %s", GetLastErrorMessage(dwLastError).c_str());

  000f0	8b d0		 mov	 edx, eax
  000f2	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  000f5	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  000fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00101	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00105	72 02		 jb	 SHORT $LN36@SystemLogi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00107	8b 00		 mov	 eax, DWORD PTR [eax]
$LN36@SystemLogi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1699 :                 Log(LOG_DEBUG, __LINE__, "-- SysLogProcInfo, GLPI %s", GetLastErrorMessage(dwLastError).c_str());

  00109	50		 push	 eax
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KHIEGLFN@?9?9?5SysLogProcInfo?0?5GLPI?5?$CFs@
  0010f	68 a3 06 00 00	 push	 1699			; 000006a3H
  00114	6a 10		 push	 16			; 00000010H
  00116	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0011b	83 c4 10	 add	 esp, 16			; 00000010H
  0011e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00125	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  00128	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0012b	72 2c		 jb	 SHORT $LN84@SystemLogi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012d	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00130	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00131	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00133	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00139	72 14		 jb	 SHORT $LN83@SystemLogi

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0013b	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0013e	83 c2 23	 add	 edx, 35			; 00000023H
  00141	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00143	83 c0 fc	 add	 eax, -4			; fffffffcH
  00146	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00149	0f 87 e6 01 00
	00		 ja	 $LN138@SystemLogi
$LN83@SystemLogi:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014f	52		 push	 edx
  00150	51		 push	 ecx
  00151	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00156	83 c4 08	 add	 esp, 8
$LN84@SystemLogi:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00159	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00160	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00167	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1709 :     if (done)

  0016b	e9 78 01 00 00	 jmp	 $LN15@SystemLogi
$LN117@SystemLogi:

; 1710 :     {
; 1711 :         DWORD logicalProcessorCount = 0;
; 1712 :         DWORD numaNodeCount = 0;
; 1713 :         DWORD processorCoreCount = 0;
; 1714 :         DWORD processorL1CacheCount = 0;

  00170	33 d2		 xor	 edx, edx
  00172	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _logicalProcessorCount$1$[ebp], 0
  00179	33 ff		 xor	 edi, edi
  0017b	89 55 d0	 mov	 DWORD PTR _processorL1CacheCount$1$[ebp], edx

; 1715 :         DWORD processorL2CacheCount = 0;

  0017e	33 db		 xor	 ebx, ebx
  00180	89 7d b8	 mov	 DWORD PTR _numaNodeCount$1$[ebp], edi
  00183	89 7d c4	 mov	 DWORD PTR _processorCoreCount$1$[ebp], edi
  00186	89 5d cc	 mov	 DWORD PTR _processorL2CacheCount$1$[ebp], ebx

; 1716 :         DWORD processorL3CacheCount = 0;

  00189	89 55 bc	 mov	 DWORD PTR _processorL3CacheCount$1$[ebp], edx

; 1717 :         DWORD processorPackageCount = 0;

  0018c	89 55 c8	 mov	 DWORD PTR _processorPackageCount$1$[ebp], edx

; 1718 :         ptr = buffer;
; 1719 : 
; 1720 :         if (ptr)

  0018f	85 f6		 test	 esi, esi
  00191	0f 84 ce 00 00
	00		 je	 $LN5@SystemLogi

; 1721 :         {
; 1722 :             DWORD byteOffset = 0;
; 1723 :             while (byteOffset + sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) <= returnLength)

  00197	83 7d d4 18	 cmp	 DWORD PTR _returnLength$[ebp], 24 ; 00000018H
  0019b	0f 82 c4 00 00
	00		 jb	 $LN5@SystemLogi
  001a1	8b 4d d4	 mov	 ecx, DWORD PTR _returnLength$[ebp]
  001a4	8d 5e 08	 lea	 ebx, DWORD PTR [esi+8]
  001a7	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  001ac	89 5d b4	 mov	 DWORD PTR tv663[ebp], ebx
  001af	2b c6		 sub	 eax, esi
  001b1	89 45 ac	 mov	 DWORD PTR tv660[ebp], eax
$LL4@SystemLogi:

; 1724 :             {
; 1725 :                 switch (ptr->Relationship)

  001b4	8b 43 fc	 mov	 eax, DWORD PTR [ebx-4]
  001b7	83 f8 03	 cmp	 eax, 3
  001ba	77 75		 ja	 SHORT $LN26@SystemLogi
  001bc	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN139@SystemLogi[eax*4]
$LN17@SystemLogi:

; 1726 :                 {
; 1727 :                 case RelationNumaNode:
; 1728 :                     // Non-NUMA systems report a single record of this type.
; 1729 :                     numaNodeCount++;

  001c3	47		 inc	 edi
  001c4	89 7d b8	 mov	 DWORD PTR _numaNodeCount$1$[ebp], edi

; 1730 :                     break;

  001c7	e9 80 00 00 00	 jmp	 $LN6@SystemLogi
$LN18@SystemLogi:

; 1731 : 
; 1732 :                 case RelationProcessorCore:
; 1733 :                     processorCoreCount++;

  001cc	ff 45 c4	 inc	 DWORD PTR _processorCoreCount$1$[ebp]

; 1645 :     DWORD bitSetCount = 0;

  001cf	33 d2		 xor	 edx, edx

; 1650 :     {
; 1651 :         bitSetCount += ((bitMask & bitTest) ? 1 : 0);

  001d1	8b 5b f8	 mov	 ebx, DWORD PTR [ebx-8]
  001d4	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001d9	33 ff		 xor	 edi, edi

; 1731 : 
; 1732 :                 case RelationProcessorCore:
; 1733 :                     processorCoreCount++;

  001db	8d 72 10	 lea	 esi, DWORD PTR [edx+16]
  001de	66 90		 npad	 2
$LL102@SystemLogi:

; 1651 :         bitSetCount += ((bitMask & bitTest) ? 1 : 0);

  001e0	8b c3		 mov	 eax, ebx
  001e2	23 c1		 and	 eax, ecx
  001e4	f7 d8		 neg	 eax
  001e6	1b c0		 sbb	 eax, eax

; 1652 :         bitTest /= 2;

  001e8	d1 e9		 shr	 ecx, 1
  001ea	f7 d8		 neg	 eax
  001ec	03 d0		 add	 edx, eax
  001ee	8b c3		 mov	 eax, ebx
  001f0	23 c1		 and	 eax, ecx
  001f2	f7 d8		 neg	 eax
  001f4	1b c0		 sbb	 eax, eax
  001f6	d1 e9		 shr	 ecx, 1
  001f8	f7 d8		 neg	 eax
  001fa	03 f8		 add	 edi, eax
  001fc	83 ee 01	 sub	 esi, 1
  001ff	75 df		 jne	 SHORT $LL102@SystemLogi

; 1737 :                     break;

  00201	8b 5d b4	 mov	 ebx, DWORD PTR tv663[ebp]

; 1649 :     for (i = 0; i <= LSHIFT; ++i)

  00204	03 d7		 add	 edx, edi

; 1734 : 
; 1735 :                     // A hyperthreaded core supplies more than one logical processor.
; 1736 :                     logicalProcessorCount += CountSetBits(ptr->ProcessorMask);

  00206	01 55 c0	 add	 DWORD PTR _logicalProcessorCount$1$[ebp], edx

; 1737 :                     break;

  00209	8b 7d b8	 mov	 edi, DWORD PTR _numaNodeCount$1$[ebp]
  0020c	eb 38		 jmp	 SHORT $LN136@SystemLogi
$LN19@SystemLogi:

; 1738 : 
; 1739 :                 case RelationCache:
; 1740 :                     // Cache data is in ptr->Cache, one CACHE_DESCRIPTOR structure for each cache. 
; 1741 :                     Cache = &ptr->Cache;
; 1742 :                     if (Cache->Level == 1)

  0020e	8a 03		 mov	 al, BYTE PTR [ebx]
  00210	3c 01		 cmp	 al, 1
  00212	75 06		 jne	 SHORT $LN20@SystemLogi

; 1743 :                     {
; 1744 :                         processorL1CacheCount++;

  00214	42		 inc	 edx
  00215	89 55 d0	 mov	 DWORD PTR _processorL1CacheCount$1$[ebp], edx
  00218	eb 32		 jmp	 SHORT $LN6@SystemLogi
$LN20@SystemLogi:

; 1745 :                     }
; 1746 :                     else if (Cache->Level == 2)

  0021a	3c 02		 cmp	 al, 2
  0021c	75 05		 jne	 SHORT $LN22@SystemLogi

; 1747 :                     {
; 1748 :                         processorL2CacheCount++;

  0021e	ff 45 cc	 inc	 DWORD PTR _processorL2CacheCount$1$[ebp]
  00221	eb 29		 jmp	 SHORT $LN6@SystemLogi
$LN22@SystemLogi:

; 1749 :                     }
; 1750 :                     else if (Cache->Level == 3)

  00223	3c 03		 cmp	 al, 3
  00225	75 25		 jne	 SHORT $LN6@SystemLogi

; 1751 :                     {
; 1752 :                         processorL3CacheCount++;

  00227	ff 45 bc	 inc	 DWORD PTR _processorL3CacheCount$1$[ebp]

; 1753 :                     }
; 1754 :                     break;

  0022a	eb 20		 jmp	 SHORT $LN6@SystemLogi
$LN25@SystemLogi:

; 1755 : 
; 1756 :                 case RelationProcessorPackage:
; 1757 :                     // Logical processors share a physical package.
; 1758 :                     processorPackageCount++;

  0022c	ff 45 c8	 inc	 DWORD PTR _processorPackageCount$1$[ebp]

; 1759 :                     break;

  0022f	eb 1b		 jmp	 SHORT $LN6@SystemLogi
$LN26@SystemLogi:

; 1760 : 
; 1761 :                 default:
; 1762 :                     Log(LOG_DEBUG, __LINE__, "-- SysLogProcInfo, Unsupp LOGICAL_PROCESSOR_RELATIONSHIP value %d", ptr->Relationship);

  00231	50		 push	 eax
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@BGADHKMF@?9?9?5SysLogProcInfo?0?5Unsupp?5LOGIC@
  00237	68 e2 06 00 00	 push	 1762			; 000006e2H
  0023c	6a 10		 push	 16			; 00000010H
  0023e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00243	83 c4 10	 add	 esp, 16			; 00000010H
$LN136@SystemLogi:

; 1763 :                     break;
; 1764 :                 }
; 1765 :                 byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
; 1766 :                 ptr++;

  00246	8b 55 d0	 mov	 edx, DWORD PTR _processorL1CacheCount$1$[ebp]
  00249	8b 4d d4	 mov	 ecx, DWORD PTR _returnLength$[ebp]
$LN6@SystemLogi:
  0024c	8b 45 ac	 mov	 eax, DWORD PTR tv660[ebp]
  0024f	83 c3 18	 add	 ebx, 24			; 00000018H
  00252	03 c3		 add	 eax, ebx
  00254	89 5d b4	 mov	 DWORD PTR tv663[ebp], ebx
  00257	3b c1		 cmp	 eax, ecx
  00259	0f 86 55 ff ff
	ff		 jbe	 $LL4@SystemLogi
  0025f	8b 75 b0	 mov	 esi, DWORD PTR _buffer$1$[ebp]
  00262	8b 5d cc	 mov	 ebx, DWORD PTR _processorL2CacheCount$1$[ebp]
$LN5@SystemLogi:

; 1767 :             }
; 1768 :         }
; 1769 : 
; 1770 :         Log(LOG_HEADER, __LINE__, "Logical Processor(s) Information");

  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@ECHENMHH@Logical?5Processor?$CIs?$CJ?5Informatio@
  0026a	68 ea 06 00 00	 push	 1770			; 000006eaH
  0026f	6a 02		 push	 2
  00271	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1771 :         Log(LOG_MESSAGE, __LINE__, "Number of NUMA nodes: %d", numaNodeCount);

  00276	57		 push	 edi
  00277	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CBGNJNLO@Number?5of?5NUMA?5nodes?3?5?$CFd@
  0027c	68 eb 06 00 00	 push	 1771			; 000006ebH
  00281	6a 01		 push	 1
  00283	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1772 :         Log(LOG_MESSAGE, __LINE__, "Number of physical processor packages: %d", processorPackageCount);

  00288	ff 75 c8	 push	 DWORD PTR _processorPackageCount$1$[ebp]
  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@CIFFOGGE@Number?5of?5physical?5processor?5pa@
  00290	68 ec 06 00 00	 push	 1772			; 000006ecH
  00295	6a 01		 push	 1
  00297	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1773 :         Log(LOG_MESSAGE, __LINE__, "Number of processor cores: %d", processorCoreCount);

  0029c	ff 75 c4	 push	 DWORD PTR _processorCoreCount$1$[ebp]
  0029f	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@JLJNFPPO@Number?5of?5processor?5cores?3?5?$CFd@
  002a4	68 ed 06 00 00	 push	 1773			; 000006edH
  002a9	6a 01		 push	 1
  002ab	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1774 :         Log(LOG_MESSAGE, __LINE__, "Number of logical processors: %d", logicalProcessorCount);

  002b0	ff 75 c0	 push	 DWORD PTR _logicalProcessorCount$1$[ebp]
  002b3	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@NEBFNBCF@Number?5of?5logical?5processors?3?5?$CF@
  002b8	68 ee 06 00 00	 push	 1774			; 000006eeH
  002bd	6a 01		 push	 1
  002bf	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002c4	83 c4 4c	 add	 esp, 76			; 0000004cH

; 1775 :         Log(LOG_MESSAGE, __LINE__, "Number of processor L1/L2/L3 caches: %d/%d/%d", processorL1CacheCount, processorL2CacheCount, processorL3CacheCount);

  002c7	ff 75 bc	 push	 DWORD PTR _processorL3CacheCount$1$[ebp]
  002ca	53		 push	 ebx
  002cb	ff 75 d0	 push	 DWORD PTR _processorL1CacheCount$1$[ebp]
  002ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JLHKKOJE@Number?5of?5processor?5L1?1L2?1L3?5ca@
  002d3	68 ef 06 00 00	 push	 1775			; 000006efH
  002d8	6a 01		 push	 1
  002da	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1776 : 
; 1777 :         free(buffer);

  002df	56		 push	 esi
  002e0	e8 00 00 00 00	 call	 _free
  002e5	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN15@SystemLogi:

; 1778 :     }
; 1779 : 
; 1780 :     LogElapsedTime(__LINE__, tickStart);

  002e8	ff 75 a8	 push	 DWORD PTR _tickStart$1$[ebp]
  002eb	33 d2		 xor	 edx, edx
  002ed	b9 f4 06 00 00	 mov	 ecx, 1780		; 000006f4H
  002f2	ff 75 a4	 push	 DWORD PTR _tickStart$2$[ebp]
  002f5	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1781 : 
; 1782 :     Log(LOG_DEBUG, __LINE__, "<< SysLogProcInfo");

  002fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BKCMKMCI@?$DM?$DM?5SysLogProcInfo@
  002ff	68 f6 06 00 00	 push	 1782			; 000006f6H
  00304	6a 10		 push	 16			; 00000010H
  00306	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1783 :     _endthreadex(0);

  0030b	6a 00		 push	 0
  0030d	e8 00 00 00 00	 call	 __endthreadex
  00312	83 c4 18	 add	 esp, 24			; 00000018H

; 1784 :     return 0;

  00315	33 c0		 xor	 eax, eax
$LN1@SystemLogi:

; 1785 : }      

  00317	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0031a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00321	59		 pop	 ecx
  00322	5f		 pop	 edi
  00323	5e		 pop	 esi
  00324	5b		 pop	 ebx
  00325	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00328	33 cd		 xor	 ecx, ebp
  0032a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032f	8b e5		 mov	 esp, ebp
  00331	5d		 pop	 ebp
  00332	c2 04 00	 ret	 4
$LN138@SystemLogi:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00335	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN135@SystemLogi:
  0033a	66 90		 npad	 2
$LN139@SystemLogi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1785 : }      

  0033c	00 00 00 00	 DD	 $LN18@SystemLogi
  00340	00 00 00 00	 DD	 $LN17@SystemLogi
  00344	00 00 00 00	 DD	 $LN19@SystemLogi
  00348	00 00 00 00	 DD	 $LN25@SystemLogi
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SystemLogicalProcessorInforamtion@@YGIPAX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?SystemLogicalProcessorInforamtion@@YGIPAX@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SystemLogicalProcessorInforamtion@@YGIPAX@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SystemLogicalProcessorInforamtion@@YGIPAX@Z ENDP	; SystemLogicalProcessorInforamtion
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_tickStart$1$ = -10064					; size = 4
_tickStart$2$ = -10060					; size = 4
_drivers$ = -10056					; size = 12
_cbNeeded$ = -10044					; size = 4
$T2 = -10040						; size = 24
_szDriver$3 = -10016					; size = 5000
_szFile$4 = -5016					; size = 5000
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?DeviceDrivers@@YGIPAX@Z PROC				; DeviceDrivers

; 1791 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DeviceDrivers@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	b8 44 27 00 00	 mov	 eax, 10052		; 00002744H
  00016	e8 00 00 00 00	 call	 __chkstk
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	53		 push	 ebx
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1792 :     Log(LOG_DEBUG, __LINE__, ">> DevDrvs (%p)", lpData);

  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HKMBGJGH@?$DO?$DO?5DevDrvs?5?$CI?$CFp?$CJ@
  0003b	68 00 07 00 00	 push	 1792			; 00000700H
  00040	6a 10		 push	 16			; 00000010H
  00042	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1793 : 
; 1794 :     const int DriveArraySize = 5000;
; 1795 :     std::vector<LPVOID> drivers(DriveArraySize);

  00047	83 c4 08	 add	 esp, 8
  0004a	8d 8d b8 d8 ff
	ff		 lea	 ecx, DWORD PTR _drivers$[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1796 :     DWORD cbNeeded = 0;

  0005c	c7 85 c4 d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _cbNeeded$[ebp], 0

; 1798 :     uint64_t tickStart = SysTick();

  00066	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  0006b	8b 9d bc d8 ff
	ff		 mov	 ebx, DWORD PTR _drivers$[ebp+4]
  00071	8b b5 b8 d8 ff
	ff		 mov	 esi, DWORD PTR _drivers$[ebp]
  00077	2b de		 sub	 ebx, esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1798 :     uint64_t tickStart = SysTick();

  00079	89 85 b0 d8 ff
	ff		 mov	 DWORD PTR _tickStart$1$[ebp], eax

; 1801 :     if (EnumDeviceDrivers(&drivers[0], size, &cbNeeded) && (cbNeeded < size))

  0007f	8d 85 c4 d8 ff
	ff		 lea	 eax, DWORD PTR _cbNeeded$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00085	c1 fb 02	 sar	 ebx, 2
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1801 :     if (EnumDeviceDrivers(&drivers[0], size, &cbNeeded) && (cbNeeded < size))

  00088	50		 push	 eax
  00089	83 c3 04	 add	 ebx, 4
  0008c	89 95 b4 d8 ff
	ff		 mov	 DWORD PTR _tickStart$2$[ebp], edx
  00092	53		 push	 ebx
  00093	56		 push	 esi
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32EnumDeviceDrivers@12
  0009a	8b bd c4 d8 ff
	ff		 mov	 edi, DWORD PTR _cbNeeded$[ebp]
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 aa 00 00
	00		 je	 $LN5@DeviceDriv
  000a8	3b fb		 cmp	 edi, ebx
  000aa	0f 83 a2 00 00
	00		 jae	 $LN5@DeviceDriv

; 1802 :     {
; 1803 :         size_t const cDrivers = cbNeeded / sizeof(drivers[0]);

  000b0	c1 ef 02	 shr	 edi, 2

; 1804 : 
; 1805 :         Log(LOG_HEADER, __LINE__, "Device Drivers, Number of: %d", cDrivers);

  000b3	57		 push	 edi
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@PHKHDLGJ@Device?5Drivers?0?5Number?5of?3?5?$CFd@
  000b9	68 0d 07 00 00	 push	 1805			; 0000070dH
  000be	6a 02		 push	 2
  000c0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000c5	83 c4 10	 add	 esp, 16			; 00000010H
  000c8	33 db		 xor	 ebx, ebx

; 1806 :         for (size_t i = 0; i < cDrivers; i++)

  000ca	85 ff		 test	 edi, edi
  000cc	0f 84 11 01 00
	00		 je	 $LN107@DeviceDriv
$LL4@DeviceDriv:

; 1807 :         {
; 1808 :             char szDriver[DriveArraySize] = { 0 };

  000d2	68 88 13 00 00	 push	 5000			; 00001388H
  000d7	8d 85 e0 d8 ff
	ff		 lea	 eax, DWORD PTR _szDriver$3[ebp]
  000dd	6a 00		 push	 0
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 _memset

; 1809 :             char szFile[DriveArraySize] = { 0 };

  000e5	68 88 13 00 00	 push	 5000			; 00001388H
  000ea	8d 85 68 ec ff
	ff		 lea	 eax, DWORD PTR _szFile$4[ebp]
  000f0	6a 00		 push	 0
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _memset
  000f8	83 c4 18	 add	 esp, 24			; 00000018H

; 1810 : 
; 1811 :             GetDeviceDriverBaseName(drivers[i], szDriver, sizeof(szDriver) / sizeof(szDriver[0]));

  000fb	8d 85 e0 d8 ff
	ff		 lea	 eax, DWORD PTR _szDriver$3[ebp]
  00101	68 88 13 00 00	 push	 5000			; 00001388H
  00106	50		 push	 eax
  00107	ff 34 9e	 push	 DWORD PTR [esi+ebx*4]
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetDeviceDriverBaseNameA@12

; 1812 :             GetDeviceDriverFileName(drivers[i], szFile, sizeof(szFile) / sizeof(szFile[0]));

  00110	68 88 13 00 00	 push	 5000			; 00001388H
  00115	8d 85 68 ec ff
	ff		 lea	 eax, DWORD PTR _szFile$4[ebp]
  0011b	50		 push	 eax
  0011c	ff 34 9e	 push	 DWORD PTR [esi+ebx*4]
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetDeviceDriverFileNameA@12

; 1813 : 
; 1814 :             Log(LOG_MESSAGE, __LINE__, "> %.3zu, %s, %s", i + 1, szDriver, szFile);

  00125	8d 85 68 ec ff
	ff		 lea	 eax, DWORD PTR _szFile$4[ebp]
  0012b	43		 inc	 ebx
  0012c	50		 push	 eax
  0012d	8d 85 e0 d8 ff
	ff		 lea	 eax, DWORD PTR _szDriver$3[ebp]
  00133	50		 push	 eax
  00134	53		 push	 ebx
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DGAJHBGD@?$DO?5?$CF?43zu?0?5?$CFs?0?5?$CFs@
  0013a	68 16 07 00 00	 push	 1814			; 00000716H
  0013f	6a 01		 push	 1
  00141	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	3b df		 cmp	 ebx, edi
  0014b	72 85		 jb	 SHORT $LL4@DeviceDriv

; 1815 :         }
; 1816 :     }
; 1817 :     else

  0014d	e9 91 00 00 00	 jmp	 $LN107@DeviceDriv
$LN5@DeviceDriv:

; 1819 :         Log(LOG_HEADER, __LINE__, "DevDrvs, EnumDeviceDrivers %s (array size needed %u)", GetLastErrorMessage(GetLastError()).c_str(), cbNeeded / sizeof(LPVOID));

  00152	c1 ef 02	 shr	 edi, 2
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0015b	8b d0		 mov	 edx, eax
  0015d	8d 8d c8 d8 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00163	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00168	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0016c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00170	72 02		 jb	 SHORT $LN57@DeviceDriv
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00172	8b 00		 mov	 eax, DWORD PTR [eax]
$LN57@DeviceDriv:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1819 :         Log(LOG_HEADER, __LINE__, "DevDrvs, EnumDeviceDrivers %s (array size needed %u)", GetLastErrorMessage(GetLastError()).c_str(), cbNeeded / sizeof(LPVOID));

  00174	57		 push	 edi
  00175	50		 push	 eax
  00176	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@CJPNLIJE@DevDrvs?0?5EnumDeviceDrivers?5?$CFs?5?$CI@
  0017b	68 1b 07 00 00	 push	 1819			; 0000071bH
  00180	6a 02		 push	 2
  00182	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00187	83 c4 14	 add	 esp, 20			; 00000014H
  0018a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0018e	8b 95 dc d8 ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+20]
  00194	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00197	72 2f		 jb	 SHORT $LN105@DeviceDriv
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00199	8b 8d c8 d8 ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0019f	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001a0	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001a2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001a8	72 14		 jb	 SHORT $LN104@DeviceDriv

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001aa	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001ad	83 c2 23	 add	 edx, 35			; 00000023H
  001b0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b2	83 c0 fc	 add	 eax, -4			; fffffffcH
  001b5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001b8	0f 87 d0 00 00
	00		 ja	 $LN247@DeviceDriv
$LN104@DeviceDriv:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001be	52		 push	 edx
  001bf	51		 push	 ecx
  001c0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001c5	83 c4 08	 add	 esp, 8
$LN105@DeviceDriv:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  001c8	c7 85 d8 d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001d2	c7 85 dc d8 ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001dc	c6 85 c8 d8 ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
$LN107@DeviceDriv:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1822 :     LogElapsedTime(__LINE__, tickStart);

  001e3	ff b5 b4 d8 ff
	ff		 push	 DWORD PTR _tickStart$2$[ebp]
  001e9	33 d2		 xor	 edx, edx
  001eb	b9 1e 07 00 00	 mov	 ecx, 1822		; 0000071eH
  001f0	ff b5 b0 d8 ff
	ff		 push	 DWORD PTR _tickStart$1$[ebp]
  001f6	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1823 : 
; 1824 :     Log(LOG_DEBUG, __LINE__, "<< DevDrvs");

  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@NHDPJOBN@?$DM?$DM?5DevDrvs@
  00200	68 20 07 00 00	 push	 1824			; 00000720H
  00205	6a 10		 push	 16			; 00000010H
  00207	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1825 :     _endthreadex(0);

  0020c	6a 00		 push	 0
  0020e	e8 00 00 00 00	 call	 __endthreadex
  00213	83 c4 18	 add	 esp, 24			; 00000018H

; 1826 :     return 0;

  00216	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  0021d	85 f6		 test	 esi, esi
  0021f	74 4d		 je	 SHORT $LN141@DeviceDriv

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00221	8b 8d c0 d8 ff
	ff		 mov	 ecx, DWORD PTR _drivers$[ebp+8]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00227	8b c6		 mov	 eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00229	2b ce		 sub	 ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0022b	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0022e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00234	72 10		 jb	 SHORT $LN217@DeviceDriv

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00236	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  00239	83 c1 23	 add	 ecx, 35			; 00000023H
  0023c	2b c6		 sub	 eax, esi

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0023e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00241	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00244	77 4d		 ja	 SHORT $LN248@DeviceDriv
$LN217@DeviceDriv:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00246	51		 push	 ecx
  00247	56		 push	 esi
  00248	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0024d	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00250	c7 85 b8 d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivers$[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  0025a	c7 85 bc d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivers$[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  00264	c7 85 c0 d8 ff
	ff 00 00 00 00	 mov	 DWORD PTR _drivers$[ebp+8], 0
$LN141@DeviceDriv:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1826 :     return 0;

  0026e	33 c0		 xor	 eax, eax

; 1827 : }

  00270	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00273	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0027a	59		 pop	 ecx
  0027b	5f		 pop	 edi
  0027c	5e		 pop	 esi
  0027d	5b		 pop	 ebx
  0027e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00281	33 cd		 xor	 ecx, ebp
  00283	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c2 04 00	 ret	 4
$LN247@DeviceDriv:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0028e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN248@DeviceDriv:
  00293	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN245@DeviceDriv:
  00298	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DeviceDrivers@@YGIPAX@Z$0:
  00000	8d 8d b8 d8 ff
	ff		 lea	 ecx, DWORD PTR _drivers$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
__unwindfunclet$?DeviceDrivers@@YGIPAX@Z$1:
  0000b	8d 8d c8 d8 ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?DeviceDrivers@@YGIPAX@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a ac d8 ff
	ff		 mov	 ecx, DWORD PTR [edx-10068]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DeviceDrivers@@YGIPAX@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DeviceDrivers@@YGIPAX@Z ENDP				; DeviceDrivers
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -96						; size = 24
_perfInfo$ = -72					; size = 56
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
?PerformanceInfo@@YGIPAX@Z PROC				; PerformanceInfo

; 1833 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PerformanceInfo@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpData$[ebp]

; 1834 :     Log(LOG_DEBUG, __LINE__, ">> PerfInfo (%p)", lpData);

  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LPGMBLGN@?$DO?$DO?5PerfInfo?5?$CI?$CFp?$CJ@
  00033	68 2a 07 00 00	 push	 1834			; 0000072aH
  00038	6a 10		 push	 16			; 00000010H
  0003a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1835 : 
; 1836 :     uint64_t tickStart = SysTick();

  0003f	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 1837 : 
; 1838 :     PERFORMANCE_INFORMATION perfInfo = { 0 };

  00044	6a 38		 push	 56			; 00000038H
  00046	8b f0		 mov	 esi, eax
  00048	8b fa		 mov	 edi, edx
  0004a	8d 45 b8	 lea	 eax, DWORD PTR _perfInfo$[ebp]
  0004d	6a 00		 push	 0
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _memset
  00055	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1839 :     if (GetPerformanceInfo(&perfInfo, sizeof(PERFORMANCE_INFORMATION)))

  00058	8d 45 b8	 lea	 eax, DWORD PTR _perfInfo$[ebp]
  0005b	6a 38		 push	 56			; 00000038H
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetPerformanceInfo@8
  00064	85 c0		 test	 eax, eax
  00066	0f 84 a6 00 00
	00		 je	 $LN2@Performanc

; 1840 :     {
; 1841 :         Log(LOG_HEADER, __LINE__, "Performance Information");

  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@ECNHKKAA@Performance?5Information@
  00071	68 31 07 00 00	 push	 1841			; 00000731H
  00076	6a 02		 push	 2
  00078	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1842 :         Log(LOG_MESSAGE, __LINE__, "Commit: Total %u, Limit %u, Peak %u", perfInfo.CommitTotal, perfInfo.CommitLimit, perfInfo.CommitPeak);

  0007d	ff 75 c4	 push	 DWORD PTR _perfInfo$[ebp+12]
  00080	ff 75 c0	 push	 DWORD PTR _perfInfo$[ebp+8]
  00083	ff 75 bc	 push	 DWORD PTR _perfInfo$[ebp+4]
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@ONMEHFLA@Commit?3?5Total?5?$CFu?0?5Limit?5?$CFu?0?5Pea@
  0008b	68 32 07 00 00	 push	 1842			; 00000732H
  00090	6a 01		 push	 1
  00092	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1843 :         Log(LOG_MESSAGE, __LINE__, "Physical: Total %u, Available %u", perfInfo.PhysicalTotal, perfInfo.PhysicalAvailable);

  00097	ff 75 cc	 push	 DWORD PTR _perfInfo$[ebp+20]
  0009a	ff 75 c8	 push	 DWORD PTR _perfInfo$[ebp+16]
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KFDPCIGB@Physical?3?5Total?5?$CFu?0?5Available?5?$CF@
  000a2	68 33 07 00 00	 push	 1843			; 00000733H
  000a7	6a 01		 push	 1
  000a9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1844 :         Log(LOG_MESSAGE, __LINE__, "System Cache %u", perfInfo.SystemCache);

  000ae	ff 75 d0	 push	 DWORD PTR _perfInfo$[ebp+24]
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@DCNNFMJH@System?5Cache?5?$CFu@
  000b6	68 34 07 00 00	 push	 1844			; 00000734H
  000bb	6a 01		 push	 1
  000bd	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000c2	83 c4 48	 add	 esp, 72			; 00000048H

; 1845 :         Log(LOG_MESSAGE, __LINE__, "Kernel: Total %u, Paged %u, Nonpaged %u", perfInfo.KernelTotal, perfInfo.KernelPaged, perfInfo.KernelNonpaged);

  000c5	ff 75 dc	 push	 DWORD PTR _perfInfo$[ebp+36]
  000c8	ff 75 d8	 push	 DWORD PTR _perfInfo$[ebp+32]
  000cb	ff 75 d4	 push	 DWORD PTR _perfInfo$[ebp+28]
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@POMBEGEK@Kernel?3?5Total?5?$CFu?0?5Paged?5?$CFu?0?5Non@
  000d3	68 35 07 00 00	 push	 1845			; 00000735H
  000d8	6a 01		 push	 1
  000da	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1846 :         Log(LOG_MESSAGE, __LINE__, "Page Size %u", perfInfo.PageSize);

  000df	ff 75 e0	 push	 DWORD PTR _perfInfo$[ebp+40]
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HEDGONEI@Page?5Size?5?$CFu@
  000e7	68 36 07 00 00	 push	 1846			; 00000736H
  000ec	6a 01		 push	 1
  000ee	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1847 :         Log(LOG_MESSAGE, __LINE__, "Process %u, Handles %u, Threads %u", perfInfo.ProcessCount, perfInfo.HandleCount, perfInfo.ThreadCount);

  000f3	ff 75 ec	 push	 DWORD PTR _perfInfo$[ebp+52]
  000f6	ff 75 e4	 push	 DWORD PTR _perfInfo$[ebp+44]
  000f9	ff 75 e8	 push	 DWORD PTR _perfInfo$[ebp+48]
  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@DBCKLHBG@Process?5?$CFu?0?5Handles?5?$CFu?0?5Threads@
  00101	68 37 07 00 00	 push	 1847			; 00000737H
  00106	6a 01		 push	 1
  00108	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0010d	83 c4 40	 add	 esp, 64			; 00000040H

; 1848 :     }
; 1849 :     else

  00110	eb 7d		 jmp	 SHORT $LN63@Performanc
$LN2@Performanc:

; 1851 :         Log(LOG_HEADER, __LINE__, "PerfInfo, GetPerformanceInfo %s", GetLastErrorMessage(GetLastError()).c_str());

  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00118	8b d0		 mov	 edx, eax
  0011a	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  0011d	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00122	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00129	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0012d	72 02		 jb	 SHORT $LN13@Performanc
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0012f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN13@Performanc:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1851 :         Log(LOG_HEADER, __LINE__, "PerfInfo, GetPerformanceInfo %s", GetLastErrorMessage(GetLastError()).c_str());

  00131	50		 push	 eax
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JENOJKFE@PerfInfo?0?5GetPerformanceInfo?5?$CFs@
  00137	68 3b 07 00 00	 push	 1851			; 0000073bH
  0013c	6a 02		 push	 2
  0013e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00143	83 c4 10	 add	 esp, 16			; 00000010H
  00146	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0014d	8b 55 b4	 mov	 edx, DWORD PTR $T2[ebp+20]
  00150	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00153	72 28		 jb	 SHORT $LN61@Performanc
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00155	8b 4d a0	 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00158	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00159	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0015b	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00161	72 10		 jb	 SHORT $LN60@Performanc

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00163	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00166	83 c2 23	 add	 edx, 35			; 00000023H
  00169	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0016b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0016e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00171	77 64		 ja	 SHORT $LN79@Performanc
$LN60@Performanc:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00173	52		 push	 edx
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0017a	83 c4 08	 add	 esp, 8
$LN61@Performanc:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0017d	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00184	c7 45 b4 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0018b	c6 45 a0 00	 mov	 BYTE PTR $T2[ebp], 0
$LN63@Performanc:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1854 :     LogElapsedTime(__LINE__, tickStart);

  0018f	57		 push	 edi
  00190	56		 push	 esi
  00191	33 d2		 xor	 edx, edx
  00193	b9 3e 07 00 00	 mov	 ecx, 1854		; 0000073eH
  00198	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 1855 : 
; 1856 :     Log(LOG_DEBUG, __LINE__, "<< PerfInfo");

  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JHACCAAA@?$DM?$DM?5PerfInfo@
  001a2	68 40 07 00 00	 push	 1856			; 00000740H
  001a7	6a 10		 push	 16			; 00000010H
  001a9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1857 :     _endthreadex(0);

  001ae	6a 00		 push	 0
  001b0	e8 00 00 00 00	 call	 __endthreadex
  001b5	83 c4 18	 add	 esp, 24			; 00000018H

; 1858 :     return 0;

  001b8	33 c0		 xor	 eax, eax

; 1859 : }

  001ba	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001bd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c4	59		 pop	 ecx
  001c5	5f		 pop	 edi
  001c6	5e		 pop	 esi
  001c7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ca	33 cd		 xor	 ecx, ebp
  001cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c2 04 00	 ret	 4
$LN79@Performanc:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN77@Performanc:
  001dc	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PerformanceInfo@@YGIPAX@Z$0:
  00000	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?PerformanceInfo@@YGIPAX@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PerformanceInfo@@YGIPAX@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PerformanceInfo@@YGIPAX@Z ENDP				; PerformanceInfo
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_B$ = -56						; size = 8
_l$ = -48						; size = 4
_n$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetPrintersList@@YAHXZ PROC				; GetPrintersList

; 1892 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetPrintersList@@YAHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 110  :         pMem = nullptr;

  0002b	33 f6		 xor	 esi, esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1893 :     int l = 0, n = 0;

  0002d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _l$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 110  :         pMem = nullptr;

  00034	89 75 c8	 mov	 DWORD PTR _B$[ebp], esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1893 :     int l = 0, n = 0;

  00037	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 111  :         lMem = 0;

  0003e	89 75 cc	 mov	 DWORD PTR _B$[ebp+4], esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1894 :     PBuffer B;

  00041	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi

; 1895 : 
; 1896 :     Log(LOG_DEBUG, __LINE__, ">> GetPtrsList");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CKNBFJNB@?$DO?$DO?5GetPtrsList@
  00049	68 68 07 00 00	 push	 1896			; 00000768H
  0004e	6a 10		 push	 16			; 00000010H
  00050	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1897 : 
; 1898 :     //release printer info list
; 1899 :     if (gpPrinterInfoList)

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	85 c0		 test	 eax, eax
  0005f	74 0f		 je	 SHORT $LN5@GetPrinter

; 1900 :     {
; 1901 :         delete[] gpPrinterInfoList;

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00067	83 c4 04	 add	 esp, 4

; 1902 :         gpPrinterInfoList = nullptr;

  0006a	89 35 00 00 00
	00		 mov	 DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A, esi ; gpPrinterInfoList
$LN5@GetPrinter:

; 1903 :     }
; 1904 : 
; 1905 :     //get number of printers
; 1906 :     EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 2, NULL, l, (DWORD*)&l, (DWORD*)&n);

  00070	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__EnumPrintersA@28
  00076	8d 45 d4	 lea	 eax, DWORD PTR _n$[ebp]
  00079	50		 push	 eax
  0007a	8d 45 d0	 lea	 eax, DWORD PTR _l$[ebp]
  0007d	50		 push	 eax
  0007e	ff 75 d0	 push	 DWORD PTR _l$[ebp]
  00081	6a 00		 push	 0
  00083	6a 02		 push	 2
  00085	6a 00		 push	 0
  00087	6a 06		 push	 6
  00089	ff d3		 call	 ebx

; 1907 :     if (l == 0)

  0008b	8b 7d d0	 mov	 edi, DWORD PTR _l$[ebp]
  0008e	85 ff		 test	 edi, edi
  00090	75 0f		 jne	 SHORT $LN6@GetPrinter

; 1908 :     {
; 1909 :         Log(LOG_DEBUG, __LINE__, "<< GetPtrsList, No Printer");

  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CMACENMK@?$DM?$DM?5GetPtrsList?0?5No?5Printer@
  00097	68 75 07 00 00	 push	 1909			; 00000775H
  0009c	e9 10 02 00 00	 jmp	 $LN127@GetPrinter
$LN6@GetPrinter:

; 1910 :         return 0;
; 1911 :     }
; 1912 :     n = 0;

  000a1	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 1913 :     LPBYTE lpbPtrInfo = B._allocMem(l);

  000a8	85 ff		 test	 edi, edi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  000aa	0f 84 f7 01 00
	00		 je	 $LN124@GetPrinter

; 126  :         {
; 127  :             if (pMem)
; 128  :                 delete[] pMem;
; 129  :             lMem = len;
; 130  :             pMem = new byte[lMem];

  000b0	57		 push	 edi
  000b1	89 7d cc	 mov	 DWORD PTR _B$[ebp+4], edi
  000b4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  000b9	57		 push	 edi
  000ba	8b f0		 mov	 esi, eax
  000bc	6a 00		 push	 0
  000be	56		 push	 esi
  000bf	89 75 c8	 mov	 DWORD PTR _B$[ebp], esi
  000c2	e8 00 00 00 00	 call	 _memset
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1914 :     if (!lpbPtrInfo)

  000ca	85 f6		 test	 esi, esi
  000cc	0f 84 d5 01 00
	00		 je	 $LN124@GetPrinter

; 1917 :         return 0;
; 1918 :     }
; 1919 : 
; 1920 :     //get the printer list information
; 1921 :     if (!EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 2, lpbPtrInfo, l, (DWORD*)&l, (DWORD*)&n))

  000d2	8d 45 d4	 lea	 eax, DWORD PTR _n$[ebp]
  000d5	50		 push	 eax
  000d6	8d 45 d0	 lea	 eax, DWORD PTR _l$[ebp]
  000d9	50		 push	 eax
  000da	ff 75 d0	 push	 DWORD PTR _l$[ebp]
  000dd	56		 push	 esi
  000de	6a 02		 push	 2
  000e0	6a 00		 push	 0
  000e2	6a 06		 push	 6
  000e4	ff d3		 call	 ebx
  000e6	85 c0		 test	 eax, eax
  000e8	0f 85 80 00 00
	00		 jne	 $LN8@GetPrinter

; 1923 :         Log(LOG_DEBUG, __LINE__, "<< GetPtrsList, EnumPrinters %s", GetLastErrorMessage(GetLastError()).c_str());

  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000f4	8b d0		 mov	 edx, eax
  000f6	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  000f9	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  000fe	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00102	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00106	72 02		 jb	 SHORT $LN42@GetPrinter
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00108	8b 00		 mov	 eax, DWORD PTR [eax]
$LN42@GetPrinter:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1923 :         Log(LOG_DEBUG, __LINE__, "<< GetPtrsList, EnumPrinters %s", GetLastErrorMessage(GetLastError()).c_str());

  0010a	50		 push	 eax
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CCAKGGPA@?$DM?$DM?5GetPtrsList?0?5EnumPrinters?5?$CFs@
  00110	68 83 07 00 00	 push	 1923			; 00000783H
  00115	6a 10		 push	 16			; 00000010H
  00117	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0011c	83 c4 10	 add	 esp, 16			; 00000010H
  0011f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00123	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  00126	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00129	72 2c		 jb	 SHORT $LN90@GetPrinter
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012b	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0012e	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0012f	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00131	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00137	72 14		 jb	 SHORT $LN89@GetPrinter

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00139	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0013c	83 c2 23	 add	 edx, 35			; 00000023H
  0013f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00141	83 c0 fc	 add	 eax, -4			; fffffffcH
  00144	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00147	0f 87 b0 01 00
	00		 ja	 $LN129@GetPrinter
$LN89@GetPrinter:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0014d	52		 push	 edx
  0014e	51		 push	 ecx
  0014f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00154	83 c4 08	 add	 esp, 8
$LN90@GetPrinter:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00157	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0015e	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00165	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
  00169	e9 4d 01 00 00	 jmp	 $LN17@GetPrinter
$LN8@GetPrinter:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1928 :     size_t size = sizeof(PRINTER_INFO_LIST) + ((n - 1) * sizeof(PRINTER_INFO));

  0016e	8b 45 d4	 mov	 eax, DWORD PTR _n$[ebp]
  00171	48		 dec	 eax
  00172	69 f8 0c 03 00
	00		 imul	 edi, eax, 780
  00178	81 c7 10 03 00
	00		 add	 edi, 784		; 00000310H

; 1929 :     gpPrinterInfoList = (LP_PRINTER_INFO_LIST)new BYTE[size];

  0017e	57		 push	 edi
  0017f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00184	83 c4 04	 add	 esp, 4
  00187	a3 00 00 00 00	 mov	 DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A, eax ; gpPrinterInfoList

; 1930 :     if (!gpPrinterInfoList)

  0018c	85 c0		 test	 eax, eax
  0018e	75 0f		 jne	 SHORT $LN9@GetPrinter

; 1931 :     {
; 1932 :         Log(LOG_DEBUG, __LINE__, "<< GetPtrsList, new PrtInfoList null");

  00190	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@POBEDBNN@?$DM?$DM?5GetPtrsList?0?5new?5PrtInfoList@
  00195	68 8c 07 00 00	 push	 1932			; 0000078cH
  0019a	e9 12 01 00 00	 jmp	 $LN127@GetPrinter
$LN9@GetPrinter:

; 1933 :         return 0;
; 1934 :     }
; 1935 :     memset(gpPrinterInfoList, 0x00, size);

  0019f	57		 push	 edi
  001a0	6a 00		 push	 0
  001a2	50		 push	 eax
  001a3	e8 00 00 00 00	 call	 _memset

; 1936 : 
; 1937 :     Log(LOG_HEADER, __LINE__, "Printers Information (%d):", n);

  001a8	ff 75 d4	 push	 DWORD PTR _n$[ebp]
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DODNOLI@Printers?5Information?5?$CI?$CFd?$CJ?3@
  001b0	68 91 07 00 00	 push	 1937			; 00000791H
  001b5	6a 02		 push	 2
  001b7	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1938 :     PRINTER_INFO_2* pi2 = (PRINTER_INFO_2*)lpbPtrInfo;
; 1939 :     Log(LOG_MESSAGE, __LINE__, ">     Printer, Port, Driver, Processor, Status, Priority, Location, Share, Comment");

  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@LPLLHANM@?$DO?5?5?5?5?5Printer?0?5Port?0?5Driver?0?5Pr@
  001c1	68 93 07 00 00	 push	 1939			; 00000793H
  001c6	6a 01		 push	 1
  001c8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001cd	83 c4 28	 add	 esp, 40			; 00000028H

; 1940 :     for (int i = 0; i < n; i++)

  001d0	83 7d d4 00	 cmp	 DWORD PTR _n$[ebp], 0
  001d4	0f 8e b0 00 00
	00		 jle	 $LN3@GetPrinter

; 1933 :         return 0;
; 1934 :     }
; 1935 :     memset(gpPrinterInfoList, 0x00, size);

  001da	33 db		 xor	 ebx, ebx
  001dc	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  001df	33 f6		 xor	 esi, esi
$LL4@GetPrinter:

; 1941 :     {
; 1942 :         Log(LOG_MESSAGE, __LINE__, "> %.2d: \\\\%s\\%s,  %s, %s, %s, %u, %u, %s, %s, %s", i + 1,

  001e1	ff 77 0c	 push	 DWORD PTR [edi+12]
  001e4	8b 47 f8	 mov	 eax, DWORD PTR [edi-8]
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0P@EABBNIJO@?$DMLocalPrinter?$DO@
  001ec	ff 37		 push	 DWORD PTR [edi]
  001ee	85 c0		 test	 eax, eax
  001f0	ff 77 10	 push	 DWORD PTR [edi+16]
  001f3	0f 45 c8	 cmovne	 ecx, eax
  001f6	46		 inc	 esi
  001f7	ff 77 30	 push	 DWORD PTR [edi+48]
  001fa	ff 77 40	 push	 DWORD PTR [edi+64]
  001fd	ff 77 1c	 push	 DWORD PTR [edi+28]
  00200	ff 77 08	 push	 DWORD PTR [edi+8]
  00203	ff 77 04	 push	 DWORD PTR [edi+4]
  00206	ff 77 fc	 push	 DWORD PTR [edi-4]
  00209	51		 push	 ecx
  0020a	56		 push	 esi
  0020b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OBDCAEAF@?$DO?5?$CF?42d?3?5?2?2?$CFs?2?$CFs?0?5?5?$CFs?0?5?$CFs?0?5?$CFs?0?5?$CF@
  00210	68 96 07 00 00	 push	 1942			; 00000796H
  00215	6a 01		 push	 1
  00217	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1943 :             pi2->pServerName ? pi2->pServerName : "<LocalPrinter>", pi2->pPrinterName,
; 1944 :             pi2->pPortName, pi2->pDriverName, pi2->pPrintProcessor, pi2->Status,
; 1945 :             pi2->Priority, pi2->pLocation, pi2->pShareName, pi2->pComment);
; 1946 : 
; 1947 :         strncpy(gpPrinterInfoList->PrinterInfo[i].PrinterName, pi2->pPrinterName, _MAX_PATH - 1);

  0021c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  00221	68 03 01 00 00	 push	 259			; 00000103H
  00226	ff 77 fc	 push	 DWORD PTR [edi-4]
  00229	83 c0 04	 add	 eax, 4
  0022c	03 c3		 add	 eax, ebx
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _strncpy

; 1948 :         strncpy(gpPrinterInfoList->PrinterInfo[i].PortName, pi2->pPortName, _MAX_PATH - 1);

  00234	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  00239	83 c4 44	 add	 esp, 68			; 00000044H
  0023c	05 08 01 00 00	 add	 eax, 264		; 00000108H
  00241	03 c3		 add	 eax, ebx
  00243	68 03 01 00 00	 push	 259			; 00000103H
  00248	ff 77 04	 push	 DWORD PTR [edi+4]
  0024b	50		 push	 eax
  0024c	e8 00 00 00 00	 call	 _strncpy

; 1949 :         strncpy(gpPrinterInfoList->PrinterInfo[i].DriverName, pi2->pDriverName, _MAX_PATH - 1);

  00251	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  00256	68 03 01 00 00	 push	 259			; 00000103H
  0025b	ff 77 08	 push	 DWORD PTR [edi+8]
  0025e	05 0c 02 00 00	 add	 eax, 524		; 0000020cH
  00263	03 c3		 add	 eax, ebx
  00265	50		 push	 eax
  00266	e8 00 00 00 00	 call	 _strncpy

; 1950 :         gpPrinterInfoList->num++;

  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList

; 1951 :         pi2++;

  00270	8d 7f 54	 lea	 edi, DWORD PTR [edi+84]
  00273	83 c4 18	 add	 esp, 24			; 00000018H
  00276	81 c3 0c 03 00
	00		 add	 ebx, 780		; 0000030cH
  0027c	ff 00		 inc	 DWORD PTR [eax]
  0027e	3b 75 d4	 cmp	 esi, DWORD PTR _n$[ebp]
  00281	0f 8c 5a ff ff
	ff		 jl	 $LL4@GetPrinter
  00287	8b 75 c8	 mov	 esi, DWORD PTR _B$[ebp]
$LN3@GetPrinter:

; 1952 :     }
; 1953 : 
; 1954 :     Log(LOG_DEBUG, __LINE__, "<< GetPtrsList");

  0028a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GDDJCMON@?$DM?$DM?5GetPtrsList@
  0028f	68 a2 07 00 00	 push	 1954			; 000007a2H
  00294	6a 10		 push	 16			; 00000010H
  00296	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 1955 :     return gpPrinterInfoList->num;

  0029b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a3	8b 38		 mov	 edi, DWORD PTR [eax]
  002a5	eb 16		 jmp	 SHORT $LN18@GetPrinter
$LN124@GetPrinter:

; 1915 :     {
; 1916 :         Log(LOG_DEBUG, __LINE__, "<< GetPtrsList, new PtrInfo null");

  002a7	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@CEENFMON@?$DM?$DM?5GetPtrsList?0?5new?5PtrInfo?5nul@
  002ac	68 7c 07 00 00	 push	 1916			; 0000077cH
$LN127@GetPrinter:
  002b1	6a 10		 push	 16			; 00000010H
  002b3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002b8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@GetPrinter:
  002bb	33 ff		 xor	 edi, edi
$LN18@GetPrinter:

; 1955 :     return gpPrinterInfoList->num;

  002bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 164  :         if (pMem)

  002c4	85 f6		 test	 esi, esi
  002c6	74 10		 je	 SHORT $LN118@GetPrinter

; 165  :         {
; 166  :             delete[] pMem;

  002c8	56		 push	 esi
  002c9	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  002ce	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  002d1	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _B$[ebp], 0
$LN118@GetPrinter:

; 168  :         }
; 169  :         lMem = 0;

  002d8	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _B$[ebp+4], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1955 :     return gpPrinterInfoList->num;

  002df	8b c7		 mov	 eax, edi

; 1956 : }

  002e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002eb	59		 pop	 ecx
  002ec	5f		 pop	 edi
  002ed	5e		 pop	 esi
  002ee	5b		 pop	 ebx
  002ef	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f2	33 cd		 xor	 ecx, ebp
  002f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f9	8b e5		 mov	 esp, ebp
  002fb	5d		 pop	 ebp
  002fc	c3		 ret	 0
$LN129@GetPrinter:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002fd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN126@GetPrinter:
  00302	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetPrintersList@@YAHXZ$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _B$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1PBuffer@@QAE@XZ	; PBuffer::~PBuffer
__unwindfunclet$?GetPrintersList@@YAHXZ$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetPrintersList@@YAHXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetPrintersList@@YAHXZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetPrintersList@@YAHXZ ENDP				; GetPrintersList
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -72						; size = 4
_len$1$ = -68						; size = 4
_B$ = -64						; size = 8
_PortName$GSCopy$1$ = -56				; size = 4
_PrinterName$GSCopy$1$ = -52				; size = 4
_l$1$ = -48						; size = 4
_len$1$ = -44						; size = 4
_size$1$ = -44						; size = 4
$T3 = -40						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z PROC	; GetBinList
; _PrinterName$ = ecx
; _PortName$ = edx

; 1973 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b c2		 mov	 eax, edx
  0002c	89 45 c8	 mov	 DWORD PTR _PortName$GSCopy$1$[ebp], eax
  0002f	8b f9		 mov	 edi, ecx
  00031	89 7d cc	 mov	 DWORD PTR _PrinterName$GSCopy$1$[ebp], edi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 110  :         pMem = nullptr;

  00034	33 f6		 xor	 esi, esi
  00036	89 75 c0	 mov	 DWORD PTR _B$[ebp], esi

; 111  :         lMem = 0;

  00039	89 75 c4	 mov	 DWORD PTR _B$[ebp+4], esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1979 :     PBuffer B;

  0003c	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi

; 1980 : 
; 1981 :     Log(LOG_DEBUG, __LINE__, ">> GetBinList, Name %s, Port %s", PrinterName, PortName);

  0003f	50		 push	 eax
  00040	57		 push	 edi
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MEDOMPCD@?$DO?$DO?5GetBinList?0?5Name?5?$CFs?0?5Port?5?$CFs@
  00046	68 bd 07 00 00	 push	 1981			; 000007bdH
  0004b	6a 10		 push	 16			; 00000010H
  0004d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00052	83 c4 14	 add	 esp, 20			; 00000014H

; 1982 : 
; 1983 :     // *** bins
; 1984 :     if ((l = DeviceCapabilities(PrinterName, PortName, DC_BINS, NULL, NULL)) <= 0)

  00055	56		 push	 esi
  00056	56		 push	 esi
  00057	6a 06		 push	 6
  00059	ff 75 c8	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  0005c	57		 push	 edi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  00063	89 45 d0	 mov	 DWORD PTR _l$1$[ebp], eax
  00066	85 c0		 test	 eax, eax
  00068	0f 8f 80 00 00
	00		 jg	 $LN8@GetBinList

; 1986 :         Log(LOG_DEBUG, __LINE__, "<< GetBinList, DeviceCapabilities(DC_BINS, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00074	8b d0		 mov	 edx, eax
  00076	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00079	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  0007e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00082	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00086	72 02		 jb	 SHORT $LN37@GetBinList
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00088	8b 00		 mov	 eax, DWORD PTR [eax]
$LN37@GetBinList:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1986 :         Log(LOG_DEBUG, __LINE__, "<< GetBinList, DeviceCapabilities(DC_BINS, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  0008a	50		 push	 eax
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FGDAMBLB@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@
  00090	68 c2 07 00 00	 push	 1986			; 000007c2H
  00095	6a 10		 push	 16			; 00000010H
  00097	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0009c	83 c4 10	 add	 esp, 16			; 00000010H
  0009f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000a3	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp+20]
  000a6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000a9	72 2c		 jb	 SHORT $LN85@GetBinList
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ab	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000ae	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000af	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000b1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000b7	72 14		 jb	 SHORT $LN84@GetBinList

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000b9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000bc	83 c2 23	 add	 edx, 35			; 00000023H
  000bf	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c1	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c7	0f 87 f9 02 00
	00		 ja	 $LN284@GetBinList
$LN84@GetBinList:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000cd	52		 push	 edx
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d4	83 c4 08	 add	 esp, 8
$LN85@GetBinList:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  000d7	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000de	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000e5	c6 45 d8 00	 mov	 BYTE PTR $T5[ebp], 0
  000e9	e9 97 02 00 00	 jmp	 $LN26@GetBinList
$LN8@GetBinList:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1991 :         ppi = B._allocMem(l * sizeof(WORD));

  000ee	03 c0		 add	 eax, eax
  000f0	89 45 bc	 mov	 DWORD PTR _len$1$[ebp], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  000f3	0f 84 77 02 00
	00		 je	 $LN279@GetBinList

; 130  :             pMem = new byte[lMem];

  000f9	50		 push	 eax
  000fa	89 45 c4	 mov	 DWORD PTR _B$[ebp+4], eax
  000fd	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  00102	ff 75 bc	 push	 DWORD PTR _len$1$[ebp]
  00105	8b f0		 mov	 esi, eax
  00107	6a 00		 push	 0
  00109	56		 push	 esi
  0010a	89 75 c0	 mov	 DWORD PTR _B$[ebp], esi
  0010d	e8 00 00 00 00	 call	 _memset
  00112	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 1992 :         if (!ppi)

  00115	85 f6		 test	 esi, esi
  00117	0f 84 53 02 00
	00		 je	 $LN279@GetBinList

; 1995 :             return NULL;
; 1996 :         }
; 1997 :         else
; 1998 :         {
; 1999 :             bins = l;
; 2000 :             size_t size = sizeof(PTRDATA_INFO_LIST) + ((l - 1) * sizeof(PTRDATA_INFO));

  0011d	8b 45 d0	 mov	 eax, DWORD PTR _l$1$[ebp]
  00120	48		 dec	 eax
  00121	69 c0 10 01 00
	00		 imul	 eax, eax, 272
  00127	05 14 01 00 00	 add	 eax, 276		; 00000114H

; 2001 :             pList = (LP_PTRDATA_INFO_LIST)new BYTE[size];

  0012c	50		 push	 eax
  0012d	89 45 d4	 mov	 DWORD PTR _size$1$[ebp], eax
  00130	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00135	8b f8		 mov	 edi, eax
  00137	83 c4 04	 add	 esp, 4
  0013a	89 7d b8	 mov	 DWORD PTR $T2[ebp], edi

; 2002 :             if (!pList)

  0013d	85 ff		 test	 edi, edi
  0013f	75 12		 jne	 SHORT $LN12@GetBinList

; 2003 :             {
; 2004 :                 Log(LOG_DEBUG, __LINE__, "<< GetBinList, <%s> new PTRDATA_INFO_LIST mem null", PrinterName);

  00141	ff 75 cc	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GBLOLICC@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5PTRDATA@
  00149	68 d4 07 00 00	 push	 2004			; 000007d4H
  0014e	e9 28 02 00 00	 jmp	 $LN282@GetBinList
$LN12@GetBinList:

; 2005 :                 return NULL;
; 2006 :             }
; 2007 :             memset(pList, 0x00, size);

  00153	ff 75 d4	 push	 DWORD PTR _size$1$[ebp]
  00156	6a 00		 push	 0
  00158	57		 push	 edi
  00159	e8 00 00 00 00	 call	 _memset

; 2008 :             pList->num = bins;

  0015e	8b 45 d0	 mov	 eax, DWORD PTR _l$1$[ebp]
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
  00164	89 07		 mov	 DWORD PTR [edi], eax

; 2009 : 
; 2010 :             if ((n = DeviceCapabilities(PrinterName, PortName, DC_BINS, (LPSTR)ppi, NULL)) != l)

  00166	6a 00		 push	 0
  00168	56		 push	 esi
  00169	6a 06		 push	 6
  0016b	ff 75 c8	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  0016e	ff 75 cc	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  00177	3b 45 d0	 cmp	 eax, DWORD PTR _l$1$[ebp]
  0017a	0f 84 8a 00 00
	00		 je	 $LN13@GetBinList

; 2012 :                 Log(LOG_DEBUG, __LINE__, "<< GetBinList, DeviceCapabilities(DC_BINS, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00186	8b d0		 mov	 edx, eax
  00188	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  0018b	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00190	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00194	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00198	72 02		 jb	 SHORT $LN126@GetBinList
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0019a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN126@GetBinList:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2012 :                 Log(LOG_DEBUG, __LINE__, "<< GetBinList, DeviceCapabilities(DC_BINS, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  0019c	50		 push	 eax
  0019d	56		 push	 esi
  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@FCIPFBFM@?$DM?$DM?5GetBinList?0?5DeviceCapabiliti@
  001a3	68 dc 07 00 00	 push	 2012			; 000007dcH
  001a8	6a 10		 push	 16			; 00000010H
  001aa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001af	83 c4 14	 add	 esp, 20			; 00000014H
  001b2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001b6	8b 55 ec	 mov	 edx, DWORD PTR $T4[ebp+20]
  001b9	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001bc	72 2c		 jb	 SHORT $LN174@GetBinList
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001be	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001c1	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c2	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001c4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001ca	72 14		 jb	 SHORT $LN173@GetBinList

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001cc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001cf	83 c2 23	 add	 edx, 35			; 00000023H
  001d2	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d4	83 c0 fc	 add	 eax, -4			; fffffffcH
  001d7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001da	0f 87 eb 01 00
	00		 ja	 $LN285@GetBinList
$LN173@GetBinList:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001e0	52		 push	 edx
  001e1	51		 push	 ecx
  001e2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001e7	83 c4 08	 add	 esp, 8
$LN174@GetBinList:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2013 :                 delete[] pList;

  001ea	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  001eb	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001f2	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001f9	c6 45 d8 00	 mov	 BYTE PTR $T4[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2013 :                 delete[] pList;

  001fd	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00202	83 c4 04	 add	 esp, 4
  00205	e9 7b 01 00 00	 jmp	 $LN26@GetBinList
$LN13@GetBinList:

; 2014 :                 return NULL;
; 2015 :             }
; 2016 :             else
; 2017 :             {
; 2018 :                 for (i = 0, pw = (WORD *)ppi; i < n; i++, pw++)

  0020a	8b ce		 mov	 ecx, esi
  0020c	85 c0		 test	 eax, eax
  0020e	7e 2a		 jle	 SHORT $LN3@GetBinList
  00210	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00213	8b f8		 mov	 edi, eax
  00215	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GetBinList:

; 2019 :                 {
; 2020 :                     pList->PtrDataInfo[i].id = *pw;

  00220	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00223	8d 92 10 01 00
	00		 lea	 edx, DWORD PTR [edx+272]
  00229	89 82 f0 fe ff
	ff		 mov	 DWORD PTR [edx-272], eax
  0022f	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00232	83 ef 01	 sub	 edi, 1
  00235	75 e9		 jne	 SHORT $LL4@GetBinList
  00237	8b 7d b8	 mov	 edi, DWORD PTR $T2[ebp]
$LN3@GetBinList:

; 2021 :                 }
; 2022 :             }
; 2023 :         }
; 2024 :     }
; 2025 : 
; 2026 :     // *** binnames
; 2027 :     ppi = B._allocMem(bins * sizeof(NAME_24BYTES));

  0023a	8b 45 d0	 mov	 eax, DWORD PTR _l$1$[ebp]
  0023d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00240	c1 e0 03	 shl	 eax, 3
  00243	89 45 d4	 mov	 DWORD PTR _len$1$[ebp], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  00246	3b 45 bc	 cmp	 eax, DWORD PTR _len$1$[ebp]
  00249	76 25		 jbe	 SHORT $LN194@GetBinList

; 126  :         {
; 127  :             if (pMem)
; 128  :                 delete[] pMem;

  0024b	56		 push	 esi
  0024c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 129  :             lMem = len;

  00251	8b 45 d4	 mov	 eax, DWORD PTR _len$1$[ebp]

; 130  :             pMem = new byte[lMem];

  00254	50		 push	 eax
  00255	89 45 c4	 mov	 DWORD PTR _B$[ebp+4], eax
  00258	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  0025d	ff 75 d4	 push	 DWORD PTR _len$1$[ebp]
  00260	8b f0		 mov	 esi, eax
  00262	6a 00		 push	 0
  00264	56		 push	 esi
  00265	89 75 c0	 mov	 DWORD PTR _B$[ebp], esi
  00268	e8 00 00 00 00	 call	 _memset
  0026d	83 c4 14	 add	 esp, 20			; 00000014H
$LN194@GetBinList:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2028 :     if (!ppi)

  00270	85 f6		 test	 esi, esi
  00272	75 1c		 jne	 SHORT $LN15@GetBinList

; 2029 :     {
; 2030 :         Log(LOG_DEBUG, __LINE__, "-- GetBinList, <%s> new DC_BINNAMES mem null", PrinterName);

  00274	ff 75 cc	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00277	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@HGGHLGCE@?9?9?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINN@
  0027c	68 ee 07 00 00	 push	 2030			; 000007eeH
  00281	6a 10		 push	 16			; 00000010H
  00283	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00288	83 c4 10	 add	 esp, 16			; 00000010H

; 2031 :     }
; 2032 :     else

  0028b	e9 c9 00 00 00	 jmp	 $LN6@GetBinList
$LN15@GetBinList:

; 2033 :     {
; 2034 :         if ((n = DeviceCapabilities(PrinterName, PortName, DC_BINNAMES, (LPSTR)ppi, NULL)) != l)

  00290	6a 00		 push	 0
  00292	56		 push	 esi
  00293	6a 0c		 push	 12			; 0000000cH
  00295	ff 75 c8	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  00298	ff 75 cc	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  0029b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  002a1	8b d0		 mov	 edx, eax
  002a3	3b 55 d0	 cmp	 edx, DWORD PTR _l$1$[ebp]
  002a6	0f 84 7e 00 00
	00		 je	 $LN17@GetBinList

; 2036 :             Log(LOG_DEBUG, __LINE__, "-- GetBinList, DeviceCapabilities(DC_BINNAMES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  002ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002b2	8b d0		 mov	 edx, eax
  002b4	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  002b7	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  002bc	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002c0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  002c4	72 02		 jb	 SHORT $LN204@GetBinList
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  002c6	8b 00		 mov	 eax, DWORD PTR [eax]
$LN204@GetBinList:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2036 :             Log(LOG_DEBUG, __LINE__, "-- GetBinList, DeviceCapabilities(DC_BINNAMES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  002c8	50		 push	 eax
  002c9	56		 push	 esi
  002ca	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HABDBBMM@?9?9?5GetBinList?0?5DeviceCapabiliti@
  002cf	68 f4 07 00 00	 push	 2036			; 000007f4H
  002d4	6a 10		 push	 16			; 00000010H
  002d6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002db	83 c4 14	 add	 esp, 20			; 00000014H
  002de	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002e2	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
  002e5	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002e8	72 2c		 jb	 SHORT $LN252@GetBinList
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ea	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002ed	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ee	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002f0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002f6	72 14		 jb	 SHORT $LN251@GetBinList

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002f8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002fb	83 c2 23	 add	 edx, 35			; 00000023H
  002fe	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00300	83 c0 fc	 add	 eax, -4			; fffffffcH
  00303	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00306	0f 87 c4 00 00
	00		 ja	 $LN286@GetBinList
$LN251@GetBinList:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0030c	52		 push	 edx
  0030d	51		 push	 ecx
  0030e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00313	83 c4 08	 add	 esp, 8
$LN252@GetBinList:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00316	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0031d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00324	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2038 :         else

  00328	eb 2f		 jmp	 SHORT $LN6@GetBinList
$LN17@GetBinList:

; 2039 :         {
; 2040 :             NAME_24BYTES *pn24 = NULL;
; 2041 :             for (i = 0, pn24 = (NAME_24BYTES *)ppi; i < n; i++, pn24++)

  0032a	8b c6		 mov	 eax, esi
  0032c	85 d2		 test	 edx, edx
  0032e	7e 29		 jle	 SHORT $LN6@GetBinList
  00330	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
$LL7@GetBinList:
  00333	8d 89 10 01 00
	00		 lea	 ecx, DWORD PTR [ecx+272]
  00339	8d 40 18	 lea	 eax, DWORD PTR [eax+24]

; 2042 :             {
; 2043 :                 memcpy(pList->PtrDataInfo[i].name, pn24->name, sizeof(NAME_24BYTES));

  0033c	0f 10 40 e8	 movups	 xmm0, XMMWORD PTR [eax-24]
  00340	0f 11 81 f0 fe
	ff ff		 movups	 XMMWORD PTR [ecx-272], xmm0
  00347	f3 0f 7e 40 f8	 movq	 xmm0, QWORD PTR [eax-8]
  0034c	66 0f d6 81 00
	ff ff ff	 movq	 QWORD PTR [ecx-256], xmm0
  00354	83 ea 01	 sub	 edx, 1
  00357	75 da		 jne	 SHORT $LL7@GetBinList
$LN6@GetBinList:

; 2044 :             }
; 2045 :         }
; 2046 :     }
; 2047 : 
; 2048 :     Log(LOG_DEBUG, __LINE__, "<< GetBinList, List %p", pList);

  00359	57		 push	 edi
  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CEPOJCOE@?$DM?$DM?5GetBinList?0?5List?5?$CFp@
  0035f	68 00 08 00 00	 push	 2048			; 00000800H
  00364	6a 10		 push	 16			; 00000010H
  00366	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0036b	83 c4 10	 add	 esp, 16			; 00000010H

; 2049 :     return pList;

  0036e	eb 17		 jmp	 SHORT $LN27@GetBinList
$LN279@GetBinList:

; 1993 :         {
; 1994 :             Log(LOG_DEBUG, __LINE__, "<< GetBinList, <%s> new DC_BINS mem null", PrinterName);

  00370	57		 push	 edi
  00371	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@MFGEJMEH@?$DM?$DM?5GetBinList?0?5?$DM?$CFs?$DO?5new?5DC_BINS@
  00376	68 ca 07 00 00	 push	 1994			; 000007caH
$LN282@GetBinList:
  0037b	6a 10		 push	 16			; 00000010H
  0037d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00382	83 c4 10	 add	 esp, 16			; 00000010H
$LN26@GetBinList:
  00385	33 ff		 xor	 edi, edi
$LN27@GetBinList:

; 2049 :     return pList;

  00387	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 164  :         if (pMem)

  0038e	85 f6		 test	 esi, esi
  00390	74 10		 je	 SHORT $LN269@GetBinList

; 165  :         {
; 166  :             delete[] pMem;

  00392	56		 push	 esi
  00393	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00398	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  0039b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _B$[ebp], 0
$LN269@GetBinList:

; 168  :         }
; 169  :         lMem = 0;

  003a2	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _B$[ebp+4], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2049 :     return pList;

  003a9	8b c7		 mov	 eax, edi

; 2050 : }

  003ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003b5	59		 pop	 ecx
  003b6	5f		 pop	 edi
  003b7	5e		 pop	 esi
  003b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003bb	33 cd		 xor	 ecx, ebp
  003bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003c2	8b e5		 mov	 esp, ebp
  003c4	5d		 pop	 ebp
  003c5	c3		 ret	 0
$LN284@GetBinList:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003c6	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN285@GetBinList:
  003cb	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN286@GetBinList:
  003d0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN281@GetBinList:
  003d5	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _B$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1PBuffer@@QAE@XZ	; PBuffer::~PBuffer
__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$2:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z ENDP	; GetBinList
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_l$1$ = -4						; size = 4
?GetDeviceMode@@YAPAU_devicemodeA@@PBD0@Z PROC		; GetDeviceMode
; _DriverName$ = ecx
; $T1 = edx

; 2053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 2054 :     DEVMODE *pdm = nullptr;
; 2055 :     HANDLE hPrinter = nullptr;
; 2056 : 
; 2057 :     if (OpenPrinter(const_cast<LPSTR>(PrinterName), &hPrinter, nullptr))
; 2058 :     {
; 2059 :         long const l = DocumentProperties(NULL, hPrinter, const_cast<LPSTR>(DriverName), nullptr, nullptr, 0);

  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b fa		 mov	 edi, edx
  0000f	8b d9		 mov	 ebx, ecx
  00011	53		 push	 ebx
  00012	ff 37		 push	 DWORD PTR [edi]
  00014	6a 00		 push	 0
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DocumentPropertiesA@24

; 2060 :         pdm = reinterpret_cast<DEVMODE *>(new uint8_t[l]);

  0001c	50		 push	 eax
  0001d	89 45 fc	 mov	 DWORD PTR _l$1$[ebp], eax
  00020	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00025	8b f0		 mov	 esi, eax
  00027	83 c4 04	 add	 esp, 4

; 2061 :         if (pdm)

  0002a	85 f6		 test	 esi, esi
  0002c	74 20		 je	 SHORT $LN3@GetDeviceM

; 2062 :         {
; 2063 :             memset(pdm, 0x00, sizeof(uint8_t)*l);

  0002e	ff 75 fc	 push	 DWORD PTR _l$1$[ebp]
  00031	6a 00		 push	 0
  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 _memset
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2064 :             DocumentProperties(NULL, hPrinter, const_cast<LPSTR>(DriverName), pdm, NULL, DM_OUT_BUFFER);

  0003c	6a 02		 push	 2
  0003e	6a 00		 push	 0
  00040	56		 push	 esi
  00041	53		 push	 ebx
  00042	ff 37		 push	 DWORD PTR [edi]
  00044	6a 00		 push	 0
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DocumentPropertiesA@24

; 2065 :         }
; 2066 :     }
; 2067 :     return pdm;

  0004c	8b c6		 mov	 eax, esi
$LN3@GetDeviceM:

; 2068 : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GetDeviceMode@@YAPAU_devicemodeA@@PBD0@Z ENDP		; GetDeviceMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_size$1$ = -72						; size = 4
_B$ = -68						; size = 8
_PortName$GSCopy$1$ = -60				; size = 4
_B$2$ = -56						; size = 4
_l$1$ = -52						; size = 4
$T2 = -48						; size = 4
_len$1$ = -44						; size = 4
_PrinterName$GSCopy$1$ = -44				; size = 4
$T3 = -40						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pdm$ = 8						; size = 4
?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z PROC ; GetPaperList
; _PrinterName$ = ecx
; _PortName$ = edx

; 2071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 55 c4	 mov	 DWORD PTR _PortName$GSCopy$1$[ebp], edx
  0002d	8b c1		 mov	 eax, ecx
  0002f	89 45 d4	 mov	 DWORD PTR _PrinterName$GSCopy$1$[ebp], eax
  00032	8b 75 08	 mov	 esi, DWORD PTR _pdm$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 110  :         pMem = nullptr;

  00035	33 ff		 xor	 edi, edi
  00037	89 7d bc	 mov	 DWORD PTR _B$[ebp], edi

; 111  :         lMem = 0;

  0003a	89 7d c0	 mov	 DWORD PTR _B$[ebp+4], edi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2078 :     PBuffer B;

  0003d	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi

; 2079 : 
; 2080 :     Log(LOG_DEBUG, __LINE__, ">> GetPaperList, Name %s, Port %s", PrinterName, PortName);

  00040	52		 push	 edx
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@ONAFHJDF@?$DO?$DO?5GetPaperList?0?5Name?5?$CFs?0?5Port?5@
  00047	68 20 08 00 00	 push	 2080			; 00000820H
  0004c	6a 10		 push	 16			; 00000010H
  0004e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00053	83 c4 14	 add	 esp, 20			; 00000014H

; 2081 : 
; 2082 :     if ((l = DeviceCapabilities(PrinterName, PortName, DC_PAPERS, NULL, pdm)) <= 0)

  00056	56		 push	 esi
  00057	8b 75 d4	 mov	 esi, DWORD PTR _PrinterName$GSCopy$1$[ebp]
  0005a	57		 push	 edi
  0005b	6a 02		 push	 2
  0005d	ff 75 c4	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  00060	56		 push	 esi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  00067	89 45 cc	 mov	 DWORD PTR _l$1$[ebp], eax
  0006a	85 c0		 test	 eax, eax
  0006c	0f 8f 80 00 00
	00		 jg	 $LN11@GetPaperLi

; 2084 :         Log(LOG_DEBUG, __LINE__, "<< GetPaperList, DeviceCapabilities(DC_PAPERS, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00078	8b d0		 mov	 edx, eax
  0007a	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0007d	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00082	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00086	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0008a	72 02		 jb	 SHORT $LN45@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN45@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2084 :         Log(LOG_DEBUG, __LINE__, "<< GetPaperList, DeviceCapabilities(DC_PAPERS, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  0008e	50		 push	 eax
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CDPGKELL@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@
  00094	68 24 08 00 00	 push	 2084			; 00000824H
  00099	6a 10		 push	 16			; 00000010H
  0009b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000a0	83 c4 10	 add	 esp, 16			; 00000010H
  000a3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000a7	8b 55 ec	 mov	 edx, DWORD PTR $T6[ebp+20]
  000aa	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000ad	72 2c		 jb	 SHORT $LN93@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000af	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000b2	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b3	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000b5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000bb	72 14		 jb	 SHORT $LN92@GetPaperLi

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000bd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000c0	83 c2 23	 add	 edx, 35			; 00000023H
  000c3	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c5	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000cb	0f 87 3e 04 00
	00		 ja	 $LN370@GetPaperLi
$LN92@GetPaperLi:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000d1	52		 push	 edx
  000d2	51		 push	 ecx
  000d3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d8	83 c4 08	 add	 esp, 8
$LN93@GetPaperLi:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000e2	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000e9	c6 45 d8 00	 mov	 BYTE PTR $T6[ebp], 0
  000ed	e9 d6 03 00 00	 jmp	 $LN34@GetPaperLi
$LN11@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2089 :         ppi = B._allocMem(l * sizeof(WORD));

  000f2	03 c0		 add	 eax, eax
  000f4	89 45 c8	 mov	 DWORD PTR _B$2$[ebp], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  000f7	0f 84 b6 03 00
	00		 je	 $LN364@GetPaperLi

; 130  :             pMem = new byte[lMem];

  000fd	50		 push	 eax
  000fe	89 45 c0	 mov	 DWORD PTR _B$[ebp+4], eax
  00101	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00106	8b f8		 mov	 edi, eax
  00108	89 7d bc	 mov	 DWORD PTR _B$[ebp], edi

; 131  :             memset(pMem, 0x00, lMem);

  0010b	ff 75 c8	 push	 DWORD PTR _B$2$[ebp]
  0010e	6a 00		 push	 0
  00110	57		 push	 edi
  00111	e8 00 00 00 00	 call	 _memset
  00116	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2090 :         if (!ppi)

  00119	85 ff		 test	 edi, edi
  0011b	0f 84 92 03 00
	00		 je	 $LN364@GetPaperLi

; 2093 :             return NULL;
; 2094 :         }
; 2095 :         else
; 2096 :         {
; 2097 :             papers = l;
; 2098 :             size_t size = sizeof(PTRDATA_INFO_LIST) + ((l - 1) * sizeof(PTRDATA_INFO));

  00121	8b 45 cc	 mov	 eax, DWORD PTR _l$1$[ebp]
  00124	48		 dec	 eax
  00125	69 c0 10 01 00
	00		 imul	 eax, eax, 272
  0012b	05 14 01 00 00	 add	 eax, 276		; 00000114H

; 2099 :             pList = (LP_PTRDATA_INFO_LIST)new BYTE[size];

  00130	50		 push	 eax
  00131	89 45 b8	 mov	 DWORD PTR _size$1$[ebp], eax
  00134	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00139	83 c4 04	 add	 esp, 4
  0013c	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax

; 2100 :             if (!pList)

  0013f	85 c0		 test	 eax, eax
  00141	75 10		 jne	 SHORT $LN15@GetPaperLi

; 2101 :             {
; 2102 :                 Log(LOG_DEBUG, __LINE__, "<< GetPaperList, <%s> new PTRDATA_INFO_LIST mem null", PrinterName);

  00143	56		 push	 esi
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@MINJLAHF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5PTRDA@
  00149	68 36 08 00 00	 push	 2102			; 00000836H
  0014e	e9 6b 03 00 00	 jmp	 $LN368@GetPaperLi
$LN15@GetPaperLi:

; 2103 :                 return NULL;
; 2104 :             }
; 2105 :             memset(pList, 0x00, size);

  00153	ff 75 b8	 push	 DWORD PTR _size$1$[ebp]
  00156	6a 00		 push	 0
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 _memset

; 2106 :             pList->num = papers;

  0015e	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
  00164	8b 4d cc	 mov	 ecx, DWORD PTR _l$1$[ebp]

; 2107 : 
; 2108 :             if ((n = DeviceCapabilities(PrinterName, PortName, DC_PAPERS, (LPSTR)ppi, NULL)) != l)

  00167	6a 00		 push	 0
  00169	57		 push	 edi
  0016a	6a 02		 push	 2
  0016c	ff 75 c4	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  0016f	89 08		 mov	 DWORD PTR [eax], ecx
  00171	56		 push	 esi
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  00178	8b f0		 mov	 esi, eax
  0017a	8b 45 cc	 mov	 eax, DWORD PTR _l$1$[ebp]
  0017d	3b f0		 cmp	 esi, eax
  0017f	0f 84 8c 00 00
	00		 je	 $LN16@GetPaperLi

; 2110 :                 Log(LOG_DEBUG, __LINE__, "<< GetPaperList, DeviceCapabilities(DC_PAPERS, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0018b	8b d0		 mov	 edx, eax
  0018d	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00190	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00195	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00199	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0019d	72 02		 jb	 SHORT $LN134@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0019f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN134@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2110 :                 Log(LOG_DEBUG, __LINE__, "<< GetPaperList, DeviceCapabilities(DC_PAPERS, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  001a1	50		 push	 eax
  001a2	57		 push	 edi
  001a3	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@CIOANDHH@?$DM?$DM?5GetPaperList?0?5DeviceCapabili@
  001a8	68 3e 08 00 00	 push	 2110			; 0000083eH
  001ad	6a 10		 push	 16			; 00000010H
  001af	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001b4	83 c4 14	 add	 esp, 20			; 00000014H
  001b7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001bb	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp+20]
  001be	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001c1	72 2c		 jb	 SHORT $LN182@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c3	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001c6	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c7	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001c9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001cf	72 14		 jb	 SHORT $LN181@GetPaperLi

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001d1	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001d4	83 c2 23	 add	 edx, 35			; 00000023H
  001d7	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d9	83 c0 fc	 add	 eax, -4			; fffffffcH
  001dc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001df	0f 87 2f 03 00
	00		 ja	 $LN371@GetPaperLi
$LN181@GetPaperLi:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001e5	52		 push	 edx
  001e6	51		 push	 ecx
  001e7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ec	83 c4 08	 add	 esp, 8
$LN182@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2111 :                 delete[] pList;

  001ef	ff 75 d0	 push	 DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  001f2	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001f9	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00200	c6 45 d8 00	 mov	 BYTE PTR $T5[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2111 :                 delete[] pList;

  00204	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00209	83 c4 04	 add	 esp, 4
  0020c	e9 b7 02 00 00	 jmp	 $LN34@GetPaperLi
$LN16@GetPaperLi:

; 2112 :                 return NULL;
; 2113 :             }
; 2114 :             else
; 2115 :             {
; 2116 :                 for (i = 0, pw = (WORD *)ppi; i < n; i++, pw++)

  00211	8b cf		 mov	 ecx, edi
  00213	85 f6		 test	 esi, esi
  00215	7e 23		 jle	 SHORT $LN3@GetPaperLi
  00217	8b 55 d0	 mov	 edx, DWORD PTR $T2[ebp]
  0021a	83 c2 04	 add	 edx, 4
  0021d	0f 1f 00	 npad	 3
$LL4@GetPaperLi:

; 2117 :                 {
; 2118 :                     pList->PtrDataInfo[i].id = *pw;

  00220	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00223	8d 92 10 01 00
	00		 lea	 edx, DWORD PTR [edx+272]
  00229	89 82 f0 fe ff
	ff		 mov	 DWORD PTR [edx-272], eax
  0022f	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00232	83 ee 01	 sub	 esi, 1
  00235	75 e9		 jne	 SHORT $LL4@GetPaperLi
  00237	8b 45 cc	 mov	 eax, DWORD PTR _l$1$[ebp]
$LN3@GetPaperLi:

; 2119 :                 }
; 2120 :             }
; 2121 :         }
; 2122 :     }
; 2123 : 
; 2124 :     // *** paper sizes
; 2125 :     ppi = B._allocMem(papers * sizeof(POINT));

  0023a	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  00241	3b 75 c8	 cmp	 esi, DWORD PTR _B$2$[ebp]
  00244	76 25		 jbe	 SHORT $LN202@GetPaperLi

; 128  :                 delete[] pMem;

  00246	57		 push	 edi
  00247	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 129  :             lMem = len;

  0024c	8b c6		 mov	 eax, esi

; 130  :             pMem = new byte[lMem];

  0024e	56		 push	 esi
  0024f	89 45 c8	 mov	 DWORD PTR _B$2$[ebp], eax
  00252	89 45 c0	 mov	 DWORD PTR _B$[ebp+4], eax
  00255	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  0025a	56		 push	 esi
  0025b	8b f8		 mov	 edi, eax
  0025d	6a 00		 push	 0
  0025f	57		 push	 edi
  00260	89 7d bc	 mov	 DWORD PTR _B$[ebp], edi
  00263	e8 00 00 00 00	 call	 _memset
  00268	83 c4 14	 add	 esp, 20			; 00000014H
$LN202@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2126 :     if (!ppi)

  0026b	85 ff		 test	 edi, edi
  0026d	75 1d		 jne	 SHORT $LN18@GetPaperLi

; 2127 :     {
; 2128 :         Log(LOG_DEBUG, __LINE__, "-- GetPaperList, <%s> new DC_PAPERSIZE mem null", PrinterName);

  0026f	8b 75 d4	 mov	 esi, DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00272	56		 push	 esi
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@NJCIHNJI@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@
  00278	68 50 08 00 00	 push	 2128			; 00000850H
  0027d	6a 10		 push	 16			; 00000010H
  0027f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00284	83 c4 10	 add	 esp, 16			; 00000010H

; 2129 :     }
; 2130 :     else

  00287	e9 d6 00 00 00	 jmp	 $LN6@GetPaperLi
$LN18@GetPaperLi:

; 2131 :     {
; 2132 :         if ((n = DeviceCapabilities(PrinterName, PortName, DC_PAPERSIZE, (LPSTR)ppi, NULL)) != l)

  0028c	6a 00		 push	 0
  0028e	57		 push	 edi
  0028f	6a 03		 push	 3
  00291	ff 75 c4	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  00294	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00297	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  0029d	8b f0		 mov	 esi, eax
  0029f	3b 75 cc	 cmp	 esi, DWORD PTR _l$1$[ebp]
  002a2	0f 84 7e 00 00
	00		 je	 $LN20@GetPaperLi

; 2134 :             Log(LOG_DEBUG, __LINE__, "-- GetPaperList, DeviceCapabilities(DC_PAPERSIZE, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  002a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002ae	8b d0		 mov	 edx, eax
  002b0	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  002b3	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  002b8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002bc	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  002c0	72 02		 jb	 SHORT $LN212@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  002c2	8b 00		 mov	 eax, DWORD PTR [eax]
$LN212@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2134 :             Log(LOG_DEBUG, __LINE__, "-- GetPaperList, DeviceCapabilities(DC_PAPERSIZE, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  002c4	50		 push	 eax
  002c5	57		 push	 edi
  002c6	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@BNKOAMAF@?9?9?5GetPaperList?0?5DeviceCapabili@
  002cb	68 56 08 00 00	 push	 2134			; 00000856H
  002d0	6a 10		 push	 16			; 00000010H
  002d2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002d7	83 c4 14	 add	 esp, 20			; 00000014H
  002da	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002de	8b 55 ec	 mov	 edx, DWORD PTR $T4[ebp+20]
  002e1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002e4	72 2c		 jb	 SHORT $LN260@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002e6	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002e9	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002ea	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002ec	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002f2	72 14		 jb	 SHORT $LN259@GetPaperLi

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002f4	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002f7	83 c2 23	 add	 edx, 35			; 00000023H
  002fa	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002fc	83 c0 fc	 add	 eax, -4			; fffffffcH
  002ff	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00302	0f 87 11 02 00
	00		 ja	 $LN372@GetPaperLi
$LN259@GetPaperLi:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00308	52		 push	 edx
  00309	51		 push	 ecx
  0030a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0030f	83 c4 08	 add	 esp, 8
$LN260@GetPaperLi:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00312	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00319	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00320	c6 45 d8 00	 mov	 BYTE PTR $T4[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2136 :         else

  00324	eb 39		 jmp	 SHORT $LN365@GetPaperLi
$LN20@GetPaperLi:

; 2137 :         {
; 2138 :             for (i = 0, pp = (POINT *)ppi; i < n; i++, pp++)

  00326	8b cf		 mov	 ecx, edi
  00328	85 f6		 test	 esi, esi
  0032a	7e 33		 jle	 SHORT $LN365@GetPaperLi
  0032c	8b 55 d0	 mov	 edx, DWORD PTR $T2[ebp]
  0032f	81 c2 10 01 00
	00		 add	 edx, 272		; 00000110H
  00335	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@GetPaperLi:

; 2139 :             {
; 2140 :                 pList->PtrDataInfo[i].x = pp->x;

  00340	8b 01		 mov	 eax, DWORD PTR [ecx]
  00342	8d 92 10 01 00
	00		 lea	 edx, DWORD PTR [edx+272]
  00348	89 82 ec fe ff
	ff		 mov	 DWORD PTR [edx-276], eax
  0034e	8d 49 08	 lea	 ecx, DWORD PTR [ecx+8]

; 2141 :                 pList->PtrDataInfo[i].y = pp->y;

  00351	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00354	89 82 f0 fe ff
	ff		 mov	 DWORD PTR [edx-272], eax
  0035a	83 ee 01	 sub	 esi, 1
  0035d	75 e1		 jne	 SHORT $LL7@GetPaperLi
$LN365@GetPaperLi:

; 2142 :             }
; 2143 :         }
; 2144 :     }
; 2145 : 
; 2146 :     // *** paper names
; 2147 :     ppi = B._allocMem(papers * sizeof(NAME_64BYTES));

  0035f	8b 75 d4	 mov	 esi, DWORD PTR _PrinterName$GSCopy$1$[ebp]
$LN6@GetPaperLi:
  00362	8b 45 cc	 mov	 eax, DWORD PTR _l$1$[ebp]
  00365	c1 e0 06	 shl	 eax, 6
  00368	89 45 d4	 mov	 DWORD PTR _len$1$[ebp], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  0036b	3b 45 c8	 cmp	 eax, DWORD PTR _B$2$[ebp]
  0036e	76 2c		 jbe	 SHORT $LN275@GetPaperLi

; 126  :         {
; 127  :             if (pMem)

  00370	85 ff		 test	 edi, edi
  00372	74 0c		 je	 SHORT $LN276@GetPaperLi

; 128  :                 delete[] pMem;

  00374	57		 push	 edi
  00375	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0037a	8b 45 d4	 mov	 eax, DWORD PTR _len$1$[ebp]
  0037d	83 c4 04	 add	 esp, 4
$LN276@GetPaperLi:

; 130  :             pMem = new byte[lMem];

  00380	50		 push	 eax
  00381	89 45 c0	 mov	 DWORD PTR _B$[ebp+4], eax
  00384	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  00389	ff 75 d4	 push	 DWORD PTR _len$1$[ebp]
  0038c	8b f8		 mov	 edi, eax
  0038e	6a 00		 push	 0
  00390	57		 push	 edi
  00391	89 7d bc	 mov	 DWORD PTR _B$[ebp], edi
  00394	e8 00 00 00 00	 call	 _memset
  00399	83 c4 10	 add	 esp, 16			; 00000010H
$LN275@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2148 :     if (!ppi)

  0039c	85 ff		 test	 edi, edi
  0039e	75 1a		 jne	 SHORT $LN22@GetPaperLi

; 2149 :     {
; 2150 :         Log(LOG_DEBUG, __LINE__, "-- GetPaperList, <%s> new DC_PAPERNAMES mem null", PrinterName);

  003a0	56		 push	 esi
  003a1	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@DLBCIEDL@?9?9?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@
  003a6	68 66 08 00 00	 push	 2150			; 00000866H
  003ab	6a 10		 push	 16			; 00000010H
  003ad	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003b2	83 c4 10	 add	 esp, 16			; 00000010H

; 2151 :     }
; 2152 :     else

  003b5	e9 e0 00 00 00	 jmp	 $LN9@GetPaperLi
$LN22@GetPaperLi:

; 2153 :     {
; 2154 :         if ((n = DeviceCapabilities(PrinterName, PortName, DC_PAPERNAMES, (LPSTR)ppi, NULL)) != l)

  003ba	6a 00		 push	 0
  003bc	57		 push	 edi
  003bd	6a 10		 push	 16			; 00000010H
  003bf	ff 75 c4	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  003c2	56		 push	 esi
  003c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  003c9	8b d0		 mov	 edx, eax
  003cb	3b 55 cc	 cmp	 edx, DWORD PTR _l$1$[ebp]
  003ce	74 7e		 je	 SHORT $LN24@GetPaperLi

; 2156 :             Log(LOG_DEBUG, __LINE__, "-- GetPaperList, DeviceCapabilities(DC_PAPERNAMES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  003d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  003d6	8b d0		 mov	 edx, eax
  003d8	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  003db	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  003e0	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003e4	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  003e8	72 02		 jb	 SHORT $LN285@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  003ea	8b 00		 mov	 eax, DWORD PTR [eax]
$LN285@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2156 :             Log(LOG_DEBUG, __LINE__, "-- GetPaperList, DeviceCapabilities(DC_PAPERNAMES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  003ec	50		 push	 eax
  003ed	57		 push	 edi
  003ee	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@CGKLJHJE@?9?9?5GetPaperList?0?5DeviceCapabili@
  003f3	68 6c 08 00 00	 push	 2156			; 0000086cH
  003f8	6a 10		 push	 16			; 00000010H
  003fa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003ff	83 c4 14	 add	 esp, 20			; 00000014H
  00402	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00406	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
  00409	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0040c	72 2c		 jb	 SHORT $LN333@GetPaperLi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0040e	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00411	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00412	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00414	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0041a	72 14		 jb	 SHORT $LN332@GetPaperLi

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0041c	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0041f	83 c2 23	 add	 edx, 35			; 00000023H
  00422	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00424	83 c0 fc	 add	 eax, -4			; fffffffcH
  00427	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0042a	0f 87 ee 00 00
	00		 ja	 $LN373@GetPaperLi
$LN332@GetPaperLi:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00430	52		 push	 edx
  00431	51		 push	 ecx
  00432	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00437	83 c4 08	 add	 esp, 8
$LN333@GetPaperLi:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0043a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00441	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00448	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2158 :         else

  0044c	eb 4c		 jmp	 SHORT $LN9@GetPaperLi
$LN24@GetPaperLi:

; 2159 :         {
; 2160 :             NAME_64BYTES *pn64 = NULL;
; 2161 :             for (i = 0, pn64 = (NAME_64BYTES *)ppi; i < n; i++, pn64++)

  0044e	8b c7		 mov	 eax, edi
  00450	85 d2		 test	 edx, edx
  00452	7e 46		 jle	 SHORT $LN9@GetPaperLi
  00454	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  00457	83 c1 08	 add	 ecx, 8
  0045a	66 0f 1f 44 00
	00		 npad	 6
$LL10@GetPaperLi:
  00460	8d 89 10 01 00
	00		 lea	 ecx, DWORD PTR [ecx+272]
  00466	8d 40 40	 lea	 eax, DWORD PTR [eax+64]

; 2162 :             {
; 2163 :                 memcpy(pList->PtrDataInfo[i].name, pn64->name, sizeof(NAME_64BYTES));

  00469	0f 10 40 c0	 movups	 xmm0, XMMWORD PTR [eax-64]
  0046d	0f 11 81 f0 fe
	ff ff		 movups	 XMMWORD PTR [ecx-272], xmm0
  00474	0f 10 40 d0	 movups	 xmm0, XMMWORD PTR [eax-48]
  00478	0f 11 81 00 ff
	ff ff		 movups	 XMMWORD PTR [ecx-256], xmm0
  0047f	0f 10 40 e0	 movups	 xmm0, XMMWORD PTR [eax-32]
  00483	0f 11 81 10 ff
	ff ff		 movups	 XMMWORD PTR [ecx-240], xmm0
  0048a	0f 10 40 f0	 movups	 xmm0, XMMWORD PTR [eax-16]
  0048e	0f 11 81 20 ff
	ff ff		 movups	 XMMWORD PTR [ecx-224], xmm0
  00495	83 ea 01	 sub	 edx, 1
  00498	75 c6		 jne	 SHORT $LL10@GetPaperLi
$LN9@GetPaperLi:

; 2164 :             }
; 2165 :         }
; 2166 :     }
; 2167 : 
; 2168 :     Log(LOG_DEBUG, __LINE__, "<< GetPaperList, List %p", pList);

  0049a	ff 75 d0	 push	 DWORD PTR $T2[ebp]
  0049d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HGBNGAMD@?$DM?$DM?5GetPaperList?0?5List?5?$CFp@
  004a2	68 78 08 00 00	 push	 2168			; 00000878H
  004a7	6a 10		 push	 16			; 00000010H
  004a9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  004ae	83 c4 10	 add	 esp, 16			; 00000010H

; 2169 :     return pList;

  004b1	eb 1c		 jmp	 SHORT $LN35@GetPaperLi
$LN364@GetPaperLi:

; 2091 :         {
; 2092 :             Log(LOG_DEBUG, __LINE__, "<< GetPaperList, <%s> new DC_PAPERS mem null", PrinterName);

  004b3	56		 push	 esi
  004b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@BIOGLDPF@?$DM?$DM?5GetPaperList?0?5?$DM?$CFs?$DO?5new?5DC_PA@
  004b9	68 2c 08 00 00	 push	 2092			; 0000082cH
$LN368@GetPaperLi:
  004be	6a 10		 push	 16			; 00000010H
  004c0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  004c5	83 c4 10	 add	 esp, 16			; 00000010H
$LN34@GetPaperLi:
  004c8	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
$LN35@GetPaperLi:

; 2169 :     return pList;

  004cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 164  :         if (pMem)

  004d6	85 ff		 test	 edi, edi
  004d8	74 10		 je	 SHORT $LN350@GetPaperLi

; 165  :         {
; 166  :             delete[] pMem;

  004da	57		 push	 edi
  004db	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  004e0	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  004e3	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _B$[ebp], 0
$LN350@GetPaperLi:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2169 :     return pList;

  004ea	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 169  :         lMem = 0;

  004ed	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _B$[ebp+4], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2170 : }

  004f4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004f7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004fe	59		 pop	 ecx
  004ff	5f		 pop	 edi
  00500	5e		 pop	 esi
  00501	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00504	33 cd		 xor	 ecx, ebp
  00506	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0050b	8b e5		 mov	 esp, ebp
  0050d	5d		 pop	 ebp
  0050e	c3		 ret	 0
$LN370@GetPaperLi:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0050f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN371@GetPaperLi:
  00514	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN372@GetPaperLi:
  00519	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN373@GetPaperLi:
  0051e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN367@GetPaperLi:
  00523	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$0:
  00000	8d 4d bc	 lea	 ecx, DWORD PTR _B$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1PBuffer@@QAE@XZ	; PBuffer::~PBuffer
__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$2:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z$4:
  00020	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z:
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z ENDP ; GetPaperList
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -72						; size = 4
_n$2$ = -72						; size = 4
_size$1$ = -68						; size = 4
_PortName$GSCopy$1$ = -64				; size = 4
_B$ = -60						; size = 8
_l$1$ = -52						; size = 4
_len$1$ = -48						; size = 4
_PrinterName$GSCopy$1$ = -44				; size = 4
$T3 = -40						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z PROC ; GetMediaTypeList
; _PrinterName$ = ecx
; _PortName$ = edx

; 2173 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 55 c0	 mov	 DWORD PTR _PortName$GSCopy$1$[ebp], edx
  0002d	8b c1		 mov	 eax, ecx
  0002f	89 45 d4	 mov	 DWORD PTR _PrinterName$GSCopy$1$[ebp], eax

; 2174 :     int l = 0, n = 0, i = 0, mediaTypes = 0;

  00032	33 c9		 xor	 ecx, ecx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 110  :         pMem = nullptr;

  00034	33 f6		 xor	 esi, esi
  00036	89 75 c4	 mov	 DWORD PTR _B$[ebp], esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2175 :     LP_PTRDATA_INFO_LIST pList = nullptr;

  00039	33 ff		 xor	 edi, edi
  0003b	89 4d d0	 mov	 DWORD PTR _len$1$[ebp], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 111  :         lMem = 0;

  0003e	89 4d c8	 mov	 DWORD PTR _B$[ebp+4], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2179 :     PBuffer B;

  00041	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi

; 2180 : 
; 2181 :     Log(LOG_DEBUG, __LINE__, ">> GetMediaTypeList, Name %s, Port %s", PrinterName, PortName);

  00044	52		 push	 edx
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@PBHDOEPC@?$DO?$DO?5GetMediaTypeList?0?5Name?5?$CFs?0?5P@
  0004b	68 85 08 00 00	 push	 2181			; 00000885H
  00050	6a 10		 push	 16			; 00000010H
  00052	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00057	83 c4 14	 add	 esp, 20			; 00000014H

; 2182 : 
; 2183 :     if ((l = DeviceCapabilities(PrinterName, PortName, DC_MEDIATYPES, NULL, NULL)) <= 0)

  0005a	56		 push	 esi
  0005b	56		 push	 esi
  0005c	6a 23		 push	 35			; 00000023H
  0005e	ff 75 c0	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  00061	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  0006a	89 45 cc	 mov	 DWORD PTR _l$1$[ebp], eax
  0006d	85 c0		 test	 eax, eax
  0006f	0f 8f 82 00 00
	00		 jg	 $LN8@GetMediaTy

; 2185 :         Log(LOG_DEBUG, __LINE__, "<< GetMediaTypeList, DeviceCapabilities(DC_MEDIATYPES, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007b	8b d0		 mov	 edx, eax
  0007d	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  00080	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00089	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0008d	72 02		 jb	 SHORT $LN36@GetMediaTy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0008f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN36@GetMediaTy:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2185 :         Log(LOG_DEBUG, __LINE__, "<< GetMediaTypeList, DeviceCapabilities(DC_MEDIATYPES, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00091	50		 push	 eax
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@NNAOKLFO@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@
  00097	68 89 08 00 00	 push	 2185			; 00000889H
  0009c	6a 10		 push	 16			; 00000010H
  0009e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000aa	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp+20]
  000ad	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000b0	72 2c		 jb	 SHORT $LN84@GetMediaTy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b2	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000b5	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b6	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000b8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000be	72 14		 jb	 SHORT $LN83@GetMediaTy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000c0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000c3	83 c2 23	 add	 edx, 35			; 00000023H
  000c6	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000cb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ce	0f 87 26 03 00
	00		 ja	 $LN278@GetMediaTy
$LN83@GetMediaTy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000d4	52		 push	 edx
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000db	83 c4 08	 add	 esp, 8
$LN84@GetMediaTy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  000de	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0
  000e5	33 ff		 xor	 edi, edi

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000e7	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000ee	c6 45 d8 00	 mov	 BYTE PTR $T5[ebp], 0
  000f2	e9 c4 02 00 00	 jmp	 $LN26@GetMediaTy
$LN8@GetMediaTy:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2190 :         ppi = B._allocMem(l * sizeof(DWORD));

  000f7	c1 e0 02	 shl	 eax, 2
  000fa	85 c0		 test	 eax, eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  000fc	0f 84 59 01 00
	00		 je	 $LN273@GetMediaTy

; 129  :             lMem = len;
; 130  :             pMem = new byte[lMem];

  00102	50		 push	 eax
  00103	89 45 c8	 mov	 DWORD PTR _B$[ebp+4], eax
  00106	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  0010b	8b 55 cc	 mov	 edx, DWORD PTR _l$1$[ebp]
  0010e	8b f0		 mov	 esi, eax
  00110	89 75 c4	 mov	 DWORD PTR _B$[ebp], esi
  00113	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  0011a	51		 push	 ecx
  0011b	6a 00		 push	 0
  0011d	56		 push	 esi
  0011e	e8 00 00 00 00	 call	 _memset
  00123	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2191 :         if (!ppi)

  00126	85 f6		 test	 esi, esi
  00128	0f 84 2d 01 00
	00		 je	 $LN273@GetMediaTy

; 2194 :         }
; 2195 :         else
; 2196 :         {
; 2197 :             mediaTypes = l;

  0012e	8b 45 cc	 mov	 eax, DWORD PTR _l$1$[ebp]
  00131	89 45 d0	 mov	 DWORD PTR _len$1$[ebp], eax

; 2198 :             size_t size = sizeof(PTRDATA_INFO_LIST) + ((l - 1) * sizeof(PTRDATA_INFO));

  00134	48		 dec	 eax
  00135	69 c0 10 01 00
	00		 imul	 eax, eax, 272
  0013b	05 14 01 00 00	 add	 eax, 276		; 00000114H

; 2199 :             pList = (LP_PTRDATA_INFO_LIST)new BYTE[size];

  00140	50		 push	 eax
  00141	89 45 bc	 mov	 DWORD PTR _size$1$[ebp], eax
  00144	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00149	8b f8		 mov	 edi, eax
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 7d b8	 mov	 DWORD PTR $T2[ebp], edi

; 2200 :             if (!pList)

  00151	85 ff		 test	 edi, edi
  00153	75 1c		 jne	 SHORT $LN12@GetMediaTy

; 2201 :             {
; 2202 :                 Log(LOG_DEBUG, __LINE__, "<< GetMediaTypeList, <%s> new PTRDATA_INFO_LIST mem null", PrinterName);

  00155	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@IAEPPFOH@?$DM?$DM?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5P@
  0015d	68 9a 08 00 00	 push	 2202			; 0000089aH
  00162	6a 10		 push	 16			; 00000010H
  00164	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00169	83 c4 10	 add	 esp, 16			; 00000010H
  0016c	e9 4a 02 00 00	 jmp	 $LN26@GetMediaTy
$LN12@GetMediaTy:

; 2203 :                 return NULL;
; 2204 :             }
; 2205 :             memset(pList, 0x00, size);

  00171	ff 75 bc	 push	 DWORD PTR _size$1$[ebp]
  00174	6a 00		 push	 0
  00176	57		 push	 edi
  00177	e8 00 00 00 00	 call	 _memset

; 2206 :             pList->num = mediaTypes;

  0017c	8b 45 cc	 mov	 eax, DWORD PTR _l$1$[ebp]
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	89 07		 mov	 DWORD PTR [edi], eax

; 2207 : 
; 2208 :             if ((n = DeviceCapabilities(PrinterName, PortName, DC_MEDIATYPES, (LPSTR)ppi, NULL)) != l)

  00184	6a 00		 push	 0
  00186	56		 push	 esi
  00187	6a 23		 push	 35			; 00000023H
  00189	ff 75 c0	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  0018c	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  00195	3b 45 cc	 cmp	 eax, DWORD PTR _l$1$[ebp]
  00198	0f 84 8c 00 00
	00		 je	 $LN13@GetMediaTy

; 2210 :                 Log(LOG_DEBUG, __LINE__, "<< GetMediaTypeList, DeviceCapabilities(DC_MEDIATYPES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001a4	8b d0		 mov	 edx, eax
  001a6	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  001a9	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  001ae	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001b2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  001b6	72 02		 jb	 SHORT $LN120@GetMediaTy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN120@GetMediaTy:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2210 :                 Log(LOG_DEBUG, __LINE__, "<< GetMediaTypeList, DeviceCapabilities(DC_MEDIATYPES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  001ba	50		 push	 eax
  001bb	56		 push	 esi
  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@OFONMAMJ@?$DM?$DM?5GetMediaTypeList?0?5DeviceCapa@
  001c1	68 a2 08 00 00	 push	 2210			; 000008a2H
  001c6	6a 10		 push	 16			; 00000010H
  001c8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001cd	83 c4 14	 add	 esp, 20			; 00000014H
  001d0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001d4	8b 55 ec	 mov	 edx, DWORD PTR $T4[ebp+20]
  001d7	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001da	72 2c		 jb	 SHORT $LN168@GetMediaTy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001dc	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001df	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e0	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001e2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001e8	72 14		 jb	 SHORT $LN167@GetMediaTy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001ea	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001ed	83 c2 23	 add	 edx, 35			; 00000023H
  001f0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f2	83 c0 fc	 add	 eax, -4			; fffffffcH
  001f5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001f8	0f 87 01 02 00
	00		 ja	 $LN279@GetMediaTy
$LN167@GetMediaTy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001fe	52		 push	 edx
  001ff	51		 push	 ecx
  00200	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00205	83 c4 08	 add	 esp, 8
$LN168@GetMediaTy:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2211 :                 delete[] pList;

  00208	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00209	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00210	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00217	c6 45 d8 00	 mov	 BYTE PTR $T4[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2211 :                 delete[] pList;

  0021b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00220	83 c4 04	 add	 esp, 4
  00223	33 ff		 xor	 edi, edi
  00225	e9 91 01 00 00	 jmp	 $LN26@GetMediaTy
$LN13@GetMediaTy:

; 2212 :                 return NULL;
; 2213 :             }
; 2214 :             else
; 2215 :             {
; 2216 :                 for (i = 0, pdw = (DWORD *)ppi; i < n; i++, pdw++)

  0022a	8b ce		 mov	 ecx, esi
  0022c	85 c0		 test	 eax, eax
  0022e	7e 42		 jle	 SHORT $LN3@GetMediaTy
  00230	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  00233	8b f8		 mov	 edi, eax
  00235	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@GetMediaTy:

; 2217 :                 {
; 2218 :                     pList->PtrDataInfo[i].id = *pdw;

  00240	8b 01		 mov	 eax, DWORD PTR [ecx]
  00242	8d 92 10 01 00
	00		 lea	 edx, DWORD PTR [edx+272]
  00248	89 82 f0 fe ff
	ff		 mov	 DWORD PTR [edx-272], eax
  0024e	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00251	83 ef 01	 sub	 edi, 1
  00254	75 ea		 jne	 SHORT $LL4@GetMediaTy

; 2212 :                 return NULL;
; 2213 :             }
; 2214 :             else
; 2215 :             {
; 2216 :                 for (i = 0, pdw = (DWORD *)ppi; i < n; i++, pdw++)

  00256	8b 7d b8	 mov	 edi, DWORD PTR $T2[ebp]
  00259	eb 17		 jmp	 SHORT $LN3@GetMediaTy
$LN273@GetMediaTy:

; 2192 :         {
; 2193 :             Log(LOG_DEBUG, __LINE__, "-- GetMediaTypeList, <%s> new DC_MEDIATYPES mem null", PrinterName);

  0025b	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EKPICGIC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@
  00263	68 91 08 00 00	 push	 2193			; 00000891H
  00268	6a 10		 push	 16			; 00000010H
  0026a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0026f	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@GetMediaTy:

; 2219 :                 }
; 2220 :             }
; 2221 :         }
; 2222 :     }
; 2223 : 
; 2224 :     // *** media type names
; 2225 :     ppi = B._allocMem(mediaTypes * sizeof(NAME_64BYTES));

  00272	8b 45 d0	 mov	 eax, DWORD PTR _len$1$[ebp]
  00275	c1 e0 06	 shl	 eax, 6
  00278	89 45 d0	 mov	 DWORD PTR _len$1$[ebp], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  0027b	3b 45 c8	 cmp	 eax, DWORD PTR _B$[ebp+4]
  0027e	76 2d		 jbe	 SHORT $LN188@GetMediaTy

; 126  :         {
; 127  :             if (pMem)

  00280	85 f6		 test	 esi, esi
  00282	74 0c		 je	 SHORT $LN189@GetMediaTy

; 128  :                 delete[] pMem;

  00284	56		 push	 esi
  00285	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0028a	8b 45 d0	 mov	 eax, DWORD PTR _len$1$[ebp]
  0028d	83 c4 04	 add	 esp, 4
$LN189@GetMediaTy:

; 129  :             lMem = len;
; 130  :             pMem = new byte[lMem];

  00290	50		 push	 eax
  00291	89 45 c8	 mov	 DWORD PTR _B$[ebp+4], eax
  00294	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 131  :             memset(pMem, 0x00, lMem);

  00299	8b 4d d0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  0029c	8b f0		 mov	 esi, eax
  0029e	51		 push	 ecx
  0029f	6a 00		 push	 0
  002a1	56		 push	 esi
  002a2	89 75 c4	 mov	 DWORD PTR _B$[ebp], esi
  002a5	e8 00 00 00 00	 call	 _memset
  002aa	83 c4 10	 add	 esp, 16			; 00000010H
$LN188@GetMediaTy:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2226 :     if (!ppi)

  002ad	85 f6		 test	 esi, esi
  002af	75 1c		 jne	 SHORT $LN15@GetMediaTy

; 2227 :     {
; 2228 :         Log(LOG_DEBUG, __LINE__, "-- GetMediaTypeList, <%s> new DC_MEDIATYPENAMES mem null", PrinterName);

  002b1	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@CAKMLHPC@?9?9?5GetMediaTypeList?0?5?$DM?$CFs?$DO?5new?5D@
  002b9	68 b4 08 00 00	 push	 2228			; 000008b4H
  002be	6a 10		 push	 16			; 00000010H
  002c0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  002c5	83 c4 10	 add	 esp, 16			; 00000010H

; 2229 :     }
; 2230 :     else

  002c8	e9 d9 00 00 00	 jmp	 $LN6@GetMediaTy
$LN15@GetMediaTy:

; 2231 :     {
; 2232 :         if ((n = DeviceCapabilities(PrinterName, PortName, DC_MEDIATYPENAMES, (LPSTR)ppi, NULL)) != l)

  002cd	6a 00		 push	 0
  002cf	56		 push	 esi
  002d0	6a 22		 push	 34			; 00000022H
  002d2	ff 75 c0	 push	 DWORD PTR _PortName$GSCopy$1$[ebp]
  002d5	ff 75 d4	 push	 DWORD PTR _PrinterName$GSCopy$1$[ebp]
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceCapabilitiesA@20
  002de	8b c8		 mov	 ecx, eax
  002e0	89 4d b8	 mov	 DWORD PTR _n$2$[ebp], ecx
  002e3	3b 4d cc	 cmp	 ecx, DWORD PTR _l$1$[ebp]
  002e6	0f 84 7e 00 00
	00		 je	 $LN17@GetMediaTy

; 2234 :             Log(LOG_DEBUG, __LINE__, "-- GetMediaTypeList, DeviceCapabilities(DC_MEDIATYPENAMES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  002ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002f2	8b d0		 mov	 edx, eax
  002f4	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  002f7	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  002fc	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00300	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00304	72 02		 jb	 SHORT $LN198@GetMediaTy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00306	8b 00		 mov	 eax, DWORD PTR [eax]
$LN198@GetMediaTy:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2234 :             Log(LOG_DEBUG, __LINE__, "-- GetMediaTypeList, DeviceCapabilities(DC_MEDIATYPENAMES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00308	50		 push	 eax
  00309	56		 push	 esi
  0030a	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@ONNFKLG@?9?9?5GetMediaTypeList?0?5DeviceCapa@
  0030f	68 ba 08 00 00	 push	 2234			; 000008baH
  00314	6a 10		 push	 16			; 00000010H
  00316	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0031b	83 c4 14	 add	 esp, 20			; 00000014H
  0031e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00322	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
  00325	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00328	72 2c		 jb	 SHORT $LN246@GetMediaTy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0032a	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0032d	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0032e	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00330	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00336	72 14		 jb	 SHORT $LN245@GetMediaTy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00338	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0033b	83 c2 23	 add	 edx, 35			; 00000023H
  0033e	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00340	83 c0 fc	 add	 eax, -4			; fffffffcH
  00343	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00346	0f 87 b8 00 00
	00		 ja	 $LN280@GetMediaTy
$LN245@GetMediaTy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0034c	52		 push	 edx
  0034d	51		 push	 ecx
  0034e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00353	83 c4 08	 add	 esp, 8
$LN246@GetMediaTy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00356	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0035d	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00364	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2236 :         else

  00368	eb 3c		 jmp	 SHORT $LN6@GetMediaTy
$LN17@GetMediaTy:

; 2237 :         {
; 2238 :             NAME_64BYTES *pn64 = nullptr;
; 2239 :             for (i = 0, pn64 = (NAME_64BYTES *)ppi; i < n && pList; ++i, ++pn64)

  0036a	33 d2		 xor	 edx, edx
  0036c	8b c6		 mov	 eax, esi
  0036e	85 c9		 test	 ecx, ecx
  00370	7e 34		 jle	 SHORT $LN6@GetMediaTy
  00372	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
$LL7@GetMediaTy:
  00375	85 ff		 test	 edi, edi
  00377	74 2d		 je	 SHORT $LN6@GetMediaTy

; 2240 :             {
; 2241 :                 memcpy(pList->PtrDataInfo[i].name, pn64->name, sizeof(NAME_64BYTES));

  00379	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0037c	42		 inc	 edx
  0037d	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  00380	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00384	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00388	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  0038c	0f 11 41 20	 movups	 XMMWORD PTR [ecx+32], xmm0
  00390	0f 10 40 30	 movups	 xmm0, XMMWORD PTR [eax+48]
  00394	83 c0 40	 add	 eax, 64			; 00000040H
  00397	0f 11 41 30	 movups	 XMMWORD PTR [ecx+48], xmm0
  0039b	81 c1 10 01 00
	00		 add	 ecx, 272		; 00000110H
  003a1	3b 55 b8	 cmp	 edx, DWORD PTR _n$2$[ebp]
  003a4	7c cf		 jl	 SHORT $LL7@GetMediaTy
$LN6@GetMediaTy:

; 2242 :             }
; 2243 :         }
; 2244 :     }
; 2245 : 
; 2246 :     Log(LOG_DEBUG, __LINE__, "<< GetMediaTypeList, List %p", pList);

  003a6	57		 push	 edi
  003a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@IBLEBHCE@?$DM?$DM?5GetMediaTypeList?0?5List?5?$CFp@
  003ac	68 c6 08 00 00	 push	 2246			; 000008c6H
  003b1	6a 10		 push	 16			; 00000010H
  003b3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003b8	83 c4 10	 add	 esp, 16			; 00000010H
$LN26@GetMediaTy:

; 2247 :     return pList;

  003bb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 164  :         if (pMem)

  003c2	85 f6		 test	 esi, esi
  003c4	74 10		 je	 SHORT $LN263@GetMediaTy

; 165  :         {
; 166  :             delete[] pMem;

  003c6	56		 push	 esi
  003c7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  003cc	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  003cf	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _B$[ebp], 0
$LN263@GetMediaTy:

; 168  :         }
; 169  :         lMem = 0;

  003d6	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _B$[ebp+4], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2247 :     return pList;

  003dd	8b c7		 mov	 eax, edi

; 2248 : }

  003df	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003e2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003e9	59		 pop	 ecx
  003ea	5f		 pop	 edi
  003eb	5e		 pop	 esi
  003ec	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003ef	33 cd		 xor	 ecx, ebp
  003f1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f6	8b e5		 mov	 esp, ebp
  003f8	5d		 pop	 ebp
  003f9	c3		 ret	 0
$LN278@GetMediaTy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003fa	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN279@GetMediaTy:
  003ff	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN280@GetMediaTy:
  00404	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN276@GetMediaTy:
  00409	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _B$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1PBuffer@@QAE@XZ	; PBuffer::~PBuffer
__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$2:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z:
  00020	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00024	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00027	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z ENDP ; GetMediaTypeList
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_tickStart$ = -1136					; size = 8
_hGdi$1$ = -1128					; size = 4
_hPrinter$2 = -1124					; size = 4
_printerCnt$3 = -1120					; size = 4
_hPrinter$4 = -1116					; size = 4
_i$ = -1112						; size = 4
_B$ = -1108						; size = 8
_ppi$ = -1100						; size = 4
_hdc$1$ = -1096						; size = 4
_pdm$1$ = -1096						; size = 4
_n$5$ = -1096						; size = 4
_n$4$ = -1096						; size = 4
_n$3$ = -1096						; size = 4
_n$2$ = -1096						; size = 4
_n$1$ = -1096						; size = 4
_iBufferSize$1$ = -1092					; size = 4
_pMediaTypeList$1$ = -1092				; size = 4
_pPaperList$1$ = -1092					; size = 4
_pBinList$1$ = -1092					; size = 4
_i$8$ = -1092						; size = 4
_i$6$ = -1092						; size = 4
_i$5$ = -1092						; size = 4
_l$19$ = -1092						; size = 4
_l$18$ = -1092						; size = 4
_l$17$ = -1092						; size = 4
_l$16$ = -1092						; size = 4
_l$15$ = -1092						; size = 4
_l$2$ = -1092						; size = 4
$T5 = -1088						; size = 24
$T6 = -1064						; size = 24
$T7 = -1040						; size = 24
$T8 = -1016						; size = 24
$T9 = -992						; size = 24
$T10 = -968						; size = 24
$T11 = -944						; size = 24
$T12 = -920						; size = 24
$T13 = -896						; size = 24
$T14 = -872						; size = 24
$T15 = -848						; size = 24
$T16 = -824						; size = 24
_DriverName$ = -800					; size = 260
_PortName$ = -540					; size = 260
_PrinterName$ = -280					; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpData$ = 8						; size = 4
?PrinterInfo@@YGIPAX@Z PROC				; PrinterInfo

; 2251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PrinterInfo@@YGIPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 64 04 00
	00		 sub	 esp, 1124		; 00000464H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR _lpData$[ebp]

; 2252 :     int l = 0, n = 0, i = 0;
; 2253 :     DWORD *pdw = nullptr;
; 2254 :     BYTE *ppi = nullptr;

  00034	33 db		 xor	 ebx, ebx
  00036	89 9d b4 fb ff
	ff		 mov	 DWORD PTR _ppi$[ebp], ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 110  :         pMem = nullptr;

  0003c	33 ff		 xor	 edi, edi
  0003e	89 bd ac fb ff
	ff		 mov	 DWORD PTR _B$[ebp], edi

; 111  :         lMem = 0;

  00044	89 9d b0 fb ff
	ff		 mov	 DWORD PTR _B$[ebp+4], ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2255 :     PBuffer B;

  0004a	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi

; 2256 : 
; 2257 :     char PrinterName[_MAX_PATH] = { 0 };

  0004d	68 04 01 00 00	 push	 260			; 00000104H
  00052	57		 push	 edi
  00053	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _memset

; 2258 :     char DriverName[_MAX_PATH] = { 0 };

  0005f	68 04 01 00 00	 push	 260			; 00000104H
  00064	57		 push	 edi
  00065	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 _memset

; 2259 :     char PortName[_MAX_PATH] = { 0 };

  00071	68 04 01 00 00	 push	 260			; 00000104H
  00076	57		 push	 edi
  00077	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _memset

; 2260 : 
; 2261 :     NAME_32BYTES *pn32 = nullptr;
; 2262 :     NAME_64BYTES *pn64 = nullptr;
; 2263 : 
; 2264 :     uint64_t tickStart = SysTick();

  00083	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  00088	89 85 90 fb ff
	ff		 mov	 DWORD PTR _tickStart$[ebp], eax
  0008e	89 95 94 fb ff
	ff		 mov	 DWORD PTR _tickStart$[ebp+4], edx

; 2265 : 
; 2266 :     Log(LOG_DEBUG, __LINE__, ">> PtrInfo (%p)", lpData);

  00094	56		 push	 esi
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EKNEIKHO@?$DO?$DO?5PtrInfo?5?$CI?$CFp?$CJ@
  0009a	68 da 08 00 00	 push	 2266			; 000008daH
  0009f	6a 10		 push	 16			; 00000010H
  000a1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000a6	83 c4 34	 add	 esp, 52			; 00000034H

; 2267 :     if (GetPrintersList() == 0)

  000a9	e8 00 00 00 00	 call	 ?GetPrintersList@@YAHXZ	; GetPrintersList
  000ae	85 c0		 test	 eax, eax
  000b0	75 26		 jne	 SHORT $LN29@PrinterInf

; 2268 :     {
; 2269 :         Log(LOG_DEBUG, __LINE__, "<< PtrInfo, No Printer");

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ENEDNFCI@?$DM?$DM?5PtrInfo?0?5No?5Printer@
  000b7	68 dd 08 00 00	 push	 2269			; 000008ddH
  000bc	6a 10		 push	 16			; 00000010H
  000be	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2270 :         _endthreadex(0);

  000c3	57		 push	 edi
  000c4	e8 00 00 00 00	 call	 __endthreadex
  000c9	83 c4 10	 add	 esp, 16			; 00000010H

; 2271 :         return 0;

  000cc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000d3	e9 25 1d 00 00	 jmp	 $LN995@PrinterInf
$LN29@PrinterInf:

; 2272 :     }
; 2273 : 
; 2274 :     if (!gpPrinterInfoList)

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  000dd	85 c0		 test	 eax, eax
  000df	75 2c		 jne	 SHORT $LN30@PrinterInf

; 2275 :     {
; 2276 :         Log(LOG_DEBUG, __LINE__, "<< PtrInfo, PtrInfoList null");

  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HOILGMMA@?$DM?$DM?5PtrInfo?0?5PtrInfoList?5null@
  000e6	68 e4 08 00 00	 push	 2276			; 000008e4H
  000eb	6a 10		 push	 16			; 00000010H
  000ed	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2277 :         _endthreadex(ERROR_OUTOFMEMORY);

  000f2	6a 0e		 push	 14			; 0000000eH
  000f4	e8 00 00 00 00	 call	 __endthreadex
  000f9	83 c4 10	 add	 esp, 16			; 00000010H

; 2278 :         return ERROR_OUTOFMEMORY;

  000fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00103	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00108	e9 f2 1c 00 00	 jmp	 $LN1033@PrinterInf
$LN30@PrinterInf:

; 2281 :     for (int printerCnt = 0; printerCnt < gpPrinterInfoList->num; printerCnt++)

  0010d	33 f6		 xor	 esi, esi
$LN1039@PrinterInf:
  0010f	89 b5 a0 fb ff
	ff		 mov	 DWORD PTR _printerCnt$3[ebp], esi
  00115	3b 30		 cmp	 esi, DWORD PTR [eax]
  00117	0f 8d 7f 1c 00
	00		 jge	 $LN3@PrinterInf

; 2282 :     {
; 2283 :         memset(PrinterName, 0x00, sizeof(PrinterName));

  0011d	68 04 01 00 00	 push	 260			; 00000104H
  00122	6a 00		 push	 0
  00124	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memset

; 2284 :         memset(PortName, 0x00, sizeof(PortName));

  00130	68 04 01 00 00	 push	 260			; 00000104H
  00135	6a 00		 push	 0
  00137	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 _memset

; 2285 :         memset(DriverName, 0x00, sizeof(DriverName));

  00143	68 04 01 00 00	 push	 260			; 00000104H
  00148	6a 00		 push	 0
  0014a	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 _memset

; 2286 : 
; 2287 :         strncpy(PrinterName, gpPrinterInfoList->PrinterInfo[printerCnt].PrinterName, _MAX_PATH - 1);

  00156	69 f6 0c 03 00
	00		 imul	 esi, esi, 780
  0015c	68 03 01 00 00	 push	 259			; 00000103H
  00161	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  00166	83 c0 04	 add	 eax, 4
  00169	03 c6		 add	 eax, esi
  0016b	50		 push	 eax
  0016c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _strncpy

; 2288 :         strncpy(PortName, gpPrinterInfoList->PrinterInfo[printerCnt].PortName, _MAX_PATH - 1);

  00178	68 03 01 00 00	 push	 259			; 00000103H
  0017d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  00182	05 08 01 00 00	 add	 eax, 264		; 00000108H
  00187	03 c6		 add	 eax, esi
  00189	50		 push	 eax
  0018a	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _strncpy

; 2289 :         strncpy(DriverName, gpPrinterInfoList->PrinterInfo[printerCnt].DriverName, _MAX_PATH - 1);

  00196	68 03 01 00 00	 push	 259			; 00000103H
  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  001a0	05 0c 02 00 00	 add	 eax, 524		; 0000020cH
  001a5	03 c6		 add	 eax, esi
  001a7	50		 push	 eax
  001a8	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _strncpy
  001b4	83 c4 48	 add	 esp, 72			; 00000048H

; 2290 : 
; 2291 :         Log(LOG_HEADER, __LINE__, "Info from %s, Port %s, Driver %s (%d)", PrinterName, PortName, DriverName, printerCnt);

  001b7	ff b5 a0 fb ff
	ff		 push	 DWORD PTR _printerCnt$3[ebp]
  001bd	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  001c3	50		 push	 eax
  001c4	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  001ca	50		 push	 eax
  001cb	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  001d1	50		 push	 eax
  001d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GNJLFBNH@Info?5from?5?$CFs?0?5Port?5?$CFs?0?5Driver?5?$CF@
  001d7	68 f3 08 00 00	 push	 2291			; 000008f3H
  001dc	6a 02		 push	 2
  001de	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001e3	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2292 : 
; 2293 :         //GET PRINTER CAPABILITIES
; 2294 :         // *** resolution(s)
; 2295 :         if ((l = DeviceCapabilities(PrinterName, PortName, DC_ENUMRESOLUTIONS, NULL, NULL)) <= 0)

  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	6a 0d		 push	 13			; 0000000dH
  001ec	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  001f2	50		 push	 eax
  001f3	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  001f9	50		 push	 eax
  001fa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceCapabilitiesA@20
  00200	ff d6		 call	 esi
  00202	89 85 bc fb ff
	ff		 mov	 DWORD PTR _l$2$[ebp], eax
  00208	85 c0		 test	 eax, eax
  0020a	0f 8f 92 00 00
	00		 jg	 $LN31@PrinterInf

; 2297 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_ENUMRESOLUTIONS, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00216	8b d0		 mov	 edx, eax
  00218	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  0021e	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00223	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00227	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0022b	72 02		 jb	 SHORT $LN128@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0022d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN128@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2297 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_ENUMRESOLUTIONS, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  0022f	50		 push	 eax
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@DLHDGDPE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00235	68 f9 08 00 00	 push	 2297			; 000008f9H
  0023a	6a 10		 push	 16			; 00000010H
  0023c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00241	83 c4 10	 add	 esp, 16			; 00000010H
  00244	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00248	8b 95 dc fc ff
	ff		 mov	 edx, DWORD PTR $T16[ebp+20]
  0024e	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00251	72 2f		 jb	 SHORT $LN176@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00253	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00254	8b 8d c8 fc ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  0025a	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0025c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00262	72 14		 jb	 SHORT $LN175@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00264	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00267	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0026a	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0026c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0026f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00272	0f 87 af 1b 00
	00		 ja	 $LN1041@PrinterInf
$LN175@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00278	52		 push	 edx
  00279	51		 push	 ecx
  0027a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0027f	83 c4 08	 add	 esp, 8
$LN176@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00282	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0028c	c7 85 dc fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00296	c6 85 c8 fc ff
	ff 00		 mov	 BYTE PTR $T16[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2299 :         else

  0029d	e9 7c 01 00 00	 jmp	 $LN6@PrinterInf
$LN31@PrinterInf:

; 2300 :         {
; 2301 :             ppi = B._allocMem(l * sizeof(POINT));

  002a2	8d 1c c5 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*8]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  002a9	3b 9d b0 fb ff
	ff		 cmp	 ebx, DWORD PTR _B$[ebp+4]
  002af	76 2d		 jbe	 SHORT $LN192@PrinterInf

; 126  :         {
; 127  :             if (pMem)

  002b1	85 ff		 test	 edi, edi
  002b3	74 09		 je	 SHORT $LN193@PrinterInf

; 128  :                 delete[] pMem;

  002b5	57		 push	 edi
  002b6	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  002bb	83 c4 04	 add	 esp, 4
$LN193@PrinterInf:

; 129  :             lMem = len;

  002be	89 9d b0 fb ff
	ff		 mov	 DWORD PTR _B$[ebp+4], ebx

; 130  :             pMem = new byte[lMem];

  002c4	53		 push	 ebx
  002c5	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002ca	8b f8		 mov	 edi, eax
  002cc	89 bd ac fb ff
	ff		 mov	 DWORD PTR _B$[ebp], edi

; 131  :             memset(pMem, 0x00, lMem);

  002d2	53		 push	 ebx
  002d3	6a 00		 push	 0
  002d5	57		 push	 edi
  002d6	e8 00 00 00 00	 call	 _memset
  002db	83 c4 10	 add	 esp, 16			; 00000010H
$LN192@PrinterInf:

; 132  :         }
; 133  :         return pMem;

  002de	8b df		 mov	 ebx, edi
  002e0	89 9d b4 fb ff
	ff		 mov	 DWORD PTR _ppi$[ebp], ebx
  002e6	85 db		 test	 ebx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2302 :             if (!ppi)

  002e8	75 20		 jne	 SHORT $LN33@PrinterInf

; 2303 :             {
; 2304 :                 Log(LOG_DEBUG, __LINE__, "-- PtrInfo, <%s> new DC_ENUMRESOLUTIONS mem null", PrinterName);

  002ea	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  002f0	50		 push	 eax
  002f1	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@OINKGGOI@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_ENUMRES@
  002f6	68 00 09 00 00	 push	 2304			; 00000900H
  002fb	6a 10		 push	 16			; 00000010H
  002fd	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00302	83 c4 10	 add	 esp, 16			; 00000010H

; 2305 :             }
; 2306 :             else

  00305	e9 14 01 00 00	 jmp	 $LN6@PrinterInf
$LN33@PrinterInf:

; 2307 :             {
; 2308 :                 if ((n = DeviceCapabilities(PrinterName, PortName, DC_ENUMRESOLUTIONS, (LPSTR)ppi, NULL)) != l)

  0030a	6a 00		 push	 0
  0030c	57		 push	 edi
  0030d	6a 0d		 push	 13			; 0000000dH
  0030f	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00315	50		 push	 eax
  00316	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  0031c	50		 push	 eax
  0031d	ff d6		 call	 esi
  0031f	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _n$1$[ebp], eax
  00325	3b 85 bc fb ff
	ff		 cmp	 eax, DWORD PTR _l$2$[ebp]
  0032b	0f 84 90 00 00
	00		 je	 $LN35@PrinterInf

; 2310 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_ENUMRESOLUTIONS, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00331	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00337	8b d0		 mov	 edx, eax
  00339	8d 8d b0 fc ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0033f	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00344	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00348	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0034c	72 02		 jb	 SHORT $LN202@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0034e	8b 00		 mov	 eax, DWORD PTR [eax]
$LN202@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2310 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_ENUMRESOLUTIONS, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00350	50		 push	 eax
  00351	57		 push	 edi
  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@HALEOHFL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00357	68 06 09 00 00	 push	 2310			; 00000906H
  0035c	6a 10		 push	 16			; 00000010H
  0035e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00363	83 c4 14	 add	 esp, 20			; 00000014H
  00366	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0036a	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR $T15[ebp+20]
  00370	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00373	72 2f		 jb	 SHORT $LN250@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00375	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00376	8b 8d b0 fc ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  0037c	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0037e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00384	72 14		 jb	 SHORT $LN249@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00386	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00389	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  0038c	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0038e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00391	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00394	0f 87 92 1a 00
	00		 ja	 $LN1042@PrinterInf
$LN249@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0039a	52		 push	 edx
  0039b	51		 push	 ecx
  0039c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003a1	83 c4 08	 add	 esp, 8
$LN250@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  003a4	c7 85 c0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003ae	c7 85 c4 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  003b8	c6 85 b0 fc ff
	ff 00		 mov	 BYTE PTR $T15[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2312 :                 else

  003bf	eb 5d		 jmp	 SHORT $LN6@PrinterInf
$LN35@PrinterInf:

; 2313 :                 {
; 2314 :                     Log(LOG_MESSAGE, __LINE__, "DC_ENUMRESOLUTIONS (%d):", n);

  003c1	50		 push	 eax
  003c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PLJPAGFI@DC_ENUMRESOLUTIONS?5?$CI?$CFd?$CJ?3@
  003c7	68 0a 09 00 00	 push	 2314			; 0000090aH
  003cc	6a 01		 push	 1
  003ce	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  003d3	83 c4 10	 add	 esp, 16			; 00000010H
  003d6	33 f6		 xor	 esi, esi

; 2315 :                     for (i = 0, pdw = (DWORD*)ppi; i < n; i++)

  003d8	39 b5 b8 fb ff
	ff		 cmp	 DWORD PTR _n$1$[ebp], esi
  003de	7e 3e		 jle	 SHORT $LN6@PrinterInf
  003e0	8b 9d b8 fb ff
	ff		 mov	 ebx, DWORD PTR _n$1$[ebp]
  003e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@PrinterInf:

; 2316 :                     {
; 2317 :                         Log(LOG_MESSAGE, __LINE__, ">%.2d: %u x %u", i + 1, pdw[i * 2], pdw[i * 2 + 1]);

  003f0	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  003f7	46		 inc	 esi
  003f8	ff 74 07 04	 push	 DWORD PTR [edi+eax+4]
  003fc	ff 34 07	 push	 DWORD PTR [edi+eax]
  003ff	56		 push	 esi
  00400	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OBKMFCDP@?$DO?$CF?42d?3?5?$CFu?5x?5?$CFu@
  00405	68 0d 09 00 00	 push	 2317			; 0000090dH
  0040a	6a 01		 push	 1
  0040c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00411	83 c4 18	 add	 esp, 24			; 00000018H

; 2315 :                     for (i = 0, pdw = (DWORD*)ppi; i < n; i++)

  00414	3b f3		 cmp	 esi, ebx
  00416	7c d8		 jl	 SHORT $LL7@PrinterInf
  00418	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
$LN6@PrinterInf:

; 2318 :                     }
; 2319 :                 }
; 2320 :             }
; 2321 :         }
; 2322 : 
; 2323 :         // *** bins & binnames
; 2324 :         try

  0041e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 2325 :         {
; 2326 :             LP_PTRDATA_INFO_LIST pBinList = GetBinList(PrinterName, PortName);

  00422	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _PortName$[ebp]
  00428	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _PrinterName$[ebp]
  0042e	e8 00 00 00 00	 call	 ?GetBinList@@YAPAU_ptrdata_info_list_@@PBD0@Z ; GetBinList
  00433	89 85 bc fb ff
	ff		 mov	 DWORD PTR _pBinList$1$[ebp], eax

; 2327 :             if (pBinList)

  00439	85 c0		 test	 eax, eax
  0043b	74 58		 je	 SHORT $LN38@PrinterInf

; 2328 :             {
; 2329 :                 Log(LOG_MESSAGE, __LINE__, "DC_BINS, DC_BINNAMES (%d):", pBinList->num);

  0043d	ff 30		 push	 DWORD PTR [eax]
  0043f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@IBIADDJ@DC_BINS?0?5DC_BINNAMES?5?$CI?$CFd?$CJ?3@
  00444	68 19 09 00 00	 push	 2329			; 00000919H
  00449	6a 01		 push	 1
  0044b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00450	83 c4 10	 add	 esp, 16			; 00000010H

; 2330 :                 for (i = 0; i < pBinList->num; i++)

  00453	33 f6		 xor	 esi, esi
$LN1034@PrinterInf:
  00455	89 b5 a8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], esi
  0045b	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _pBinList$1$[ebp]
  00461	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00463	7d 27		 jge	 SHORT $LN9@PrinterInf

; 2331 :                 {
; 2332 :                     Log(LOG_MESSAGE, __LINE__, ">%.2d: %u, %s", i + 1, pBinList->PtrDataInfo[i].id, pBinList->PtrDataInfo[i].name);

  00465	69 c6 10 01 00
	00		 imul	 eax, esi, 272
  0046b	03 c8		 add	 ecx, eax
  0046d	46		 inc	 esi
  0046e	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00471	50		 push	 eax
  00472	ff 71 04	 push	 DWORD PTR [ecx+4]
  00475	56		 push	 esi
  00476	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KDMGFAIN@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs@
  0047b	68 1c 09 00 00	 push	 2332			; 0000091cH
  00480	6a 01		 push	 1
  00482	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00487	83 c4 18	 add	 esp, 24			; 00000018H

; 2330 :                 for (i = 0; i < pBinList->num; i++)

  0048a	eb c9		 jmp	 SHORT $LN1034@PrinterInf
$LN9@PrinterInf:

; 2333 :                 }
; 2334 :                 delete[] pBinList;

  0048c	51		 push	 ecx
  0048d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00492	83 c4 04	 add	 esp, 4
$LN38@PrinterInf:
  00495	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0049c	eb 2d		 jmp	 SHORT $LN103@PrinterInf
__catch$?PrinterInfo@@YGIPAX@Z$0:

; 2335 :                 pBinList = NULL;
; 2336 :             }
; 2337 :         }
; 2338 :         catch (...)
; 2339 :         {
; 2340 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, Catch unhndld excpetion on BinList");

  0049e	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BNOBPGPC@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@
  004a3	68 24 09 00 00	 push	 2340			; 00000924H
  004a8	6a 10		 push	 16			; 00000010H
  004aa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  004af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2341 :         }

  004b2	b8 00 00 00 00	 mov	 eax, $LN104@PrinterInf
  004b7	c3		 ret	 0
$LN104@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
  004b8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  004bf	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
  004c5	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
$LN103@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2342 : 
; 2343 :         // *** papers & paper names & paper sizes
; 2344 :         try

  004cb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 2055 :     HANDLE hPrinter = nullptr;

  004cf	c7 85 9c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _hPrinter$2[ebp], 0

; 2056 : 
; 2057 :     if (OpenPrinter(const_cast<LPSTR>(PrinterName), &hPrinter, nullptr))

  004d9	6a 00		 push	 0
  004db	8d 85 9c fb ff
	ff		 lea	 eax, DWORD PTR _hPrinter$2[ebp]
  004e1	50		 push	 eax
  004e2	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  004e8	50		 push	 eax
  004e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenPrinterA@12
  004ef	85 c0		 test	 eax, eax
  004f1	74 15		 je	 SHORT $LN265@PrinterInf
  004f3	8d 95 9c fb ff
	ff		 lea	 edx, DWORD PTR _hPrinter$2[ebp]
  004f9	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR _DriverName$[ebp]
  004ff	e8 00 00 00 00	 call	 ?GetDeviceMode@@YAPAU_devicemodeA@@PBD0@Z ; GetDeviceMode
  00504	8b f0		 mov	 esi, eax
  00506	eb 02		 jmp	 SHORT $LN1035@PrinterInf
$LN265@PrinterInf:

; 2058 :     {
; 2059 :         long const l = DocumentProperties(NULL, hPrinter, const_cast<LPSTR>(DriverName), nullptr, nullptr, 0);
; 2060 :         pdm = reinterpret_cast<DEVMODE *>(new uint8_t[l]);
; 2061 :         if (pdm)
; 2062 :         {
; 2063 :             memset(pdm, 0x00, sizeof(uint8_t)*l);
; 2064 :             DocumentProperties(NULL, hPrinter, const_cast<LPSTR>(DriverName), pdm, NULL, DM_OUT_BUFFER);
; 2065 :         }
; 2066 :     }
; 2067 :     return pdm;

  00508	33 f6		 xor	 esi, esi
$LN1035@PrinterInf:

; 2345 :         {
; 2346 :             DEVMODE* pdm = GetDeviceMode(PrinterName, DriverName);
; 2347 : 
; 2348 :             LP_PTRDATA_INFO_LIST pPaperList = GetPaperList(PrinterName, PortName, pdm);

  0050a	89 b5 b8 fb ff
	ff		 mov	 DWORD PTR _pdm$1$[ebp], esi
  00510	56		 push	 esi
  00511	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _PortName$[ebp]
  00517	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _PrinterName$[ebp]
  0051d	e8 00 00 00 00	 call	 ?GetPaperList@@YAPAU_ptrdata_info_list_@@PBD0PBU_devicemodeA@@@Z ; GetPaperList
  00522	83 c4 04	 add	 esp, 4
  00525	89 85 bc fb ff
	ff		 mov	 DWORD PTR _pPaperList$1$[ebp], eax

; 2349 :             if (pPaperList)

  0052b	85 c0		 test	 eax, eax
  0052d	74 6a		 je	 SHORT $LN40@PrinterInf

; 2350 :             {
; 2351 :                 Log(LOG_MESSAGE, __LINE__, "DC_PAPERS, DC_PAPERNAMES, DC_PAPERSIZE (%d):", pPaperList->num);

  0052f	ff 30		 push	 DWORD PTR [eax]
  00531	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@GKNAEPGN@DC_PAPERS?0?5DC_PAPERNAMES?0?5DC_PA@
  00536	68 2f 09 00 00	 push	 2351			; 0000092fH
  0053b	6a 01		 push	 1
  0053d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00542	83 c4 10	 add	 esp, 16			; 00000010H

; 2352 :                 for (i = 0; i < pPaperList->num; i++)

  00545	33 f6		 xor	 esi, esi
$LN1036@PrinterInf:
  00547	89 b5 a8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], esi
  0054d	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _pPaperList$1$[ebp]
  00553	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00555	7d 33		 jge	 SHORT $LN12@PrinterInf

; 2353 :                 {
; 2354 :                     Log(LOG_MESSAGE, __LINE__, ">%.2d: %u, %s, %.5d %.5d", i + 1, pPaperList->PtrDataInfo[i].id, pPaperList->PtrDataInfo[i].name, pPaperList->PtrDataInfo[i].x, pPaperList->PtrDataInfo[i].y);

  00557	69 c6 10 01 00
	00		 imul	 eax, esi, 272
  0055d	03 c8		 add	 ecx, eax
  0055f	46		 inc	 esi
  00560	ff b1 10 01 00
	00		 push	 DWORD PTR [ecx+272]
  00566	ff b1 0c 01 00
	00		 push	 DWORD PTR [ecx+268]
  0056c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  0056f	50		 push	 eax
  00570	ff 71 04	 push	 DWORD PTR [ecx+4]
  00573	56		 push	 esi
  00574	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@ENBLCNAO@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs?0?5?$CF?45d?5?$CF?45d@
  00579	68 32 09 00 00	 push	 2354			; 00000932H
  0057e	6a 01		 push	 1
  00580	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00585	83 c4 20	 add	 esp, 32			; 00000020H

; 2352 :                 for (i = 0; i < pPaperList->num; i++)

  00588	eb bd		 jmp	 SHORT $LN1036@PrinterInf
$LN12@PrinterInf:

; 2355 :                 }
; 2356 :                 delete[] pPaperList;

  0058a	51		 push	 ecx
  0058b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00590	83 c4 04	 add	 esp, 4
  00593	8b b5 b8 fb ff
	ff		 mov	 esi, DWORD PTR _pdm$1$[ebp]
$LN40@PrinterInf:

; 2357 :                 pPaperList = NULL;
; 2358 :             }
; 2359 : 
; 2360 :             if (pdm) delete[] reinterpret_cast<uint8_t*>(pdm);

  00599	85 f6		 test	 esi, esi
  0059b	74 09		 je	 SHORT $LN41@PrinterInf
  0059d	56		 push	 esi
  0059e	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  005a3	83 c4 04	 add	 esp, 4
$LN41@PrinterInf:
  005a6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  005ad	eb 2d		 jmp	 SHORT $LN105@PrinterInf
__catch$?PrinterInfo@@YGIPAX@Z$2:

; 2361 :         }
; 2362 :         catch (...)
; 2363 :         {
; 2364 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, Catch unhndld excpetion on PaperList");

  005af	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CMDEFNNK@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@
  005b4	68 3c 09 00 00	 push	 2364			; 0000093cH
  005b9	6a 10		 push	 16			; 00000010H
  005bb	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  005c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2365 :         }

  005c3	b8 00 00 00 00	 mov	 eax, $LN106@PrinterInf
  005c8	c3		 ret	 0
$LN106@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
  005c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  005d0	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
  005d6	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
$LN105@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2366 : 
; 2367 :         // *** portrait - landscape
; 2368 :         l = DeviceCapabilities(PrinterName, PortName, DC_ORIENTATION, (LPSTR)ppi, NULL);

  005dc	6a 00		 push	 0
  005de	53		 push	 ebx
  005df	6a 11		 push	 17			; 00000011H
  005e1	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  005e7	50		 push	 eax
  005e8	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  005ee	50		 push	 eax
  005ef	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceCapabilitiesA@20
  005f5	ff d6		 call	 esi

; 2369 :         Log(LOG_MESSAGE, __LINE__, "DC_ORIENTATION %d", l);

  005f7	50		 push	 eax
  005f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NAFPPPIH@DC_ORIENTATION?5?$CFd@
  005fd	68 41 09 00 00	 push	 2369			; 00000941H
  00602	6a 01		 push	 1
  00604	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00609	83 c4 10	 add	 esp, 16			; 00000010H

; 2370 : 
; 2371 :         // *** maximum number of copies supported
; 2372 :         l = DeviceCapabilities(PrinterName, PortName, DC_COPIES, (LPSTR)ppi, NULL);

  0060c	6a 00		 push	 0
  0060e	53		 push	 ebx
  0060f	6a 12		 push	 18			; 00000012H
  00611	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00617	50		 push	 eax
  00618	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  0061e	50		 push	 eax
  0061f	ff d6		 call	 esi

; 2373 :         Log(LOG_MESSAGE, __LINE__, "DC_COPIES %d", l);

  00621	50		 push	 eax
  00622	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GOBEBGOJ@DC_COPIES?5?$CFd@
  00627	68 45 09 00 00	 push	 2373			; 00000945H
  0062c	6a 01		 push	 1
  0062e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00633	83 c4 10	 add	 esp, 16			; 00000010H

; 2374 : 
; 2375 :         // *** collate
; 2376 :         l = DeviceCapabilities(PrinterName, PortName, DC_COLLATE, (LPSTR)ppi, NULL);

  00636	6a 00		 push	 0
  00638	53		 push	 ebx
  00639	6a 16		 push	 22			; 00000016H
  0063b	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00641	50		 push	 eax
  00642	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00648	50		 push	 eax
  00649	ff d6		 call	 esi

; 2377 :         Log(LOG_MESSAGE, __LINE__, "DC_COLLATE %d", l);

  0064b	50		 push	 eax
  0064c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CECDKEDL@DC_COLLATE?5?$CFd@
  00651	68 49 09 00 00	 push	 2377			; 00000949H
  00656	6a 01		 push	 1
  00658	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0065d	83 c4 10	 add	 esp, 16			; 00000010H

; 2378 : 
; 2379 :         // *** color support
; 2380 :         l = DeviceCapabilities(PrinterName, PortName, DC_COLORDEVICE, (LPSTR)ppi, NULL);

  00660	6a 00		 push	 0
  00662	53		 push	 ebx
  00663	6a 20		 push	 32			; 00000020H
  00665	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0066b	50		 push	 eax
  0066c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00672	50		 push	 eax
  00673	ff d6		 call	 esi

; 2381 :         Log(LOG_MESSAGE, __LINE__, "DC_COLORDEVICE %d", l);

  00675	50		 push	 eax
  00676	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CPGDDBNJ@DC_COLORDEVICE?5?$CFd@
  0067b	68 4d 09 00 00	 push	 2381			; 0000094dH
  00680	6a 01		 push	 1
  00682	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00687	83 c4 10	 add	 esp, 16			; 00000010H

; 2382 : 
; 2383 :         // *** duplex support
; 2384 :         l = DeviceCapabilities(PrinterName, PortName, DC_DUPLEX, (LPSTR)ppi, NULL);

  0068a	6a 00		 push	 0
  0068c	53		 push	 ebx
  0068d	6a 07		 push	 7
  0068f	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00695	50		 push	 eax
  00696	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  0069c	50		 push	 eax
  0069d	ff d6		 call	 esi

; 2385 :         Log(LOG_MESSAGE, __LINE__, "DC_DUPLEX %d", l);

  0069f	50		 push	 eax
  006a0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JAMONLMJ@DC_DUPLEX?5?$CFd@
  006a5	68 51 09 00 00	 push	 2385			; 00000951H
  006aa	6a 01		 push	 1
  006ac	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  006b1	83 c4 10	 add	 esp, 16			; 00000010H

; 2386 : 
; 2387 :         // *** driver version
; 2388 :         l = DeviceCapabilities(PrinterName, PortName, DC_DRIVER, (LPSTR)ppi, NULL);

  006b4	6a 00		 push	 0
  006b6	53		 push	 ebx
  006b7	6a 0b		 push	 11			; 0000000bH
  006b9	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  006bf	50		 push	 eax
  006c0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  006c6	50		 push	 eax
  006c7	ff d6		 call	 esi

; 2389 :         Log(LOG_MESSAGE, __LINE__, "DC_DRIVER %d", l);

  006c9	50		 push	 eax
  006ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@BOEFEHCB@DC_DRIVER?5?$CFd@
  006cf	68 55 09 00 00	 push	 2389			; 00000955H
  006d4	6a 01		 push	 1
  006d6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  006db	83 c4 10	 add	 esp, 16			; 00000010H

; 2390 : 
; 2391 :         // *** spec driver version
; 2392 :         l = DeviceCapabilities(PrinterName, PortName, DC_VERSION, (LPSTR)ppi, NULL);

  006de	6a 00		 push	 0
  006e0	53		 push	 ebx
  006e1	6a 0a		 push	 10			; 0000000aH
  006e3	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  006e9	50		 push	 eax
  006ea	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  006f0	50		 push	 eax
  006f1	ff d6		 call	 esi

; 2393 :         Log(LOG_MESSAGE, __LINE__, "DC_VERSION %d", l);

  006f3	50		 push	 eax
  006f4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BHGLDB@DC_VERSION?5?$CFd@
  006f9	68 59 09 00 00	 push	 2393			; 00000959H
  006fe	6a 01		 push	 1
  00700	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00705	83 c4 10	 add	 esp, 16			; 00000010H

; 2394 : 
; 2395 :         // *** fields
; 2396 :         l = DeviceCapabilities(PrinterName, PortName, DC_FIELDS, (LPSTR)ppi, NULL);

  00708	6a 00		 push	 0
  0070a	53		 push	 ebx
  0070b	6a 01		 push	 1
  0070d	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00713	50		 push	 eax
  00714	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  0071a	50		 push	 eax
  0071b	ff d6		 call	 esi

; 2397 :         Log(LOG_MESSAGE, __LINE__, "DC_FIELDS %u", l);

  0071d	50		 push	 eax
  0071e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FMBEEHK@DC_FIELDS?5?$CFu@
  00723	68 5d 09 00 00	 push	 2397			; 0000095dH
  00728	6a 01		 push	 1
  0072a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0072f	83 c4 10	 add	 esp, 16			; 00000010H

; 2398 : 
; 2399 :         // *** maximum paper size
; 2400 :         l = DeviceCapabilities(PrinterName, PortName, DC_MAXEXTENT, (LPSTR)ppi, NULL);

  00732	6a 00		 push	 0
  00734	53		 push	 ebx
  00735	6a 05		 push	 5
  00737	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0073d	50		 push	 eax
  0073e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00744	50		 push	 eax
  00745	ff d6		 call	 esi

; 2401 :         Log(LOG_MESSAGE, __LINE__, "DC_MAXEXTENT: Length %u, Width %u", HIWORD((DWORD)l), LOWORD((DWORD)l));

  00747	0f b7 c8	 movzx	 ecx, ax
  0074a	51		 push	 ecx
  0074b	c1 e8 10	 shr	 eax, 16			; 00000010H
  0074e	50		 push	 eax
  0074f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HHEJCDLL@DC_MAXEXTENT?3?5Length?5?$CFu?0?5Width?5@
  00754	68 61 09 00 00	 push	 2401			; 00000961H
  00759	6a 01		 push	 1
  0075b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00760	83 c4 14	 add	 esp, 20			; 00000014H

; 2402 : 
; 2403 :         // *** minimum paper size
; 2404 :         l = DeviceCapabilities(PrinterName, PortName, DC_MINEXTENT, (LPSTR)ppi, NULL);

  00763	6a 00		 push	 0
  00765	53		 push	 ebx
  00766	6a 04		 push	 4
  00768	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0076e	50		 push	 eax
  0076f	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00775	50		 push	 eax
  00776	ff d6		 call	 esi

; 2405 :         Log(LOG_MESSAGE, __LINE__, "DC_MINEXTENT: Length %u, Width %u", HIWORD((DWORD)l), LOWORD((DWORD)l));

  00778	0f b7 c8	 movzx	 ecx, ax
  0077b	51		 push	 ecx
  0077c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0077f	50		 push	 eax
  00780	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@FIJGGACG@DC_MINEXTENT?3?5Length?5?$CFu?0?5Width?5@
  00785	68 65 09 00 00	 push	 2405			; 00000965H
  0078a	6a 01		 push	 1
  0078c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00791	83 c4 14	 add	 esp, 20			; 00000014H

; 2406 : 
; 2407 :         // *** size
; 2408 :         l = DeviceCapabilities(PrinterName, PortName, DC_SIZE, (LPSTR)ppi, NULL);

  00794	6a 00		 push	 0
  00796	53		 push	 ebx
  00797	6a 08		 push	 8
  00799	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0079f	50		 push	 eax
  007a0	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  007a6	50		 push	 eax
  007a7	ff d6		 call	 esi

; 2409 :         Log(LOG_MESSAGE, __LINE__, "DC_SIZE %d", l);

  007a9	50		 push	 eax
  007aa	68 00 00 00 00	 push	 OFFSET ??_C@_0L@ICJGKLML@DC_SIZE?5?$CFd@
  007af	68 69 09 00 00	 push	 2409			; 00000969H
  007b4	6a 01		 push	 1
  007b6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  007bb	83 c4 10	 add	 esp, 16			; 00000010H

; 2410 : 
; 2411 :         // *** staple
; 2412 :         l = DeviceCapabilities(PrinterName, PortName, DC_STAPLE, (LPSTR)ppi, NULL);

  007be	6a 00		 push	 0
  007c0	53		 push	 ebx
  007c1	6a 1e		 push	 30			; 0000001eH
  007c3	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  007c9	50		 push	 eax
  007ca	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  007d0	50		 push	 eax
  007d1	ff d6		 call	 esi

; 2413 :         Log(LOG_MESSAGE, __LINE__, "DC_STAPLE %d", l);

  007d3	50		 push	 eax
  007d4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ONNHJAOP@DC_STAPLE?5?$CFd@
  007d9	68 6d 09 00 00	 push	 2413			; 0000096dH
  007de	6a 01		 push	 1
  007e0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  007e5	83 c4 10	 add	 esp, 16			; 00000010H

; 2414 : 
; 2415 :         // *** TrueType
; 2416 :         l = DeviceCapabilities(PrinterName, PortName, DC_TRUETYPE, (LPSTR)ppi, NULL);

  007e8	6a 00		 push	 0
  007ea	53		 push	 ebx
  007eb	6a 0f		 push	 15			; 0000000fH
  007ed	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  007f3	50		 push	 eax
  007f4	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  007fa	50		 push	 eax
  007fb	ff d6		 call	 esi

; 2417 :         Log(LOG_MESSAGE, __LINE__, "DC_TRUETYPE %d", l);

  007fd	50		 push	 eax
  007fe	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MLIHNHLK@DC_TRUETYPE?5?$CFd@
  00803	68 71 09 00 00	 push	 2417			; 00000971H
  00808	6a 01		 push	 1
  0080a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0080f	83 c4 10	 add	 esp, 16			; 00000010H

; 2418 : 
; 2419 :         // *** multiple document pages per printed page
; 2420 :         if ((l = DeviceCapabilities(PrinterName, PortName, DC_NUP, NULL, NULL)) <= 0)

  00812	6a 00		 push	 0
  00814	6a 00		 push	 0
  00816	6a 21		 push	 33			; 00000021H
  00818	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0081e	50		 push	 eax
  0081f	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00825	50		 push	 eax
  00826	ff d6		 call	 esi
  00828	89 85 bc fb ff
	ff		 mov	 DWORD PTR _l$15$[ebp], eax
  0082e	85 c0		 test	 eax, eax
  00830	0f 8f 92 00 00
	00		 jg	 $LN42@PrinterInf

; 2422 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_NUP, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00836	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0083c	8b d0		 mov	 edx, eax
  0083e	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00844	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00849	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0084d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00851	72 02		 jb	 SHORT $LN277@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00853	8b 00		 mov	 eax, DWORD PTR [eax]
$LN277@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2422 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_NUP, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00855	50		 push	 eax
  00856	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BHONBGKL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  0085b	68 76 09 00 00	 push	 2422			; 00000976H
  00860	6a 10		 push	 16			; 00000010H
  00862	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00867	83 c4 10	 add	 esp, 16			; 00000010H
  0086a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0086e	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR $T14[ebp+20]
  00874	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00877	72 2f		 jb	 SHORT $LN325@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00879	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0087a	8b 8d 98 fc ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  00880	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00882	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00888	72 14		 jb	 SHORT $LN324@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  0088a	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0088d	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00890	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00892	83 c0 fc	 add	 eax, -4			; fffffffcH
  00895	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00898	0f 87 93 15 00
	00		 ja	 $LN1043@PrinterInf
$LN324@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0089e	52		 push	 edx
  0089f	51		 push	 ecx
  008a0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008a5	83 c4 08	 add	 esp, 8
$LN325@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  008a8	c7 85 a8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  008b2	c7 85 ac fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  008bc	c6 85 98 fc ff
	ff 00		 mov	 BYTE PTR $T14[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2424 :         else

  008c3	e9 79 01 00 00	 jmp	 $LN15@PrinterInf
$LN42@PrinterInf:

; 2425 :         {
; 2426 :             ppi = B._allocMem(l * sizeof(DWORD));

  008c8	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  008cf	3b 9d b0 fb ff
	ff		 cmp	 ebx, DWORD PTR _B$[ebp+4]
  008d5	76 2d		 jbe	 SHORT $LN340@PrinterInf

; 126  :         {
; 127  :             if (pMem)

  008d7	85 ff		 test	 edi, edi
  008d9	74 09		 je	 SHORT $LN341@PrinterInf

; 128  :                 delete[] pMem;

  008db	57		 push	 edi
  008dc	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  008e1	83 c4 04	 add	 esp, 4
$LN341@PrinterInf:

; 129  :             lMem = len;

  008e4	89 9d b0 fb ff
	ff		 mov	 DWORD PTR _B$[ebp+4], ebx

; 130  :             pMem = new byte[lMem];

  008ea	53		 push	 ebx
  008eb	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  008f0	8b f8		 mov	 edi, eax
  008f2	89 bd ac fb ff
	ff		 mov	 DWORD PTR _B$[ebp], edi

; 131  :             memset(pMem, 0x00, lMem);

  008f8	53		 push	 ebx
  008f9	6a 00		 push	 0
  008fb	57		 push	 edi
  008fc	e8 00 00 00 00	 call	 _memset
  00901	83 c4 10	 add	 esp, 16			; 00000010H
$LN340@PrinterInf:

; 132  :         }
; 133  :         return pMem;

  00904	8b df		 mov	 ebx, edi
  00906	89 9d b4 fb ff
	ff		 mov	 DWORD PTR _ppi$[ebp], ebx
  0090c	85 db		 test	 ebx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2427 :             if (!ppi)

  0090e	75 20		 jne	 SHORT $LN44@PrinterInf

; 2428 :             {
; 2429 :                 Log(LOG_DEBUG, __LINE__, "-- PtrInfo, <%s> new DC_NUP mem null", PrinterName);

  00910	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00916	50		 push	 eax
  00917	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DGNIMKMD@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_NUP?5mem@
  0091c	68 7d 09 00 00	 push	 2429			; 0000097dH
  00921	6a 10		 push	 16			; 00000010H
  00923	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00928	83 c4 10	 add	 esp, 16			; 00000010H

; 2430 :             }
; 2431 :             else

  0092b	e9 11 01 00 00	 jmp	 $LN15@PrinterInf
$LN44@PrinterInf:

; 2432 :             {
; 2433 :                 if ((n = DeviceCapabilities(PrinterName, PortName, DC_NUP, (LPSTR)ppi, NULL)) != l)

  00930	6a 00		 push	 0
  00932	57		 push	 edi
  00933	6a 21		 push	 33			; 00000021H
  00935	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  0093b	50		 push	 eax
  0093c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00942	50		 push	 eax
  00943	ff d6		 call	 esi
  00945	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _n$2$[ebp], eax
  0094b	3b 85 bc fb ff
	ff		 cmp	 eax, DWORD PTR _l$15$[ebp]
  00951	0f 84 90 00 00
	00		 je	 $LN46@PrinterInf

; 2435 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_NUP, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00957	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0095d	8b d0		 mov	 edx, eax
  0095f	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00965	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  0096a	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+12], 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0096e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00972	72 02		 jb	 SHORT $LN350@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00974	8b 00		 mov	 eax, DWORD PTR [eax]
$LN350@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2435 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_NUP, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00976	50		 push	 eax
  00977	57		 push	 edi
  00978	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CJKPCGLF@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  0097d	68 83 09 00 00	 push	 2435			; 00000983H
  00982	6a 10		 push	 16			; 00000010H
  00984	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00989	83 c4 14	 add	 esp, 20			; 00000014H
  0098c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00990	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR $T13[ebp+20]
  00996	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00999	72 2f		 jb	 SHORT $LN398@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0099b	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0099c	8b 8d 80 fc ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  009a2	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  009a4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  009aa	72 14		 jb	 SHORT $LN397@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  009ac	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  009af	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  009b2	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009b4	83 c0 fc	 add	 eax, -4			; fffffffcH
  009b7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009ba	0f 87 76 14 00
	00		 ja	 $LN1044@PrinterInf
$LN397@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  009c0	52		 push	 edx
  009c1	51		 push	 ecx
  009c2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009c7	83 c4 08	 add	 esp, 8
$LN398@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  009ca	c7 85 90 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  009d4	c7 85 94 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T13[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  009de	c6 85 80 fc ff
	ff 00		 mov	 BYTE PTR $T13[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2437 :                 else

  009e5	eb 5a		 jmp	 SHORT $LN15@PrinterInf
$LN46@PrinterInf:

; 2438 :                 {
; 2439 :                     Log(LOG_MESSAGE, __LINE__, "DC_NUP (%d):", n);

  009e7	50		 push	 eax
  009e8	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EHIGBDLP@DC_NUP?5?$CI?$CFd?$CJ?3@
  009ed	68 87 09 00 00	 push	 2439			; 00000987H
  009f2	6a 01		 push	 1
  009f4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  009f9	83 c4 10	 add	 esp, 16			; 00000010H
  009fc	33 f6		 xor	 esi, esi

; 2440 :                     for (i = 0, pdw = (DWORD *)ppi; i < n; i++, pdw++)

  009fe	39 b5 b8 fb ff
	ff		 cmp	 DWORD PTR _n$2$[ebp], esi
  00a04	7e 35		 jle	 SHORT $LN1029@PrinterInf
  00a06	8b fb		 mov	 edi, ebx
  00a08	8b 9d b8 fb ff
	ff		 mov	 ebx, DWORD PTR _n$2$[ebp]
  00a0e	66 90		 npad	 2
$LL16@PrinterInf:

; 2441 :                     {
; 2442 :                         Log(LOG_MESSAGE, __LINE__, ">%.2d: %u", i + 1, *pdw);

  00a10	46		 inc	 esi
  00a11	ff 37		 push	 DWORD PTR [edi]
  00a13	56		 push	 esi
  00a14	68 00 00 00 00	 push	 OFFSET ??_C@_09MFCBGNBM@?$DO?$CF?42d?3?5?$CFu@
  00a19	68 8a 09 00 00	 push	 2442			; 0000098aH
  00a1e	6a 01		 push	 1
  00a20	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00a25	83 c4 14	 add	 esp, 20			; 00000014H

; 2440 :                     for (i = 0, pdw = (DWORD *)ppi; i < n; i++, pdw++)

  00a28	8d 7f 04	 lea	 edi, DWORD PTR [edi+4]
  00a2b	3b f3		 cmp	 esi, ebx
  00a2d	7c e1		 jl	 SHORT $LL16@PrinterInf
  00a2f	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
  00a35	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
$LN1029@PrinterInf:

; 2443 :                     }
; 2444 :                 }
; 2445 :             }
; 2446 :         }
; 2447 : 
; 2448 :         // *** field dependencies
; 2449 :         if ((l = DeviceCapabilities(PrinterName, PortName, DC_FILEDEPENDENCIES, NULL, NULL)) <= 0)

  00a3b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceCapabilitiesA@20
$LN15@PrinterInf:
  00a41	6a 00		 push	 0
  00a43	6a 00		 push	 0
  00a45	6a 0e		 push	 14			; 0000000eH
  00a47	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00a4d	50		 push	 eax
  00a4e	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00a54	50		 push	 eax
  00a55	ff d6		 call	 esi
  00a57	89 85 bc fb ff
	ff		 mov	 DWORD PTR _l$16$[ebp], eax
  00a5d	85 c0		 test	 eax, eax
  00a5f	0f 8f 92 00 00
	00		 jg	 $LN48@PrinterInf

; 2451 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_FILEDEPENDENCIES, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00a65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00a6b	8b d0		 mov	 edx, eax
  00a6d	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00a73	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00a78	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00a7c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00a80	72 02		 jb	 SHORT $LN419@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00a82	8b 00		 mov	 eax, DWORD PTR [eax]
$LN419@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2451 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_FILEDEPENDENCIES, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00a84	50		 push	 eax
  00a85	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@GGKKNNDH@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00a8a	68 93 09 00 00	 push	 2451			; 00000993H
  00a8f	6a 10		 push	 16			; 00000010H
  00a91	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00a96	83 c4 10	 add	 esp, 16			; 00000010H
  00a99	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00a9d	8b 95 7c fc ff
	ff		 mov	 edx, DWORD PTR $T12[ebp+20]
  00aa3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00aa6	72 2f		 jb	 SHORT $LN467@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00aa8	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aa9	8b 8d 68 fc ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp]
  00aaf	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00ab1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00ab7	72 14		 jb	 SHORT $LN466@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00ab9	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00abc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00abf	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00ac1	83 c0 fc	 add	 eax, -4			; fffffffcH
  00ac4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00ac7	0f 87 6e 13 00
	00		 ja	 $LN1045@PrinterInf
$LN466@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00acd	52		 push	 edx
  00ace	51		 push	 ecx
  00acf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ad4	83 c4 08	 add	 esp, 8
$LN467@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00ad7	c7 85 78 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ae1	c7 85 7c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T12[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00aeb	c6 85 68 fc ff
	ff 00		 mov	 BYTE PTR $T12[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2453 :         else

  00af2	e9 8d 01 00 00	 jmp	 $LN18@PrinterInf
$LN48@PrinterInf:

; 2454 :         {
; 2455 :             ppi = B._allocMem(l * sizeof(NAME_64BYTES));

  00af7	8b d8		 mov	 ebx, eax
  00af9	c1 e3 06	 shl	 ebx, 6
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  00afc	3b 9d b0 fb ff
	ff		 cmp	 ebx, DWORD PTR _B$[ebp+4]
  00b02	76 2d		 jbe	 SHORT $LN482@PrinterInf

; 126  :         {
; 127  :             if (pMem)

  00b04	85 ff		 test	 edi, edi
  00b06	74 09		 je	 SHORT $LN483@PrinterInf

; 128  :                 delete[] pMem;

  00b08	57		 push	 edi
  00b09	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00b0e	83 c4 04	 add	 esp, 4
$LN483@PrinterInf:

; 129  :             lMem = len;

  00b11	89 9d b0 fb ff
	ff		 mov	 DWORD PTR _B$[ebp+4], ebx

; 130  :             pMem = new byte[lMem];

  00b17	53		 push	 ebx
  00b18	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00b1d	8b f8		 mov	 edi, eax
  00b1f	89 bd ac fb ff
	ff		 mov	 DWORD PTR _B$[ebp], edi

; 131  :             memset(pMem, 0x00, lMem);

  00b25	53		 push	 ebx
  00b26	6a 00		 push	 0
  00b28	57		 push	 edi
  00b29	e8 00 00 00 00	 call	 _memset
  00b2e	83 c4 10	 add	 esp, 16			; 00000010H
$LN482@PrinterInf:

; 132  :         }
; 133  :         return pMem;

  00b31	8b df		 mov	 ebx, edi
  00b33	89 9d b4 fb ff
	ff		 mov	 DWORD PTR _ppi$[ebp], ebx
  00b39	85 db		 test	 ebx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2456 :             if (!ppi)

  00b3b	75 20		 jne	 SHORT $LN50@PrinterInf

; 2457 :             {
; 2458 :                 Log(LOG_DEBUG, __LINE__, "-- PtrInfo, <%s> new DC_FILEDEPENDENCIES mem null", PrinterName);

  00b3d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00b43	50		 push	 eax
  00b44	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MCOOCAIH@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_FILEDEP@
  00b49	68 9a 09 00 00	 push	 2458			; 0000099aH
  00b4e	6a 10		 push	 16			; 00000010H
  00b50	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00b55	83 c4 10	 add	 esp, 16			; 00000010H

; 2459 :             }
; 2460 :             else

  00b58	e9 27 01 00 00	 jmp	 $LN18@PrinterInf
$LN50@PrinterInf:

; 2461 :             {
; 2462 :                 if ((n = DeviceCapabilities(PrinterName, PortName, DC_FILEDEPENDENCIES, (LPSTR)ppi, NULL)) != l)

  00b5d	6a 00		 push	 0
  00b5f	57		 push	 edi
  00b60	6a 0e		 push	 14			; 0000000eH
  00b62	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00b68	50		 push	 eax
  00b69	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00b6f	50		 push	 eax
  00b70	ff d6		 call	 esi
  00b72	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _n$3$[ebp], eax
  00b78	3b 85 bc fb ff
	ff		 cmp	 eax, DWORD PTR _l$16$[ebp]
  00b7e	0f 84 90 00 00
	00		 je	 $LN52@PrinterInf

; 2464 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_FILEDEPENDENCIES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00b84	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00b8a	8b d0		 mov	 edx, eax
  00b8c	8d 8d 50 fc ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00b92	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00b97	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00b9b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00b9f	72 02		 jb	 SHORT $LN492@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00ba1	8b 00		 mov	 eax, DWORD PTR [eax]
$LN492@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2464 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_FILEDEPENDENCIES, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00ba3	50		 push	 eax
  00ba4	57		 push	 edi
  00ba5	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@NOJMDJGA@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00baa	68 a0 09 00 00	 push	 2464			; 000009a0H
  00baf	6a 10		 push	 16			; 00000010H
  00bb1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00bb6	83 c4 14	 add	 esp, 20			; 00000014H
  00bb9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00bbd	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR $T11[ebp+20]
  00bc3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00bc6	72 2f		 jb	 SHORT $LN540@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00bc8	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bc9	8b 8d 50 fc ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  00bcf	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00bd1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00bd7	72 14		 jb	 SHORT $LN539@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00bd9	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00bdc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00bdf	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00be1	83 c0 fc	 add	 eax, -4			; fffffffcH
  00be4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00be7	0f 87 53 12 00
	00		 ja	 $LN1046@PrinterInf
$LN539@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00bed	52		 push	 edx
  00bee	51		 push	 ecx
  00bef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00bf4	83 c4 08	 add	 esp, 8
$LN540@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00bf7	c7 85 60 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00c01	c7 85 64 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00c0b	c6 85 50 fc ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2466 :                 else

  00c12	eb 70		 jmp	 SHORT $LN18@PrinterInf
$LN52@PrinterInf:

; 2467 :                 {
; 2468 :                     pn64 = NULL;
; 2469 :                     Log(LOG_MESSAGE, __LINE__, "DC_FILEDEPENDENCIES (%d):", n);

  00c14	50		 push	 eax
  00c15	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@NAHDGPCH@DC_FILEDEPENDENCIES?5?$CI?$CFd?$CJ?3@
  00c1a	68 a5 09 00 00	 push	 2469			; 000009a5H
  00c1f	6a 01		 push	 1
  00c21	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00c26	83 c4 10	 add	 esp, 16			; 00000010H
  00c29	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$5$[ebp], 0

; 2470 :                     for (i = 0, pn64 = (NAME_64BYTES *)ppi; i < n; i++, pn64++)

  00c33	83 bd b8 fb ff
	ff 00		 cmp	 DWORD PTR _n$3$[ebp], 0
  00c3a	7e 48		 jle	 SHORT $LN18@PrinterInf
  00c3c	8b f3		 mov	 esi, ebx
  00c3e	8b bd bc fb ff
	ff		 mov	 edi, DWORD PTR _i$5$[ebp]
  00c44	8b 9d b8 fb ff
	ff		 mov	 ebx, DWORD PTR _n$3$[ebp]
  00c4a	66 0f 1f 44 00
	00		 npad	 6
$LL19@PrinterInf:

; 2471 :                     {
; 2472 :                         pn64->name[63] = 0x00;      //avoid memory over-read if the whole buffer is filled

  00c50	c6 46 3f 00	 mov	 BYTE PTR [esi+63], 0

; 2473 :                         Log(LOG_MESSAGE, __LINE__, ">%.2d: %s", i + 1, pn64->name);

  00c54	47		 inc	 edi
  00c55	56		 push	 esi
  00c56	57		 push	 edi
  00c57	68 00 00 00 00	 push	 OFFSET ??_C@_09JDHLMKJK@?$DO?$CF?42d?3?5?$CFs@
  00c5c	68 a9 09 00 00	 push	 2473			; 000009a9H
  00c61	6a 01		 push	 1
  00c63	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00c68	83 c4 14	 add	 esp, 20			; 00000014H

; 2470 :                     for (i = 0, pn64 = (NAME_64BYTES *)ppi; i < n; i++, pn64++)

  00c6b	83 c6 40	 add	 esi, 64			; 00000040H
  00c6e	3b fb		 cmp	 edi, ebx
  00c70	7c de		 jl	 SHORT $LL19@PrinterInf
  00c72	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
  00c78	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
  00c7e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceCapabilitiesA@20
$LN18@PrinterInf:

; 2474 :                     }
; 2475 :                 }
; 2476 :             }
; 2477 :         }
; 2478 : 
; 2479 :         // *** paper forms
; 2480 :         if ((l = DeviceCapabilities(PrinterName, PortName, DC_MEDIAREADY, NULL, NULL)) <= 0)

  00c84	6a 00		 push	 0
  00c86	6a 00		 push	 0
  00c88	6a 1d		 push	 29			; 0000001dH
  00c8a	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00c90	50		 push	 eax
  00c91	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00c97	50		 push	 eax
  00c98	ff d6		 call	 esi
  00c9a	89 85 bc fb ff
	ff		 mov	 DWORD PTR _l$17$[ebp], eax
  00ca0	85 c0		 test	 eax, eax
  00ca2	0f 8f 92 00 00
	00		 jg	 $LN54@PrinterInf

; 2482 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_MEDIAREADY, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00ca8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00cae	8b d0		 mov	 edx, eax
  00cb0	8d 8d 38 fc ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00cb6	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00cbb	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00cbf	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00cc3	72 02		 jb	 SHORT $LN561@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00cc5	8b 00		 mov	 eax, DWORD PTR [eax]
$LN561@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2482 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_MEDIAREADY, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00cc7	50		 push	 eax
  00cc8	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@GEGMAAP@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00ccd	68 b2 09 00 00	 push	 2482			; 000009b2H
  00cd2	6a 10		 push	 16			; 00000010H
  00cd4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00cd9	83 c4 10	 add	 esp, 16			; 00000010H
  00cdc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00ce0	8b 95 4c fc ff
	ff		 mov	 edx, DWORD PTR $T10[ebp+20]
  00ce6	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00ce9	72 2f		 jb	 SHORT $LN609@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ceb	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00cec	8b 8d 38 fc ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  00cf2	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00cf4	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00cfa	72 14		 jb	 SHORT $LN608@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00cfc	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00cff	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00d02	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d04	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d07	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d0a	0f 87 35 11 00
	00		 ja	 $LN1047@PrinterInf
$LN608@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00d10	52		 push	 edx
  00d11	51		 push	 ecx
  00d12	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00d17	83 c4 08	 add	 esp, 8
$LN609@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00d1a	c7 85 48 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d24	c7 85 4c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T10[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00d2e	c6 85 38 fc ff
	ff 00		 mov	 BYTE PTR $T10[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2484 :         else

  00d35	e9 84 01 00 00	 jmp	 $LN21@PrinterInf
$LN54@PrinterInf:

; 2485 :         {
; 2486 :             ppi = B._allocMem(l * sizeof(NAME_64BYTES));

  00d3a	8b d8		 mov	 ebx, eax
  00d3c	c1 e3 06	 shl	 ebx, 6
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  00d3f	3b 9d b0 fb ff
	ff		 cmp	 ebx, DWORD PTR _B$[ebp+4]
  00d45	76 2d		 jbe	 SHORT $LN624@PrinterInf

; 126  :         {
; 127  :             if (pMem)

  00d47	85 ff		 test	 edi, edi
  00d49	74 09		 je	 SHORT $LN625@PrinterInf

; 128  :                 delete[] pMem;

  00d4b	57		 push	 edi
  00d4c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00d51	83 c4 04	 add	 esp, 4
$LN625@PrinterInf:

; 129  :             lMem = len;

  00d54	89 9d b0 fb ff
	ff		 mov	 DWORD PTR _B$[ebp+4], ebx

; 130  :             pMem = new byte[lMem];

  00d5a	53		 push	 ebx
  00d5b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00d60	8b f8		 mov	 edi, eax
  00d62	89 bd ac fb ff
	ff		 mov	 DWORD PTR _B$[ebp], edi

; 131  :             memset(pMem, 0x00, lMem);

  00d68	53		 push	 ebx
  00d69	6a 00		 push	 0
  00d6b	57		 push	 edi
  00d6c	e8 00 00 00 00	 call	 _memset
  00d71	83 c4 10	 add	 esp, 16			; 00000010H
$LN624@PrinterInf:

; 132  :         }
; 133  :         return pMem;

  00d74	8b df		 mov	 ebx, edi
  00d76	89 9d b4 fb ff
	ff		 mov	 DWORD PTR _ppi$[ebp], ebx
  00d7c	85 db		 test	 ebx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2487 :             if (!ppi)

  00d7e	75 20		 jne	 SHORT $LN56@PrinterInf

; 2488 :             {
; 2489 :                 Log(LOG_DEBUG, __LINE__, "-- PtrInfo, <%s> new DC_MEDIAREADY mem null", PrinterName);

  00d80	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00d86	50		 push	 eax
  00d87	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@KMOLCCC@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_MEDIARE@
  00d8c	68 b9 09 00 00	 push	 2489			; 000009b9H
  00d91	6a 10		 push	 16			; 00000010H
  00d93	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00d98	83 c4 10	 add	 esp, 16			; 00000010H

; 2490 :             }
; 2491 :             else

  00d9b	e9 1e 01 00 00	 jmp	 $LN21@PrinterInf
$LN56@PrinterInf:

; 2492 :             {
; 2493 :                 if ((n = DeviceCapabilities(PrinterName, PortName, DC_MEDIAREADY, (LPSTR)ppi, NULL)) != l)

  00da0	6a 00		 push	 0
  00da2	57		 push	 edi
  00da3	6a 1d		 push	 29			; 0000001dH
  00da5	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00dab	50		 push	 eax
  00dac	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00db2	50		 push	 eax
  00db3	ff d6		 call	 esi
  00db5	8b f0		 mov	 esi, eax
  00db7	89 b5 b8 fb ff
	ff		 mov	 DWORD PTR _n$4$[ebp], esi
  00dbd	3b b5 bc fb ff
	ff		 cmp	 esi, DWORD PTR _l$17$[ebp]
  00dc3	0f 84 90 00 00
	00		 je	 $LN58@PrinterInf

; 2495 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_MEDIAREADY, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00dc9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00dcf	8b d0		 mov	 edx, eax
  00dd1	8d 8d 20 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00dd7	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00ddc	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+12], 12 ; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00de0	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00de4	72 02		 jb	 SHORT $LN634@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00de6	8b 00		 mov	 eax, DWORD PTR [eax]
$LN634@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2495 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_MEDIAREADY, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  00de8	50		 push	 eax
  00de9	57		 push	 edi
  00dea	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@POBLKCNL@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00def	68 bf 09 00 00	 push	 2495			; 000009bfH
  00df4	6a 10		 push	 16			; 00000010H
  00df6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00dfb	83 c4 14	 add	 esp, 20			; 00000014H
  00dfe	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00e02	8b 95 34 fc ff
	ff		 mov	 edx, DWORD PTR $T9[ebp+20]
  00e08	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00e0b	72 2f		 jb	 SHORT $LN682@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e0d	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00e0e	8b 8d 20 fc ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00e14	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00e16	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00e1c	72 14		 jb	 SHORT $LN681@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00e1e	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00e21	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00e24	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00e26	83 c0 fc	 add	 eax, -4			; fffffffcH
  00e29	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00e2c	0f 87 18 10 00
	00		 ja	 $LN1048@PrinterInf
$LN681@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00e32	52		 push	 edx
  00e33	51		 push	 ecx
  00e34	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00e39	83 c4 08	 add	 esp, 8
$LN682@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00e3c	c7 85 30 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e46	c7 85 34 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00e50	c6 85 20 fc ff
	ff 00		 mov	 BYTE PTR $T9[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2497 :                 else

  00e57	eb 65		 jmp	 SHORT $LN21@PrinterInf
$LN58@PrinterInf:

; 2498 :                 {
; 2499 :                     pn64 = NULL;
; 2500 :                     Log(LOG_MESSAGE, __LINE__, "DC_MEDIAREADY (%d):", n);

  00e59	56		 push	 esi
  00e5a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JHLOAEJA@DC_MEDIAREADY?5?$CI?$CFd?$CJ?3@
  00e5f	68 c4 09 00 00	 push	 2500			; 000009c4H
  00e64	6a 01		 push	 1
  00e66	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00e6b	83 c4 10	 add	 esp, 16			; 00000010H
  00e6e	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$6$[ebp], 0

; 2501 :                     for (i = 0, pn64 = (NAME_64BYTES *)ppi; i < n; i++, pn64++)

  00e78	85 f6		 test	 esi, esi
  00e7a	7e 42		 jle	 SHORT $LN21@PrinterInf
  00e7c	8b f3		 mov	 esi, ebx
  00e7e	8b bd bc fb ff
	ff		 mov	 edi, DWORD PTR _i$6$[ebp]
  00e84	8b 9d b8 fb ff
	ff		 mov	 ebx, DWORD PTR _n$4$[ebp]
  00e8a	66 0f 1f 44 00
	00		 npad	 6
$LL22@PrinterInf:

; 2502 :                     {
; 2503 :                         pn64->name[63] = 0x00;      //avoid memory over-read if the whole buffer is filled

  00e90	c6 46 3f 00	 mov	 BYTE PTR [esi+63], 0

; 2504 :                         Log(LOG_MESSAGE, __LINE__, ">%.2d: %s", i + 1, pn64->name);

  00e94	47		 inc	 edi
  00e95	56		 push	 esi
  00e96	57		 push	 edi
  00e97	68 00 00 00 00	 push	 OFFSET ??_C@_09JDHLMKJK@?$DO?$CF?42d?3?5?$CFs@
  00e9c	68 c8 09 00 00	 push	 2504			; 000009c8H
  00ea1	6a 01		 push	 1
  00ea3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00ea8	83 c4 14	 add	 esp, 20			; 00000014H

; 2501 :                     for (i = 0, pn64 = (NAME_64BYTES *)ppi; i < n; i++, pn64++)

  00eab	83 c6 40	 add	 esi, 64			; 00000040H
  00eae	3b fb		 cmp	 edi, ebx
  00eb0	7c de		 jl	 SHORT $LL22@PrinterInf
  00eb2	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
  00eb8	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
$LN21@PrinterInf:

; 2505 :                     }
; 2506 :                 }
; 2507 :             }
; 2508 :         }
; 2509 : 
; 2510 :         if (GetWinVer() > 5)

  00ebe	e8 00 00 00 00	 call	 ?GetWinVer@@YAKXZ	; GetWinVer
  00ec3	83 f8 05	 cmp	 eax, 5
  00ec6	0f 86 ad 00 00
	00		 jbe	 $LN107@PrinterInf

; 2511 :         {
; 2512 :             // *** media types & media type names
; 2513 :             try

  00ecc	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+12], 13 ; 0000000dH

; 2514 :             {
; 2515 :                 LP_PTRDATA_INFO_LIST pMediaTypeList = GetMediaTypeList(PrinterName, PortName);

  00ed0	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _PortName$[ebp]
  00ed6	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _PrinterName$[ebp]
  00edc	e8 00 00 00 00	 call	 ?GetMediaTypeList@@YAPAU_ptrdata_info_list_@@PBD0@Z ; GetMediaTypeList
  00ee1	89 85 bc fb ff
	ff		 mov	 DWORD PTR _pMediaTypeList$1$[ebp], eax

; 2516 :                 if (pMediaTypeList)

  00ee7	85 c0		 test	 eax, eax
  00ee9	74 58		 je	 SHORT $LN62@PrinterInf

; 2517 :                 {
; 2518 :                     Log(LOG_MESSAGE, __LINE__, "DC_MEDIATYPES, DC_MEDIATYPENAMES (%d):", pMediaTypeList->num);

  00eeb	ff 30		 push	 DWORD PTR [eax]
  00eed	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OFCLBKDH@DC_MEDIATYPES?0?5DC_MEDIATYPENAME@
  00ef2	68 d6 09 00 00	 push	 2518			; 000009d6H
  00ef7	6a 01		 push	 1
  00ef9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00efe	83 c4 10	 add	 esp, 16			; 00000010H

; 2519 :                     for (i = 0; i < pMediaTypeList->num; i++)

  00f01	33 f6		 xor	 esi, esi
$LN1037@PrinterInf:
  00f03	89 b5 a8 fb ff
	ff		 mov	 DWORD PTR _i$[ebp], esi
  00f09	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR _pMediaTypeList$1$[ebp]
  00f0f	3b 31		 cmp	 esi, DWORD PTR [ecx]
  00f11	7d 27		 jge	 SHORT $LN24@PrinterInf

; 2520 :                     {
; 2521 :                         Log(LOG_MESSAGE, __LINE__, ">%.2d: %u, %s", i + 1, pMediaTypeList->PtrDataInfo[i].id, pMediaTypeList->PtrDataInfo[i].name);

  00f13	69 c6 10 01 00
	00		 imul	 eax, esi, 272
  00f19	03 c8		 add	 ecx, eax
  00f1b	46		 inc	 esi
  00f1c	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00f1f	50		 push	 eax
  00f20	ff 71 04	 push	 DWORD PTR [ecx+4]
  00f23	56		 push	 esi
  00f24	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KDMGFAIN@?$DO?$CF?42d?3?5?$CFu?0?5?$CFs@
  00f29	68 d9 09 00 00	 push	 2521			; 000009d9H
  00f2e	6a 01		 push	 1
  00f30	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00f35	83 c4 18	 add	 esp, 24			; 00000018H

; 2519 :                     for (i = 0; i < pMediaTypeList->num; i++)

  00f38	eb c9		 jmp	 SHORT $LN1037@PrinterInf
$LN24@PrinterInf:

; 2522 :                     }
; 2523 :                     delete[] pMediaTypeList;

  00f3a	51		 push	 ecx
  00f3b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00f40	83 c4 04	 add	 esp, 4
$LN62@PrinterInf:
  00f43	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00f4a	eb 2d		 jmp	 SHORT $LN107@PrinterInf
__catch$?PrinterInfo@@YGIPAX@Z$4:

; 2524 :                     pMediaTypeList = NULL;
; 2525 :                 }
; 2526 :             }
; 2527 :             catch (...)
; 2528 :             {
; 2529 :                 Log(LOG_DEBUG, __LINE__, "-- PtrInfo, Catch unhndld excpetion on MediaTypeList");

  00f4c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@CIBLFONP@?9?9?5PtrInfo?0?5Catch?5unhndld?5excpe@
  00f51	68 e1 09 00 00	 push	 2529			; 000009e1H
  00f56	6a 10		 push	 16			; 00000010H
  00f58	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00f5d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2530 :             }

  00f60	b8 00 00 00 00	 mov	 eax, $LN108@PrinterInf
  00f65	c3		 ret	 0
$LN108@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h
  00f66	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00f6d	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
  00f73	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
$LN107@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2531 :         }
; 2532 : 
; 2533 :         // *** list of printer description languages supported
; 2534 :         if ((l = DeviceCapabilities(PrinterName, PortName, DC_PERSONALITY, NULL, NULL)) <= 0)

  00f79	6a 00		 push	 0
  00f7b	6a 00		 push	 0
  00f7d	6a 19		 push	 25			; 00000019H
  00f7f	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  00f85	50		 push	 eax
  00f86	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  00f8c	50		 push	 eax
  00f8d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__DeviceCapabilitiesA@20
  00f93	ff d6		 call	 esi
  00f95	89 85 bc fb ff
	ff		 mov	 DWORD PTR _l$18$[ebp], eax
  00f9b	85 c0		 test	 eax, eax
  00f9d	0f 8f 94 00 00
	00		 jg	 $LN63@PrinterInf

; 2536 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_PERSONALITY, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00fa3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  00fa9	ff d6		 call	 esi
  00fab	8b d0		 mov	 edx, eax
  00fad	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00fb3	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00fb8	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+12], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00fbc	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00fc0	72 02		 jb	 SHORT $LN707@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00fc2	8b 00		 mov	 eax, DWORD PTR [eax]
$LN707@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2536 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_PERSONALITY, null) %s", GetLastErrorMessage(GetLastError()).c_str());

  00fc4	50		 push	 eax
  00fc5	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@PACCMPGC@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  00fca	68 e8 09 00 00	 push	 2536			; 000009e8H
  00fcf	6a 10		 push	 16			; 00000010H
  00fd1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00fd6	83 c4 10	 add	 esp, 16			; 00000010H
  00fd9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00fdd	8b 95 1c fc ff
	ff		 mov	 edx, DWORD PTR $T8[ebp+20]
  00fe3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00fe6	72 2f		 jb	 SHORT $LN755@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00fe8	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00fe9	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  00fef	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00ff1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00ff7	72 14		 jb	 SHORT $LN754@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  00ff9	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00ffc	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00fff	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01001	83 c0 fc	 add	 eax, -4			; fffffffcH
  01004	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01007	0f 87 42 0e 00
	00		 ja	 $LN1049@PrinterInf
$LN754@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0100d	52		 push	 edx
  0100e	51		 push	 ecx
  0100f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01014	83 c4 08	 add	 esp, 8
$LN755@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01017	c7 85 18 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01021	c7 85 1c fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0102b	c6 85 08 fc ff
	ff 00		 mov	 BYTE PTR $T8[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2538 :         else

  01032	e9 8d 01 00 00	 jmp	 $LN27@PrinterInf
$LN63@PrinterInf:

; 2539 :         {
; 2540 :             ppi = B._allocMem(l * sizeof(NAME_32BYTES));

  01037	8b d8		 mov	 ebx, eax
  01039	c1 e3 05	 shl	 ebx, 5
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 125  :         if (len > lMem)

  0103c	3b 9d b0 fb ff
	ff		 cmp	 ebx, DWORD PTR _B$[ebp+4]
  01042	76 2d		 jbe	 SHORT $LN770@PrinterInf

; 126  :         {
; 127  :             if (pMem)

  01044	85 ff		 test	 edi, edi
  01046	74 09		 je	 SHORT $LN771@PrinterInf

; 128  :                 delete[] pMem;

  01048	57		 push	 edi
  01049	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0104e	83 c4 04	 add	 esp, 4
$LN771@PrinterInf:

; 129  :             lMem = len;

  01051	89 9d b0 fb ff
	ff		 mov	 DWORD PTR _B$[ebp+4], ebx

; 130  :             pMem = new byte[lMem];

  01057	53		 push	 ebx
  01058	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0105d	8b f8		 mov	 edi, eax
  0105f	89 bd ac fb ff
	ff		 mov	 DWORD PTR _B$[ebp], edi

; 131  :             memset(pMem, 0x00, lMem);

  01065	53		 push	 ebx
  01066	6a 00		 push	 0
  01068	57		 push	 edi
  01069	e8 00 00 00 00	 call	 _memset
  0106e	83 c4 10	 add	 esp, 16			; 00000010H
$LN770@PrinterInf:

; 132  :         }
; 133  :         return pMem;

  01071	8b df		 mov	 ebx, edi
  01073	89 9d b4 fb ff
	ff		 mov	 DWORD PTR _ppi$[ebp], ebx
  01079	85 db		 test	 ebx, ebx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2541 :             if (!ppi)

  0107b	75 20		 jne	 SHORT $LN65@PrinterInf

; 2542 :             {
; 2543 :                 Log(LOG_DEBUG, __LINE__, "-- PtrInfo, <%s> new DC_PERSONALITY mem null", PrinterName);

  0107d	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  01083	50		 push	 eax
  01084	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FDCGHEM@?9?9?5PtrInfo?0?5?$DM?$CFs?$DO?5new?5DC_PERSONA@
  01089	68 ef 09 00 00	 push	 2543			; 000009efH
  0108e	6a 10		 push	 16			; 00000010H
  01090	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01095	83 c4 10	 add	 esp, 16			; 00000010H

; 2544 :             }
; 2545 :             else

  01098	e9 21 01 00 00	 jmp	 $LN1030@PrinterInf
$LN65@PrinterInf:

; 2546 :             {
; 2547 :                 if ((n = DeviceCapabilities(PrinterName, PortName, DC_PERSONALITY, (LPSTR)ppi, NULL)) != l)

  0109d	6a 00		 push	 0
  0109f	57		 push	 edi
  010a0	6a 19		 push	 25			; 00000019H
  010a2	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _PortName$[ebp]
  010a8	50		 push	 eax
  010a9	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  010af	50		 push	 eax
  010b0	ff d6		 call	 esi
  010b2	8b f0		 mov	 esi, eax
  010b4	89 b5 b8 fb ff
	ff		 mov	 DWORD PTR _n$5$[ebp], esi
  010ba	3b b5 bc fb ff
	ff		 cmp	 esi, DWORD PTR _l$18$[ebp]
  010c0	0f 84 92 00 00
	00		 je	 $LN67@PrinterInf

; 2549 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_PERSONALITY, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  010c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  010cc	ff d6		 call	 esi
  010ce	8b d0		 mov	 edx, eax
  010d0	8d 8d f0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  010d6	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  010db	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+12], 16 ; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  010df	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  010e3	72 02		 jb	 SHORT $LN780@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  010e5	8b 00		 mov	 eax, DWORD PTR [eax]
$LN780@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2549 :                     Log(LOG_DEBUG, __LINE__, "-- PtrInfo, DeviceCapabilities(DC_PERSONALITY, %p) %s", ppi, GetLastErrorMessage(GetLastError()).c_str());

  010e7	50		 push	 eax
  010e8	57		 push	 edi
  010e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NKFBLOLE@?9?9?5PtrInfo?0?5DeviceCapabilities?$CI@
  010ee	68 f5 09 00 00	 push	 2549			; 000009f5H
  010f3	6a 10		 push	 16			; 00000010H
  010f5	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  010fa	83 c4 14	 add	 esp, 20			; 00000014H
  010fd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  01101	8b 95 04 fc ff
	ff		 mov	 edx, DWORD PTR $T7[ebp+20]
  01107	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0110a	72 2f		 jb	 SHORT $LN828@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0110c	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0110d	8b 8d f0 fb ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  01113	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01115	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0111b	72 14		 jb	 SHORT $LN827@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  0111d	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01120	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01123	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01125	83 c0 fc	 add	 eax, -4			; fffffffcH
  01128	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0112b	0f 87 23 0d 00
	00		 ja	 $LN1050@PrinterInf
$LN827@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01131	52		 push	 edx
  01132	51		 push	 ecx
  01133	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01138	83 c4 08	 add	 esp, 8
$LN828@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0113b	c7 85 00 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01145	c7 85 04 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0114f	c6 85 f0 fb ff
	ff 00		 mov	 BYTE PTR $T7[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2551 :                 else

  01156	eb 6c		 jmp	 SHORT $LN27@PrinterInf
$LN67@PrinterInf:

; 2552 :                 {
; 2553 :                     pn32 = NULL;
; 2554 :                     Log(LOG_MESSAGE, __LINE__, "DC_PERSONALITY (%d):", n);

  01158	56		 push	 esi
  01159	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JJAELOOF@DC_PERSONALITY?5?$CI?$CFd?$CJ?3@
  0115e	68 fa 09 00 00	 push	 2554			; 000009faH
  01163	6a 01		 push	 1
  01165	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0116a	83 c4 10	 add	 esp, 16			; 00000010H
  0116d	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8$[ebp], 0

; 2555 :                     for (i = 0, pn32 = (NAME_32BYTES *)ppi; i < n; i++, pn32++)

  01177	85 f6		 test	 esi, esi
  01179	7e 43		 jle	 SHORT $LN1030@PrinterInf
  0117b	8b f3		 mov	 esi, ebx
  0117d	8b bd bc fb ff
	ff		 mov	 edi, DWORD PTR _i$8$[ebp]
  01183	8b 9d b8 fb ff
	ff		 mov	 ebx, DWORD PTR _n$5$[ebp]
  01189	0f 1f 80 00 00
	00 00		 npad	 7
$LL28@PrinterInf:

; 2556 :                     {
; 2557 :                         pn32->name[31] = 0x00;      //avoid memory over-read if the whole buffer is filled

  01190	c6 46 1f 00	 mov	 BYTE PTR [esi+31], 0

; 2558 :                         Log(LOG_MESSAGE, __LINE__, ">%.2d: %s", i + 1, pn32->name);

  01194	47		 inc	 edi
  01195	56		 push	 esi
  01196	57		 push	 edi
  01197	68 00 00 00 00	 push	 OFFSET ??_C@_09JDHLMKJK@?$DO?$CF?42d?3?5?$CFs@
  0119c	68 fe 09 00 00	 push	 2558			; 000009feH
  011a1	6a 01		 push	 1
  011a3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  011a8	83 c4 14	 add	 esp, 20			; 00000014H

; 2555 :                     for (i = 0, pn32 = (NAME_32BYTES *)ppi; i < n; i++, pn32++)

  011ab	83 c6 20	 add	 esi, 32			; 00000020H
  011ae	3b fb		 cmp	 edi, ebx
  011b0	7c de		 jl	 SHORT $LL28@PrinterInf
  011b2	8b bd ac fb ff
	ff		 mov	 edi, DWORD PTR _B$[ebp]
  011b8	8b 9d b4 fb ff
	ff		 mov	 ebx, DWORD PTR _ppi$[ebp]
$LN1030@PrinterInf:

; 2559 :                     }
; 2560 :                 }
; 2561 :             }
; 2562 :         }
; 2563 : 
; 2564 :         // *** document properties
; 2565 :         HANDLE hPrinter = NULL;

  011be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
$LN27@PrinterInf:
  011c4	c7 85 a4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _hPrinter$4[ebp], 0

; 2566 :         if (OpenPrinter(PrinterName, &hPrinter, NULL))

  011ce	6a 00		 push	 0
  011d0	8d 85 a4 fb ff
	ff		 lea	 eax, DWORD PTR _hPrinter$4[ebp]
  011d6	50		 push	 eax
  011d7	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  011dd	50		 push	 eax
  011de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenPrinterA@12
  011e4	85 c0		 test	 eax, eax
  011e6	0f 84 7b 03 00
	00		 je	 $LN69@PrinterInf

; 2567 :         {
; 2568 :             l = DocumentProperties(NULL, hPrinter, DriverName, NULL, NULL, 0);

  011ec	6a 00		 push	 0
  011ee	6a 00		 push	 0
  011f0	6a 00		 push	 0
  011f2	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  011f8	50		 push	 eax
  011f9	ff b5 a4 fb ff
	ff		 push	 DWORD PTR _hPrinter$4[ebp]
  011ff	6a 00		 push	 0
  01201	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DocumentPropertiesA@24
  01207	89 85 bc fb ff
	ff		 mov	 DWORD PTR _l$19$[ebp], eax

; 2569 :             DEVMODE *pdm = (DEVMODE *)new char[l];

  0120d	50		 push	 eax
  0120e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01213	83 c4 04	 add	 esp, 4
  01216	8b f0		 mov	 esi, eax

; 2570 :             if (pdm)

  01218	85 f6		 test	 esi, esi
  0121a	0f 84 30 03 00
	00		 je	 $LN71@PrinterInf

; 2571 :             {
; 2572 :                 memset(pdm, 0x00, sizeof(char)*l);

  01220	ff b5 bc fb ff
	ff		 push	 DWORD PTR _l$19$[ebp]
  01226	6a 00		 push	 0
  01228	56		 push	 esi
  01229	e8 00 00 00 00	 call	 _memset
  0122e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2573 :                 DocumentProperties(NULL, hPrinter, DriverName, pdm, NULL, DM_OUT_BUFFER);

  01231	6a 02		 push	 2
  01233	6a 00		 push	 0
  01235	56		 push	 esi
  01236	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  0123c	50		 push	 eax
  0123d	ff b5 a4 fb ff
	ff		 push	 DWORD PTR _hPrinter$4[ebp]
  01243	6a 00		 push	 0
  01245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DocumentPropertiesA@24

; 2574 :                 Log(LOG_MESSAGE, __LINE__, "DEVMODE:");

  0124b	68 00 00 00 00	 push	 OFFSET ??_C@_08JFBLCBEM@DEVMODE?3@
  01250	68 0e 0a 00 00	 push	 2574			; 00000a0eH
  01255	6a 01		 push	 1
  01257	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2575 :                 Log(LOG_MESSAGE, __LINE__, "> DeviceName %s", pdm->dmDeviceName);

  0125c	56		 push	 esi
  0125d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KDNAKNNN@?$DO?5DeviceName?5?$CFs@
  01262	68 0f 0a 00 00	 push	 2575			; 00000a0fH
  01267	6a 01		 push	 1
  01269	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2576 :                 Log(LOG_MESSAGE, __LINE__, "> SpecVersion %d", pdm->dmSpecVersion);

  0126e	0f b7 46 20	 movzx	 eax, WORD PTR [esi+32]
  01272	50		 push	 eax
  01273	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GFIGJBOF@?$DO?5SpecVersion?5?$CFd@
  01278	68 10 0a 00 00	 push	 2576			; 00000a10H
  0127d	6a 01		 push	 1
  0127f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2577 :                 Log(LOG_MESSAGE, __LINE__, "> DriverVersion %d", pdm->dmDriverVersion);

  01284	0f b7 46 22	 movzx	 eax, WORD PTR [esi+34]
  01288	50		 push	 eax
  01289	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FHCKIAEA@?$DO?5DriverVersion?5?$CFd@
  0128e	68 11 0a 00 00	 push	 2577			; 00000a11H
  01293	6a 01		 push	 1
  01295	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2578 :                 Log(LOG_MESSAGE, __LINE__, "> Size %d", pdm->dmSize);

  0129a	0f b7 46 24	 movzx	 eax, WORD PTR [esi+36]
  0129e	50		 push	 eax
  0129f	68 00 00 00 00	 push	 OFFSET ??_C@_09EJHHAJLO@?$DO?5Size?5?$CFd@
  012a4	68 12 0a 00 00	 push	 2578			; 00000a12H
  012a9	6a 01		 push	 1
  012ab	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  012b0	83 c4 4c	 add	 esp, 76			; 0000004cH

; 2579 :                 Log(LOG_MESSAGE, __LINE__, "> DriverExtra %d", pdm->dmDriverExtra);

  012b3	0f b7 46 26	 movzx	 eax, WORD PTR [esi+38]
  012b7	50		 push	 eax
  012b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NFLJLFB@?$DO?5DriverExtra?5?$CFd@
  012bd	68 13 0a 00 00	 push	 2579			; 00000a13H
  012c2	6a 01		 push	 1
  012c4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2580 :                 Log(LOG_MESSAGE, __LINE__, "> DriverFields 0x%.8X", pdm->dmFields);

  012c9	ff 76 28	 push	 DWORD PTR [esi+40]
  012cc	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JDMKIO@?$DO?5DriverFields?50x?$CF?48X@
  012d1	68 14 0a 00 00	 push	 2580			; 00000a14H
  012d6	6a 01		 push	 1
  012d8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2581 :                 Log(LOG_MESSAGE, __LINE__, "> Orient %d", pdm->dmOrientation);

  012dd	0f bf 46 2c	 movsx	 eax, WORD PTR [esi+44]
  012e1	50		 push	 eax
  012e2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PJOJJBEC@?$DO?5Orient?5?$CFd@
  012e7	68 15 0a 00 00	 push	 2581			; 00000a15H
  012ec	6a 01		 push	 1
  012ee	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2582 :                 Log(LOG_MESSAGE, __LINE__, "> PaperSize %d", pdm->dmPaperSize);

  012f3	0f bf 46 2e	 movsx	 eax, WORD PTR [esi+46]
  012f7	50		 push	 eax
  012f8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MIJBPCPJ@?$DO?5PaperSize?5?$CFd@
  012fd	68 16 0a 00 00	 push	 2582			; 00000a16H
  01302	6a 01		 push	 1
  01304	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01309	83 c4 40	 add	 esp, 64			; 00000040H

; 2583 :                 Log(LOG_MESSAGE, __LINE__, "> PaperLength %d", pdm->dmPaperLength);

  0130c	0f bf 46 30	 movsx	 eax, WORD PTR [esi+48]
  01310	50		 push	 eax
  01311	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NFCPDFAH@?$DO?5PaperLength?5?$CFd@
  01316	68 17 0a 00 00	 push	 2583			; 00000a17H
  0131b	6a 01		 push	 1
  0131d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2584 :                 Log(LOG_MESSAGE, __LINE__, "> PaperWidth %d", pdm->dmPaperWidth);

  01322	0f bf 46 32	 movsx	 eax, WORD PTR [esi+50]
  01326	50		 push	 eax
  01327	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@EJLKBGAF@?$DO?5PaperWidth?5?$CFd@
  0132c	68 18 0a 00 00	 push	 2584			; 00000a18H
  01331	6a 01		 push	 1
  01333	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2585 :                 Log(LOG_MESSAGE, __LINE__, "> Scale %d", pdm->dmScale);

  01338	0f bf 46 34	 movsx	 eax, WORD PTR [esi+52]
  0133c	50		 push	 eax
  0133d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CIICACOJ@?$DO?5Scale?5?$CFd@
  01342	68 19 0a 00 00	 push	 2585			; 00000a19H
  01347	6a 01		 push	 1
  01349	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2586 :                 Log(LOG_MESSAGE, __LINE__, "> Copies %d", pdm->dmCopies);

  0134e	0f bf 46 36	 movsx	 eax, WORD PTR [esi+54]
  01352	50		 push	 eax
  01353	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MCOJLIEN@?$DO?5Copies?5?$CFd@
  01358	68 1a 0a 00 00	 push	 2586			; 00000a1aH
  0135d	6a 01		 push	 1
  0135f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01364	83 c4 40	 add	 esp, 64			; 00000040H

; 2587 :                 Log(LOG_MESSAGE, __LINE__, "> DefaultSource %d", pdm->dmDefaultSource);

  01367	0f bf 46 38	 movsx	 eax, WORD PTR [esi+56]
  0136b	50		 push	 eax
  0136c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PBLNKDE@?$DO?5DefaultSource?5?$CFd@
  01371	68 1b 0a 00 00	 push	 2587			; 00000a1bH
  01376	6a 01		 push	 1
  01378	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2588 :                 Log(LOG_MESSAGE, __LINE__, "> PrintQulity %d", pdm->dmPrintQuality);

  0137d	0f bf 46 3a	 movsx	 eax, WORD PTR [esi+58]
  01381	50		 push	 eax
  01382	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FEEDGEPE@?$DO?5PrintQulity?5?$CFd@
  01387	68 1c 0a 00 00	 push	 2588			; 00000a1cH
  0138c	6a 01		 push	 1
  0138e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2589 :                 Log(LOG_MESSAGE, __LINE__, "> Color %d", pdm->dmColor);

  01393	0f bf 46 3c	 movsx	 eax, WORD PTR [esi+60]
  01397	50		 push	 eax
  01398	68 00 00 00 00	 push	 OFFSET ??_C@_0L@OGGOANCL@?$DO?5Color?5?$CFd@
  0139d	68 1d 0a 00 00	 push	 2589			; 00000a1dH
  013a2	6a 01		 push	 1
  013a4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2590 :                 Log(LOG_MESSAGE, __LINE__, "> Duplex %d", pdm->dmDuplex);

  013a9	0f bf 46 3e	 movsx	 eax, WORD PTR [esi+62]
  013ad	50		 push	 eax
  013ae	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DMDDHFGN@?$DO?5Duplex?5?$CFd@
  013b3	68 1e 0a 00 00	 push	 2590			; 00000a1eH
  013b8	6a 01		 push	 1
  013ba	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  013bf	83 c4 40	 add	 esp, 64			; 00000040H

; 2591 :                 Log(LOG_MESSAGE, __LINE__, "> YResolution %d", pdm->dmYResolution);

  013c2	0f bf 46 40	 movsx	 eax, WORD PTR [esi+64]
  013c6	50		 push	 eax
  013c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@ODANIHPJ@?$DO?5YResolution?5?$CFd@
  013cc	68 1f 0a 00 00	 push	 2591			; 00000a1fH
  013d1	6a 01		 push	 1
  013d3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2592 :                 Log(LOG_MESSAGE, __LINE__, "> TTOption %d", pdm->dmTTOption);

  013d8	0f bf 46 42	 movsx	 eax, WORD PTR [esi+66]
  013dc	50		 push	 eax
  013dd	68 00 00 00 00	 push	 OFFSET ??_C@_0O@ODMOOLLN@?$DO?5TTOption?5?$CFd@
  013e2	68 20 0a 00 00	 push	 2592			; 00000a20H
  013e7	6a 01		 push	 1
  013e9	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2593 :                 Log(LOG_MESSAGE, __LINE__, "> Collate %d", pdm->dmCollate);

  013ee	0f bf 46 44	 movsx	 eax, WORD PTR [esi+68]
  013f2	50		 push	 eax
  013f3	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DEPFBBGA@?$DO?5Collate?5?$CFd@
  013f8	68 21 0a 00 00	 push	 2593			; 00000a21H
  013fd	6a 01		 push	 1
  013ff	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2594 :                 Log(LOG_MESSAGE, __LINE__, "> FormName %s", pdm->dmFormName);

  01404	8d 46 46	 lea	 eax, DWORD PTR [esi+70]
  01407	50		 push	 eax
  01408	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NAFNONHG@?$DO?5FormName?5?$CFs@
  0140d	68 22 0a 00 00	 push	 2594			; 00000a22H
  01412	6a 01		 push	 1
  01414	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01419	83 c4 40	 add	 esp, 64			; 00000040H

; 2595 :                 Log(LOG_MESSAGE, __LINE__, "> LogPixels %d", pdm->dmLogPixels);

  0141c	0f b7 46 66	 movzx	 eax, WORD PTR [esi+102]
  01420	50		 push	 eax
  01421	68 00 00 00 00	 push	 OFFSET ??_C@_0P@HBAMONIO@?$DO?5LogPixels?5?$CFd@
  01426	68 23 0a 00 00	 push	 2595			; 00000a23H
  0142b	6a 01		 push	 1
  0142d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2596 :                 Log(LOG_MESSAGE, __LINE__, "> BitsPerPel %u", pdm->dmBitsPerPel);

  01432	ff 76 68	 push	 DWORD PTR [esi+104]
  01435	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IJGBMLDF@?$DO?5BitsPerPel?5?$CFu@
  0143a	68 24 0a 00 00	 push	 2596			; 00000a24H
  0143f	6a 01		 push	 1
  01441	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2597 :                 Log(LOG_MESSAGE, __LINE__, "> PelsWidth %u", pdm->dmPelsWidth);

  01446	ff 76 6c	 push	 DWORD PTR [esi+108]
  01449	68 00 00 00 00	 push	 OFFSET ??_C@_0P@GJDEABGN@?$DO?5PelsWidth?5?$CFu@
  0144e	68 25 0a 00 00	 push	 2597			; 00000a25H
  01453	6a 01		 push	 1
  01455	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2598 :                 Log(LOG_MESSAGE, __LINE__, "> PelsHeight %d", pdm->dmPelsHeight);

  0145a	ff 76 70	 push	 DWORD PTR [esi+112]
  0145d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FJKIIKDN@?$DO?5PelsHeight?5?$CFd@
  01462	68 26 0a 00 00	 push	 2598			; 00000a26H
  01467	6a 01		 push	 1
  01469	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0146e	83 c4 40	 add	 esp, 64			; 00000040H

; 2599 :                 if (GetWinVer() >= 4)

  01471	e8 00 00 00 00	 call	 ?GetWinVer@@YAKXZ	; GetWinVer
  01476	83 f8 04	 cmp	 eax, 4
  01479	0f 82 c8 00 00
	00		 jb	 $LN73@PrinterInf

; 2600 :                 {
; 2601 :                     Log(LOG_MESSAGE, __LINE__, "> ICMMethod %u", pdm->dmICMMethod);

  0147f	ff 76 7c	 push	 DWORD PTR [esi+124]
  01482	68 00 00 00 00	 push	 OFFSET ??_C@_0P@BALKIIFI@?$DO?5ICMMethod?5?$CFu@
  01487	68 29 0a 00 00	 push	 2601			; 00000a29H
  0148c	6a 01		 push	 1
  0148e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2602 :                     Log(LOG_MESSAGE, __LINE__, "> ICMIntent %u", pdm->dmICMIntent);

  01493	ff b6 80 00 00
	00		 push	 DWORD PTR [esi+128]
  01499	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FBGPJDBI@?$DO?5ICMIntent?5?$CFu@
  0149e	68 2a 0a 00 00	 push	 2602			; 00000a2aH
  014a3	6a 01		 push	 1
  014a5	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2603 :                     Log(LOG_MESSAGE, __LINE__, "> MediaType %u", pdm->dmMediaType);

  014aa	ff b6 84 00 00
	00		 push	 DWORD PTR [esi+132]
  014b0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DGLLLDPA@?$DO?5MediaType?5?$CFu@
  014b5	68 2b 0a 00 00	 push	 2603			; 00000a2bH
  014ba	6a 01		 push	 1
  014bc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2604 :                     Log(LOG_MESSAGE, __LINE__, "> DitherType %u", pdm->dmDitherType);

  014c1	ff b6 88 00 00
	00		 push	 DWORD PTR [esi+136]
  014c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IBDIEDAP@?$DO?5DitherType?5?$CFu@
  014cc	68 2c 0a 00 00	 push	 2604			; 00000a2cH
  014d1	6a 01		 push	 1
  014d3	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  014d8	83 c4 40	 add	 esp, 64			; 00000040H

; 2605 :                     Log(LOG_MESSAGE, __LINE__, "> Reserved1 %u", pdm->dmReserved1);

  014db	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  014e1	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ODIJDFHK@?$DO?5Reserved1?5?$CFu@
  014e6	68 2d 0a 00 00	 push	 2605			; 00000a2dH
  014eb	6a 01		 push	 1
  014ed	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2606 :                     Log(LOG_MESSAGE, __LINE__, "> Reserved2 %u", pdm->dmReserved2);

  014f2	ff b6 90 00 00
	00		 push	 DWORD PTR [esi+144]
  014f8	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KECJEPKK@?$DO?5Reserved2?5?$CFu@
  014fd	68 2e 0a 00 00	 push	 2606			; 00000a2eH
  01502	6a 01		 push	 1
  01504	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01509	83 c4 20	 add	 esp, 32			; 00000020H

; 2607 :                     if (GetWinVer() >= 5)

  0150c	e8 00 00 00 00	 call	 ?GetWinVer@@YAKXZ	; GetWinVer
  01511	83 f8 05	 cmp	 eax, 5
  01514	72 31		 jb	 SHORT $LN73@PrinterInf

; 2608 :                     {
; 2609 :                         Log(LOG_MESSAGE, __LINE__, "> PanningWidth %u", pdm->dmPanningWidth);

  01516	ff b6 94 00 00
	00		 push	 DWORD PTR [esi+148]
  0151c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@ILEBHAGL@?$DO?5PanningWidth?5?$CFu@
  01521	68 31 0a 00 00	 push	 2609			; 00000a31H
  01526	6a 01		 push	 1
  01528	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2610 :                         Log(LOG_MESSAGE, __LINE__, "> PanningHeight %u", pdm->dmPanningHeight);

  0152d	ff b6 98 00 00
	00		 push	 DWORD PTR [esi+152]
  01533	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@ODPAHJGJ@?$DO?5PanningHeight?5?$CFu@
  01538	68 32 0a 00 00	 push	 2610			; 00000a32H
  0153d	6a 01		 push	 1
  0153f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01544	83 c4 20	 add	 esp, 32			; 00000020H
$LN73@PrinterInf:

; 2611 :                     }
; 2612 :                 }
; 2613 : 
; 2614 :                 delete[] pdm;

  01547	56		 push	 esi
  01548	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0154d	83 c4 04	 add	 esp, 4
$LN71@PrinterInf:

; 2615 :                 pdm = nullptr;
; 2616 :             }
; 2617 :             ClosePrinter(hPrinter);

  01550	ff b5 a4 fb ff
	ff		 push	 DWORD PTR _hPrinter$4[ebp]
  01556	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ClosePrinter@4

; 2618 :         }
; 2619 :         else

  0155c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetLastError@0
  01562	e9 89 00 00 00	 jmp	 $LN907@PrinterInf
$LN69@PrinterInf:

; 2621 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, OpenPrinter %s", GetLastErrorMessage(GetLastError()).c_str());

  01567	ff d6		 call	 esi
  01569	8b d0		 mov	 edx, eax
  0156b	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  01571	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  01576	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+12], 17 ; 00000011H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0157a	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0157e	72 02		 jb	 SHORT $LN857@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  01580	8b 00		 mov	 eax, DWORD PTR [eax]
$LN857@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2621 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, OpenPrinter %s", GetLastErrorMessage(GetLastError()).c_str());

  01582	50		 push	 eax
  01583	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@NKEHJDBP@?9?9?5PtrInfo?0?5OpenPrinter?5?$CFs@
  01588	68 3d 0a 00 00	 push	 2621			; 00000a3dH
  0158d	6a 10		 push	 16			; 00000010H
  0158f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01594	83 c4 10	 add	 esp, 16			; 00000010H
  01597	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0159b	8b 95 ec fb ff
	ff		 mov	 edx, DWORD PTR $T6[ebp+20]
  015a1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  015a4	72 2f		 jb	 SHORT $LN905@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  015a6	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  015a7	8b 8d d8 fb ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  015ad	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  015af	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  015b5	72 14		 jb	 SHORT $LN904@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  015b7	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  015ba	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  015bd	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  015bf	83 c0 fc	 add	 eax, -4			; fffffffcH
  015c2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  015c5	0f 87 8e 08 00
	00		 ja	 $LN1051@PrinterInf
$LN904@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  015cb	52		 push	 edx
  015cc	51		 push	 ecx
  015cd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  015d2	83 c4 08	 add	 esp, 8
$LN905@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  015d5	c7 85 e8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  015df	c7 85 ec fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  015e9	c6 85 d8 fb ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
$LN907@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2625 :         HDC hdc = CreateIC(DriverName, PrinterName, NULL, NULL);

  015f0	6a 00		 push	 0
  015f2	6a 00		 push	 0
  015f4	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _PrinterName$[ebp]
  015fa	50		 push	 eax
  015fb	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _DriverName$[ebp]
  01601	50		 push	 eax
  01602	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateICA@16
  01608	89 85 b8 fb ff
	ff		 mov	 DWORD PTR _hdc$1$[ebp], eax

; 2626 :         if (hdc)

  0160e	85 c0		 test	 eax, eax
  01610	0f 84 ec 06 00
	00		 je	 $LN74@PrinterInf

; 2627 :         {
; 2628 :             Log(LOG_MESSAGE, __LINE__, "DeviceCaps:");

  01616	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CPAOAHIM@DeviceCaps?3@
  0161b	68 44 0a 00 00	 push	 2628			; 00000a44H
  01620	6a 01		 push	 1
  01622	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01627	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2629 : 
; 2630 :             l = GetDeviceCaps(hdc, DRIVERVERSION);

  0162a	6a 00		 push	 0
  0162c	8b b5 b8 fb ff
	ff		 mov	 esi, DWORD PTR _hdc$1$[ebp]
  01632	56		 push	 esi
  01633	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2631 :             Log(LOG_MESSAGE, __LINE__, "> DRIVERVERSION %d", l);

  01639	50		 push	 eax
  0163a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JDPBNNPN@?$DO?5DRIVERVERSION?5?$CFd@
  0163f	68 47 0a 00 00	 push	 2631			; 00000a47H
  01644	6a 01		 push	 1
  01646	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0164b	83 c4 10	 add	 esp, 16			; 00000010H

; 2632 : 
; 2633 :             l = GetDeviceCaps(hdc, TECHNOLOGY);

  0164e	6a 02		 push	 2
  01650	56		 push	 esi
  01651	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2634 :             Log(LOG_MESSAGE, __LINE__, "> TECHNOLOGY %d", l);

  01657	50		 push	 eax
  01658	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KDKPJOH@?$DO?5TECHNOLOGY?5?$CFd@
  0165d	68 4a 0a 00 00	 push	 2634			; 00000a4aH
  01662	6a 01		 push	 1
  01664	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01669	83 c4 10	 add	 esp, 16			; 00000010H

; 2635 : 
; 2636 :             l = GetDeviceCaps(hdc, HORZSIZE);

  0166c	6a 04		 push	 4
  0166e	56		 push	 esi
  0166f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2637 :             Log(LOG_MESSAGE, __LINE__, "> HORZSIZE %d", l);

  01675	50		 push	 eax
  01676	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HMCMNAPC@?$DO?5HORZSIZE?5?$CFd@
  0167b	68 4d 0a 00 00	 push	 2637			; 00000a4dH
  01680	6a 01		 push	 1
  01682	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01687	83 c4 10	 add	 esp, 16			; 00000010H

; 2638 : 
; 2639 :             l = GetDeviceCaps(hdc, VERTSIZE);

  0168a	6a 06		 push	 6
  0168c	56		 push	 esi
  0168d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2640 :             Log(LOG_MESSAGE, __LINE__, "> VERTSIZE %d", l);

  01693	50		 push	 eax
  01694	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LDGIGNAG@?$DO?5VERTSIZE?5?$CFd@
  01699	68 50 0a 00 00	 push	 2640			; 00000a50H
  0169e	6a 01		 push	 1
  016a0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  016a5	83 c4 10	 add	 esp, 16			; 00000010H

; 2641 : 
; 2642 :             l = GetDeviceCaps(hdc, HORZRES);

  016a8	6a 08		 push	 8
  016aa	56		 push	 esi
  016ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2643 :             Log(LOG_MESSAGE, __LINE__, "> HORZRES %d", l);

  016b1	50		 push	 eax
  016b2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IFBEPCKP@?$DO?5HORZRES?5?$CFd@
  016b7	68 53 0a 00 00	 push	 2643			; 00000a53H
  016bc	6a 01		 push	 1
  016be	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  016c3	83 c4 10	 add	 esp, 16			; 00000010H

; 2644 : 
; 2645 :             l = GetDeviceCaps(hdc, VERTRES);

  016c6	6a 0a		 push	 10			; 0000000aH
  016c8	56		 push	 esi
  016c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2646 :             Log(LOG_MESSAGE, __LINE__, "> VERTRES %d", l);

  016cf	50		 push	 eax
  016d0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HLDMJPJJ@?$DO?5VERTRES?5?$CFd@
  016d5	68 56 0a 00 00	 push	 2646			; 00000a56H
  016da	6a 01		 push	 1
  016dc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  016e1	83 c4 10	 add	 esp, 16			; 00000010H

; 2647 : 
; 2648 :             l = GetDeviceCaps(hdc, BITSPIXEL);

  016e4	6a 0c		 push	 12			; 0000000cH
  016e6	56		 push	 esi
  016e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2649 :             Log(LOG_MESSAGE, __LINE__, "> BITSPIXEL %d", l);

  016ed	50		 push	 eax
  016ee	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CHMKJDGJ@?$DO?5BITSPIXEL?5?$CFd@
  016f3	68 59 0a 00 00	 push	 2649			; 00000a59H
  016f8	6a 01		 push	 1
  016fa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  016ff	83 c4 10	 add	 esp, 16			; 00000010H

; 2650 : 
; 2651 :             l = GetDeviceCaps(hdc, PLANES);

  01702	6a 0e		 push	 14			; 0000000eH
  01704	56		 push	 esi
  01705	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2652 :             Log(LOG_MESSAGE, __LINE__, "> PLANES %d", l);

  0170b	50		 push	 eax
  0170c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DABMECAD@?$DO?5PLANES?5?$CFd@
  01711	68 5c 0a 00 00	 push	 2652			; 00000a5cH
  01716	6a 01		 push	 1
  01718	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0171d	83 c4 10	 add	 esp, 16			; 00000010H

; 2653 : 
; 2654 :             l = GetDeviceCaps(hdc, NUMBRUSHES);

  01720	6a 10		 push	 16			; 00000010H
  01722	56		 push	 esi
  01723	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2655 :             Log(LOG_MESSAGE, __LINE__, "> NUMBRUSHES %d", l);

  01729	50		 push	 eax
  0172a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GCBODPHK@?$DO?5NUMBRUSHES?5?$CFd@
  0172f	68 5f 0a 00 00	 push	 2655			; 00000a5fH
  01734	6a 01		 push	 1
  01736	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0173b	83 c4 10	 add	 esp, 16			; 00000010H

; 2656 : 
; 2657 :             l = GetDeviceCaps(hdc, NUMPENS);

  0173e	6a 12		 push	 18			; 00000012H
  01740	56		 push	 esi
  01741	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2658 :             Log(LOG_MESSAGE, __LINE__, "> NUMPENS %d", l);

  01747	50		 push	 eax
  01748	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HHCKOKCG@?$DO?5NUMPENS?5?$CFd@
  0174d	68 62 0a 00 00	 push	 2658			; 00000a62H
  01752	6a 01		 push	 1
  01754	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01759	83 c4 10	 add	 esp, 16			; 00000010H

; 2659 : 
; 2660 :             l = GetDeviceCaps(hdc, NUMMARKERS);

  0175c	6a 14		 push	 20			; 00000014H
  0175e	56		 push	 esi
  0175f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2661 :             Log(LOG_MESSAGE, __LINE__, "> NUMMARKERS %d", l);

  01765	50		 push	 eax
  01766	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@IJEEOFOD@?$DO?5NUMMARKERS?5?$CFd@
  0176b	68 65 0a 00 00	 push	 2661			; 00000a65H
  01770	6a 01		 push	 1
  01772	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01777	83 c4 10	 add	 esp, 16			; 00000010H

; 2662 : 
; 2663 :             l = GetDeviceCaps(hdc, NUMFONTS);

  0177a	6a 16		 push	 22			; 00000016H
  0177c	56		 push	 esi
  0177d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2664 :             Log(LOG_MESSAGE, __LINE__, "> NUMFONTS %d", l);

  01783	50		 push	 eax
  01784	68 00 00 00 00	 push	 OFFSET ??_C@_0O@HIAAJLOF@?$DO?5NUMFONTS?5?$CFd@
  01789	68 68 0a 00 00	 push	 2664			; 00000a68H
  0178e	6a 01		 push	 1
  01790	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01795	83 c4 10	 add	 esp, 16			; 00000010H

; 2665 : 
; 2666 :             l = GetDeviceCaps(hdc, NUMCOLORS);

  01798	6a 18		 push	 24			; 00000018H
  0179a	56		 push	 esi
  0179b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2667 :             Log(LOG_MESSAGE, __LINE__, "> NUMCOLORS %d", l);

  017a1	50		 push	 eax
  017a2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CDPEOCLN@?$DO?5NUMCOLORS?5?$CFd@
  017a7	68 6b 0a 00 00	 push	 2667			; 00000a6bH
  017ac	6a 01		 push	 1
  017ae	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  017b3	83 c4 10	 add	 esp, 16			; 00000010H

; 2668 : 
; 2669 :             l = GetDeviceCaps(hdc, PDEVICESIZE);

  017b6	6a 1a		 push	 26			; 0000001aH
  017b8	56		 push	 esi
  017b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2670 :             Log(LOG_MESSAGE, __LINE__, "> PDEVICESIZE %d", l);

  017bf	50		 push	 eax
  017c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BIAFAHJC@?$DO?5PDEVICESIZE?5?$CFd@
  017c5	68 6e 0a 00 00	 push	 2670			; 00000a6eH
  017ca	6a 01		 push	 1
  017cc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  017d1	83 c4 10	 add	 esp, 16			; 00000010H

; 2671 : 
; 2672 :             l = GetDeviceCaps(hdc, CURVECAPS);

  017d4	6a 1c		 push	 28			; 0000001cH
  017d6	56		 push	 esi
  017d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2673 :             Log(LOG_MESSAGE, __LINE__, "> CURVECAPS %d", l);

  017dd	50		 push	 eax
  017de	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MJKILKAG@?$DO?5CURVECAPS?5?$CFd@
  017e3	68 71 0a 00 00	 push	 2673			; 00000a71H
  017e8	6a 01		 push	 1
  017ea	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  017ef	83 c4 10	 add	 esp, 16			; 00000010H

; 2674 : 
; 2675 :             l = GetDeviceCaps(hdc, LINECAPS);

  017f2	6a 1e		 push	 30			; 0000001eH
  017f4	56		 push	 esi
  017f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2676 :             Log(LOG_MESSAGE, __LINE__, "> LINECAPS %d", l);

  017fb	50		 push	 eax
  017fc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NIBLPDAA@?$DO?5LINECAPS?5?$CFd@
  01801	68 74 0a 00 00	 push	 2676			; 00000a74H
  01806	6a 01		 push	 1
  01808	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0180d	83 c4 10	 add	 esp, 16			; 00000010H

; 2677 : 
; 2678 :             l = GetDeviceCaps(hdc, POLYGONALCAPS);

  01810	6a 20		 push	 32			; 00000020H
  01812	56		 push	 esi
  01813	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2679 :             Log(LOG_MESSAGE, __LINE__, "> POLYGONALCAPS %d", l);

  01819	50		 push	 eax
  0181a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NDEFMMIK@?$DO?5POLYGONALCAPS?5?$CFd@
  0181f	68 77 0a 00 00	 push	 2679			; 00000a77H
  01824	6a 01		 push	 1
  01826	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0182b	83 c4 10	 add	 esp, 16			; 00000010H

; 2680 : 
; 2681 :             l = GetDeviceCaps(hdc, TEXTCAPS);

  0182e	6a 22		 push	 34			; 00000022H
  01830	56		 push	 esi
  01831	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2682 :             Log(LOG_MESSAGE, __LINE__, "> TEXTCAPS %d", l);

  01837	50		 push	 eax
  01838	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EJBOFNFI@?$DO?5TEXTCAPS?5?$CFd@
  0183d	68 7a 0a 00 00	 push	 2682			; 00000a7aH
  01842	6a 01		 push	 1
  01844	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01849	83 c4 10	 add	 esp, 16			; 00000010H

; 2683 : 
; 2684 :             l = GetDeviceCaps(hdc, CLIPCAPS);

  0184c	6a 24		 push	 36			; 00000024H
  0184e	56		 push	 esi
  0184f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2685 :             Log(LOG_MESSAGE, __LINE__, "> CLIPCAPS %d", l);

  01855	50		 push	 eax
  01856	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NPFDNMHE@?$DO?5CLIPCAPS?5?$CFd@
  0185b	68 7d 0a 00 00	 push	 2685			; 00000a7dH
  01860	6a 01		 push	 1
  01862	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01867	83 c4 10	 add	 esp, 16			; 00000010H

; 2686 : 
; 2687 :             l = GetDeviceCaps(hdc, RASTERCAPS);

  0186a	6a 26		 push	 38			; 00000026H
  0186c	56		 push	 esi
  0186d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2688 :             Log(LOG_MESSAGE, __LINE__, "> RASTERCAPS %d", l);

  01873	50		 push	 eax
  01874	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OCKGHOJF@?$DO?5RASTERCAPS?5?$CFd@
  01879	68 80 0a 00 00	 push	 2688			; 00000a80H
  0187e	6a 01		 push	 1
  01880	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01885	83 c4 10	 add	 esp, 16			; 00000010H

; 2689 : 
; 2690 :             l = GetDeviceCaps(hdc, ASPECTX);

  01888	6a 28		 push	 40			; 00000028H
  0188a	56		 push	 esi
  0188b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2691 :             Log(LOG_MESSAGE, __LINE__, "> ASPECTX %d", l);

  01891	50		 push	 eax
  01892	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGFFNBBI@?$DO?5ASPECTX?5?$CFd@
  01897	68 83 0a 00 00	 push	 2691			; 00000a83H
  0189c	6a 01		 push	 1
  0189e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  018a3	83 c4 10	 add	 esp, 16			; 00000010H

; 2692 : 
; 2693 :             l = GetDeviceCaps(hdc, ASPECTY);

  018a6	6a 2a		 push	 42			; 0000002aH
  018a8	56		 push	 esi
  018a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2694 :             Log(LOG_MESSAGE, __LINE__, "> ASPECTY %d", l);

  018af	50		 push	 eax
  018b0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LDFPIKI@?$DO?5ASPECTY?5?$CFd@
  018b5	68 86 0a 00 00	 push	 2694			; 00000a86H
  018ba	6a 01		 push	 1
  018bc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  018c1	83 c4 10	 add	 esp, 16			; 00000010H

; 2695 : 
; 2696 :             l = GetDeviceCaps(hdc, ASPECTXY);

  018c4	6a 2c		 push	 44			; 0000002cH
  018c6	56		 push	 esi
  018c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2697 :             Log(LOG_MESSAGE, __LINE__, "> ASPECTXY %d", l);

  018cd	50		 push	 eax
  018ce	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KAIPPGFP@?$DO?5ASPECTXY?5?$CFd@
  018d3	68 89 0a 00 00	 push	 2697			; 00000a89H
  018d8	6a 01		 push	 1
  018da	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  018df	83 c4 10	 add	 esp, 16			; 00000010H

; 2698 : 
; 2699 :             l = GetDeviceCaps(hdc, LOGPIXELSX);

  018e2	6a 58		 push	 88			; 00000058H
  018e4	56		 push	 esi
  018e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2700 :             Log(LOG_MESSAGE, __LINE__, "> LOGPIXELSX %d", l);

  018eb	50		 push	 eax
  018ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@NDEAPPCA@?$DO?5LOGPIXELSX?5?$CFd@
  018f1	68 8c 0a 00 00	 push	 2700			; 00000a8cH
  018f6	6a 01		 push	 1
  018f8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  018fd	83 c4 10	 add	 esp, 16			; 00000010H

; 2701 : 
; 2702 :             l = GetDeviceCaps(hdc, LOGPIXELSY);

  01900	6a 5a		 push	 90			; 0000005aH
  01902	56		 push	 esi
  01903	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2703 :             Log(LOG_MESSAGE, __LINE__, "> LOGPIXELSY %d", l);

  01909	50		 push	 eax
  0190a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OOCANGJA@?$DO?5LOGPIXELSY?5?$CFd@
  0190f	68 8f 0a 00 00	 push	 2703			; 00000a8fH
  01914	6a 01		 push	 1
  01916	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0191b	83 c4 10	 add	 esp, 16			; 00000010H

; 2704 : 
; 2705 :             l = GetDeviceCaps(hdc, SIZEPALETTE);

  0191e	6a 68		 push	 104			; 00000068H
  01920	56		 push	 esi
  01921	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2706 :             Log(LOG_MESSAGE, __LINE__, "> SIZEPALETTE %d", l);

  01927	50		 push	 eax
  01928	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KNEJGJKJ@?$DO?5SIZEPALETTE?5?$CFd@
  0192d	68 92 0a 00 00	 push	 2706			; 00000a92H
  01932	6a 01		 push	 1
  01934	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01939	83 c4 10	 add	 esp, 16			; 00000010H

; 2707 : 
; 2708 :             l = GetDeviceCaps(hdc, NUMRESERVED);

  0193c	6a 6a		 push	 106			; 0000006aH
  0193e	56		 push	 esi
  0193f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2709 :             Log(LOG_MESSAGE, __LINE__, "> NUMRESERVED %d", l);

  01945	50		 push	 eax
  01946	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KMMENDMI@?$DO?5NUMRESERVED?5?$CFd@
  0194b	68 95 0a 00 00	 push	 2709			; 00000a95H
  01950	6a 01		 push	 1
  01952	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01957	83 c4 10	 add	 esp, 16			; 00000010H

; 2710 : 
; 2711 :             l = GetDeviceCaps(hdc, COLORRES);

  0195a	6a 6c		 push	 108			; 0000006cH
  0195c	56		 push	 esi
  0195d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2712 :             Log(LOG_MESSAGE, __LINE__, "> COLORRES %d", l);

  01963	50		 push	 eax
  01964	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GGNNNIFP@?$DO?5COLORRES?5?$CFd@
  01969	68 98 0a 00 00	 push	 2712			; 00000a98H
  0196e	6a 01		 push	 1
  01970	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01975	83 c4 10	 add	 esp, 16			; 00000010H

; 2713 : 
; 2714 :             l = GetDeviceCaps(hdc, PHYSICALWIDTH);

  01978	6a 6e		 push	 110			; 0000006eH
  0197a	56		 push	 esi
  0197b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2715 :             Log(LOG_MESSAGE, __LINE__, "> PHYSICALWIDTH %d", l);

  01981	50		 push	 eax
  01982	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@HDEIPKKB@?$DO?5PHYSICALWIDTH?5?$CFd@
  01987	68 9b 0a 00 00	 push	 2715			; 00000a9bH
  0198c	6a 01		 push	 1
  0198e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01993	83 c4 10	 add	 esp, 16			; 00000010H

; 2716 : 
; 2717 :             l = GetDeviceCaps(hdc, PHYSICALHEIGHT);

  01996	6a 6f		 push	 111			; 0000006fH
  01998	56		 push	 esi
  01999	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2718 :             Log(LOG_MESSAGE, __LINE__, "> PHYSICALHEIGHT %d", l);

  0199f	50		 push	 eax
  019a0	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BHEFJOBO@?$DO?5PHYSICALHEIGHT?5?$CFd@
  019a5	68 9e 0a 00 00	 push	 2718			; 00000a9eH
  019aa	6a 01		 push	 1
  019ac	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  019b1	83 c4 10	 add	 esp, 16			; 00000010H

; 2719 : 
; 2720 :             l = GetDeviceCaps(hdc, PHYSICALOFFSETX);

  019b4	6a 70		 push	 112			; 00000070H
  019b6	56		 push	 esi
  019b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2721 :             Log(LOG_MESSAGE, __LINE__, "> PHYSICALOFFSETX %d", l);

  019bd	50		 push	 eax
  019be	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PADOFFNF@?$DO?5PHYSICALOFFSETX?5?$CFd@
  019c3	68 a1 0a 00 00	 push	 2721			; 00000aa1H
  019c8	6a 01		 push	 1
  019ca	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  019cf	83 c4 10	 add	 esp, 16			; 00000010H

; 2722 : 
; 2723 :             l = GetDeviceCaps(hdc, PHYSICALOFFSETY);

  019d2	6a 71		 push	 113			; 00000071H
  019d4	56		 push	 esi
  019d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2724 :             Log(LOG_MESSAGE, __LINE__, "> PHYSICALOFFSETY %d", l);

  019db	50		 push	 eax
  019dc	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MNFOHMGF@?$DO?5PHYSICALOFFSETY?5?$CFd@
  019e1	68 a4 0a 00 00	 push	 2724			; 00000aa4H
  019e6	6a 01		 push	 1
  019e8	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  019ed	83 c4 10	 add	 esp, 16			; 00000010H

; 2725 : 
; 2726 :             l = GetDeviceCaps(hdc, SCALINGFACTORX);

  019f0	6a 72		 push	 114			; 00000072H
  019f2	56		 push	 esi
  019f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2727 :             Log(LOG_MESSAGE, __LINE__, "> SCALINGFACTORX %d", l);

  019f9	50		 push	 eax
  019fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LLMKMDFO@?$DO?5SCALINGFACTORX?5?$CFd@
  019ff	68 a7 0a 00 00	 push	 2727			; 00000aa7H
  01a04	6a 01		 push	 1
  01a06	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01a0b	83 c4 10	 add	 esp, 16			; 00000010H

; 2728 : 
; 2729 :             l = GetDeviceCaps(hdc, SCALINGFACTORY);

  01a0e	6a 73		 push	 115			; 00000073H
  01a10	56		 push	 esi
  01a11	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2730 :             Log(LOG_MESSAGE, __LINE__, "> SCALINGFACTORY %d", l);

  01a17	50		 push	 eax
  01a18	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@IGKKOKOO@?$DO?5SCALINGFACTORY?5?$CFd@
  01a1d	68 aa 0a 00 00	 push	 2730			; 00000aaaH
  01a22	6a 01		 push	 1
  01a24	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01a29	83 c4 10	 add	 esp, 16			; 00000010H

; 2731 : 
; 2732 :             l = GetDeviceCaps(hdc, VREFRESH);

  01a2c	6a 74		 push	 116			; 00000074H
  01a2e	56		 push	 esi
  01a2f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2733 :             Log(LOG_MESSAGE, __LINE__, "> VREFRESH %d", l);

  01a35	50		 push	 eax
  01a36	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KHHELDLL@?$DO?5VREFRESH?5?$CFd@
  01a3b	68 ad 0a 00 00	 push	 2733			; 00000aadH
  01a40	6a 01		 push	 1
  01a42	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01a47	83 c4 10	 add	 esp, 16			; 00000010H

; 2734 : 
; 2735 :             l = GetDeviceCaps(hdc, DESKTOPVERTRES);

  01a4a	6a 75		 push	 117			; 00000075H
  01a4c	56		 push	 esi
  01a4d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2736 :             Log(LOG_MESSAGE, __LINE__, "> DESKTOPVERTRES %d", l);

  01a53	50		 push	 eax
  01a54	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@COAHGLLD@?$DO?5DESKTOPVERTRES?5?$CFd@
  01a59	68 b0 0a 00 00	 push	 2736			; 00000ab0H
  01a5e	6a 01		 push	 1
  01a60	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01a65	83 c4 10	 add	 esp, 16			; 00000010H

; 2737 : 
; 2738 :             l = GetDeviceCaps(hdc, DESKTOPHORZRES);

  01a68	6a 76		 push	 118			; 00000076H
  01a6a	56		 push	 esi
  01a6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2739 :             Log(LOG_MESSAGE, __LINE__, "> DESKTOPHORZRES %d", l);

  01a71	50		 push	 eax
  01a72	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NACPAGIF@?$DO?5DESKTOPHORZRES?5?$CFd@
  01a77	68 b3 0a 00 00	 push	 2739			; 00000ab3H
  01a7c	6a 01		 push	 1
  01a7e	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01a83	83 c4 10	 add	 esp, 16			; 00000010H

; 2740 : 
; 2741 :             l = GetDeviceCaps(hdc, BLTALIGNMENT);

  01a86	6a 77		 push	 119			; 00000077H
  01a88	56		 push	 esi
  01a89	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2742 :             Log(LOG_MESSAGE, __LINE__, "> BLTALIGNMENT %d", l);

  01a8f	50		 push	 eax
  01a90	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JFPGOKHF@?$DO?5BLTALIGNMENT?5?$CFd@
  01a95	68 b6 0a 00 00	 push	 2742			; 00000ab6H
  01a9a	6a 01		 push	 1
  01a9c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01aa1	83 c4 10	 add	 esp, 16			; 00000010H

; 2743 : 
; 2744 :             if (GetWinVer() >= 5)

  01aa4	e8 00 00 00 00	 call	 ?GetWinVer@@YAKXZ	; GetWinVer
  01aa9	83 f8 05	 cmp	 eax, 5
  01aac	72 3c		 jb	 SHORT $LN76@PrinterInf

; 2745 :             {
; 2746 :                 l = GetDeviceCaps(hdc, SHADEBLENDCAPS);

  01aae	6a 78		 push	 120			; 00000078H
  01ab0	56		 push	 esi
  01ab1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2747 :                 Log(LOG_MESSAGE, __LINE__, "> SHADEBLENDCAPS %d", l);

  01ab7	50		 push	 eax
  01ab8	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BAMFBECL@?$DO?5SHADEBLENDCAPS?5?$CFd@
  01abd	68 bb 0a 00 00	 push	 2747			; 00000abbH
  01ac2	6a 01		 push	 1
  01ac4	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01ac9	83 c4 10	 add	 esp, 16			; 00000010H

; 2748 : 
; 2749 :                 l = GetDeviceCaps(hdc, COLORMGMTCAPS);

  01acc	6a 79		 push	 121			; 00000079H
  01ace	56		 push	 esi
  01acf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8

; 2750 :                 Log(LOG_MESSAGE, __LINE__, "> COLORMGMTCAPS %d", l);

  01ad5	50		 push	 eax
  01ad6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DKIEMMJN@?$DO?5COLORMGMTCAPS?5?$CFd@
  01adb	68 be 0a 00 00	 push	 2750			; 00000abeH
  01ae0	6a 01		 push	 1
  01ae2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01ae7	83 c4 10	 add	 esp, 16			; 00000010H
$LN76@PrinterInf:

; 2751 :             }
; 2752 : 
; 2753 :             //*** device context layout
; 2754 :             DWORD dw = GetLayout(hdc);

  01aea	56		 push	 esi
  01aeb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLayout@4

; 2755 :             Log(LOG_MESSAGE, __LINE__, "Layout %u", dw);

  01af1	50		 push	 eax
  01af2	68 00 00 00 00	 push	 OFFSET ??_C@_09IGELCPAM@Layout?5?$CFu@
  01af7	68 c3 0a 00 00	 push	 2755			; 00000ac3H
  01afc	6a 01		 push	 1
  01afe	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01b03	83 c4 10	 add	 esp, 16			; 00000010H

; 2756 : 
; 2757 :             //*** printer to the default FONT
; 2758 :             HGDIOBJ hGdi = NULL;
; 2759 :             if ((hGdi = GetCurrentObject(hdc, OBJ_FONT)) != NULL)

  01b06	6a 06		 push	 6
  01b08	56		 push	 esi
  01b09	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentObject@8
  01b0f	89 85 98 fb ff
	ff		 mov	 DWORD PTR _hGdi$1$[ebp], eax
  01b15	85 c0		 test	 eax, eax
  01b17	0f 84 cd 01 00
	00		 je	 $LN80@PrinterInf

; 2760 :             {
; 2761 :                 int iBufferSize = GetObject(hGdi, 0, NULL);

  01b1d	6a 00		 push	 0
  01b1f	6a 00		 push	 0
  01b21	50		 push	 eax
  01b22	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12
  01b28	89 85 bc fb ff
	ff		 mov	 DWORD PTR _iBufferSize$1$[ebp], eax

; 2762 :                 if (iBufferSize > 0)

  01b2e	85 c0		 test	 eax, eax
  01b30	0f 8e b4 01 00
	00		 jle	 $LN80@PrinterInf

; 2763 :                 {
; 2764 :                     LOGFONT *pLogFont = (LOGFONT *)new char[iBufferSize];

  01b36	50		 push	 eax
  01b37	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  01b3c	83 c4 04	 add	 esp, 4
  01b3f	8b f0		 mov	 esi, eax

; 2765 :                     if (pLogFont)

  01b41	85 f6		 test	 esi, esi
  01b43	0f 84 87 01 00
	00		 je	 $LN79@PrinterInf

; 2766 :                     {
; 2767 :                         if (GetObject(hGdi, iBufferSize, pLogFont))

  01b49	56		 push	 esi
  01b4a	ff b5 bc fb ff
	ff		 push	 DWORD PTR _iBufferSize$1$[ebp]
  01b50	ff b5 98 fb ff
	ff		 push	 DWORD PTR _hGdi$1$[ebp]
  01b56	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetObjectA@12
  01b5c	85 c0		 test	 eax, eax
  01b5e	0f 84 45 01 00
	00		 je	 $LN81@PrinterInf

; 2768 :                         {
; 2769 :                             Log(LOG_MESSAGE, __LINE__, "DEFAULT FONT:");

  01b64	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FBFECABI@DEFAULT?5FONT?3@
  01b69	68 d1 0a 00 00	 push	 2769			; 00000ad1H
  01b6e	6a 01		 push	 1
  01b70	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2770 :                             Log(LOG_MESSAGE, __LINE__, "> Height %d", pLogFont->lfHeight);

  01b75	ff 36		 push	 DWORD PTR [esi]
  01b77	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JCFCFHLH@?$DO?5Height?5?$CFd@
  01b7c	68 d2 0a 00 00	 push	 2770			; 00000ad2H
  01b81	6a 01		 push	 1
  01b83	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2771 :                             Log(LOG_MESSAGE, __LINE__, "> Width %d", pLogFont->lfWidth);

  01b88	ff 76 04	 push	 DWORD PTR [esi+4]
  01b8b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KBIDCEMN@?$DO?5Width?5?$CFd@
  01b90	68 d3 0a 00 00	 push	 2771			; 00000ad3H
  01b95	6a 01		 push	 1
  01b97	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2772 :                             Log(LOG_MESSAGE, __LINE__, "> Escapment %d", pLogFont->lfEscapement);

  01b9c	ff 76 08	 push	 DWORD PTR [esi+8]
  01b9f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DLDGLOB@?$DO?5Escapment?5?$CFd@
  01ba4	68 d4 0a 00 00	 push	 2772			; 00000ad4H
  01ba9	6a 01		 push	 1
  01bab	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2773 :                             Log(LOG_MESSAGE, __LINE__, "> Orientation %d", pLogFont->lfOrientation);

  01bb0	ff 76 0c	 push	 DWORD PTR [esi+12]
  01bb3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DFLFEINK@?$DO?5Orientation?5?$CFd@
  01bb8	68 d5 0a 00 00	 push	 2773			; 00000ad5H
  01bbd	6a 01		 push	 1
  01bbf	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01bc4	83 c4 4c	 add	 esp, 76			; 0000004cH

; 2774 :                             Log(LOG_MESSAGE, __LINE__, "> Weight %d", pLogFont->lfWeight);

  01bc7	ff 76 10	 push	 DWORD PTR [esi+16]
  01bca	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EEPHINNC@?$DO?5Weight?5?$CFd@
  01bcf	68 d6 0a 00 00	 push	 2774			; 00000ad6H
  01bd4	6a 01		 push	 1
  01bd6	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2775 :                             Log(LOG_MESSAGE, __LINE__, "> Italic %.2Xh", pLogFont->lfItalic);

  01bdb	0f b6 46 14	 movzx	 eax, BYTE PTR [esi+20]
  01bdf	50		 push	 eax
  01be0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FOGJLDPM@?$DO?5Italic?5?$CF?42Xh@
  01be5	68 d7 0a 00 00	 push	 2775			; 00000ad7H
  01bea	6a 01		 push	 1
  01bec	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2776 :                             Log(LOG_MESSAGE, __LINE__, "> Underline %.2Xh", pLogFont->lfUnderline);

  01bf1	0f b6 46 15	 movzx	 eax, BYTE PTR [esi+21]
  01bf5	50		 push	 eax
  01bf6	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IHAMIHEE@?$DO?5Underline?5?$CF?42Xh@
  01bfb	68 d8 0a 00 00	 push	 2776			; 00000ad8H
  01c00	6a 01		 push	 1
  01c02	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2777 :                             Log(LOG_MESSAGE, __LINE__, "> StrikeOut %.2Xh", pLogFont->lfStrikeOut);

  01c07	0f b6 46 16	 movzx	 eax, BYTE PTR [esi+22]
  01c0b	50		 push	 eax
  01c0c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MFABLFLO@?$DO?5StrikeOut?5?$CF?42Xh@
  01c11	68 d9 0a 00 00	 push	 2777			; 00000ad9H
  01c16	6a 01		 push	 1
  01c18	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01c1d	83 c4 40	 add	 esp, 64			; 00000040H

; 2778 :                             Log(LOG_MESSAGE, __LINE__, "> CharSet %.2Xh", pLogFont->lfCharSet);

  01c20	0f b6 46 17	 movzx	 eax, BYTE PTR [esi+23]
  01c24	50		 push	 eax
  01c25	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CJMDNNAL@?$DO?5CharSet?5?$CF?42Xh@
  01c2a	68 da 0a 00 00	 push	 2778			; 00000adaH
  01c2f	6a 01		 push	 1
  01c31	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2779 :                             Log(LOG_MESSAGE, __LINE__, "> OutPrecision %.2Xh", pLogFont->lfOutPrecision);

  01c36	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
  01c3a	50		 push	 eax
  01c3b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IIGPOAFP@?$DO?5OutPrecision?5?$CF?42Xh@
  01c40	68 db 0a 00 00	 push	 2779			; 00000adbH
  01c45	6a 01		 push	 1
  01c47	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2780 :                             Log(LOG_MESSAGE, __LINE__, "> ClipPrecision %.2Xh", pLogFont->lfClipPrecision);

  01c4c	0f b6 46 19	 movzx	 eax, BYTE PTR [esi+25]
  01c50	50		 push	 eax
  01c51	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FHJOGBNN@?$DO?5ClipPrecision?5?$CF?42Xh@
  01c56	68 dc 0a 00 00	 push	 2780			; 00000adcH
  01c5b	6a 01		 push	 1
  01c5d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2781 :                             Log(LOG_MESSAGE, __LINE__, "> Quality %.2Xh", pLogFont->lfQuality);

  01c62	0f b6 46 1a	 movzx	 eax, BYTE PTR [esi+26]
  01c66	50		 push	 eax
  01c67	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PONLFNLB@?$DO?5Quality?5?$CF?42Xh@
  01c6c	68 dd 0a 00 00	 push	 2781			; 00000addH
  01c71	6a 01		 push	 1
  01c73	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01c78	83 c4 40	 add	 esp, 64			; 00000040H

; 2782 :                             Log(LOG_MESSAGE, __LINE__, "> PitchAndFamily %.2Xh", pLogFont->lfPitchAndFamily);

  01c7b	0f b6 46 1b	 movzx	 eax, BYTE PTR [esi+27]
  01c7f	50		 push	 eax
  01c80	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FCEMNLND@?$DO?5PitchAndFamily?5?$CF?42Xh@
  01c85	68 de 0a 00 00	 push	 2782			; 00000adeH
  01c8a	6a 01		 push	 1
  01c8c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2783 :                             Log(LOG_MESSAGE, __LINE__, "> FaceName %s", pLogFont->lfFaceName);

  01c91	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  01c94	50		 push	 eax
  01c95	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBJPIOLO@?$DO?5FaceName?5?$CFs@
  01c9a	68 df 0a 00 00	 push	 2783			; 00000adfH
  01c9f	6a 01		 push	 1
  01ca1	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01ca6	83 c4 20	 add	 esp, 32			; 00000020H
$LN81@PrinterInf:

; 2784 :                         }
; 2785 :                         delete[] pLogFont;

  01ca9	56		 push	 esi
  01caa	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  01caf	83 c4 04	 add	 esp, 4

; 2790 :                     }
; 2791 :                 }
; 2792 :             }
; 2793 :             DeleteDC(hdc);

  01cb2	8b b5 b8 fb ff
	ff		 mov	 esi, DWORD PTR _hdc$1$[ebp]
  01cb8	56		 push	 esi
  01cb9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 2281 :     for (int printerCnt = 0; printerCnt < gpPrinterInfoList->num; printerCnt++)

  01cbf	8b b5 a0 fb ff
	ff		 mov	 esi, DWORD PTR _printerCnt$3[ebp]
  01cc5	46		 inc	 esi
  01cc6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  01ccb	e9 3f e4 ff ff	 jmp	 $LN1039@PrinterInf
$LN79@PrinterInf:

; 2786 :                     }
; 2787 :                     else
; 2788 :                     {
; 2789 :                         Log(LOG_DEBUG, __LINE__, "-- PtrInfo, new LOGFONT null");

  01cd0	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PNGCEDEF@?9?9?5PtrInfo?0?5new?5LOGFONT?5null@
  01cd5	68 e5 0a 00 00	 push	 2789			; 00000ae5H
  01cda	6a 10		 push	 16			; 00000010H
  01cdc	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01ce1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2790 :                     }
; 2791 :                 }
; 2792 :             }
; 2793 :             DeleteDC(hdc);

  01ce4	8b b5 b8 fb ff
	ff		 mov	 esi, DWORD PTR _hdc$1$[ebp]
$LN80@PrinterInf:
  01cea	56		 push	 esi
  01ceb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4

; 2281 :     for (int printerCnt = 0; printerCnt < gpPrinterInfoList->num; printerCnt++)

  01cf1	8b b5 a0 fb ff
	ff		 mov	 esi, DWORD PTR _printerCnt$3[ebp]
  01cf7	46		 inc	 esi
  01cf8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  01cfd	e9 0d e4 ff ff	 jmp	 $LN1039@PrinterInf
$LN74@PrinterInf:

; 2797 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, CreateIC %s", GetLastErrorMessage(GetLastError()).c_str());

  01d02	ff d6		 call	 esi
  01d04	8b d0		 mov	 edx, eax
  01d06	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  01d0c	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  01d11	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+12], 18 ; 00000012H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  01d15	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  01d19	72 02		 jb	 SHORT $LN930@PrinterInf
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  01d1b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN930@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2797 :             Log(LOG_DEBUG, __LINE__, "-- PtrInfo, CreateIC %s", GetLastErrorMessage(GetLastError()).c_str());

  01d1d	50		 push	 eax
  01d1e	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CCOPIFBO@?9?9?5PtrInfo?0?5CreateIC?5?$CFs@
  01d23	68 ed 0a 00 00	 push	 2797			; 00000aedH
  01d28	6a 10		 push	 16			; 00000010H
  01d2a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  01d2f	83 c4 10	 add	 esp, 16			; 00000010H
  01d32	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  01d36	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR $T5[ebp+20]
  01d3c	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  01d3f	72 2f		 jb	 SHORT $LN978@PrinterInf

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01d41	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01d42	8b 8d c0 fb ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  01d48	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  01d4a	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  01d50	72 14		 jb	 SHORT $LN977@PrinterInf

; 115  : 	_Bytes += _Non_user_size;

  01d52	83 c2 23	 add	 edx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  01d55	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  01d58	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01d5a	83 c0 fc	 add	 eax, -4			; fffffffcH
  01d5d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01d60	0f 87 f8 00 00
	00		 ja	 $LN1052@PrinterInf
$LN977@PrinterInf:

; 207  : 	::operator delete(_Ptr, _Bytes);

  01d66	52		 push	 edx
  01d67	51		 push	 ecx
  01d68	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01d6d	83 c4 08	 add	 esp, 8
$LN978@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  01d70	c7 85 d0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01d7a	c7 85 d4 fb ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  01d84	c6 85 c0 fb ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2281 :     for (int printerCnt = 0; printerCnt < gpPrinterInfoList->num; printerCnt++)

  01d8b	8b b5 a0 fb ff
	ff		 mov	 esi, DWORD PTR _printerCnt$3[ebp]
  01d91	46		 inc	 esi
  01d92	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A ; gpPrinterInfoList
  01d97	e9 73 e3 ff ff	 jmp	 $LN1039@PrinterInf
$LN3@PrinterInf:

; 2798 :         }
; 2799 :     }   //END: for(int printerCnt=0;printerCnt<gpPrinterInfoList->num;printerCnt++)
; 2800 : 
; 2801 :     //release printer info list
; 2802 :     if (gpPrinterInfoList)
; 2803 :     {
; 2804 :         delete[] gpPrinterInfoList;

  01d9c	50		 push	 eax
  01d9d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 2805 :         gpPrinterInfoList = NULL;

  01da2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gpPrinterInfoList@@3PAU_printer_info_list_@@A, 0 ; gpPrinterInfoList

; 2806 :     }
; 2807 : 
; 2808 :     LogElapsedTime(__LINE__, tickStart);

  01dac	ff b5 94 fb ff
	ff		 push	 DWORD PTR _tickStart$[ebp+4]
  01db2	ff b5 90 fb ff
	ff		 push	 DWORD PTR _tickStart$[ebp]
  01db8	33 d2		 xor	 edx, edx
  01dba	b9 f8 0a 00 00	 mov	 ecx, 2808		; 00000af8H
  01dbf	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime

; 2809 : 
; 2810 :     Log(LOG_DEBUG, __LINE__, "<< PtrInfo");

  01dc4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GNPIKGBL@?$DM?$DM?5PtrInfo@
  01dc9	68 fa 0a 00 00	 push	 2810			; 00000afaH
  01dce	6a 10		 push	 16			; 00000010H
  01dd0	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 2811 :     _endthreadex(0);

  01dd5	6a 00		 push	 0
  01dd7	e8 00 00 00 00	 call	 __endthreadex
  01ddc	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2812 :     return 0;

  01ddf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.h

; 164  :         if (pMem)

  01de6	85 ff		 test	 edi, edi
  01de8	74 13		 je	 SHORT $LN995@PrinterInf

; 165  :         {
; 166  :             delete[] pMem;

  01dea	57		 push	 edi
  01deb	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  01df0	83 c4 04	 add	 esp, 4

; 167  :             pMem = nullptr;

  01df3	c7 85 ac fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _B$[ebp], 0
$LN995@PrinterInf:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2813 : }

  01dfd	33 c0		 xor	 eax, eax
$LN1033@PrinterInf:
  01dff	c7 85 b0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _B$[ebp+4], 0
  01e09	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  01e0c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01e13	59		 pop	 ecx
  01e14	5f		 pop	 edi
  01e15	5e		 pop	 esi
  01e16	5b		 pop	 ebx
  01e17	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01e1a	33 cd		 xor	 ecx, ebp
  01e1c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01e21	8b e5		 mov	 esp, ebp
  01e23	5d		 pop	 ebp
  01e24	c2 04 00	 ret	 4
$LN1041@PrinterInf:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01e27	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1042@PrinterInf:
  01e2c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1043@PrinterInf:
  01e31	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1044@PrinterInf:
  01e36	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1045@PrinterInf:
  01e3b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1046@PrinterInf:
  01e40	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1047@PrinterInf:
  01e45	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1048@PrinterInf:
  01e4a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1049@PrinterInf:
  01e4f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1050@PrinterInf:
  01e54	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1051@PrinterInf:
  01e59	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1052@PrinterInf:
  01e5e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1032@PrinterInf:
  01e63	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$6:
  00000	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR _B$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1PBuffer@@QAE@XZ	; PBuffer::~PBuffer
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$7:
  0000b	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$8:
  00016	8d 8d b0 fc ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$9:
  00021	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$10:
  0002c	8d 8d 80 fc ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$11:
  00037	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$12:
  00042	8d 8d 50 fc ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$13:
  0004d	8d 8d 38 fc ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$14:
  00058	8d 8d 20 fc ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$15:
  00063	8d 8d 08 fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$16:
  0006e	8d 8d f0 fb ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$17:
  00079	8d 8d d8 fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?PrinterInfo@@YGIPAX@Z$18:
  00084	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?PrinterInfo@@YGIPAX@Z:
  0008f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00093	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00096	8b 8a 8c fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1140]
  0009c	33 c8		 xor	 ecx, eax
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  000a6	33 c8		 xor	 ecx, eax
  000a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ad	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PrinterInfo@@YGIPAX@Z
  000b2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PrinterInfo@@YGIPAX@Z ENDP				; PrinterInfo
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_ips$2 = -32						; size = 12
_tickStart$2$ = -20					; size = 4
$T3 = -20						; size = 1
_tickStart$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z PROC	; GetSystemIPAddresses
; _monIps$ = ecx
; _bMonIps$ = dl

; 2819 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8a da		 mov	 bl, dl
  0002a	8b f1		 mov	 esi, ecx

; 2820 :     Log(LOG_DEBUG, __LINE__, ">> GetSysIPAddrs, %p, %s", monIps, (bMonIps ? "True" : "False"));

  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05MKDOIIA@False@
  00031	84 db		 test	 bl, bl
  00033	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04HPMIDMKH@True@
  00038	0f 44 c1	 cmove	 eax, ecx
  0003b	50		 push	 eax
  0003c	56		 push	 esi
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@JNNHNEI@?$DO?$DO?5GetSysIPAddrs?0?5?$CFp?0?5?$CFs@
  00042	68 04 0b 00 00	 push	 2820			; 00000b04H
  00047	6a 10		 push	 16			; 00000010H
  00049	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0004e	83 c4 14	 add	 esp, 20			; 00000014H

; 2821 : 
; 2822 :     if (bMonIps && monIps)

  00051	84 db		 test	 bl, bl
  00053	0f 84 17 01 00
	00		 je	 $LN5@GetSystemI
  00059	85 f6		 test	 esi, esi
  0005b	0f 84 0f 01 00
	00		 je	 $LN5@GetSystemI

; 2823 :     {
; 2824 :         uint64_t tickStart = SysTick();

  00061	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  00066	89 45 ec	 mov	 DWORD PTR _tickStart$2$[ebp], eax
  00069	89 55 f0	 mov	 DWORD PTR _tickStart$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  0006c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ips$2[ebp], 0

; 390  : 		_Mylast(),

  00073	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _ips$2[ebp+4], 0

; 391  : 		_Myend()

  0007a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ips$2[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2825 :         std::vector<std::string> ips;

  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 67   :         WaitForSingleObject(m_hSync, MINUTE);

  00088	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0008d	ff 36		 push	 DWORD PTR [esi]
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 68   : 
; 69   :         ips = m_ips;

  00095	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1400 : 		if (this != _STD addressof(_Right))

  00098	8d 4d e0	 lea	 ecx, DWORD PTR _ips$2[ebp]
  0009b	3b c8		 cmp	 ecx, eax
  0009d	74 0d		 je	 SHORT $LN22@GetSystemI

; 1390 : 		_Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0009f	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  000a2	ff 70 04	 push	 DWORD PTR [eax+4]
  000a5	ff 30		 push	 DWORD PTR [eax]
  000a7	e8 00 00 00 00	 call	 ??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN22@GetSystemI:
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 71   :         ReleaseMutex(m_hSync);

  000ac	ff 36		 push	 DWORD PTR [esi]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  000b4	8b 4d e4	 mov	 ecx, DWORD PTR _ips$2[ebp+4]
  000b7	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000bc	2b 4d e0	 sub	 ecx, DWORD PTR _ips$2[ebp]
  000bf	f7 e9		 imul	 ecx
  000c1	c1 fa 02	 sar	 edx, 2
  000c4	8b c2		 mov	 eax, edx
  000c6	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c9	03 c2		 add	 eax, edx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2828 :         if (ips.size())

  000cb	74 7f		 je	 SHORT $LN3@GetSystemI

; 2830 :             Log(LOG_HEADER, __LINE__, "IP Addresses (%u):", ips.size());

  000cd	50		 push	 eax
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JGGPHJBD@IP?5Addresses?5?$CI?$CFu?$CJ?3@
  000d3	68 0e 0b 00 00	 push	 2830			; 00000b0eH
  000d8	6a 02		 push	 2
  000da	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  000df	8b 4d e4	 mov	 ecx, DWORD PTR _ips$2[ebp+4]
  000e2	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000e7	8b 7d e0	 mov	 edi, DWORD PTR _ips$2[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2830 :             Log(LOG_HEADER, __LINE__, "IP Addresses (%u):", ips.size());

  000ea	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  000ed	2b cf		 sub	 ecx, edi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2832 :             for (unsigned int cnt = 0; cnt < ips.size(); cnt++)

  000ef	33 f6		 xor	 esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  000f1	f7 e9		 imul	 ecx
  000f3	c1 fa 02	 sar	 edx, 2
  000f6	8b c2		 mov	 eax, edx
  000f8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000fb	03 c2		 add	 eax, edx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2832 :             for (unsigned int cnt = 0; cnt < ips.size(); cnt++)

  000fd	74 4d		 je	 SHORT $LN3@GetSystemI
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  000ff	33 db		 xor	 ebx, ebx

; 1750 : 		if (size() <= _Pos)

  00101	3b c6		 cmp	 eax, esi
  00103	0f 86 8d 00 00
	00		 jbe	 $LN143@GetSystemI
$LN150@GetSystemI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00109	83 7c 3b 14 10	 cmp	 DWORD PTR [ebx+edi+20], 16 ; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1755 : 		return (this->_Myfirst()[_Pos]);

  0010e	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1815 : 		if (_Large_string_engaged())

  00111	72 02		 jb	 SHORT $LN134@GetSystemI
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00113	8b 00		 mov	 eax, DWORD PTR [eax]
$LN134@GetSystemI:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2834 :                 Log(LOG_MESSAGE, __LINE__, "> %02u %s", cnt + 1, ips.at(cnt).c_str());

  00115	50		 push	 eax
  00116	46		 inc	 esi
  00117	56		 push	 esi
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_09BDGNKGNI@?$DO?5?$CF02u?5?$CFs@
  0011d	68 12 0b 00 00	 push	 2834			; 00000b12H
  00122	6a 01		 push	 1
  00124	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00129	8b 4d e4	 mov	 ecx, DWORD PTR _ips$2[ebp+4]
  0012c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00131	8b 7d e0	 mov	 edi, DWORD PTR _ips$2[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2834 :                 Log(LOG_MESSAGE, __LINE__, "> %02u %s", cnt + 1, ips.at(cnt).c_str());

  00134	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00137	2b cf		 sub	 ecx, edi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2832 :             for (unsigned int cnt = 0; cnt < ips.size(); cnt++)

  00139	83 c3 18	 add	 ebx, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  0013c	f7 e9		 imul	 ecx
  0013e	c1 fa 02	 sar	 edx, 2
  00141	8b c2		 mov	 eax, edx
  00143	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00146	03 c2		 add	 eax, edx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2832 :             for (unsigned int cnt = 0; cnt < ips.size(); cnt++)

  00148	3b c6		 cmp	 eax, esi
  0014a	77 bd		 ja	 SHORT $LN150@GetSystemI
$LN3@GetSystemI:

; 2835 :             }
; 2836 :         }
; 2837 : 
; 2838 :         LogElapsedTime(__LINE__, tickStart);

  0014c	ff 75 f0	 push	 DWORD PTR _tickStart$1$[ebp]
  0014f	33 d2		 xor	 edx, edx
  00151	b9 16 0b 00 00	 mov	 ecx, 2838		; 00000b16H
  00156	ff 75 ec	 push	 DWORD PTR _tickStart$2$[ebp]
  00159	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime
  0015e	83 c4 08	 add	 esp, 8

; 2839 :     }

  00161	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00168	8d 4d e0	 lea	 ecx, DWORD PTR _ips$2[ebp]
  0016b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
$LN5@GetSystemI:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2840 :     Log(LOG_DEBUG, __LINE__, "<< GetSysIPAddrs");

  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CMFNMPNL@?$DM?$DM?5GetSysIPAddrs@
  00175	68 18 0b 00 00	 push	 2840			; 00000b18H
  0017a	6a 10		 push	 16			; 00000010H
  0017c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2841 : }

  00184	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00187	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0018e	59		 pop	 ecx
  0018f	5f		 pop	 edi
  00190	5e		 pop	 esi
  00191	5b		 pop	 ebx
  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
$LN143@GetSystemI:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1752 : 			_Xrange();

  00196	e8 00 00 00 00	 call	 ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
$LN148@GetSystemI:
  0019b	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _ips$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z ENDP	; GetSystemIPAddresses
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -140						; size = 24
$T3 = -140						; size = 24
$T4 = -140						; size = 24
$T5 = -140						; size = 24
$T6 = -140						; size = 24
_sMember$7 = -116					; size = 100
_sMember$8 = -116					; size = 100
_sMember$9 = -116					; size = 100
_sMember$10 = -116					; size = 100
_sMember$11 = -116					; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetSystemDetails@@YAXXZ PROC				; GetSystemDetails

; 2852 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemDetails@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2853 :     Log(LOG_DEBUG, __LINE__, ">> GetSysDets");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BHNLPBFJ@?$DO?$DO?5GetSysDets@
  00033	68 25 0b 00 00	 push	 2853			; 00000b25H
  00038	6a 10		 push	 16			; 00000010H
  0003a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 73   :     char sMember[100] = { 0 };

  0003f	6a 64		 push	 100			; 00000064H
  00041	8d 45 8c	 lea	 eax, DWORD PTR _sMember$11[ebp]
  00044	6a 00		 push	 0
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0004c	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00056	8d 45 8c	 lea	 eax, DWORD PTR _sMember$11[ebp]
  00059	6a 63		 push	 99			; 00000063H
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __snprintf

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00061	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateMutexA@12
  00067	8d 45 8c	 lea	 eax, DWORD PTR _sMember$11[ebp]
  0006a	83 c4 28	 add	 esp, 40			; 00000028H
  0006d	50		 push	 eax
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	ff d3		 call	 ebx
  00074	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00076	6a ff		 push	 -1
  00078	57		 push	 edi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0007f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00085	57		 push	 edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0008c	57		 push	 edi
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2854 : 
; 2855 :     /* Hardware Profile */
; 2856 :     if (_thGetInt(&gbShutdown) == FALSE)

  00093	85 f6		 test	 esi, esi
  00095	0f 85 99 00 00
	00		 jne	 $LN84@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009b	6a 09		 push	 9

; 1784 : 		_Mysize(0),

  0009d	89 75 84	 mov	 DWORD PTR $T6[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a0	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]

; 1785 : 		_Myres(0)

  000a6	89 75 88	 mov	 DWORD PTR $T6[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_09NLLCGGEI@HwProfile@

; 3976 : 		_My_data._Mysize = 0;

  000ae	89 75 84	 mov	 DWORD PTR $T6[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000b1	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000b8	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000bf	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2858 :         StartThread("HwProfile", HwProfile, NULL, MINUTE);

  000c4	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  000c7	ba 00 00 00 00	 mov	 edx, OFFSET ?HwProfile@@YGIPAX@Z ; HwProfile
  000cc	56		 push	 esi
  000cd	68 60 ea 00 00	 push	 60000			; 0000ea60H
  000d2	56		 push	 esi
  000d3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000d9	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000e8	8b 55 88	 mov	 edx, DWORD PTR $T6[ebp+20]
  000eb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000ee	72 2f		 jb	 SHORT $LN82@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f0	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000f6	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f7	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000f9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000ff	72 14		 jb	 SHORT $LN81@GetSystemD

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00101	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00104	83 c2 23	 add	 edx, 35			; 00000023H
  00107	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00109	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010f	0f 87 17 04 00
	00		 ja	 $LN432@GetSystemD
$LN81@GetSystemD:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00115	52		 push	 edx
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011c	83 c4 08	 add	 esp, 8
$LN82@GetSystemD:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0011f	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T6[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00126	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0012d	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
$LN84@GetSystemD:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00134	6a 64		 push	 100			; 00000064H
  00136	8d 45 8c	 lea	 eax, DWORD PTR _sMember$10[ebp]
  00139	6a 00		 push	 0
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00141	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0014b	8d 45 8c	 lea	 eax, DWORD PTR _sMember$10[ebp]
  0014e	6a 63		 push	 99			; 00000063H
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 __snprintf
  00156	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00159	8d 45 8c	 lea	 eax, DWORD PTR _sMember$10[ebp]
  0015c	50		 push	 eax
  0015d	6a 00		 push	 0
  0015f	6a 00		 push	 0
  00161	ff d3		 call	 ebx
  00163	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00165	6a ff		 push	 -1
  00167	57		 push	 edi
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0016e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00174	57		 push	 edi
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0017b	57		 push	 edi
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2859 :     }
; 2860 : 
; 2861 :     /* Computer */
; 2862 :     if (_thGetInt(&gbShutdown) == FALSE)

  00182	85 f6		 test	 esi, esi
  00184	0f 85 9d 00 00
	00		 jne	 $LN168@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0018a	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  0018c	89 75 84	 mov	 DWORD PTR $T5[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0018f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]

; 1785 : 		_Myres(0)

  00195	89 75 88	 mov	 DWORD PTR $T5[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00198	68 00 00 00 00	 push	 OFFSET ??_C@_07JFBHEENG@SysInfo@

; 3976 : 		_My_data._Mysize = 0;

  0019d	89 75 84	 mov	 DWORD PTR $T5[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001a0	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001a7	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001ae	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2864 :         StartThread("SysInfo", SystemInfo, NULL, MINUTE);

  001b3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001ba	ba 00 00 00 00	 mov	 edx, OFFSET ?SystemInfo@@YGIPAX@Z ; SystemInfo
  001bf	56		 push	 esi
  001c0	68 60 ea 00 00	 push	 60000			; 0000ea60H
  001c5	56		 push	 esi
  001c6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  001cc	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001db	8b 55 88	 mov	 edx, DWORD PTR $T5[ebp+20]
  001de	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001e1	72 2f		 jb	 SHORT $LN166@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001e9	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ea	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001ec	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001f2	72 14		 jb	 SHORT $LN165@GetSystemD

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001f4	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001f7	83 c2 23	 add	 edx, 35			; 00000023H
  001fa	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001fc	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ff	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00202	0f 87 29 03 00
	00		 ja	 $LN433@GetSystemD
$LN165@GetSystemD:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00208	52		 push	 edx
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0020f	83 c4 08	 add	 esp, 8
$LN166@GetSystemD:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00212	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00219	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00220	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
$LN168@GetSystemD:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00227	6a 64		 push	 100			; 00000064H
  00229	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  0022c	6a 00		 push	 0
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00234	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0023e	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00241	6a 63		 push	 99			; 00000063H
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 __snprintf
  00249	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0024c	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  0024f	50		 push	 eax
  00250	6a 00		 push	 0
  00252	6a 00		 push	 0
  00254	ff d3		 call	 ebx
  00256	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00258	6a ff		 push	 -1
  0025a	57		 push	 edi
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00261	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00267	57		 push	 edi
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0026e	57		 push	 edi
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2865 :     }
; 2866 : 
; 2867 :     /* OSInfo */
; 2868 :     if (_thGetInt(&gbShutdown) == FALSE)

  00275	85 f6		 test	 esi, esi
  00277	0f 85 9d 00 00
	00		 jne	 $LN251@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0027d	6a 06		 push	 6

; 1784 : 		_Mysize(0),

  0027f	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00282	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]

; 1785 : 		_Myres(0)

  00288	89 75 88	 mov	 DWORD PTR $T4[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_06HKOPCFLK@OSInfo@

; 3976 : 		_My_data._Mysize = 0;

  00290	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00293	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0029a	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2870 :         StartThread("OSInfo", OSInfo, NULL, MINUTE);

  002a6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002ad	ba 00 00 00 00	 mov	 edx, OFFSET ?OSInfo@@YGIPAX@Z ; OSInfo
  002b2	56		 push	 esi
  002b3	68 60 ea 00 00	 push	 60000			; 0000ea60H
  002b8	56		 push	 esi
  002b9	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  002bf	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002ce	8b 55 88	 mov	 edx, DWORD PTR $T4[ebp+20]
  002d1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002d4	72 2f		 jb	 SHORT $LN249@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002d6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002dc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002dd	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002df	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002e5	72 14		 jb	 SHORT $LN248@GetSystemD

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002e7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002ea	83 c2 23	 add	 edx, 35			; 00000023H
  002ed	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002ef	83 c0 fc	 add	 eax, -4			; fffffffcH
  002f2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002f5	0f 87 3b 02 00
	00		 ja	 $LN434@GetSystemD
$LN248@GetSystemD:

; 207  : 	::operator delete(_Ptr, _Bytes);

  002fb	52		 push	 edx
  002fc	51		 push	 ecx
  002fd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00302	83 c4 08	 add	 esp, 8
$LN249@GetSystemD:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00305	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0030c	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00313	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
$LN251@GetSystemD:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  0031a	6a 64		 push	 100			; 00000064H
  0031c	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  0031f	6a 00		 push	 0
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00327	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  0032c	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00331	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  00334	6a 63		 push	 99			; 00000063H
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 __snprintf
  0033c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0033f	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  00342	50		 push	 eax
  00343	6a 00		 push	 0
  00345	6a 00		 push	 0
  00347	ff d3		 call	 ebx
  00349	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  0034b	6a ff		 push	 -1
  0034d	57		 push	 edi
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00354	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  0035a	57		 push	 edi
  0035b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  00361	57		 push	 edi
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2871 :     }
; 2872 : 
; 2873 :     /* Logical Processor(s) Information */
; 2874 :     if (_thGetInt(&gbShutdown) == FALSE)

  00368	85 f6		 test	 esi, esi
  0036a	0f 85 9d 00 00
	00		 jne	 $LN334@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00370	6a 0f		 push	 15			; 0000000fH

; 1784 : 		_Mysize(0),

  00372	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00375	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]

; 1785 : 		_Myres(0)

  0037b	89 75 88	 mov	 DWORD PTR $T3[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0037e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JCIBBNDO@SysLogPrcsrInfo@

; 3976 : 		_My_data._Mysize = 0;

  00383	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00386	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0038d	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00394	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2876 :         StartThread("SysLogPrcsrInfo", SystemLogicalProcessorInforamtion, NULL, MINUTE);

  00399	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  003a0	ba 00 00 00 00	 mov	 edx, OFFSET ?SystemLogicalProcessorInforamtion@@YGIPAX@Z ; SystemLogicalProcessorInforamtion
  003a5	56		 push	 esi
  003a6	68 60 ea 00 00	 push	 60000			; 0000ea60H
  003ab	56		 push	 esi
  003ac	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  003b2	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  003b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ba	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003c1	8b 55 88	 mov	 edx, DWORD PTR $T3[ebp+20]
  003c4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  003c7	72 2f		 jb	 SHORT $LN332@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003c9	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  003cf	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003d0	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  003d2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003d8	72 14		 jb	 SHORT $LN331@GetSystemD

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  003da	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003dd	83 c2 23	 add	 edx, 35			; 00000023H
  003e0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003e2	83 c0 fc	 add	 eax, -4			; fffffffcH
  003e5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003e8	0f 87 4d 01 00
	00		 ja	 $LN435@GetSystemD
$LN331@GetSystemD:

; 207  : 	::operator delete(_Ptr, _Bytes);

  003ee	52		 push	 edx
  003ef	51		 push	 ecx
  003f0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003f5	83 c4 08	 add	 esp, 8
$LN332@GetSystemD:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  003f8	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003ff	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00406	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN334@GetSystemD:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  0040d	6a 64		 push	 100			; 00000064H
  0040f	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00412	6a 00		 push	 0
  00414	50		 push	 eax
  00415	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0041a	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  0041f	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00424	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00427	6a 63		 push	 99			; 00000063H
  00429	50		 push	 eax
  0042a	e8 00 00 00 00	 call	 __snprintf
  0042f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00432	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00435	50		 push	 eax
  00436	6a 00		 push	 0
  00438	6a 00		 push	 0
  0043a	ff d3		 call	 ebx
  0043c	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  0043e	6a ff		 push	 -1
  00440	57		 push	 edi
  00441	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00447	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  0044d	57		 push	 edi
  0044e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  00454	57		 push	 edi
  00455	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2877 :     }
; 2878 : 
; 2879 :     /* System Directories */
; 2880 :     if (_thGetInt(&gbShutdown) == FALSE)

  0045b	85 f6		 test	 esi, esi
  0045d	0f 85 99 00 00
	00		 jne	 $LN417@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00463	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  00465	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00468	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]

; 1785 : 		_Myres(0)

  0046e	89 75 88	 mov	 DWORD PTR $T2[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00471	68 00 00 00 00	 push	 OFFSET ??_C@_07NAIOOCP@SysDirs@

; 3976 : 		_My_data._Mysize = 0;

  00476	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00479	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00480	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00487	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2882 :         StartThread("SysDirs", SystemDirs, NULL, MINUTE);

  0048c	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00493	ba 00 00 00 00	 mov	 edx, OFFSET ?SystemDirs@@YGIPAX@Z ; SystemDirs
  00498	56		 push	 esi
  00499	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0049e	56		 push	 esi
  0049f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  004a5	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  004aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  004b4	8b 55 88	 mov	 edx, DWORD PTR $T2[ebp+20]
  004b7	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  004ba	72 2b		 jb	 SHORT $LN415@GetSystemD
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004bc	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  004c2	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004c3	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  004c5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004cb	72 10		 jb	 SHORT $LN414@GetSystemD

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  004cd	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004d0	83 c2 23	 add	 edx, 35			; 00000023H
  004d3	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004d5	83 c0 fc	 add	 eax, -4			; fffffffcH
  004d8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004db	77 63		 ja	 SHORT $LN436@GetSystemD
$LN414@GetSystemD:

; 207  : 	::operator delete(_Ptr, _Bytes);

  004dd	52		 push	 edx
  004de	51		 push	 ecx
  004df	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004e4	83 c4 08	 add	 esp, 8
$LN415@GetSystemD:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  004e7	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  004ee	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  004f5	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
$LN417@GetSystemD:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2885 :     Log(LOG_DEBUG, __LINE__, "<< GetSysDets");

  004fc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JGOJIALP@?$DM?$DM?5GetSysDets@
  00501	68 45 0b 00 00	 push	 2885			; 00000b45H
  00506	6a 10		 push	 16			; 00000010H
  00508	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0050d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2886 : }

  00510	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00513	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0051a	59		 pop	 ecx
  0051b	5f		 pop	 edi
  0051c	5e		 pop	 esi
  0051d	5b		 pop	 ebx
  0051e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00521	33 cd		 xor	 ecx, ebp
  00523	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00528	8b e5		 mov	 esp, ebp
  0052a	5d		 pop	 ebp
  0052b	c3		 ret	 0
$LN432@GetSystemD:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0052c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN433@GetSystemD:
  00531	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN434@GetSystemD:
  00536	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN435@GetSystemD:
  0053b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN436@GetSystemD:
  00540	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN430@GetSystemD:
  00545	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetSystemDetails@@YAXXZ$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemDetails@@YAXXZ$1:
  0000b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemDetails@@YAXXZ$2:
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemDetails@@YAXXZ$3:
  00021	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemDetails@@YAXXZ$4:
  0002c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetSystemDetails@@YAXXZ:
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003e	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00044	33 c8		 xor	 ecx, eax
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004e	33 c8		 xor	 ecx, eax
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemDetails@@YAXXZ
  0005a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemDetails@@YAXXZ ENDP				; GetSystemDetails
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -140						; size = 24
$T3 = -140						; size = 24
$T4 = -140						; size = 24
$T5 = -140						; size = 24
_sMember$6 = -116					; size = 100
_sMember$7 = -116					; size = 100
_sMember$8 = -116					; size = 100
_sMember$9 = -116					; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetSystemStatus@@YAXXZ PROC				; GetSystemStatus

; 2892 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemStatus@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2893 :     Log(LOG_DEBUG, __LINE__, ">> GetSysSts");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DKCIAKLO@?$DO?$DO?5GetSysSts@
  00033	68 4d 0b 00 00	 push	 2893			; 00000b4dH
  00038	6a 10		 push	 16			; 00000010H
  0003a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 73   :     char sMember[100] = { 0 };

  0003f	6a 64		 push	 100			; 00000064H
  00041	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00044	6a 00		 push	 0
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0004c	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00056	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00059	6a 63		 push	 99			; 00000063H
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __snprintf

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00061	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateMutexA@12
  00067	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  0006a	83 c4 28	 add	 esp, 40			; 00000028H
  0006d	50		 push	 eax
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	ff d3		 call	 ebx
  00074	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00076	6a ff		 push	 -1
  00078	57		 push	 edi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0007f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00085	57		 push	 edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0008c	57		 push	 edi
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2894 : 
; 2895 :     /* System Times */
; 2896 :     if (_thGetInt(&gbShutdown) == FALSE)

  00093	85 f6		 test	 esi, esi
  00095	0f 85 99 00 00
	00		 jne	 $LN82@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009b	6a 08		 push	 8

; 1784 : 		_Mysize(0),

  0009d	89 75 84	 mov	 DWORD PTR $T5[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a0	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]

; 1785 : 		_Myres(0)

  000a6	89 75 88	 mov	 DWORD PTR $T5[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_08LMMJIFBC@SysTimes@

; 3976 : 		_My_data._Mysize = 0;

  000ae	89 75 84	 mov	 DWORD PTR $T5[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000b1	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000b8	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000bf	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2898 :         StartThread("SysTimes", SystemTimes, NULL, MINUTE);

  000c4	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  000c7	ba 00 00 00 00	 mov	 edx, OFFSET ?SystemTimes@@YGIPAX@Z ; SystemTimes
  000cc	56		 push	 esi
  000cd	68 60 ea 00 00	 push	 60000			; 0000ea60H
  000d2	56		 push	 esi
  000d3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000d9	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000e8	8b 55 88	 mov	 edx, DWORD PTR $T5[ebp+20]
  000eb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000ee	72 2f		 jb	 SHORT $LN80@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f0	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000f6	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f7	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000f9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000ff	72 14		 jb	 SHORT $LN79@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00101	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00104	83 c2 23	 add	 edx, 35			; 00000023H
  00107	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00109	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010f	0f 87 24 03 00
	00		 ja	 $LN347@GetSystemS
$LN79@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00115	52		 push	 edx
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011c	83 c4 08	 add	 esp, 8
$LN80@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0011f	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00126	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0012d	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
$LN82@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00134	6a 64		 push	 100			; 00000064H
  00136	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  00139	6a 00		 push	 0
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00141	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0014b	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  0014e	6a 63		 push	 99			; 00000063H
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 __snprintf
  00156	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00159	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  0015c	50		 push	 eax
  0015d	6a 00		 push	 0
  0015f	6a 00		 push	 0
  00161	ff d3		 call	 ebx
  00163	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00165	6a ff		 push	 -1
  00167	57		 push	 edi
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0016e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00174	57		 push	 edi
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0017b	57		 push	 edi
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2899 :     }
; 2900 : 
; 2901 :     /* System Memory */
; 2902 :     if (_thGetInt(&gbShutdown) == FALSE)

  00182	85 f6		 test	 esi, esi
  00184	0f 85 9d 00 00
	00		 jne	 $LN166@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0018a	6a 06		 push	 6

; 1784 : 		_Mysize(0),

  0018c	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0018f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]

; 1785 : 		_Myres(0)

  00195	89 75 88	 mov	 DWORD PTR $T4[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00198	68 00 00 00 00	 push	 OFFSET ??_C@_06BFMAIJHM@SysMem@

; 3976 : 		_My_data._Mysize = 0;

  0019d	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001a0	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001a7	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001ae	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2904 :         StartThread("SysMem", SystemMemory, NULL, MINUTE);

  001b3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001ba	ba 00 00 00 00	 mov	 edx, OFFSET ?SystemMemory@@YGIPAX@Z ; SystemMemory
  001bf	56		 push	 esi
  001c0	68 60 ea 00 00	 push	 60000			; 0000ea60H
  001c5	56		 push	 esi
  001c6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001cc	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001db	8b 55 88	 mov	 edx, DWORD PTR $T4[ebp+20]
  001de	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001e1	72 2f		 jb	 SHORT $LN164@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001e9	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ea	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001ec	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001f2	72 14		 jb	 SHORT $LN163@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001f4	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001f7	83 c2 23	 add	 edx, 35			; 00000023H
  001fa	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001fc	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ff	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00202	0f 87 36 02 00
	00		 ja	 $LN348@GetSystemS
$LN163@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00208	52		 push	 edx
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0020f	83 c4 08	 add	 esp, 8
$LN164@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00212	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00219	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00220	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
$LN166@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00227	6a 64		 push	 100			; 00000064H
  00229	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  0022c	6a 00		 push	 0
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00234	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0023e	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00241	6a 63		 push	 99			; 00000063H
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 __snprintf
  00249	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0024c	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  0024f	50		 push	 eax
  00250	6a 00		 push	 0
  00252	6a 00		 push	 0
  00254	ff d3		 call	 ebx
  00256	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00258	6a ff		 push	 -1
  0025a	57		 push	 edi
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00261	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00267	57		 push	 edi
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0026e	57		 push	 edi
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2905 :     }
; 2906 : 
; 2907 :     /* Performance Information */
; 2908 :     if (_thGetInt(&gbShutdown) == FALSE)

  00275	85 f6		 test	 esi, esi
  00277	0f 85 9d 00 00
	00		 jne	 $LN249@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0027d	6a 08		 push	 8

; 1784 : 		_Mysize(0),

  0027f	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00282	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]

; 1785 : 		_Myres(0)

  00288	89 75 88	 mov	 DWORD PTR $T3[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_08HGNAFDEP@PerfInfo@

; 3976 : 		_My_data._Mysize = 0;

  00290	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00293	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0029a	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2910 :         StartThread("PerfInfo", PerformanceInfo, NULL, MINUTE);

  002a6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002ad	ba 00 00 00 00	 mov	 edx, OFFSET ?PerformanceInfo@@YGIPAX@Z ; PerformanceInfo
  002b2	56		 push	 esi
  002b3	68 60 ea 00 00	 push	 60000			; 0000ea60H
  002b8	56		 push	 esi
  002b9	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  002bf	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002ce	8b 55 88	 mov	 edx, DWORD PTR $T3[ebp+20]
  002d1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002d4	72 2f		 jb	 SHORT $LN247@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002d6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002dc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002dd	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002df	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002e5	72 14		 jb	 SHORT $LN246@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002e7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002ea	83 c2 23	 add	 edx, 35			; 00000023H
  002ed	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002ef	83 c0 fc	 add	 eax, -4			; fffffffcH
  002f2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002f5	0f 87 48 01 00
	00		 ja	 $LN349@GetSystemS
$LN246@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  002fb	52		 push	 edx
  002fc	51		 push	 ecx
  002fd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00302	83 c4 08	 add	 esp, 8
$LN247@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00305	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0030c	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00313	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN249@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  0031a	6a 64		 push	 100			; 00000064H
  0031c	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  0031f	6a 00		 push	 0
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00327	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  0032c	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00331	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00334	6a 63		 push	 99			; 00000063H
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 __snprintf
  0033c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0033f	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00342	50		 push	 eax
  00343	6a 00		 push	 0
  00345	6a 00		 push	 0
  00347	ff d3		 call	 ebx
  00349	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  0034b	6a ff		 push	 -1
  0034d	57		 push	 edi
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00354	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  0035a	57		 push	 edi
  0035b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  00361	57		 push	 edi
  00362	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2911 :     }
; 2912 : 
; 2913 :     /* Processes Informaton */
; 2914 :     if (_thGetInt(&gbShutdown) == FALSE)

  00368	85 f6		 test	 esi, esi
  0036a	0f 85 99 00 00
	00		 jne	 $LN332@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00370	6a 08		 push	 8

; 1784 : 		_Mysize(0),

  00372	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00375	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]

; 1785 : 		_Myres(0)

  0037b	89 75 88	 mov	 DWORD PTR $T2[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0037e	68 00 00 00 00	 push	 OFFSET ??_C@_08FGGKAHMA@ProcInfo@

; 3976 : 		_My_data._Mysize = 0;

  00383	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00386	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0038d	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00394	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2916 :         StartThread("ProcInfo", ProcessInfo, NULL, MINUTE);

  00399	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  003a0	ba 00 00 00 00	 mov	 edx, OFFSET ?ProcessInfo@@YGIPAX@Z ; ProcessInfo
  003a5	56		 push	 esi
  003a6	68 60 ea 00 00	 push	 60000			; 0000ea60H
  003ab	56		 push	 esi
  003ac	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003b2	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  003b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ba	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003c1	8b 55 88	 mov	 edx, DWORD PTR $T2[ebp+20]
  003c4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  003c7	72 2b		 jb	 SHORT $LN330@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003c9	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  003cf	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003d0	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  003d2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003d8	72 10		 jb	 SHORT $LN329@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  003da	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003dd	83 c2 23	 add	 edx, 35			; 00000023H
  003e0	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003e2	83 c0 fc	 add	 eax, -4			; fffffffcH
  003e5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003e8	77 5e		 ja	 SHORT $LN350@GetSystemS
$LN329@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  003ea	52		 push	 edx
  003eb	51		 push	 ecx
  003ec	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003f1	83 c4 08	 add	 esp, 8
$LN330@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  003f4	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003fb	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00402	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
$LN332@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2919 :     Log(LOG_DEBUG, __LINE__, "<< GetSysSts");

  00409	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LGEPCBGK@?$DM?$DM?5GetSysSts@
  0040e	68 67 0b 00 00	 push	 2919			; 00000b67H
  00413	6a 10		 push	 16			; 00000010H
  00415	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0041a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2920 : }

  0041d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00420	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00427	59		 pop	 ecx
  00428	5f		 pop	 edi
  00429	5e		 pop	 esi
  0042a	5b		 pop	 ebx
  0042b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0042e	33 cd		 xor	 ecx, ebp
  00430	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00435	8b e5		 mov	 esp, ebp
  00437	5d		 pop	 ebp
  00438	c3		 ret	 0
$LN347@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00439	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN348@GetSystemS:
  0043e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN349@GetSystemS:
  00443	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN350@GetSystemS:
  00448	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN345@GetSystemS:
  0044d	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetSystemStatus@@YAXXZ$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemStatus@@YAXXZ$1:
  0000b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemStatus@@YAXXZ$2:
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemStatus@@YAXXZ$3:
  00021	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetSystemStatus@@YAXXZ:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemStatus@@YAXXZ
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemStatus@@YAXXZ ENDP				; GetSystemStatus
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -140						; size = 24
$T3 = -140						; size = 24
$T4 = -140						; size = 24
$T5 = -140						; size = 24
_sMember$6 = -116					; size = 100
_sMember$7 = -116					; size = 100
_sMember$8 = -116					; size = 100
_sMember$9 = -116					; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetSystemStatusChanges@@YAXXZ PROC			; GetSystemStatusChanges

; 2926 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSystemStatusChanges@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 73   :     char sMember[100] = { 0 };

  0002e	6a 64		 push	 100			; 00000064H
  00030	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00033	6a 00		 push	 0
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0003b	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00045	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00048	6a 63		 push	 99			; 00000063H
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 __snprintf

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00050	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateMutexA@12
  00056	8d 45 8c	 lea	 eax, DWORD PTR _sMember$9[ebp]
  00059	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	ff d3		 call	 ebx
  00063	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00065	6a ff		 push	 -1
  00067	57		 push	 edi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0006e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00074	57		 push	 edi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0007b	57		 push	 edi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2927 :     /* Logical Drivers */
; 2928 :     if (_thGetInt(&gbShutdown) == FALSE)

  00082	85 f6		 test	 esi, esi
  00084	0f 85 99 00 00
	00		 jne	 $LN82@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0008a	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  0008c	89 75 84	 mov	 DWORD PTR $T5[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0008f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]

; 1785 : 		_Myres(0)

  00095	89 75 88	 mov	 DWORD PTR $T5[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_07LEMLFMJD@LogDrvs@

; 3976 : 		_My_data._Mysize = 0;

  0009d	89 75 84	 mov	 DWORD PTR $T5[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000a0	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000a7	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000ae	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2930 :         StartThread("LogDrvs", LogicalDrives, NULL, MINUTE);

  000b3	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  000b6	ba 00 00 00 00	 mov	 edx, OFFSET ?LogicalDrives@@YGIPAX@Z ; LogicalDrives
  000bb	56		 push	 esi
  000bc	68 60 ea 00 00	 push	 60000			; 0000ea60H
  000c1	56		 push	 esi
  000c2	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000c8	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000d7	8b 55 88	 mov	 edx, DWORD PTR $T5[ebp+20]
  000da	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000dd	72 2f		 jb	 SHORT $LN80@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000df	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000e5	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000e8	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000ee	72 14		 jb	 SHORT $LN79@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000f0	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000f3	83 c2 23	 add	 edx, 35			; 00000023H
  000f6	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	0f 87 10 03 00
	00		 ja	 $LN347@GetSystemS
$LN79@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00104	52		 push	 edx
  00105	51		 push	 ecx
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN80@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0010e	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00115	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0011c	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
$LN82@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00123	6a 64		 push	 100			; 00000064H
  00125	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  00128	6a 00		 push	 0
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00130	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0013a	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  0013d	6a 63		 push	 99			; 00000063H
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 __snprintf
  00145	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00148	8d 45 8c	 lea	 eax, DWORD PTR _sMember$8[ebp]
  0014b	50		 push	 eax
  0014c	6a 00		 push	 0
  0014e	6a 00		 push	 0
  00150	ff d3		 call	 ebx
  00152	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00154	6a ff		 push	 -1
  00156	57		 push	 edi
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0015d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00163	57		 push	 edi
  00164	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0016a	57		 push	 edi
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2931 :     }
; 2932 : 
; 2933 :     /* Enumerate USB */
; 2934 :     if (_thGetInt(&gbShutdown) == FALSE)

  00171	85 f6		 test	 esi, esi
  00173	0f 85 9d 00 00
	00		 jne	 $LN166@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00179	6a 03		 push	 3

; 1784 : 		_Mysize(0),

  0017b	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0017e	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]

; 1785 : 		_Myres(0)

  00184	89 75 88	 mov	 DWORD PTR $T4[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_03IONNGCBN@USB@

; 3976 : 		_My_data._Mysize = 0;

  0018c	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0018f	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00196	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0019d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2936 :         StartThread("USB", ThreadUSB, NULL, MINUTE);

  001a2	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001a9	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadUSB@@YGIPAX@Z ; ThreadUSB
  001ae	56		 push	 esi
  001af	68 60 ea 00 00	 push	 60000			; 0000ea60H
  001b4	56		 push	 esi
  001b5	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001bb	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  001c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001ca	8b 55 88	 mov	 edx, DWORD PTR $T4[ebp+20]
  001cd	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001d0	72 2f		 jb	 SHORT $LN164@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001d2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001d8	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001d9	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001db	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001e1	72 14		 jb	 SHORT $LN163@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001e3	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001e6	83 c2 23	 add	 edx, 35			; 00000023H
  001e9	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001f1	0f 87 22 02 00
	00		 ja	 $LN348@GetSystemS
$LN163@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001f7	52		 push	 edx
  001f8	51		 push	 ecx
  001f9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001fe	83 c4 08	 add	 esp, 8
$LN164@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00201	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00208	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0020f	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
$LN166@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00216	6a 64		 push	 100			; 00000064H
  00218	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  0021b	6a 00		 push	 0
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00223	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00228	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0022d	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00230	6a 63		 push	 99			; 00000063H
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 __snprintf
  00238	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0023b	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  0023e	50		 push	 eax
  0023f	6a 00		 push	 0
  00241	6a 00		 push	 0
  00243	ff d3		 call	 ebx
  00245	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00247	6a ff		 push	 -1
  00249	57		 push	 edi
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00250	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00256	57		 push	 edi
  00257	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0025d	57		 push	 edi
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2937 :     }
; 2938 : 
; 2939 :     /* Device Drivers */
; 2940 :     if (_thGetInt(&gbShutdown) == FALSE)

  00264	85 f6		 test	 esi, esi
  00266	0f 85 9d 00 00
	00		 jne	 $LN249@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0026c	6a 08		 push	 8

; 1784 : 		_Mysize(0),

  0026e	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00271	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]

; 1785 : 		_Myres(0)

  00277	89 75 88	 mov	 DWORD PTR $T3[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_08IHNDGAAK@DevDrvrs@

; 3976 : 		_My_data._Mysize = 0;

  0027f	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00282	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00289	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00290	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2942 :         StartThread("DevDrvrs", DeviceDrivers, NULL, MINUTE);

  00295	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0029c	ba 00 00 00 00	 mov	 edx, OFFSET ?DeviceDrivers@@YGIPAX@Z ; DeviceDrivers
  002a1	56		 push	 esi
  002a2	68 60 ea 00 00	 push	 60000			; 0000ea60H
  002a7	56		 push	 esi
  002a8	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  002ae	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  002b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002bd	8b 55 88	 mov	 edx, DWORD PTR $T3[ebp+20]
  002c0	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002c3	72 2f		 jb	 SHORT $LN247@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002c5	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002cb	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002cc	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002ce	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002d4	72 14		 jb	 SHORT $LN246@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002d6	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002d9	83 c2 23	 add	 edx, 35			; 00000023H
  002dc	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002de	83 c0 fc	 add	 eax, -4			; fffffffcH
  002e1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002e4	0f 87 34 01 00
	00		 ja	 $LN349@GetSystemS
$LN246@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  002ea	52		 push	 edx
  002eb	51		 push	 ecx
  002ec	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002f1	83 c4 08	 add	 esp, 8
$LN247@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  002f4	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  002fb	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00302	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN249@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00309	6a 64		 push	 100			; 00000064H
  0030b	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  0030e	6a 00		 push	 0
  00310	50		 push	 eax
  00311	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00316	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  0031b	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00320	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00323	6a 63		 push	 99			; 00000063H
  00325	50		 push	 eax
  00326	e8 00 00 00 00	 call	 __snprintf
  0032b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0032e	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00331	50		 push	 eax
  00332	6a 00		 push	 0
  00334	6a 00		 push	 0
  00336	ff d3		 call	 ebx
  00338	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  0033a	6a ff		 push	 -1
  0033c	57		 push	 edi
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00343	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00349	57		 push	 edi
  0034a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  00350	57		 push	 edi
  00351	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 2943 :     }
; 2944 : 
; 2945 :     /* Printers Information */
; 2946 :     if (_thGetInt(&gbShutdown) == FALSE)

  00357	85 f6		 test	 esi, esi
  00359	0f 85 99 00 00
	00		 jne	 $LN332@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0035f	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  00361	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00364	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]

; 1785 : 		_Myres(0)

  0036a	89 75 88	 mov	 DWORD PTR $T2[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0036d	68 00 00 00 00	 push	 OFFSET ??_C@_07LBBDPBFA@PtrInfo@

; 3976 : 		_My_data._Mysize = 0;

  00372	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00375	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0037c	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00383	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2948 :         StartThread("PtrInfo", PrinterInfo, NULL, MINUTE);

  00388	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0038f	ba 00 00 00 00	 mov	 edx, OFFSET ?PrinterInfo@@YGIPAX@Z ; PrinterInfo
  00394	56		 push	 esi
  00395	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0039a	56		 push	 esi
  0039b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003a1	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  003a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003b0	8b 55 88	 mov	 edx, DWORD PTR $T2[ebp+20]
  003b3	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  003b6	72 2b		 jb	 SHORT $LN330@GetSystemS
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b8	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  003be	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003bf	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  003c1	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  003c7	72 10		 jb	 SHORT $LN329@GetSystemS

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  003c9	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  003cc	83 c2 23	 add	 edx, 35			; 00000023H
  003cf	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003d1	83 c0 fc	 add	 eax, -4			; fffffffcH
  003d4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003d7	77 4a		 ja	 SHORT $LN350@GetSystemS
$LN329@GetSystemS:

; 207  : 	::operator delete(_Ptr, _Bytes);

  003d9	52		 push	 edx
  003da	51		 push	 ecx
  003db	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003e0	83 c4 08	 add	 esp, 8
$LN330@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  003e3	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003ea	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  003f1	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
$LN332@GetSystemS:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2950 : }

  003f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00402	59		 pop	 ecx
  00403	5f		 pop	 edi
  00404	5e		 pop	 esi
  00405	5b		 pop	 ebx
  00406	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00409	33 cd		 xor	 ecx, ebp
  0040b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00410	8b e5		 mov	 esp, ebp
  00412	5d		 pop	 ebp
  00413	c3		 ret	 0
$LN347@GetSystemS:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00414	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN348@GetSystemS:
  00419	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN349@GetSystemS:
  0041e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN350@GetSystemS:
  00423	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN345@GetSystemS:
  00428	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$1:
  0000b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$2:
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetSystemStatusChanges@@YAXXZ$3:
  00021	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetSystemStatusChanges@@YAXXZ:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSystemStatusChanges@@YAXXZ
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSystemStatusChanges@@YAXXZ ENDP			; GetSystemStatusChanges
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
?ThreadWMISystemPerformance@@YGIPAX@Z PROC		; ThreadWMISystemPerformance

; 2957 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 2958 :     Log(LOG_DEBUG, __LINE__, ">> ThrdWMISysPerf (%p)", lpData);

  00006	ff 75 08	 push	 DWORD PTR _lpData$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HFGKIIBM@?$DO?$DO?5ThrdWMISysPerf?5?$CI?$CFp?$CJ@
  0000e	68 8e 0b 00 00	 push	 2958			; 00000b8eH
  00013	6a 10		 push	 16			; 00000010H
  00015	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 1050 :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMISysPerf");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JMIBPKNH@?$DO?$DO?5WMISysPerf@
  0001f	68 1a 04 00 00	 push	 1050			; 0000041aH
  00024	6a 40		 push	 64			; 00000040H
  00026	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0002b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1051 : 
; 1052 :     if (PerfRawData_PerfDisk_PhysicalDisk != 0)

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00035	74 14		 je	 SHORT $LN4@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00037	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfDisk_PhysicalDisk@?1??WMISystemPerformance@@YAXXZ@4KA
  0003c	33 d2		 xor	 edx, edx
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CI@FFMDGJKG@Win32_PerfRawData_PerfDisk_Phys@
  00043	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00048	83 c4 04	 add	 esp, 4
$LN4@ThreadWMIS:

; 1057 :     if (PerfRawData_PerfNet_Redirector != 0)

  0004b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00052	74 14		 je	 SHORT $LN5@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00054	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfNet_Redirector@?1??WMISystemPerformance@@YAXXZ@4KA
  00059	33 d2		 xor	 edx, edx
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CF@MIMNIAPF@Win32_PerfRawData_PerfNet_Redir@
  00060	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00065	83 c4 04	 add	 esp, 4
$LN5@ThreadWMIS:

; 1062 :     if (PerfRawData_PerfOS_Cache != 0)

  00068	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  0006f	74 14		 je	 SHORT $LN6@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00071	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Cache@?1??WMISystemPerformance@@YAXXZ@4KA
  00076	33 d2		 xor	 edx, edx
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BP@LHEMPHPB@Win32_PerfRawData_PerfOS_Cache@
  0007d	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00082	83 c4 04	 add	 esp, 4
$LN6@ThreadWMIS:

; 1067 :     if (PerfRawData_PerfOS_Memory != 0)

  00085	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  0008c	74 14		 je	 SHORT $LN7@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  0008e	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Memory@?1??WMISystemPerformance@@YAXXZ@4KA
  00093	33 d2		 xor	 edx, edx
  00095	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@MENAEGKE@Win32_PerfRawData_PerfOS_Memory@
  0009a	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0009f	83 c4 04	 add	 esp, 4
$LN7@ThreadWMIS:

; 1072 :     if (PerfRawData_PerfOS_Objects != 0)

  000a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000a9	74 14		 je	 SHORT $LN8@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  000ab	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Objects@?1??WMISystemPerformance@@YAXXZ@4KA
  000b0	33 d2		 xor	 edx, edx
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CB@OFCHCPMB@Win32_PerfRawData_PerfOS_Object@
  000b7	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000bc	83 c4 04	 add	 esp, 4
$LN8@ThreadWMIS:

; 1077 :     if (PerfRawData_PerfOS_PagingFile != 0)

  000bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000c6	74 14		 je	 SHORT $LN9@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  000c8	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_PagingFile@?1??WMISystemPerformance@@YAXXZ@4KA
  000cd	33 d2		 xor	 edx, edx
  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CE@MFJPDLKO@Win32_PerfRawData_PerfOS_Paging@
  000d4	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000d9	83 c4 04	 add	 esp, 4
$LN9@ThreadWMIS:

; 1082 :     if (PerfRawData_PerfOS_Processor != 0)

  000dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  000e3	74 14		 je	 SHORT $LN10@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  000e5	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_Processor@?1??WMISystemPerformance@@YAXXZ@4KA
  000ea	33 d2		 xor	 edx, edx
  000ec	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CD@BCJODFFP@Win32_PerfRawData_PerfOS_Proces@
  000f1	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  000f6	83 c4 04	 add	 esp, 4
$LN10@ThreadWMIS:

; 1087 :     if (PerfRawData_PerfOS_System != 0)

  000f9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA, 0
  00100	74 14		 je	 SHORT $LN11@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00102	68 00 00 00 00	 push	 OFFSET ?PerfRawData_PerfOS_System@?1??WMISystemPerformance@@YAXXZ@4KA
  00107	33 d2		 xor	 edx, edx
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0CA@OICKPIAK@Win32_PerfRawData_PerfOS_System@
  0010e	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00113	83 c4 04	 add	 esp, 4
$LN11@ThreadWMIS:

; 1092 :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMISysPerf");

  00116	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNLDILDB@?$DM?$DM?5WMISysPerf@
  0011b	68 44 04 00 00	 push	 1092			; 00000444H
  00120	6a 40		 push	 64			; 00000040H
  00122	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2962 :     Log(LOG_DEBUG, __LINE__, "<< ThrdWMISysPerf");

  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DBJGMMHB@?$DM?$DM?5ThrdWMISysPerf@
  0012f	68 92 0b 00 00	 push	 2962			; 00000b92H
  00134	6a 10		 push	 16			; 00000010H
  00136	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2963 :     _endthreadex(0);

  0013e	6a 00		 push	 0
  00140	e8 00 00 00 00	 call	 __endthreadex
  00145	83 c4 04	 add	 esp, 4

; 2964 :     return 0;

  00148	33 c0		 xor	 eax, eax

; 2965 : }

  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c2 04 00	 ret	 4
?ThreadWMISystemPerformance@@YGIPAX@Z ENDP		; ThreadWMISystemPerformance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
?ThreadWMIHardwareSensor@@YGIPAX@Z PROC			; ThreadWMIHardwareSensor

; 2969 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 2970 :     Log(LOG_DEBUG, __LINE__, ">> ThrdWMIHwSnsr (%p)", lpData);

  00006	ff 75 08	 push	 DWORD PTR _lpData$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GEAKCKEN@?$DO?$DO?5ThrdWMIHwSnsr?5?$CI?$CFp?$CJ@
  0000e	68 9a 0b 00 00	 push	 2970			; 00000b9aH
  00013	6a 10		 push	 16			; 00000010H
  00015	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 1105 :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMIHwSnsr");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LKGAGMLJ@?$DO?$DO?5WMIHwSnsr@
  0001f	68 51 04 00 00	 push	 1105			; 00000451H
  00024	6a 40		 push	 64			; 00000040H
  00026	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0002b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1106 : 
; 1107 :     if (CurrentProbe != 0)

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00035	74 14		 je	 SHORT $LN4@ThreadWMIH

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00037	68 00 00 00 00	 push	 OFFSET ?CurrentProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  0003c	33 d2		 xor	 edx, edx
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@ENAKGAAL@Win32_CurrentProbe@
  00043	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00048	83 c4 04	 add	 esp, 4
$LN4@ThreadWMIH:

; 1112 :     if (PortableBattery != 0)

  0004b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  00052	74 14		 je	 SHORT $LN5@ThreadWMIH

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00054	68 00 00 00 00	 push	 OFFSET ?PortableBattery@?1??WMIHardwareSensor@@YAXXZ@4KA
  00059	33 d2		 xor	 edx, edx
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BG@GEFEDJOA@Win32_PortableBattery@
  00060	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00065	83 c4 04	 add	 esp, 4
$LN5@ThreadWMIH:

; 1117 :     if (TemperatureProbe != 0)

  00068	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  0006f	74 14		 je	 SHORT $LN6@ThreadWMIH

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00071	68 00 00 00 00	 push	 OFFSET ?TemperatureProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  00076	33 d2		 xor	 edx, edx
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BH@HMHAIEPK@Win32_TemperatureProbe@
  0007d	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00082	83 c4 04	 add	 esp, 4
$LN6@ThreadWMIH:

; 1122 :     if (VoltageProbe != 0)

  00085	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA, 0
  0008c	74 14		 je	 SHORT $LN7@ThreadWMIH

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  0008e	68 00 00 00 00	 push	 OFFSET ?VoltageProbe@?1??WMIHardwareSensor@@YAXXZ@4KA
  00093	33 d2		 xor	 edx, edx
  00095	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BD@HAJJDCII@Win32_VoltageProbe@
  0009a	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0009f	83 c4 04	 add	 esp, 4
$LN7@ThreadWMIH:

; 1127 :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMIHwSnsr");

  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGAHEHGN@?$DM?$DM?5WMIHwSnsr@
  000a7	68 67 04 00 00	 push	 1127			; 00000467H
  000ac	6a 40		 push	 64			; 00000040H
  000ae	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2974 :     Log(LOG_DEBUG, __LINE__, "<< ThrdWMIHwSnsr");

  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MKNOIMND@?$DM?$DM?5ThrdWMIHwSnsr@
  000bb	68 9e 0b 00 00	 push	 2974			; 00000b9eH
  000c0	6a 10		 push	 16			; 00000010H
  000c2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2975 :     _endthreadex(0);

  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 __endthreadex
  000d1	83 c4 04	 add	 esp, 4

; 2976 :     return 0;

  000d4	33 c0		 xor	 eax, eax

; 2977 : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c2 04 00	 ret	 4
?ThreadWMIHardwareSensor@@YGIPAX@Z ENDP			; ThreadWMIHardwareSensor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
?ThreadWMISystemVolumes@@YGIPAX@Z PROC			; ThreadWMISystemVolumes

; 2981 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H

; 2982 :     Log(LOG_DEBUG, __LINE__, ">> ThrdWMISysVols (%p)", lpData);

  00006	ff 75 08	 push	 DWORD PTR _lpData$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LBINOCLF@?$DO?$DO?5ThrdWMISysVols?5?$CI?$CFp?$CJ@
  0000e	68 a6 0b 00 00	 push	 2982			; 00000ba6H
  00013	6a 10		 push	 16			; 00000010H
  00015	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\users\giulif\downloads\study\git\sysstatus\wmi.cpp

; 1002 :     Log(LOG_DEBUG_WMI, __LINE__, ">> WMISysVols");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@FNHBIHHN@?$DO?$DO?5WMISysVols@
  0001f	68 ea 03 00 00	 push	 1002			; 000003eaH
  00024	6a 40		 push	 64			; 00000040H
  00026	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0002b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  0002e	33 d2		 xor	 edx, edx
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BI@NLCFKEJK@Win32_NetworkConnection@
  00035	6a 00		 push	 0
  00037	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  0003c	83 c4 04	 add	 esp, 4

; 1013 :     if (Volume != 0)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA, 0
  00046	74 14		 je	 SHORT $LN4@ThreadWMIS

; 724  :     WMIex(lpszOption, NULL, lpulProperties);

  00048	68 00 00 00 00	 push	 OFFSET ?Volume@?1??WMISystemVolumes@@YAXXZ@4KA
  0004d	33 d2		 xor	 edx, edx
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0N@NNCPDPIH@Win32_Volume@
  00054	e8 00 00 00 00	 call	 ?WMIex@@YA_NPADPAVxmlwriter@@PAK@Z ; WMIex
  00059	83 c4 04	 add	 esp, 4
$LN4@ThreadWMIS:

; 1018 :     Log(LOG_DEBUG_WMI, __LINE__, "<< WMISysVols");

  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NMEDPGJL@?$DM?$DM?5WMISysVols@
  00061	68 fa 03 00 00	 push	 1018			; 000003faH
  00066	6a 40		 push	 64			; 00000040H
  00068	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 2986 :     Log(LOG_DEBUG, __LINE__, "<< ThrdWMISysVols");

  00070	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PAGGLBNL@?$DM?$DM?5ThrdWMISysVols@
  00075	68 aa 0b 00 00	 push	 2986			; 00000baaH
  0007a	6a 10		 push	 16			; 00000010H
  0007c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2987 :     _endthreadex(0);

  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 __endthreadex
  0008b	83 c4 04	 add	 esp, 4

; 2988 :     return 0;

  0008e	33 c0		 xor	 eax, eax

; 2989 : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?ThreadWMISystemVolumes@@YGIPAX@Z ENDP			; ThreadWMISystemVolumes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -140						; size = 24
$T3 = -140						; size = 24
$T4 = -140						; size = 24
_sMember$5 = -116					; size = 100
_sMember$6 = -116					; size = 100
_sMember$7 = -116					; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetWMIStatus@@YAXXZ PROC				; GetWMIStatus

; 3006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetWMIStatus@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 3007 :     Log(LOG_DEBUG, __LINE__, ">> GetWMISts");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LKBNMLDB@?$DO?$DO?5GetWMISts@
  00033	68 bf 0b 00 00	 push	 3007			; 00000bbfH
  00038	6a 10		 push	 16			; 00000010H
  0003a	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 73   :     char sMember[100] = { 0 };

  0003f	6a 64		 push	 100			; 00000064H
  00041	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00044	6a 00		 push	 0
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  0004c	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00056	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  00059	6a 63		 push	 99			; 00000063H
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __snprintf

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00061	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CreateMutexA@12
  00067	8d 45 8c	 lea	 eax, DWORD PTR _sMember$7[ebp]
  0006a	83 c4 28	 add	 esp, 40			; 00000028H
  0006d	50		 push	 eax
  0006e	6a 00		 push	 0
  00070	6a 00		 push	 0
  00072	ff d3		 call	 ebx
  00074	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00076	6a ff		 push	 -1
  00078	57		 push	 edi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0007f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00085	57		 push	 edi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0008c	57		 push	 edi
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3008 : 
; 3009 :     //get system performance
; 3010 :     if (_thGetInt(&gbShutdown) == FALSE)

  00093	85 f6		 test	 esi, esi
  00095	0f 85 99 00 00
	00		 jne	 $LN80@GetWMIStat
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009b	6a 0a		 push	 10			; 0000000aH

; 1784 : 		_Mysize(0),

  0009d	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a0	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]

; 1785 : 		_Myres(0)

  000a6	89 75 88	 mov	 DWORD PTR $T4[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@KDFOBJKP@WMISysPerf@

; 3976 : 		_My_data._Mysize = 0;

  000ae	89 75 84	 mov	 DWORD PTR $T4[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000b1	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000b8	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000bf	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3012 :         StartThread("WMISysPerf", ThreadWMISystemPerformance, NULL, MINUTE * 5);

  000c4	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  000c7	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMISystemPerformance@@YGIPAX@Z ; ThreadWMISystemPerformance
  000cc	56		 push	 esi
  000cd	68 e0 93 04 00	 push	 300000			; 000493e0H
  000d2	56		 push	 esi
  000d3	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000d9	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000e8	8b 55 88	 mov	 edx, DWORD PTR $T4[ebp+20]
  000eb	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000ee	72 2f		 jb	 SHORT $LN78@GetWMIStat
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f0	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000f6	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f7	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000f9	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000ff	72 14		 jb	 SHORT $LN77@GetWMIStat

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00101	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00104	83 c2 23	 add	 edx, 35			; 00000023H
  00107	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00109	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010f	0f 87 31 02 00
	00		 ja	 $LN262@GetWMIStat
$LN77@GetWMIStat:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00115	52		 push	 edx
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011c	83 c4 08	 add	 esp, 8
$LN78@GetWMIStat:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0011f	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T4[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00126	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T4[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0012d	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
$LN80@GetWMIStat:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00134	6a 64		 push	 100			; 00000064H
  00136	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  00139	6a 00		 push	 0
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00141	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00146	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0014b	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  0014e	6a 63		 push	 99			; 00000063H
  00150	50		 push	 eax
  00151	e8 00 00 00 00	 call	 __snprintf
  00156	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00159	8d 45 8c	 lea	 eax, DWORD PTR _sMember$6[ebp]
  0015c	50		 push	 eax
  0015d	6a 00		 push	 0
  0015f	6a 00		 push	 0
  00161	ff d3		 call	 ebx
  00163	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00165	6a ff		 push	 -1
  00167	57		 push	 edi
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0016e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00174	57		 push	 edi
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0017b	57		 push	 edi
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3013 :     }
; 3014 : 
; 3015 :     //get hardware sensor information
; 3016 :     if (_thGetInt(&gbShutdown) == FALSE)

  00182	85 f6		 test	 esi, esi
  00184	0f 85 9d 00 00
	00		 jne	 $LN164@GetWMIStat
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0018a	6a 09		 push	 9

; 1784 : 		_Mysize(0),

  0018c	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0018f	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]

; 1785 : 		_Myres(0)

  00195	89 75 88	 mov	 DWORD PTR $T3[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00198	68 00 00 00 00	 push	 OFFSET ??_C@_09NAIFMJBP@WMIHwSnsr@

; 3976 : 		_My_data._Mysize = 0;

  0019d	89 75 84	 mov	 DWORD PTR $T3[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001a0	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001a7	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001ae	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3018 :         StartThread("WMIHwSnsr", ThreadWMIHardwareSensor, NULL, MINUTE * 5);

  001b3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001ba	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMIHardwareSensor@@YGIPAX@Z ; ThreadWMIHardwareSensor
  001bf	56		 push	 esi
  001c0	68 e0 93 04 00	 push	 300000			; 000493e0H
  001c5	56		 push	 esi
  001c6	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001cc	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001db	8b 55 88	 mov	 edx, DWORD PTR $T3[ebp+20]
  001de	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  001e1	72 2f		 jb	 SHORT $LN162@GetWMIStat
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001e3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001e9	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001ea	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001ec	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  001f2	72 14		 jb	 SHORT $LN161@GetWMIStat

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001f4	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  001f7	83 c2 23	 add	 edx, 35			; 00000023H
  001fa	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001fc	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ff	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00202	0f 87 43 01 00
	00		 ja	 $LN263@GetWMIStat
$LN161@GetWMIStat:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00208	52		 push	 edx
  00209	51		 push	 ecx
  0020a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0020f	83 c4 08	 add	 esp, 8
$LN162@GetWMIStat:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00212	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00219	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00220	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN164@GetWMIStat:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 73   :     char sMember[100] = { 0 };

  00227	6a 64		 push	 100			; 00000064H
  00229	8d 45 8c	 lea	 eax, DWORD PTR _sMember$5[ebp]
  0022c	6a 00		 push	 0
  0022e	50		 push	 eax
  0022f	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00234	68 00 00 00 00	 push	 OFFSET ?gbShutdown@@3HA	; gbShutdown
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0023e	8d 45 8c	 lea	 eax, DWORD PTR _sMember$5[ebp]
  00241	6a 63		 push	 99			; 00000063H
  00243	50		 push	 eax
  00244	e8 00 00 00 00	 call	 __snprintf
  00249	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0024c	8d 45 8c	 lea	 eax, DWORD PTR _sMember$5[ebp]
  0024f	50		 push	 eax
  00250	6a 00		 push	 0
  00252	6a 00		 push	 0
  00254	ff d3		 call	 ebx
  00256	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00258	6a ff		 push	 -1
  0025a	57		 push	 edi
  0025b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00261	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbShutdown@@3HA ; gbShutdown

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00267	57		 push	 edi
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0026e	57		 push	 edi
  0026f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3019 :     }
; 3020 : 
; 3021 :     //get all system volume details
; 3022 :     if (_thGetInt(&gbShutdown) == FALSE)

  00275	85 f6		 test	 esi, esi
  00277	0f 85 99 00 00
	00		 jne	 $LN247@GetWMIStat
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0027d	6a 0a		 push	 10			; 0000000aH

; 1784 : 		_Mysize(0),

  0027f	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00282	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]

; 1785 : 		_Myres(0)

  00288	89 75 88	 mov	 DWORD PTR $T2[ebp+20], esi

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0028b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GCKOGEAF@WMISysVols@

; 3976 : 		_My_data._Mysize = 0;

  00290	89 75 84	 mov	 DWORD PTR $T2[ebp+16], esi

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00293	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0029a	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  002a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3024 :         StartThread("WMISysVols", ThreadWMISystemVolumes, NULL, MINUTE * 5);

  002a6	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002ad	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMISystemVolumes@@YGIPAX@Z ; ThreadWMISystemVolumes
  002b2	56		 push	 esi
  002b3	68 e0 93 04 00	 push	 300000			; 000493e0H
  002b8	56		 push	 esi
  002b9	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  002bf	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  002c4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  002ce	8b 55 88	 mov	 edx, DWORD PTR $T2[ebp+20]
  002d1	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  002d4	72 2b		 jb	 SHORT $LN245@GetWMIStat
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002d6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002dc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002dd	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  002df	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  002e5	72 10		 jb	 SHORT $LN244@GetWMIStat

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  002e7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  002ea	83 c2 23	 add	 edx, 35			; 00000023H
  002ed	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002ef	83 c0 fc	 add	 eax, -4			; fffffffcH
  002f2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002f5	77 59		 ja	 SHORT $LN264@GetWMIStat
$LN244@GetWMIStat:

; 207  : 	::operator delete(_Ptr, _Bytes);

  002f7	52		 push	 edx
  002f8	51		 push	 ecx
  002f9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002fe	83 c4 08	 add	 esp, 8
$LN245@GetWMIStat:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00301	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00308	c7 45 88 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0030f	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
$LN247@GetWMIStat:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3034 :     Log(LOG_DEBUG, __LINE__, "<< GetWMISts");

  00316	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DGHKOAOF@?$DM?$DM?5GetWMISts@
  0031b	68 da 0b 00 00	 push	 3034			; 00000bdaH
  00320	6a 10		 push	 16			; 00000010H
  00322	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00327	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3035 : }

  0032a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0032d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00334	59		 pop	 ecx
  00335	5f		 pop	 edi
  00336	5e		 pop	 esi
  00337	5b		 pop	 ebx
  00338	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033b	33 cd		 xor	 ecx, ebp
  0033d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00342	8b e5		 mov	 esp, ebp
  00344	5d		 pop	 ebp
  00345	c3		 ret	 0
$LN262@GetWMIStat:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00346	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN263@GetWMIStat:
  0034b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN264@GetWMIStat:
  00350	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN260@GetWMIStat:
  00355	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetWMIStatus@@YAXXZ$0:
  00000	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetWMIStatus@@YAXXZ$1:
  0000b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?GetWMIStatus@@YAXXZ$2:
  00016	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?GetWMIStatus@@YAXXZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetWMIStatus@@YAXXZ
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetWMIStatus@@YAXXZ ENDP				; GetWMIStatus
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_processToken$ = -60					; size = 4
_token$ = -56						; size = 16
$T2 = -40						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ModifyPrivilege@@YA_NPBD_N@Z PROC			; ModifyPrivilege
; _privilegeName$dead$ = ecx
; _enable$ = dl

; 3038 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ModifyPrivilege@@YA_NPBD_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	8a da		 mov	 bl, dl

; 3039 :     Log(LOG_DEBUG, __LINE__, ">> ModifyPrivilege: %s '%s'", (enable ? "Enable" : "Disable"), privilegeName);

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@COMAOBFG@SeSecurityPrivilege@
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07MIKIFGAL@Disable@
  00035	84 db		 test	 bl, bl
  00037	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06CKGENIKG@Enable@
  0003c	0f 44 c1	 cmove	 eax, ecx
  0003f	50		 push	 eax
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PMAFNLMJ@?$DO?$DO?5ModifyPrivilege?3?5?$CFs?5?8?$CFs?8@
  00045	68 df 0b 00 00	 push	 3039			; 00000bdfH
  0004a	6a 10		 push	 16			; 00000010H
  0004c	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00051	83 c4 14	 add	 esp, 20			; 00000014H

; 3040 : 
; 3041 :     HANDLE processToken = nullptr;

  00054	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _processToken$[ebp], 0

; 3042 :     if (!::OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &processToken))

  0005b	8d 45 c4	 lea	 eax, DWORD PTR _processToken$[ebp]
  0005e	50		 push	 eax
  0005f	6a 28		 push	 40			; 00000028H
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00067	50		 push	 eax
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcessToken@12
  0006e	85 c0		 test	 eax, eax
  00070	0f 85 88 00 00
	00		 jne	 $LN2@ModifyPriv

; 3044 :         Log(LOG_DEBUG, __LINE__, "<< ModifyPrivilege, OpenProcessToken %s", GetLastErrorMessage(GetLastError()).c_str());

  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0007c	8b d0		 mov	 edx, eax
  0007e	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00081	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0008d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00091	72 02		 jb	 SHORT $LN14@ModifyPriv
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00093	8b 00		 mov	 eax, DWORD PTR [eax]
$LN14@ModifyPriv:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3044 :         Log(LOG_DEBUG, __LINE__, "<< ModifyPrivilege, OpenProcessToken %s", GetLastErrorMessage(GetLastError()).c_str());

  00095	50		 push	 eax
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@FBLPGCLK@?$DM?$DM?5ModifyPrivilege?0?5OpenProcess@
  0009b	68 e4 0b 00 00	 push	 3044			; 00000be4H
  000a0	6a 10		 push	 16			; 00000010H
  000a2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  000a7	83 c4 10	 add	 esp, 16			; 00000010H
  000aa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000b1	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp+20]
  000b4	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  000b7	72 2c		 jb	 SHORT $LN62@ModifyPriv
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b9	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000bc	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bd	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000bf	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000c5	72 14		 jb	 SHORT $LN61@ModifyPriv

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000c7	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  000ca	83 c2 23	 add	 edx, 35			; 00000023H
  000cd	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cf	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d5	0f 87 2b 01 00
	00		 ja	 $LN149@ModifyPriv
$LN61@ModifyPriv:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000db	52		 push	 edx
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e2	83 c4 08	 add	 esp, 8
$LN62@ModifyPriv:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  000e5	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3045 :         return false;

  000ec	32 c0		 xor	 al, al
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000ee	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000f5	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3045 :         return false;

  000f9	e9 ee 00 00 00	 jmp	 $LN1@ModifyPriv
$LN2@ModifyPriv:

; 3046 :     }
; 3047 : 
; 3048 :     TOKEN_PRIVILEGES token{};
; 3049 :     token.PrivilegeCount = 1;
; 3050 :     token.Privileges[0].Attributes = (enable ? SE_PRIVILEGE_ENABLED : 0);

  000fe	0f b6 c3	 movzx	 eax, bl
  00101	0f 57 c0	 xorps	 xmm0, xmm0
  00104	03 c0		 add	 eax, eax
  00106	66 0f 13 45 cc	 movlpd	 QWORD PTR _token$[ebp+4], xmm0
  0010b	89 45 d4	 mov	 DWORD PTR _token$[ebp+12], eax

; 3051 :     ::LookupPrivilegeValue(NULL, privilegeName, &token.Privileges[0].Luid);

  0010e	8d 45 cc	 lea	 eax, DWORD PTR _token$[ebp+4]
  00111	50		 push	 eax
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@COMAOBFG@SeSecurityPrivilege@
  00117	6a 00		 push	 0
  00119	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _token$[ebp], 1
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LookupPrivilegeValueA@12

; 3052 : 
; 3053 :     if (!::AdjustTokenPrivileges(processToken, FALSE, &token, 0, nullptr, 0))

  00126	6a 00		 push	 0
  00128	6a 00		 push	 0
  0012a	6a 00		 push	 0
  0012c	8d 45 c8	 lea	 eax, DWORD PTR _token$[ebp]
  0012f	50		 push	 eax
  00130	6a 00		 push	 0
  00132	ff 75 c4	 push	 DWORD PTR _processToken$[ebp]
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__AdjustTokenPrivileges@24
  0013b	85 c0		 test	 eax, eax
  0013d	0f 85 8a 00 00
	00		 jne	 $LN3@ModifyPriv

; 3055 :         Log(LOG_DEBUG, __LINE__, "<< ModifyPrivilege, AdjustTokenPrivileges %s", GetLastErrorMessage(GetLastError()).c_str());

  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00149	8b d0		 mov	 edx, eax
  0014b	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0014e	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00153	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0015a	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0015e	72 02		 jb	 SHORT $LN84@ModifyPriv
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00160	8b 00		 mov	 eax, DWORD PTR [eax]
$LN84@ModifyPriv:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3055 :         Log(LOG_DEBUG, __LINE__, "<< ModifyPrivilege, AdjustTokenPrivileges %s", GetLastErrorMessage(GetLastError()).c_str());

  00162	50		 push	 eax
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CCHLMIMA@?$DM?$DM?5ModifyPrivilege?0?5AdjustToken@
  00168	68 ef 0b 00 00	 push	 3055			; 00000befH
  0016d	6a 10		 push	 16			; 00000010H
  0016f	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00174	83 c4 10	 add	 esp, 16			; 00000010H
  00177	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0017e	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp+20]
  00181	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  00184	72 28		 jb	 SHORT $LN132@ModifyPriv
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00186	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00189	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0018a	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0018c	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00192	72 10		 jb	 SHORT $LN131@ModifyPriv

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00194	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00197	83 c2 23	 add	 edx, 35			; 00000023H
  0019a	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0019c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0019f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001a2	77 67		 ja	 SHORT $LN150@ModifyPriv
$LN131@ModifyPriv:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001a4	52		 push	 edx
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ab	83 c4 08	 add	 esp, 8
$LN132@ModifyPriv:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3056 :         CloseHandle(processToken);

  001ae	ff 75 c4	 push	 DWORD PTR _processToken$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  001b1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001b8	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T2[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001bf	c6 45 d8 00	 mov	 BYTE PTR $T2[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3056 :         CloseHandle(processToken);

  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3057 :         return false;

  001c9	32 c0		 xor	 al, al
  001cb	eb 1f		 jmp	 SHORT $LN1@ModifyPriv
$LN3@ModifyPriv:

; 3058 :     }
; 3059 : 
; 3060 :     CloseHandle(processToken);

  001cd	ff 75 c4	 push	 DWORD PTR _processToken$[ebp]
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3061 :     Log(LOG_DEBUG, __LINE__, "<< ModifyPrivilege");

  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@NDFMDBME@?$DM?$DM?5ModifyPrivilege@
  001db	68 f5 0b 00 00	 push	 3061			; 00000bf5H
  001e0	6a 10		 push	 16			; 00000010H
  001e2	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3062 :     return true;

  001ea	b0 01		 mov	 al, 1
$LN1@ModifyPriv:

; 3063 : }

  001ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f6	59		 pop	 ecx
  001f7	5b		 pop	 ebx
  001f8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	33 cd		 xor	 ecx, ebp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c3		 ret	 0
$LN149@ModifyPriv:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00206	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN150@ModifyPriv:
  0020b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN147@ModifyPriv:
  00210	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ModifyPrivilege@@YA_NPBD_N@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?ModifyPrivilege@@YA_NPBD_N@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ModifyPrivilege@@YA_NPBD_N@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ModifyPrivilege@@YA_NPBD_N@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ModifyPrivilege@@YA_NPBD_N@Z ENDP			; ModifyPrivilege
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
$T2 = -268						; size = 12
$T3 = -256						; size = 12
$T4 = -244						; size = 12
$T5 = -232						; size = 12
$T6 = -220						; size = 12
_explicitAccess$7 = -208				; size = 32
_ex$8 = -176						; size = 4
_sidBuffer$9 = -172					; size = 12
__Bytes$10 = -160					; size = 4
_sidSize$11 = -156					; size = 4
_securityDescriptor$12 = -152				; size = 4
_currentDacl$13 = -148					; size = 4
_newDacl$14 = -144					; size = 4
$T15 = -140						; size = 24
$T16 = -116						; size = 24
$T17 = -92						; size = 24
$T18 = -68						; size = 24
$T19 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?AdjustProcessRights@@YAXXZ PROC			; AdjustProcessRights

; 3066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AdjustProcessRights@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 3067 :     Log(LOG_DEBUG, __LINE__, ">> AdjtProcRights");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CGDDBBID@?$DO?$DO?5AdjtProcRights@
  00036	68 fb 0b 00 00	 push	 3067			; 00000bfbH
  0003b	6a 10		 push	 16			; 00000010H
  0003d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3068 : 
; 3069 :     // Before adjusting any rights, we need to ensure we have the correct privileges required
; 3070 :     if (ModifyPrivilege(SE_SECURITY_NAME, true))

  00045	b2 01		 mov	 dl, 1
  00047	e8 00 00 00 00	 call	 ?ModifyPrivilege@@YA_NPBD_N@Z ; ModifyPrivilege
  0004c	84 c0		 test	 al, al
  0004e	0f 84 c7 01 00
	00		 je	 $LN2@AdjustProc

; 3071 :     {
; 3072 :         PACL currentDacl = nullptr;

  00054	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _currentDacl$13[ebp], 0

; 3073 :         PACL newDacl = nullptr;

  0005e	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _newDacl$14[ebp], 0

; 3074 :         PSECURITY_DESCRIPTOR securityDescriptor = nullptr;

  00068	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _securityDescriptor$12[ebp], 0

; 3075 : 
; 3076 :         try

  00072	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3077 :         {
; 3078 :             // Adjust the DACL of our process to allow any other process to synchronize on our handle (including DbdDevApi)
; 3079 :             HANDLE processHandle = ::OpenProcess(ACCESS_SYSTEM_SECURITY | WRITE_DAC, FALSE, GetCurrentProcessId());

  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  0007f	50		 push	 eax
  00080	6a 00		 push	 0
  00082	68 00 00 04 01	 push	 17039360		; 01040000H
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenProcess@12
  0008d	8b f8		 mov	 edi, eax

; 3080 :             if (!processHandle)

  0008f	85 ff		 test	 edi, edi
  00091	0f 84 f2 01 00
	00		 je	 $LN437@AdjustProc

; 3083 :             }
; 3084 : 
; 3085 :             // Get the current DACL of the process
; 3086 :             DWORD rc = ::GetSecurityInfo(processHandle, SE_KERNEL_OBJECT, SACL_SECURITY_INFORMATION, nullptr, nullptr, &currentDacl, nullptr, &securityDescriptor);

  00097	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _securityDescriptor$12[ebp]
  0009d	50		 push	 eax
  0009e	6a 00		 push	 0
  000a0	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _currentDacl$13[ebp]
  000a6	50		 push	 eax
  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	6a 08		 push	 8
  000ad	6a 06		 push	 6
  000af	57		 push	 edi
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSecurityInfo@32

; 3087 :             if (rc != ERROR_SUCCESS)

  000b6	85 c0		 test	 eax, eax
  000b8	0f 85 fc 01 00
	00		 jne	 $LN438@AdjustProc

; 3092 :             }
; 3093 : 
; 3094 :             // Ensure that 'Everyone' has the synchronize permission.  Use the SID instead of the name to support localization
; 3095 :             DWORD sidSize = SECURITY_MAX_SID_SIZE;

  000be	c7 85 64 ff ff
	ff 44 00 00 00	 mov	 DWORD PTR _sidSize$11[ebp], 68 ; 00000044H

; 3096 :             std::vector<unsigned char> sidBuffer(sidSize);

  000c8	51		 push	 ecx
  000c9	6a 44		 push	 68			; 00000044H
  000cb	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _sidBuffer$9[ebp]
  000d1	e8 00 00 00 00	 call	 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  000d6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 3097 :             if (!::CreateWellKnownSid(WinWorldSid, nullptr, sidBuffer.data(), &sidSize))

  000da	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _sidSize$11[ebp]
  000e0	50		 push	 eax
  000e1	8b b5 54 ff ff
	ff		 mov	 esi, DWORD PTR _sidBuffer$9[ebp]
  000e7	56		 push	 esi
  000e8	6a 00		 push	 0
  000ea	6a 01		 push	 1
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWellKnownSid@16
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 fa 01 00
	00		 je	 $LN439@AdjustProc
  000fa	0f 57 c0	 xorps	 xmm0, xmm0

; 3102 :             }
; 3103 : 
; 3104 :             // Create the structure that defines the required permission
; 3105 :             EXPLICIT_ACCESS explicitAccess = { 0 };

  000fd	0f 11 85 30 ff
	ff ff		 movups	 XMMWORD PTR _explicitAccess$7[ebp], xmm0
  00104	0f 11 85 40 ff
	ff ff		 movups	 XMMWORD PTR _explicitAccess$7[ebp+16], xmm0

; 3106 :             explicitAccess.grfAccessMode = GRANT_ACCESS;

  0010b	c7 85 34 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _explicitAccess$7[ebp+4], 1

; 3107 :             explicitAccess.grfAccessPermissions = SYNCHRONIZE;

  00115	c7 85 30 ff ff
	ff 00 00 10 00	 mov	 DWORD PTR _explicitAccess$7[ebp], 1048576 ; 00100000H

; 3108 :             explicitAccess.grfInheritance = NO_INHERITANCE;

  0011f	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _explicitAccess$7[ebp+8], 0

; 3109 :             ::BuildTrusteeWithSid(&explicitAccess.Trustee, sidBuffer.data());

  00129	56		 push	 esi
  0012a	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _explicitAccess$7[ebp+12]
  00130	50		 push	 eax
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BuildTrusteeWithSidA@8

; 3110 : 
; 3111 :             // Add the synchronize permission to the current DACL
; 3112 :             rc = ::SetEntriesInAcl(1, &explicitAccess, currentDacl, &newDacl);

  00137	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _newDacl$14[ebp]
  0013d	50		 push	 eax
  0013e	ff b5 6c ff ff
	ff		 push	 DWORD PTR _currentDacl$13[ebp]
  00144	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _explicitAccess$7[ebp]
  0014a	50		 push	 eax
  0014b	6a 01		 push	 1
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEntriesInAclA@16

; 3113 :             if (rc != ERROR_SUCCESS)

  00153	85 c0		 test	 eax, eax
  00155	0f 85 d3 01 00
	00		 jne	 $LN440@AdjustProc

; 3118 :             }
; 3119 : 
; 3120 :             // Update our process handle with the new DACL
; 3121 :             rc = ::SetSecurityInfo(processHandle, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION, nullptr, nullptr, newDacl, nullptr);

  0015b	50		 push	 eax
  0015c	ff b5 70 ff ff
	ff		 push	 DWORD PTR _newDacl$14[ebp]
  00162	50		 push	 eax
  00163	50		 push	 eax
  00164	6a 04		 push	 4
  00166	6a 06		 push	 6
  00168	57		 push	 edi
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetSecurityInfo@28

; 3122 :             if (rc != ERROR_SUCCESS)

  0016f	85 c0		 test	 eax, eax
  00171	0f 85 f1 01 00
	00		 jne	 $LN441@AdjustProc

; 3127 :             }
; 3128 : 
; 3129 :             Log(LOG_DEBUG, __LINE__, "-- AdjtProcRights, Successfully adjusted the process rights.");

  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CNCGHAJP@?9?9?5AdjtProcRights?0?5Successfully@
  0017c	68 39 0c 00 00	 push	 3129			; 00000c39H
  00181	6a 10		 push	 16			; 00000010H
  00183	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00188	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3130 :         }

  0018b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0018f	85 f6		 test	 esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  00191	74 5a		 je	 SHORT $LN23@AdjustProc

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00193	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _sidBuffer$9[ebp+8]
  00199	2b ce		 sub	 ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR __Bytes$10[ebp], ecx
  001a1	8b c6		 mov	 eax, esi

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  001a3	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001a9	72 1a		 jb	 SHORT $LN406@AdjustProc

; 115  : 	_Bytes += _Non_user_size;

  001ab	83 c1 23	 add	 ecx, 35			; 00000023H
  001ae	89 8d 60 ff ff
	ff		 mov	 DWORD PTR __Bytes$10[ebp], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  001b4	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]
  001b7	2b c6		 sub	 eax, esi

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b9	83 c0 fc	 add	 eax, -4			; fffffffcH
  001bc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001bf	0f 87 e0 01 00
	00		 ja	 $LN442@AdjustProc
$LN406@AdjustProc:

; 207  : 	::operator delete(_Ptr, _Bytes);

  001c5	51		 push	 ecx
  001c6	56		 push	 esi
  001c7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001cc	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  001cf	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _sidBuffer$9[ebp], 0

; 1919 : 			this->_Mylast() = pointer();

  001d9	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _sidBuffer$9[ebp+4], 0

; 1920 : 			this->_Myend() = pointer();

  001e3	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _sidBuffer$9[ebp+8], 0
$LN23@AdjustProc:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3137 :         if (securityDescriptor)

  001ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001f4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _securityDescriptor$12[ebp]
  001fa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LocalFree@4
  00200	85 c0		 test	 eax, eax
  00202	74 03		 je	 SHORT $LN9@AdjustProc

; 3138 :             ::LocalFree(securityDescriptor);

  00204	50		 push	 eax
  00205	ff d6		 call	 esi
$LN9@AdjustProc:

; 3139 : 
; 3140 :         if (newDacl)

  00207	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _newDacl$14[ebp]
  0020d	85 c0		 test	 eax, eax
  0020f	74 03		 je	 SHORT $LN10@AdjustProc

; 3141 :             ::LocalFree(newDacl);

  00211	50		 push	 eax
  00212	ff d6		 call	 esi
$LN10@AdjustProc:

; 3142 : 
; 3143 :         // Remove the privilege as it is no longer required
; 3144 :         ModifyPrivilege(SE_SECURITY_NAME, false);

  00214	32 d2		 xor	 dl, dl
  00216	e8 00 00 00 00	 call	 ?ModifyPrivilege@@YA_NPBD_N@Z ; ModifyPrivilege
$LN2@AdjustProc:

; 3145 :     }
; 3146 :     Log(LOG_DEBUG, __LINE__, "<< AdjtProcRights");

  0021b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PHNLOKMH@?$DM?$DM?5AdjtProcRights@
  00220	68 4a 0c 00 00	 push	 3146			; 00000c4aH
  00225	6a 10		 push	 16			; 00000010H
  00227	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3147 : }

  0022f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00232	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00239	59		 pop	 ecx
  0023a	5f		 pop	 edi
  0023b	5e		 pop	 esi
  0023c	5b		 pop	 ebx
  0023d	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
__catch$?AdjustProcessRights@@YAXXZ$0:

; 3131 :         catch (const std::runtime_error& ex)
; 3132 :         {

  0024b	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _ex$8[ebp]
  00251	8b 01		 mov	 eax, DWORD PTR [ecx]
  00253	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00256	3d 00 00 00 00	 cmp	 eax, OFFSET ??_7runtime_error@std@@6B@
  0025b	0f 85 49 01 00
	00		 jne	 $LN13@AdjustProc
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vcruntime_exception.h

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

  00261	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00264	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00269	85 c0		 test	 eax, eax
  0026b	0f 45 c8	 cmovne	 ecx, eax
$LN12@AdjustProc:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3133 :             Log(LOG_DEBUG, __LINE__, "-- AdjtProcRights, %s", ex.what());

  0026e	51		 push	 ecx
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PKIMIEFE@?9?9?5AdjtProcRights?0?5?$CFs@
  00274	68 3d 0c 00 00	 push	 3133			; 00000c3dH
  00279	6a 10		 push	 16			; 00000010H
  0027b	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00280	83 c4 10	 add	 esp, 16			; 00000010H

; 3134 :         }

  00283	b8 00 00 00 00	 mov	 eax, $LN23@AdjustProc
  00288	c3		 ret	 0
$LN437@AdjustProc:

; 3081 :             {
; 3082 :                 throw std::runtime_error(GetLastErrorMessage(GetLastError()));

  00289	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0028f	8b d0		 mov	 edx, eax
  00291	8d 4d d4	 lea	 ecx, DWORD PTR $T19[ebp]
  00294	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00299	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0029d	50		 push	 eax
  0029e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  002a4	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  002a9	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  002ae	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN438@AdjustProc:

; 3088 :             {
; 3089 :                 DWORD const dwLastError = GetLastError();

  002ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002c0	8b f0		 mov	 esi, eax

; 3090 :                 CloseHandle(processHandle);

  002c2	57		 push	 edi
  002c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3091 :                 throw std::runtime_error(GetLastErrorMessage(dwLastError));

  002c9	8b d6		 mov	 edx, esi
  002cb	8d 4d bc	 lea	 ecx, DWORD PTR $T18[ebp]
  002ce	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  002d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  002d7	50		 push	 eax
  002d8	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002de	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  002e3	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  002e8	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN439@AdjustProc:

; 3098 :             {
; 3099 :                 DWORD const dwLastError = GetLastError();

  002f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002fa	8b f0		 mov	 esi, eax

; 3100 :                 CloseHandle(processHandle);

  002fc	57		 push	 edi
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3101 :                 throw std::runtime_error(GetLastErrorMessage(dwLastError));

  00303	8b d6		 mov	 edx, esi
  00305	8d 4d a4	 lea	 ecx, DWORD PTR $T17[ebp]
  00308	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  0030d	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  00311	50		 push	 eax
  00312	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00318	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  0031d	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  00322	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00328	50		 push	 eax
  00329	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN440@AdjustProc:

; 3114 :             {
; 3115 :                 DWORD const dwLastError = GetLastError();

  0032e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00334	8b f0		 mov	 esi, eax

; 3116 :                 CloseHandle(processHandle);

  00336	57		 push	 edi
  00337	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3117 :                 throw std::runtime_error(GetLastErrorMessage(dwLastError));

  0033d	8b d6		 mov	 edx, esi
  0033f	8d 4d 8c	 lea	 ecx, DWORD PTR $T16[ebp]
  00342	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00347	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
  0034b	50		 push	 eax
  0034c	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00352	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  00357	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  0035c	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00362	50		 push	 eax
  00363	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN441@AdjustProc:

; 3123 :             {
; 3124 :                 DWORD const dwLastError = GetLastError();

  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0036e	8b f0		 mov	 esi, eax

; 3125 :                 CloseHandle(processHandle);

  00370	57		 push	 edi
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3126 :                 throw std::runtime_error(GetLastErrorMessage(dwLastError));

  00377	8b d6		 mov	 edx, esi
  00379	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0037f	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00384	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  00388	50		 push	 eax
  00389	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0038f	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  00394	68 00 00 00 00	 push	 OFFSET __TI2?AVruntime_error@std@@
  00399	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0039f	50		 push	 eax
  003a0	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN442@AdjustProc:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003a5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN13@AdjustProc:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3133 :             Log(LOG_DEBUG, __LINE__, "-- AdjtProcRights, %s", ex.what());

  003aa	ff d2		 call	 edx
  003ac	8b c8		 mov	 ecx, eax
  003ae	e9 bb fe ff ff	 jmp	 $LN12@AdjustProc
$LN435@AdjustProc:
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AdjustProcessRights@@YAXXZ$4:
  00000	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _sidBuffer$9[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$?AdjustProcessRights@@YAXXZ$2:
  0000b	8d 4d d4	 lea	 ecx, DWORD PTR $T19[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?AdjustProcessRights@@YAXXZ$3:
  00013	8d 4d bc	 lea	 ecx, DWORD PTR $T18[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?AdjustProcessRights@@YAXXZ$5:
  0001b	8d 4d a4	 lea	 ecx, DWORD PTR $T17[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?AdjustProcessRights@@YAXXZ$6:
  00023	8d 4d 8c	 lea	 ecx, DWORD PTR $T16[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?AdjustProcessRights@@YAXXZ$7:
  0002b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?AdjustProcessRights@@YAXXZ:
  00036	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003d	8b 8a f0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-272]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AdjustProcessRights@@YAXXZ
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AdjustProcessRights@@YAXXZ ENDP			; AdjustProcessRights
; Function compile flags: /Ogtp
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp
_TEXT	SEGMENT
_timeElapsed$1$ = -824					; size = 8
$T2 = -816						; size = 4
$T3 = -812						; size = 4
_monIps$ = -808						; size = 44
_dwNetType$ = -764					; size = 4
__Freq$1$ = -760					; size = 4
_pPreviousExceptionFilter$1$ = -760			; size = 4
_hThreadMSG$ = -756					; size = 4
_dwTimer$1$ = -752					; size = 4
_seconds$1$ = -748					; size = 4
__Whole$2$ = -748					; size = 4
_ui64Wait$ = -744					; size = 8
_ui64Wait$1$ = -740					; size = 4
__Freq$2$ = -740					; size = 4
tv1342 = -740						; size = 4
__Freq$2$ = -736					; size = 4
tv1344 = -736						; size = 4
_bytesWritten$4 = -736					; size = 4
tv151 = -736						; size = 4
_hThreadWMI$ = -732					; size = 4
__end_$2$ = -728					; size = 4
__Freq$1$ = -728					; size = 4
_dwLogSize$1$ = -728					; size = 4
_seconds$2$ = -724					; size = 4
tv1008 = -724						; size = 4
_ui64Wait$2$ = -720					; size = 4
__Whole$1$ = -720					; size = 4
tv1341 = -720						; size = 4
_ret$1$ = -713						; size = 1
__end_$1$ = -712					; size = 4
_lpCmdLine$GSCopy$1$ = -712				; size = 4
tv1404 = -712						; size = 4
tv1400 = -712						; size = 4
tv1343 = -712						; size = 4
_bMonIps$1$ = -705					; size = 1
_bShowWindow$ = -704					; size = 1
_bRunOnce$1$ = -703					; size = 1
_bRunWMI$1$ = -702					; size = 1
_bWMIThreadRunning$1$ = -701				; size = 1
$T5 = -700						; size = 24
$T6 = -700						; size = 24
$T7 = -700						; size = 24
_wndText$ = -676					; size = 260
_sMember$8 = -416					; size = 100
_sMember$9 = -316					; size = 100
_sMember$10 = -216					; size = 100
_sMember$11 = -116					; size = 100
_jump$12 = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nShowCmd$ = 20						; size = 4
_WinMain@16 PROC

; 3153 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_WinMain@16
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 2c 03 00
	00		 sub	 esp, 812		; 0000032cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b 45 10	 mov	 eax, DWORD PTR _lpCmdLine$[ebp]
  00031	89 85 38 fd ff
	ff		 mov	 DWORD PTR _lpCmdLine$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono

; 800  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

  00037	e8 00 00 00 00	 call	 __Query_perf_frequency
  0003c	8b f8		 mov	 edi, eax
  0003e	8b f2		 mov	 esi, edx
  00040	89 bd 1c fd ff
	ff		 mov	 DWORD PTR __Freq$2$[ebp], edi
  00046	89 b5 28 fd ff
	ff		 mov	 DWORD PTR __Freq$1$[ebp], esi

; 801  : 		const long long _Ctr = _Query_perf_counter();

  0004c	e8 00 00 00 00	 call	 __Query_perf_counter

; 802  : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 803  : 		const long long _Whole = (_Ctr / _Freq) * period::den;

  00051	53		 push	 ebx
  00052	56		 push	 esi
  00053	57		 push	 edi
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 __alldvrm
  0005b	8b fb		 mov	 edi, ebx
  0005d	5b		 pop	 ebx
  0005e	6a 00		 push	 0
  00060	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00065	52		 push	 edx
  00066	50		 push	 eax
  00067	8b f1		 mov	 esi, ecx
  00069	e8 00 00 00 00	 call	 __allmul

; 804  : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

  0006e	6a 00		 push	 0
  00070	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00075	57		 push	 edi
  00076	56		 push	 esi
  00077	89 85 30 fd ff
	ff		 mov	 DWORD PTR __Whole$1$[ebp], eax
  0007d	89 95 14 fd ff
	ff		 mov	 DWORD PTR __Whole$2$[ebp], edx
  00083	e8 00 00 00 00	 call	 __allmul
  00088	ff b5 28 fd ff
	ff		 push	 DWORD PTR __Freq$1$[ebp]
  0008e	ff b5 1c fd ff
	ff		 push	 DWORD PTR __Freq$2$[ebp]
  00094	52		 push	 edx
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 __alldiv

; 805  : 		return (time_point(duration(_Whole + _Part)));

  0009b	03 85 30 fd ff
	ff		 add	 eax, DWORD PTR __Whole$1$[ebp]
  000a1	8b ca		 mov	 ecx, edx
  000a3	89 85 d4 fc ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  000a9	0f 57 c0	 xorps	 xmm0, xmm0
  000ac	13 8d 14 fd ff
	ff		 adc	 ecx, DWORD PTR __Whole$2$[ebp]
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3160 :     DWORD dwLogSize = (MBYTES * 5);   //default 5 MB

  000b2	bf 00 00 50 00	 mov	 edi, 5242880		; 00500000H

; 3161 : 
; 3162 :     uint64_t ui64Wait = 0;
; 3163 : 
; 3164 :     DWORD dwNetType = 0;
; 3165 :     BOOL bNet = FALSE;
; 3166 : 
; 3167 :     bool bShowWindow = true;
; 3168 :     bool bRunWMI = false;
; 3169 :     bool bRunOnce = false;

  000b7	32 c0		 xor	 al, al
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono

; 805  : 		return (time_point(duration(_Whole + _Part)));

  000b9	89 8d d0 fc ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3173 :     LPTOP_LEVEL_EXCEPTION_FILTER pPreviousExceptionFilter = SetUnhandledExceptionFilter(AppUnhandledExceptionFilter);

  000bf	68 00 00 00 00	 push	 OFFSET ?AppUnhandledExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; AppUnhandledExceptionFilter
  000c4	c7 85 24 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _hThreadWMI$[ebp], 0
  000ce	c7 85 0c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _hThreadMSG$[ebp], 0
  000d8	c7 85 10 fd ff
	ff 60 ea 00 00	 mov	 DWORD PTR _dwTimer$1$[ebp], 60000 ; 0000ea60H
  000e2	89 bd 28 fd ff
	ff		 mov	 DWORD PTR _dwLogSize$1$[ebp], edi
  000e8	66 0f 13 85 18
	fd ff ff	 movlpd	 QWORD PTR _ui64Wait$[ebp], xmm0
  000f0	c7 85 04 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwNetType$[ebp], 0
  000fa	c6 85 40 fd ff
	ff 01		 mov	 BYTE PTR _bShowWindow$[ebp], 1
  00101	c6 85 42 fd ff
	ff 00		 mov	 BYTE PTR _bRunWMI$1$[ebp], 0
  00108	88 85 41 fd ff
	ff		 mov	 BYTE PTR _bRunOnce$1$[ebp], al
  0010e	88 85 43 fd ff
	ff		 mov	 BYTE PTR _bWMIThreadRunning$1$[ebp], al
  00114	88 85 2c fd ff
	ff		 mov	 BYTE PTR tv1008[ebp], al
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 545  :     HMODULE hKernel32 = LoadLibrary("kernel32.dll");

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MDJJJHMB@kernel32?4dll@

; 3173 :     LPTOP_LEVEL_EXCEPTION_FILTER pPreviousExceptionFilter = SetUnhandledExceptionFilter(AppUnhandledExceptionFilter);

  00125	89 85 08 fd ff
	ff		 mov	 DWORD PTR _pPreviousExceptionFilter$1$[ebp], eax

; 545  :     HMODULE hKernel32 = LoadLibrary("kernel32.dll");

  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00131	8b f0		 mov	 esi, eax

; 546  :     if (hKernel32 == nullptr)

  00133	85 f6		 test	 esi, esi
  00135	74 45		 je	 SHORT $LN66@WinMain

; 547  :         return FALSE;
; 548  : 
; 549  :     void *pOriginalFunc = GetProcAddress(hKernel32, "SetUnhandledExceptionFilter");

  00137	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EBDAABIF@SetUnhandledExceptionFilter@
  0013c	56		 push	 esi
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00143	8b d0		 mov	 edx, eax

; 550  :     if (pOriginalFunc == nullptr)

  00145	85 d2		 test	 edx, edx
  00147	74 2c		 je	 SHORT $LN650@WinMain

; 551  :     {
; 552  :         FreeLibrary(hKernel32);
; 553  :         return FALSE;
; 554  :     }
; 555  : 
; 556  :     DWORD dwOriginalAddr = (DWORD)pOriginalFunc;
; 557  :     dwOriginalAddr += 5; // add 5 for 5 op-codes for jmp far

  00149	8d 42 05	 lea	 eax, DWORD PTR [edx+5]

; 558  : 
; 559  :     void *pDecoyFunc = &ReportAttemptsToSetUnhandledExceptionFilter;
; 560  :     DWORD dwDecoyAddr = (DWORD)pDecoyFunc;
; 561  :     DWORD dwRelativeAddr = dwDecoyAddr - dwOriginalAddr;
; 562  : 
; 563  :     unsigned char jump[100];
; 564  :     jump[0] = 0xE9;  // JMP absolute

  0014c	c6 45 8c e9	 mov	 BYTE PTR _jump$12[ebp], 233 ; 000000e9H
  00150	b9 00 00 00 00	 mov	 ecx, OFFSET ?ReportAttemptsToSetUnhandledExceptionFilter@@YGP6GJPAU_EXCEPTION_POINTERS@@@ZP6GJ0@Z@Z ; ReportAttemptsToSetUnhandledExceptionFilter
  00155	2b c8		 sub	 ecx, eax

; 565  :     memcpy(&jump[1], &dwRelativeAddr, sizeof(pDecoyFunc));
; 566  :     SIZE_T bytesWritten;
; 567  : 
; 568  :     BOOL bRet = WriteProcessMemory(GetCurrentProcess(), pOriginalFunc, jump, sizeof(pDecoyFunc) + 1, &bytesWritten);

  00157	8d 85 20 fd ff
	ff		 lea	 eax, DWORD PTR _bytesWritten$4[ebp]
  0015d	50		 push	 eax
  0015e	6a 05		 push	 5
  00160	8d 45 8c	 lea	 eax, DWORD PTR _jump$12[ebp]
  00163	89 4d 8d	 mov	 DWORD PTR _jump$12[ebp+1], ecx
  00166	50		 push	 eax
  00167	52		 push	 edx
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0016e	50		 push	 eax
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
$LN650@WinMain:

; 3174 :     RedirectSetUnhandledExceptionFilter();
; 3175 : 
; 3176 :     ghInstance = hInstance;

  00175	56		 push	 esi
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN66@WinMain:

; 3177 : 
; 3178 :     //check whether or not it to run once
; 3179 :     if (lpCmdLine)

  0017c	8b b5 38 fd ff
	ff		 mov	 esi, DWORD PTR _lpCmdLine$GSCopy$1$[ebp]
  00182	8b 45 08	 mov	 eax, DWORD PTR _hInstance$[ebp]
  00185	a3 00 00 00 00	 mov	 DWORD PTR ?ghInstance@@3PAUHINSTANCE__@@A, eax ; ghInstance
  0018a	85 f6		 test	 esi, esi
  0018c	0f 84 99 01 00
	00		 je	 $LN27@WinMain

; 3180 :     {
; 3181 :         //convert command line to be checked
; 3182 :         _strlwr(lpCmdLine);

  00192	56		 push	 esi
  00193	e8 00 00 00 00	 call	 __strlwr
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00198	68 00 00 00 00	 push	 OFFSET ??_C@_07GKIGKNOK@runonce@
  0019d	56		 push	 esi
  0019e	e8 00 00 00 00	 call	 _strstr
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3185 :         if (strstr(lpCmdLine, "runonce") != NULL)

  001a3	85 c0		 test	 eax, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_07KNKAAJIE@sysinfo@
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3185 :         if (strstr(lpCmdLine, "runonce") != NULL)

  001aa	0f 95 c0	 setne	 al
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001ad	56		 push	 esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3185 :         if (strstr(lpCmdLine, "runonce") != NULL)

  001ae	88 85 41 fd ff
	ff		 mov	 BYTE PTR _bRunOnce$1$[ebp], al
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001b4	e8 00 00 00 00	 call	 _strstr
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3195 :         if (strstr(lpCmdLine, "sysinfo") != NULL)

  001b9	85 c0		 test	 eax, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_08DDBLHJBD@nowindow@
  001c0	56		 push	 esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3195 :         if (strstr(lpCmdLine, "sysinfo") != NULL)

  001c1	0f 95 85 42 fd
	ff ff		 setne	 BYTE PTR _bRunWMI$1$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001c8	e8 00 00 00 00	 call	 _strstr
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3205 :         if (strstr(lpCmdLine, "nowindow") != NULL)

  001cd	0f b6 8d 40 fd
	ff ff		 movzx	 ecx, BYTE PTR _bShowWindow$[ebp]
  001d4	33 d2		 xor	 edx, edx
  001d6	85 c0		 test	 eax, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001d8	68 00 00 00 00	 push	 OFFSET ??_C@_05NAPFDJNG@timer@
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3205 :         if (strstr(lpCmdLine, "nowindow") != NULL)

  001dd	0f 45 ca	 cmovne	 ecx, edx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001e0	56		 push	 esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3205 :         if (strstr(lpCmdLine, "nowindow") != NULL)

  001e1	88 8d 40 fd ff
	ff		 mov	 BYTE PTR _bShowWindow$[ebp], cl
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  001e7	e8 00 00 00 00	 call	 _strstr
  001ec	83 c4 24	 add	 esp, 36			; 00000024H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3212 :         if (timer)

  001ef	85 c0		 test	 eax, eax
  001f1	74 29		 je	 SHORT $LN14@WinMain

; 3213 :         {
; 3214 :             timer += 6;

  001f3	83 c0 06	 add	 eax, 6

; 3215 :             dwTimer = (DWORD)atoi(timer);

  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 _atoi
  001fc	83 c4 04	 add	 esp, 4
  001ff	89 85 10 fd ff
	ff		 mov	 DWORD PTR _dwTimer$1$[ebp], eax

; 3216 : 
; 3217 :             //timer from 1 to 360 minutes for checking the system status
; 3218 :             DWORD minTimer = 1, maxTimer = 360;
; 3219 :             if (dwTimer >= minTimer && dwTimer <= maxTimer)

  00205	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00208	81 f9 67 01 00
	00		 cmp	 ecx, 359		; 00000167H
  0020e	77 0c		 ja	 SHORT $LN14@WinMain

; 3220 :             {
; 3221 :                 dwTimer *= MINUTE;      //number of minutes specified in milliseconds

  00210	69 c0 60 ea 00
	00		 imul	 eax, eax, 60000
  00216	89 85 10 fd ff
	ff		 mov	 DWORD PTR _dwTimer$1$[ebp], eax
$LN14@WinMain:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_07MMCGMGHO@logsize@
  00221	56		 push	 esi
  00222	e8 00 00 00 00	 call	 _strstr
  00227	83 c4 08	 add	 esp, 8
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3227 :         if (logsize)

  0022a	85 c0		 test	 eax, eax
  0022c	74 21		 je	 SHORT $LN16@WinMain

; 3228 :         {
; 3229 :             logsize += 8;

  0022e	83 c0 08	 add	 eax, 8

; 3230 :             dwLogSize = (DWORD)(atoi(logsize)*KBYTES);

  00231	50		 push	 eax
  00232	e8 00 00 00 00	 call	 _atoi
  00237	8b f8		 mov	 edi, eax
  00239	83 c4 04	 add	 esp, 4
  0023c	c1 e7 0a	 shl	 edi, 10			; 0000000aH

; 3231 :             //maximum log file size should be 15 MB
; 3232 :             if (dwLogSize > (MBYTES * 15))

  0023f	b8 00 00 f0 00	 mov	 eax, 15728640		; 00f00000H
  00244	3b f8		 cmp	 edi, eax
  00246	0f 47 f8	 cmova	 edi, eax
  00249	89 bd 28 fd ff
	ff		 mov	 DWORD PTR _dwLogSize$1$[ebp], edi
$LN16@WinMain:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_09OBKGEPKB@appendlog@
  00254	56		 push	 esi
  00255	e8 00 00 00 00	 call	 _strstr
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3239 :         if (strstr(lpCmdLine, "appendlog"))

  0025a	8b 8d 2c fd ff
	ff		 mov	 ecx, DWORD PTR tv1008[ebp]
  00260	85 c0		 test	 eax, eax
  00262	0f b6 c9	 movzx	 ecx, cl
  00265	ba 01 00 00 00	 mov	 edx, 1
  0026a	0f 45 ca	 cmovne	 ecx, edx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  0026d	68 00 00 00 00	 push	 OFFSET ??_C@_06BCHOJLEN@logdir@
  00272	56		 push	 esi
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3239 :         if (strstr(lpCmdLine, "appendlog"))

  00273	89 8d 2c fd ff
	ff		 mov	 DWORD PTR tv1008[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00279	e8 00 00 00 00	 call	 _strstr
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3244 :         char *logdir = strstr(lpCmdLine, "logdir");

  0027e	8b d0		 mov	 edx, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00280	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3245 :         if (logdir)

  00283	85 d2		 test	 edx, edx
  00285	74 5e		 je	 SHORT $LN18@WinMain

; 3246 :         {
; 3247 :             //remove 'logdir:'
; 3248 :             logdir += 7;

  00287	83 c2 07	 add	 edx, 7

; 3249 : 
; 3250 :             //add '\' if last by doesn't
; 3251 :             if (strlen(logdir) > 0)

  0028a	8b ca		 mov	 ecx, edx
  0028c	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0028f	89 85 38 fd ff
	ff		 mov	 DWORD PTR tv1400[ebp], eax
$LL639@WinMain:
  00295	8a 01		 mov	 al, BYTE PTR [ecx]
  00297	41		 inc	 ecx
  00298	84 c0		 test	 al, al
  0029a	75 f9		 jne	 SHORT $LL639@WinMain
  0029c	2b 8d 38 fd ff
	ff		 sub	 ecx, DWORD PTR tv1400[ebp]
  002a2	74 41		 je	 SHORT $LN18@WinMain

; 3252 :             {
; 3253 :                 if (logdir[strlen(logdir) - 1] != '\\')

  002a4	8b ca		 mov	 ecx, edx
  002a6	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  002a9	89 85 38 fd ff
	ff		 mov	 DWORD PTR tv1404[ebp], eax
  002af	90		 npad	 1
$LL640@WinMain:
  002b0	8a 01		 mov	 al, BYTE PTR [ecx]
  002b2	41		 inc	 ecx
  002b3	84 c0		 test	 al, al
  002b5	75 f9		 jne	 SHORT $LL640@WinMain
  002b7	2b 8d 38 fd ff
	ff		 sub	 ecx, DWORD PTR tv1404[ebp]
  002bd	52		 push	 edx
  002be	80 7c 11 ff 5c	 cmp	 BYTE PTR [ecx+edx-1], 92 ; 0000005cH
  002c3	74 19		 je	 SHORT $LN22@WinMain

; 3254 :                 {
; 3255 :                     _snprintf(gszLogFilePrefix, sizeof(gszLogFilePrefix) - 1, "%s\\SysStatus", logdir);

  002c5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MHPPNGIP@?$CFs?2SysStatus@
$LN653@WinMain:

; 3263 :             {
; 3264 :                 //get log file prefix
; 3265 :                 if (GetModuleBaseName(GetCurrentProcess(), NULL, gszLogFilePrefix, sizeof(gszLogFilePrefix)) > 0)
; 3266 :                 {
; 3267 :                     //remove log file extension
; 3268 :                     PathRemoveExtension(gszLogFilePrefix);
; 3269 :                 }
; 3270 :                 else
; 3271 :                 {
; 3272 :                     //copy default name
; 3273 :                     strcpy(gszLogFilePrefix, "SysStatus");
; 3274 :                 }
; 3275 :             }
; 3276 :         }
; 3277 :         else
; 3278 :         {
; 3279 :             //get log file prefix
; 3280 :             if (GetModuleBaseName(GetCurrentProcess(), NULL, gszLogFilePrefix, sizeof(gszLogFilePrefix)) > 0)
; 3281 :             {
; 3282 :                 //remove log file extension
; 3283 :                 PathRemoveExtension(gszLogFilePrefix);
; 3284 :             }
; 3285 :             else
; 3286 :             {
; 3287 :                 //copy default name
; 3288 :                 strcpy(gszLogFilePrefix, "SysStatus");
; 3289 :             }
; 3290 :         }
; 3291 :     }
; 3292 : 
; 3293 :     gTickStart = SysTick();

  002ca	68 ff 03 00 00	 push	 1023			; 000003ffH
  002cf	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  002d4	e8 00 00 00 00	 call	 __snprintf
  002d9	83 c4 10	 add	 esp, 16			; 00000010H
  002dc	eb 4d		 jmp	 SHORT $LN27@WinMain
$LN22@WinMain:

; 3256 :                 }
; 3257 :                 else
; 3258 :                 {
; 3259 :                     _snprintf(gszLogFilePrefix, sizeof(gszLogFilePrefix) - 1, "%sSysStatus", logdir);

  002de	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NLCNCKHJ@?$CFsSysStatus@

; 3260 :                 }
; 3261 :             }
; 3262 :             else

  002e3	eb e5		 jmp	 SHORT $LN653@WinMain
$LN18@WinMain:

; 3263 :             {
; 3264 :                 //get log file prefix
; 3265 :                 if (GetModuleBaseName(GetCurrentProcess(), NULL, gszLogFilePrefix, sizeof(gszLogFilePrefix)) > 0)
; 3266 :                 {
; 3267 :                     //remove log file extension
; 3268 :                     PathRemoveExtension(gszLogFilePrefix);
; 3269 :                 }
; 3270 :                 else
; 3271 :                 {
; 3272 :                     //copy default name
; 3273 :                     strcpy(gszLogFilePrefix, "SysStatus");
; 3274 :                 }
; 3275 :             }
; 3276 :         }
; 3277 :         else
; 3278 :         {
; 3279 :             //get log file prefix
; 3280 :             if (GetModuleBaseName(GetCurrentProcess(), NULL, gszLogFilePrefix, sizeof(gszLogFilePrefix)) > 0)
; 3281 :             {
; 3282 :                 //remove log file extension
; 3283 :                 PathRemoveExtension(gszLogFilePrefix);
; 3284 :             }
; 3285 :             else
; 3286 :             {
; 3287 :                 //copy default name
; 3288 :                 strcpy(gszLogFilePrefix, "SysStatus");
; 3289 :             }
; 3290 :         }
; 3291 :     }
; 3292 : 
; 3293 :     gTickStart = SysTick();

  002e5	68 00 04 00 00	 push	 1024			; 00000400H
  002ea	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  002ef	6a 00		 push	 0
  002f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  002f7	50		 push	 eax
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__K32GetModuleBaseNameA@16
  002fe	85 c0		 test	 eax, eax
  00300	74 0d		 je	 SHORT $LN26@WinMain
  00302	68 00 00 00 00	 push	 OFFSET ?gszLogFilePrefix@@3PADA ; gszLogFilePrefix
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PathRemoveExtensionA@4
  0030d	eb 1c		 jmp	 SHORT $LN27@WinMain
$LN26@WinMain:
  0030f	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_09KECABMHK@SysStatus@+8
  00315	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09KECABMHK@SysStatus@
  0031d	66 a3 08 00 00
	00		 mov	 WORD PTR ?gszLogFilePrefix@@3PADA+8, ax
  00323	66 0f d6 05 00
	00 00 00	 movq	 QWORD PTR ?gszLogFilePrefix@@3PADA, xmm0
$LN27@WinMain:
  0032b	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 3294 :     //start new log
; 3295 :     CheckLogFileSize(bAppendLog ? dwLogSize : 0UL);

  00330	33 c9		 xor	 ecx, ecx
  00332	a3 00 00 00 00	 mov	 DWORD PTR ?gTickStart@@3_KA, eax
  00337	38 8d 2c fd ff
	ff		 cmp	 BYTE PTR tv1008[ebp], cl
  0033d	89 15 04 00 00
	00		 mov	 DWORD PTR ?gTickStart@@3_KA+4, edx
  00343	0f 45 cf	 cmovne	 ecx, edi
  00346	e8 00 00 00 00	 call	 ?CheckLogFileSize@@YAXK@Z ; CheckLogFileSize

; 3296 : 
; 3297 :     Log(LOG_DEBUG, __LINE__, ">> WinMain");

  0034b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PGBNDJPK@?$DO?$DO?5WinMain@
  00350	68 e1 0c 00 00	 push	 3297			; 00000ce1H
  00355	6a 10		 push	 16			; 00000010H
  00357	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log

; 3299 :     Log(LOG_HEADER, __LINE__, "SysStatus, CmdLine %s", lpCmdLine);

  0035c	56		 push	 esi
  0035d	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FONLKPFK@SysStatus?0?5CmdLine?5?$CFs@
  00362	68 e3 0c 00 00	 push	 3299			; 00000ce3H
  00367	6a 02		 push	 2
  00369	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0036e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3299 :     Log(LOG_HEADER, __LINE__, "SysStatus, CmdLine %s", lpCmdLine);

  00373	83 c4 1c	 add	 esp, 28			; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00376	a3 04 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3303 :     AdjustProcessRights();

  0037b	e8 00 00 00 00	 call	 ?AdjustProcessRights@@YAXXZ ; AdjustProcessRights
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00380	6a 07		 push	 7

; 1784 : 		_Mysize(0),

  00382	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0038c	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]

; 1785 : 		_Myres(0)

  00392	c7 85 58 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0039c	68 00 00 00 00	 push	 OFFSET ??_C@_07MMMFAJOG@ThrdMsg@

; 3976 : 		_My_data._Mysize = 0;

  003a1	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  003ab	c7 85 58 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  003b5	c6 85 44 fd ff
	ff 00		 mov	 BYTE PTR $T7[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003bc	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3306 :     StartThread("ThrdMsg", ThreadMessage, &bShowWindow, 0, &hThreadMSG);

  003c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  003c8	8d 85 0c fd ff
	ff		 lea	 eax, DWORD PTR _hThreadMSG$[ebp]
  003ce	50		 push	 eax
  003cf	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _bShowWindow$[ebp]
  003d5	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadMessage@@YGIPAX@Z ; ThreadMessage
  003da	6a 00		 push	 0
  003dc	50		 push	 eax
  003dd	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  003e3	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  003e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  003eb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  003f2	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR $T7[ebp+20]
  003f8	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  003fb	72 2f		 jb	 SHORT $LN194@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003fd	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00403	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00404	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00406	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0040c	72 14		 jb	 SHORT $LN193@WinMain

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0040e	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00411	83 c2 23	 add	 edx, 35			; 00000023H
  00414	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00416	83 c0 fc	 add	 eax, -4			; fffffffcH
  00419	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0041c	0f 87 62 09 00
	00		 ja	 $LN422@WinMain
$LN193@WinMain:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00422	52		 push	 edx
  00423	51		 push	 ecx
  00424	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00429	83 c4 08	 add	 esp, 8
$LN194@WinMain:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3308 :     if (bRunWMI)

  0042c	80 bd 42 fd ff
	ff 00		 cmp	 BYTE PTR _bRunWMI$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00433	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0043d	c7 85 58 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00447	c6 85 44 fd ff
	ff 00		 mov	 BYTE PTR $T7[ebp], 0
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3308 :     if (bRunWMI)

  0044e	0f 84 c8 00 00
	00		 je	 $LN277@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00454	6a 06		 push	 6

; 1784 : 		_Mysize(0),

  00456	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00460	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]

; 1785 : 		_Myres(0)

  00466	c7 85 58 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 0

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00470	68 00 00 00 00	 push	 OFFSET ??_C@_06NNJPAOHJ@ThrWMI@

; 3976 : 		_My_data._Mysize = 0;

  00475	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0047f	c7 85 58 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00489	c6 85 44 fd ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00490	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3311 :         bWMIThreadRunning = StartThread("ThrWMI", ThreadWMI, NULL, 0, &hThreadWMI);

  00495	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0049c	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR _hThreadWMI$[ebp]
  004a2	50		 push	 eax
  004a3	6a 00		 push	 0
  004a5	6a 00		 push	 0
  004a7	ba 00 00 00 00	 mov	 edx, OFFSET ?ThreadWMI@@YGIPAX@Z ; ThreadWMI
  004ac	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  004b2	e8 00 00 00 00	 call	 ?StartThread@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GIPAX@Z1KPAPAX@Z ; StartThread
  004b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ba	88 85 43 fd ff
	ff		 mov	 BYTE PTR _bWMIThreadRunning$1$[ebp], al
  004c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  004c7	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR $T6[ebp+20]
  004cd	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  004d0	72 2f		 jb	 SHORT $LN275@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004d2	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  004d8	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004d9	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  004db	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  004e1	72 14		 jb	 SHORT $LN274@WinMain

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  004e3	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  004e6	83 c2 23	 add	 edx, 35			; 00000023H
  004e9	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  004ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  004f1	0f 87 92 08 00
	00		 ja	 $LN658@WinMain
$LN274@WinMain:

; 207  : 	::operator delete(_Ptr, _Bytes);

  004f7	52		 push	 edx
  004f8	51		 push	 ecx
  004f9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004fe	83 c4 08	 add	 esp, 8
$LN275@WinMain:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  00501	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0050b	c7 85 58 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00515	c6 85 44 fd ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
$LN277@WinMain:
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 42   :     MonitorIPs() : m_hSync(nullptr), m_hWait(nullptr), m_changed(false)

  0051c	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _monIps$[ebp], 0
  00526	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _monIps$[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00530	c7 85 f4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _monIps$[ebp+28], 0

; 390  : 		_Mylast(),

  0053a	c7 85 f8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _monIps$[ebp+32], 0

; 391  : 		_Myend()

  00544	c7 85 fc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _monIps$[ebp+36], 0
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 43   :     {

  0054e	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 44   :         Log(LOG_DEBUG, __LINE__, ">> MonIPs");

  00555	68 00 00 00 00	 push	 OFFSET ??_C@_09BAECPDM@?$DO?$DO?5MonIPs@
  0055a	6a 2c		 push	 44			; 0000002cH
  0055c	6a 10		 push	 16			; 00000010H
  0055e	c6 85 00 fd ff
	ff 00		 mov	 BYTE PTR _monIps$[ebp+40], 0
  00565	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  0056a	8b 95 f8 fc ff
	ff		 mov	 edx, DWORD PTR _monIps$[ebp+32]
  00570	83 c4 08	 add	 esp, 8
  00573	8b 8d f4 fc ff
	ff		 mov	 ecx, DWORD PTR _monIps$[ebp+28]
  00579	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 45   :         ZeroMemory(&m_o, sizeof(m_o));

  0057c	0f 11 85 e0 fc
	ff ff		 movups	 XMMWORD PTR _monIps$[ebp+8], xmm0
  00583	c7 85 f0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _monIps$[ebp+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  0058d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00592	8b 85 f4 fc ff
	ff		 mov	 eax, DWORD PTR _monIps$[ebp+28]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00598	83 c4 04	 add	 esp, 4

; 1592 : 		this->_Mylast() = this->_Myfirst();

  0059b	89 85 f8 fc ff
	ff		 mov	 DWORD PTR _monIps$[ebp+32], eax
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3315 :     MonitorIPs monIps;

  005a1	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 3316 :     bool bMonIps = monIps.Initialize();

  005a8	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp]
  005ae	e8 00 00 00 00	 call	 ?Initialize@MonitorIPs@@QAE_NXZ ; MonitorIPs::Initialize
  005b3	88 85 3f fd ff
	ff		 mov	 BYTE PTR _bMonIps$1$[ebp], al

; 3317 : 
; 3318 :     if ((bRunOnce == false) || (bRunOnce == true && bWMIThreadRunning == true))

  005b9	8a 85 41 fd ff
	ff		 mov	 al, BYTE PTR _bRunOnce$1$[ebp]
  005bf	84 c0		 test	 al, al
  005c1	74 0c		 je	 SHORT $LN30@WinMain
  005c3	3c 01		 cmp	 al, 1
  005c5	75 23		 jne	 SHORT $LN29@WinMain
  005c7	38 85 43 fd ff
	ff		 cmp	 BYTE PTR _bWMIThreadRunning$1$[ebp], al
  005cd	75 1b		 jne	 SHORT $LN29@WinMain
$LN30@WinMain:

; 3319 :     {
; 3320 :         //get unchangeable system information
; 3321 :         GetSystemDetails();

  005cf	e8 00 00 00 00	 call	 ?GetSystemDetails@@YAXXZ ; GetSystemDetails

; 3322 : 
; 3323 :         //get runtime changeable system information
; 3324 :         GetSystemStatusChanges();

  005d4	e8 00 00 00 00	 call	 ?GetSystemStatusChanges@@YAXXZ ; GetSystemStatusChanges

; 3325 : 
; 3326 :         //get IPs if possible
; 3327 :         GetSystemIPAddresses(&monIps, bMonIps);

  005d9	8a 95 3f fd ff
	ff		 mov	 dl, BYTE PTR _bMonIps$1$[ebp]
  005df	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp]
  005e5	e8 00 00 00 00	 call	 ?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z ; GetSystemIPAddresses
$LN29@WinMain:

; 3328 :     }
; 3329 : 
; 3330 :     double timeElapsed{};
; 3331 :     uint64_t seconds{};
; 3332 :     uint64_t tickEnd{};
; 3333 :     char wndText[_MAX_PATH]{};

  005ea	68 04 01 00 00	 push	 260			; 00000104H
  005ef	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _wndText$[ebp]
  005f5	6a 00		 push	 0
  005f7	50		 push	 eax
  005f8	e8 00 00 00 00	 call	 _memset
  005fd	8b 85 1c fd ff
	ff		 mov	 eax, DWORD PTR _ui64Wait$[ebp+4]
  00603	83 c4 0c	 add	 esp, 12			; 0000000cH
  00606	89 85 30 fd ff
	ff		 mov	 DWORD PTR _ui64Wait$2$[ebp], eax
  0060c	8b 85 18 fd ff
	ff		 mov	 eax, DWORD PTR _ui64Wait$[ebp]
$LN654@WinMain:

; 73   :     char sMember[100] = { 0 };

  00612	89 85 1c fd ff
	ff		 mov	 DWORD PTR _ui64Wait$1$[ebp], eax
$LL2@WinMain:
  00618	6a 64		 push	 100			; 00000064H
  0061a	8d 45 8c	 lea	 eax, DWORD PTR _sMember$11[ebp]
  0061d	6a 00		 push	 0
  0061f	50		 push	 eax
  00620	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00625	68 00 00 00 00	 push	 OFFSET ?gbTerminate@@3HA ; gbTerminate
  0062a	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0062f	8d 45 8c	 lea	 eax, DWORD PTR _sMember$11[ebp]
  00632	6a 63		 push	 99			; 00000063H
  00634	50		 push	 eax
  00635	e8 00 00 00 00	 call	 __snprintf
  0063a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  0063d	8d 45 8c	 lea	 eax, DWORD PTR _sMember$11[ebp]
  00640	50		 push	 eax
  00641	6a 00		 push	 0
  00643	6a 00		 push	 0
  00645	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  0064b	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  0064d	6a ff		 push	 -1
  0064f	57		 push	 edi
  00650	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  00656	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbTerminate@@3HA ; gbTerminate

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  0065c	57		 push	 edi
  0065d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  00663	57		 push	 edi
  00664	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3334 : 
; 3335 :     //run while:
; 3336 :     // 1. close or end session has been requested AND 
; 3337 :     //    running mode is continuous
; 3338 :     // OR
; 3339 :     // 2. close or end session has been requested AND 
; 3340 :     //    running mode is simple AND
; 3341 :     //    WMI thread is still running
; 3342 :     while (_thGetInt(&gbTerminate) == FALSE &&

  0066a	8a 85 41 fd ff
	ff		 mov	 al, BYTE PTR _bRunOnce$1$[ebp]
  00670	85 f6		 test	 esi, esi
  00672	0f 85 4d 04 00
	00		 jne	 $LN3@WinMain
  00678	84 c0		 test	 al, al
  0067a	74 14		 je	 SHORT $LN31@WinMain
  0067c	3c 01		 cmp	 al, 1
  0067e	0f 85 41 04 00
	00		 jne	 $LN3@WinMain
  00684	38 85 43 fd ff
	ff		 cmp	 BYTE PTR _bWMIThreadRunning$1$[ebp], al
  0068a	0f 85 35 04 00
	00		 jne	 $LN3@WinMain
$LN31@WinMain:

; 3343 :         ((bRunOnce == false) || (bRunOnce == true && bWMIThreadRunning == true))
; 3344 :         )
; 3345 :     {
; 3346 :         if (bRunWMI)

  00690	80 bd 42 fd ff
	ff 00		 cmp	 BYTE PTR _bRunWMI$1$[ebp], 0
  00697	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__WaitForSingleObject@8
  0069d	74 16		 je	 SHORT $LN33@WinMain

; 3347 :         {
; 3348 :             if (WaitForSingleObject(hThreadWMI, (MILLISECOND * 100)) == WAIT_TIMEOUT)

  0069f	6a 64		 push	 100			; 00000064H
  006a1	ff b5 24 fd ff
	ff		 push	 DWORD PTR _hThreadWMI$[ebp]
  006a7	ff d6		 call	 esi
  006a9	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  006ae	0f 94 85 43 fd
	ff ff		 sete	 BYTE PTR _bWMIThreadRunning$1$[ebp]
$LN33@WinMain:

; 3349 :             {
; 3350 :                 bWMIThreadRunning = true;
; 3351 :             }
; 3352 :             else
; 3353 :             {
; 3354 :                 bWMIThreadRunning = false;
; 3355 :             }
; 3356 :         }
; 3357 : 
; 3358 :         if (ui64Wait > SysTick() && _thGetInt(&gbForceChecking) == FALSE)

  006b5	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  006ba	39 95 30 fd ff
	ff		 cmp	 DWORD PTR _ui64Wait$2$[ebp], edx
  006c0	72 75		 jb	 SHORT $LN35@WinMain
  006c2	77 08		 ja	 SHORT $LN641@WinMain
  006c4	39 85 1c fd ff
	ff		 cmp	 DWORD PTR _ui64Wait$1$[ebp], eax
  006ca	76 6b		 jbe	 SHORT $LN35@WinMain
$LN641@WinMain:

; 73   :     char sMember[100] = { 0 };

  006cc	6a 64		 push	 100			; 00000064H
  006ce	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _sMember$10[ebp]
  006d4	6a 00		 push	 0
  006d6	50		 push	 eax
  006d7	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  006dc	68 00 00 00 00	 push	 OFFSET ?gbForceChecking@@3HA ; gbForceChecking
  006e1	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  006e6	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _sMember$10[ebp]
  006ec	6a 63		 push	 99			; 00000063H
  006ee	50		 push	 eax
  006ef	e8 00 00 00 00	 call	 __snprintf
  006f4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  006f7	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _sMember$10[ebp]
  006fd	50		 push	 eax
  006fe	6a 00		 push	 0
  00700	6a 00		 push	 0
  00702	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00708	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  0070a	6a ff		 push	 -1
  0070c	57		 push	 edi
  0070d	ff d6		 call	 esi

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0070f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbForceChecking@@3HA ; gbForceChecking

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00715	57		 push	 edi
  00716	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0071c	57		 push	 edi
  0071d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3349 :             {
; 3350 :                 bWMIThreadRunning = true;
; 3351 :             }
; 3352 :             else
; 3353 :             {
; 3354 :                 bWMIThreadRunning = false;
; 3355 :             }
; 3356 :         }
; 3357 : 
; 3358 :         if (ui64Wait > SysTick() && _thGetInt(&gbForceChecking) == FALSE)

  00723	85 f6		 test	 esi, esi
  00725	75 10		 jne	 SHORT $LN35@WinMain

; 3359 :         {
; 3360 :             //Wait a second and then continue
; 3361 :             Sleep(SECOND);

  00727	68 e8 03 00 00	 push	 1000			; 000003e8H
  0072c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 3362 :             continue;

  00732	e9 e1 fe ff ff	 jmp	 $LL2@WinMain
$LN35@WinMain:

; 73   :     char sMember[100] = { 0 };

  00737	6a 64		 push	 100			; 00000064H
  00739	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$9[ebp]
  0073f	6a 00		 push	 0
  00741	50		 push	 eax
  00742	e8 00 00 00 00	 call	 _memset

; 74   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  00747	68 00 00 00 00	 push	 OFFSET ?gbForceChecking@@3HA ; gbForceChecking
  0074c	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  00751	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$9[ebp]
  00757	6a 63		 push	 99			; 00000063H
  00759	50		 push	 eax
  0075a	e8 00 00 00 00	 call	 __snprintf
  0075f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 75   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  00762	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$9[ebp]
  00768	50		 push	 eax
  00769	6a 00		 push	 0
  0076b	6a 00		 push	 0
  0076d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12
  00773	8b f8		 mov	 edi, eax

; 76   :     WaitForSingleObject(hdTh, INFINITE);

  00775	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__WaitForSingleObject@8
  0077a	6a ff		 push	 -1
  0077c	57		 push	 edi
  0077d	ff d0		 call	 eax

; 77   : 
; 78   :     int const iRetVal = *piProtectedVar;

  0077f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gbForceChecking@@3HA ; gbForceChecking

; 79   : 
; 80   :     ReleaseMutex(hdTh);

  00785	57		 push	 edi
  00786	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 81   :     CloseHandle(hdTh);

  0078c	57		 push	 edi
  0078d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3363 :         }
; 3364 : 
; 3365 :         if (_thGetInt(&gbForceChecking) == TRUE)

  00793	83 fe 01	 cmp	 esi, 1
  00796	75 68		 jne	 SHORT $LN642@WinMain

; 3366 :         {
; 3367 :             //get runtime changeable system information
; 3368 :             GetSystemStatusChanges();

  00798	e8 00 00 00 00	 call	 ?GetSystemStatusChanges@@YAXXZ ; GetSystemStatusChanges

; 57   :     char sMember[100] = { 0 };

  0079d	6a 64		 push	 100			; 00000064H
  0079f	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$8[ebp]
  007a5	6a 00		 push	 0
  007a7	50		 push	 eax
  007a8	e8 00 00 00 00	 call	 _memset

; 58   :     _snprintf(sMember, sizeof(sMember) - 1, "%p", piProtectedVar);

  007ad	68 00 00 00 00	 push	 OFFSET ?gbForceChecking@@3HA ; gbForceChecking
  007b2	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  007b7	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$8[ebp]
  007bd	6a 63		 push	 99			; 00000063H
  007bf	50		 push	 eax
  007c0	e8 00 00 00 00	 call	 __snprintf
  007c5	83 c4 1c	 add	 esp, 28			; 0000001cH

; 59   :     HANDLE hdTh = CreateMutex(NULL, FALSE, sMember);

  007c8	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _sMember$8[ebp]
  007ce	50		 push	 eax
  007cf	6a 00		 push	 0
  007d1	6a 00		 push	 0
  007d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMutexA@12

; 60   :     WaitForSingleObject(hdTh, INFINITE);

  007d9	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
  007df	8b f0		 mov	 esi, eax
  007e1	6a ff		 push	 -1
  007e3	56		 push	 esi
  007e4	ff d7		 call	 edi

; 61   : 
; 62   :     *piProtectedVar = iValue;
; 63   : 
; 64   :     ReleaseMutex(hdTh);

  007e6	56		 push	 esi
  007e7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gbForceChecking@@3HA, 0 ; gbForceChecking
  007f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4

; 65   :     CloseHandle(hdTh);

  007f7	56		 push	 esi
  007f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 3363 :         }
; 3364 : 
; 3365 :         if (_thGetInt(&gbForceChecking) == TRUE)

  007fe	eb 06		 jmp	 SHORT $LN368@WinMain
$LN642@WinMain:
  00800	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
$LN368@WinMain:

; 3369 : 
; 3370 :             //stop force checking
; 3371 :             _thSetInt(&gbForceChecking, FALSE);
; 3372 :         }
; 3373 : 
; 3374 :         //get system information
; 3375 :         GetSystemStatus();

  00806	e8 00 00 00 00	 call	 ?GetSystemStatus@@YAXXZ	; GetSystemStatus

; 3376 : 
; 3377 :         //get WMI status information if WMI system info thread has been completed
; 3378 :         if (!bWMIThreadRunning && bRunWMI)

  0080b	80 bd 43 fd ff
	ff 00		 cmp	 BYTE PTR _bWMIThreadRunning$1$[ebp], 0
  00812	75 0e		 jne	 SHORT $LN37@WinMain
  00814	80 bd 42 fd ff
	ff 00		 cmp	 BYTE PTR _bRunWMI$1$[ebp], 0
  0081b	74 05		 je	 SHORT $LN37@WinMain

; 3379 :         {
; 3380 :             //get WMI status information
; 3381 :             GetWMIStatus();

  0081d	e8 00 00 00 00	 call	 ?GetWMIStatus@@YAXXZ	; GetWMIStatus
$LN37@WinMain:

; 3382 :         }
; 3383 : 
; 3384 :         //Is network alive?
; 3385 :         bNet = IsNetworkAlive(&dwNetType);

  00822	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _dwNetType$[ebp]
  00828	50		 push	 eax
  00829	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsNetworkAlive@4
  0082f	8b f0		 mov	 esi, eax

; 3386 :         dwRet = GetLastError();

  00831	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 3387 : 
; 3388 :         //Was function executed successfully?
; 3389 :         if (ERROR_SUCCESS == dwRet)

  00837	85 c0		 test	 eax, eax
  00839	75 2f		 jne	 SHORT $LN38@WinMain

; 3390 :         {
; 3391 :             Log(LOG_HEADER, __LINE__, "Net Alive? %s, Type %u", (bNet ? "Yes" : "No"), dwNetType);

  0083b	ff b5 04 fd ff
	ff		 push	 DWORD PTR _dwNetType$[ebp]
  00841	85 f6		 test	 esi, esi
  00843	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02JINPPBEP@No@
  00848	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_03CCLAEDDF@Yes@
  0084d	0f 44 c8	 cmove	 ecx, eax
  00850	51		 push	 ecx
  00851	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ICNNMNOE@Net?5Alive?$DP?5?$CFs?0?5Type?5?$CFu@
  00856	68 3f 0d 00 00	 push	 3391			; 00000d3fH
  0085b	6a 02		 push	 2
  0085d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00862	83 c4 14	 add	 esp, 20			; 00000014H

; 3392 :         }
; 3393 :         else

  00865	e9 87 00 00 00	 jmp	 $LN428@WinMain
$LN38@WinMain:

; 3395 :             Log(LOG_HEADER, __LINE__, "Net Chkg %s", GetLastErrorMessage(dwRet).c_str());

  0086a	8b d0		 mov	 edx, eax
  0086c	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00872	e8 00 00 00 00	 call	 ?GetLastErrorMessage@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; GetLastErrorMessage
  00877	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0087b	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  0087f	72 02		 jb	 SHORT $LN378@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00881	8b 00		 mov	 eax, DWORD PTR [eax]
$LN378@WinMain:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3395 :             Log(LOG_HEADER, __LINE__, "Net Chkg %s", GetLastErrorMessage(dwRet).c_str());

  00883	50		 push	 eax
  00884	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MNGEFCAN@Net?5Chkg?5?$CFs@
  00889	68 43 0d 00 00	 push	 3395			; 00000d43H
  0088e	6a 02		 push	 2
  00890	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00895	83 c4 10	 add	 esp, 16			; 00000010H
  00898	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0089c	8b 95 58 fd ff
	ff		 mov	 edx, DWORD PTR $T5[ebp+20]
  008a2	83 fa 10	 cmp	 edx, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  008a5	72 2f		 jb	 SHORT $LN426@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008a7	8b 8d 44 fd ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  008ad	42		 inc	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008ae	8b c1		 mov	 eax, ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  008b0	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  008b6	72 14		 jb	 SHORT $LN425@WinMain

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  008b8	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  008bb	83 c2 23	 add	 edx, 35			; 00000023H
  008be	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008c0	83 c0 fc	 add	 eax, -4			; fffffffcH
  008c3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008c6	0f 87 b8 04 00
	00		 ja	 $LN422@WinMain
$LN425@WinMain:

; 207  : 	::operator delete(_Ptr, _Bytes);

  008cc	52		 push	 edx
  008cd	51		 push	 ecx
  008ce	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008d3	83 c4 08	 add	 esp, 8
$LN426@WinMain:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  008d6	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  008e0	c7 85 58 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  008ea	c6 85 44 fd ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
$LN428@WinMain:
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 76   :         WaitForSingleObject(m_hSync, MINUTE);

  008f1	68 60 ea 00 00	 push	 60000			; 0000ea60H
  008f6	ff b5 d8 fc ff
	ff		 push	 DWORD PTR _monIps$[ebp]
  008fc	ff d7		 call	 edi

; 77   : 
; 78   :         bool ret = m_changed;

  008fe	8a 85 00 fd ff
	ff		 mov	 al, BYTE PTR _monIps$[ebp+40]

; 79   :         m_changed = false;
; 80   : 
; 81   :         ReleaseMutex(m_hSync);

  00904	ff b5 d8 fc ff
	ff		 push	 DWORD PTR _monIps$[ebp]
  0090a	88 85 37 fd ff
	ff		 mov	 BYTE PTR _ret$1$[ebp], al
  00910	c6 85 00 fd ff
	ff 00		 mov	 BYTE PTR _monIps$[ebp+40], 0
  00917	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3399 :         if (monIps.IsChanged())

  0091d	80 bd 37 fd ff
	ff 00		 cmp	 BYTE PTR _ret$1$[ebp], 0
  00924	74 11		 je	 SHORT $LN40@WinMain

; 3400 :         {
; 3401 :             GetSystemIPAddresses(&monIps, bMonIps);

  00926	8a 95 3f fd ff
	ff		 mov	 dl, BYTE PTR _bMonIps$1$[ebp]
  0092c	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp]
  00932	e8 00 00 00 00	 call	 ?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z ; GetSystemIPAddresses
$LN40@WinMain:

; 3402 :         }
; 3403 : 
; 3404 :         CalcElapsedTime(gTickStart, tickEnd, timeElapsed, seconds);

  00937	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gTickStart@@3_KA
  0093d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gTickStart@@3_KA+4

; 718  :     tickEnd = SysTick();

  00943	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick

; 719  :     timeElapsed = (static_cast<double>(tickEnd - tickStart) / static_cast<double>(SECOND));

  00948	2b c7		 sub	 eax, edi
  0094a	8b c8		 mov	 ecx, eax
  0094c	1b d6		 sbb	 edx, esi
  0094e	e8 00 00 00 00	 call	 __ultod3
  00953	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000
  0095b	f2 0f 11 85 c8
	fc ff ff	 movsd	 QWORD PTR _timeElapsed$1$[ebp], xmm0

; 720  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  00963	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0096b	e8 00 00 00 00	 call	 __dtoul3

; 3405 :         Log(LOG_DEBUG, __LINE__, "-- %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  00970	6a 00		 push	 0

; 720  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  00972	8b f8		 mov	 edi, eax
  00974	8b c2		 mov	 eax, edx

; 3405 :         Log(LOG_DEBUG, __LINE__, "-- %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  00976	68 10 0e 00 00	 push	 3600			; 00000e10H
  0097b	50		 push	 eax
  0097c	57		 push	 edi

; 720  :     seconds = static_cast<uint64_t>(timeElapsed + 0.5);

  0097d	89 bd 14 fd ff
	ff		 mov	 DWORD PTR _seconds$1$[ebp], edi
  00983	89 85 2c fd ff
	ff		 mov	 DWORD PTR _seconds$2$[ebp], eax

; 3405 :         Log(LOG_DEBUG, __LINE__, "-- %02llu:%02llu:%02llu, %.3f s", seconds / 3600, (seconds % 3600) / 60, seconds % 60, timeElapsed);

  00989	e8 00 00 00 00	 call	 __aulldiv
  0098e	8b c8		 mov	 ecx, eax
  00990	8b c2		 mov	 eax, edx
  00992	89 85 38 fd ff
	ff		 mov	 DWORD PTR tv1343[ebp], eax
  00998	ba 10 0e 00 00	 mov	 edx, 3600		; 00000e10H
  0099d	f7 e2		 mul	 edx
  0099f	89 8d 20 fd ff
	ff		 mov	 DWORD PTR tv1344[ebp], ecx
  009a5	8b f0		 mov	 esi, eax
  009a7	8b c1		 mov	 eax, ecx
  009a9	b9 10 0e 00 00	 mov	 ecx, 3600		; 00000e10H
  009ae	f7 e1		 mul	 ecx
  009b0	8b 8d 2c fd ff
	ff		 mov	 ecx, DWORD PTR _seconds$2$[ebp]
  009b6	03 f2		 add	 esi, edx
  009b8	2b f8		 sub	 edi, eax
  009ba	6a 00		 push	 0
  009bc	6a 3c		 push	 60			; 0000003cH
  009be	1b ce		 sbb	 ecx, esi
  009c0	51		 push	 ecx
  009c1	57		 push	 edi
  009c2	e8 00 00 00 00	 call	 __aulldiv
  009c7	f2 0f 10 85 c8
	fc ff ff	 movsd	 xmm0, QWORD PTR _timeElapsed$1$[ebp]
  009cf	83 ec 08	 sub	 esp, 8
  009d2	8b bd 2c fd ff
	ff		 mov	 edi, DWORD PTR _seconds$2$[ebp]
  009d8	89 85 1c fd ff
	ff		 mov	 DWORD PTR tv1342[ebp], eax
  009de	89 95 30 fd ff
	ff		 mov	 DWORD PTR tv1341[ebp], edx
  009e4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  009e9	6a 00		 push	 0
  009eb	6a 3c		 push	 60			; 0000003cH
  009ed	57		 push	 edi
  009ee	ff b5 14 fd ff
	ff		 push	 DWORD PTR _seconds$1$[ebp]
  009f4	e8 00 00 00 00	 call	 __aulldiv
  009f9	8b c8		 mov	 ecx, eax
  009fb	8b f2		 mov	 esi, edx
  009fd	0f a4 ce 04	 shld	 esi, ecx, 4
  00a01	c1 e1 04	 shl	 ecx, 4
  00a04	2b c8		 sub	 ecx, eax
  00a06	8b 85 14 fd ff
	ff		 mov	 eax, DWORD PTR _seconds$1$[ebp]
  00a0c	1b f2		 sbb	 esi, edx
  00a0e	0f a4 ce 02	 shld	 esi, ecx, 2
  00a12	c1 e1 02	 shl	 ecx, 2
  00a15	2b c1		 sub	 eax, ecx
  00a17	1b fe		 sbb	 edi, esi
  00a19	8b b5 38 fd ff
	ff		 mov	 esi, DWORD PTR tv1343[ebp]
  00a1f	57		 push	 edi
  00a20	8b bd 20 fd ff
	ff		 mov	 edi, DWORD PTR tv1344[ebp]
  00a26	50		 push	 eax
  00a27	ff b5 30 fd ff
	ff		 push	 DWORD PTR tv1341[ebp]
  00a2d	ff b5 1c fd ff
	ff		 push	 DWORD PTR tv1342[ebp]
  00a33	56		 push	 esi
  00a34	57		 push	 edi
  00a35	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IBENHIJM@?9?9?5?$CF02llu?3?$CF02llu?3?$CF02llu?0?5?$CF?43f?5s@
  00a3a	68 4d 0d 00 00	 push	 3405			; 00000d4dH
  00a3f	6a 10		 push	 16			; 00000010H
  00a41	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00a46	83 c4 2c	 add	 esp, 44			; 0000002cH

; 3406 : 
; 3407 :         if (bShowWindow)

  00a49	80 bd 40 fd ff
	ff 00		 cmp	 BYTE PTR _bShowWindow$[ebp], 0
  00a50	74 4d		 je	 SHORT $LN41@WinMain

; 3408 :         {
; 3409 :             //Update the window name with the time app is running
; 3410 :             memset(wndText, 0x00, sizeof(wndText));

  00a52	68 04 01 00 00	 push	 260			; 00000104H
  00a57	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _wndText$[ebp]
  00a5d	6a 00		 push	 0
  00a5f	50		 push	 eax
  00a60	e8 00 00 00 00	 call	 _memset

; 3411 :             _snprintf(wndText, sizeof(wndText) - 1, "SysStatus - Running for %02llu:%02llu", seconds / 3600, (seconds % 3600) / 60);

  00a65	ff b5 30 fd ff
	ff		 push	 DWORD PTR tv1341[ebp]
  00a6b	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _wndText$[ebp]
  00a71	ff b5 1c fd ff
	ff		 push	 DWORD PTR tv1342[ebp]
  00a77	56		 push	 esi
  00a78	57		 push	 edi
  00a79	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DLNNNFPM@SysStatus?5?9?5Running?5for?5?$CF02llu?3@
  00a7e	68 03 01 00 00	 push	 259			; 00000103H
  00a83	50		 push	 eax
  00a84	e8 00 00 00 00	 call	 __snprintf
  00a89	83 c4 28	 add	 esp, 40			; 00000028H

; 3412 :             SetWindowText(ghWnd, (LPCTSTR)wndText);

  00a8c	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR _wndText$[ebp]
  00a92	50		 push	 eax
  00a93	ff 35 00 00 00
	00		 push	 DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00a99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextA@8
$LN41@WinMain:

; 3413 :         }
; 3414 : 
; 3415 :         //check de log file size
; 3416 :         CheckLogFileSize(dwLogSize);

  00a9f	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR _dwLogSize$1$[ebp]
  00aa5	e8 00 00 00 00	 call	 ?CheckLogFileSize@@YAXK@Z ; CheckLogFileSize

; 3417 : 
; 3418 :         //set timer for next checking
; 3419 :         ui64Wait = SysTick() + dwTimer;

  00aaa	e8 00 00 00 00	 call	 ?SysTick@@YA_KXZ	; SysTick
  00aaf	03 85 10 fd ff
	ff		 add	 eax, DWORD PTR _dwTimer$1$[ebp]
  00ab5	8b ca		 mov	 ecx, edx
  00ab7	83 d1 00	 adc	 ecx, 0
  00aba	89 8d 30 fd ff
	ff		 mov	 DWORD PTR _ui64Wait$2$[ebp], ecx

; 3420 :     }   //END: while(_thGetInt(&gbTerminate)==FALSE && bRunOnce==false)

  00ac0	e9 4d fb ff ff	 jmp	 $LN654@WinMain
$LN3@WinMain:

; 3421 : 
; 3422 :     //wait for WMI Ascii thread completion
; 3423 :     if (hThreadWMI)

  00ac5	8b 8d 24 fd ff
	ff		 mov	 ecx, DWORD PTR _hThreadWMI$[ebp]
  00acb	85 c9		 test	 ecx, ecx
  00acd	74 48		 je	 SHORT $LN645@WinMain

; 3424 :     {
; 3425 :         if (bRunOnce)

  00acf	84 c0		 test	 al, al
  00ad1	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__WaitForSingleObject@8
  00ad6	74 15		 je	 SHORT $LN43@WinMain

; 3426 :         {
; 3427 :             //wait until it is completed
; 3428 :             WaitForSingleObject(hThreadWMI, INFINITE);

  00ad8	6a ff		 push	 -1
  00ada	51		 push	 ecx
  00adb	ff d0		 call	 eax

; 3438 :             }
; 3439 :         }
; 3440 :         CloseHandle(hThreadWMI);

  00add	ff b5 24 fd ff
	ff		 push	 DWORD PTR _hThreadWMI$[ebp]
  00ae3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00ae9	ff d6		 call	 esi
  00aeb	eb 30		 jmp	 SHORT $LN42@WinMain
$LN43@WinMain:

; 3429 :         }
; 3430 :         else
; 3431 :         {
; 3432 :             //quickly wait while the thread has not completed
; 3433 :             //and, when timeout is completed, force terminate
; 3434 :             //the WMI thread if the thread is still runing
; 3435 :             if (WaitForSingleObject(hThreadWMI, (MINUTE * 10)) == WAIT_TIMEOUT)

  00aed	68 c0 27 09 00	 push	 600000			; 000927c0H
  00af2	51		 push	 ecx
  00af3	ff d0		 call	 eax
  00af5	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00afa	75 0b		 jne	 SHORT $LN45@WinMain

; 3436 :             {
; 3437 :                 EndPendingThread(hThreadWMI);

  00afc	8b 8d 24 fd ff
	ff		 mov	 ecx, DWORD PTR _hThreadWMI$[ebp]
  00b02	e8 00 00 00 00	 call	 ?EndPendingThread@@YAXPAX@Z ; EndPendingThread
$LN45@WinMain:

; 3438 :             }
; 3439 :         }
; 3440 :         CloseHandle(hThreadWMI);

  00b07	ff b5 24 fd ff
	ff		 push	 DWORD PTR _hThreadWMI$[ebp]
  00b0d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00b13	ff d6		 call	 esi
  00b15	eb 06		 jmp	 SHORT $LN42@WinMain
$LN645@WinMain:

; 3421 : 
; 3422 :     //wait for WMI Ascii thread completion
; 3423 :     if (hThreadWMI)

  00b17	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
$LN42@WinMain:

; 3441 :     }
; 3442 : 
; 3443 :     //get unchangeable system information
; 3444 :     GetSystemDetails();

  00b1d	e8 00 00 00 00	 call	 ?GetSystemDetails@@YAXXZ ; GetSystemDetails

; 3445 : 
; 3446 :     //get runtime changeable system information
; 3447 :     GetSystemStatusChanges();

  00b22	e8 00 00 00 00	 call	 ?GetSystemStatusChanges@@YAXXZ ; GetSystemStatusChanges

; 3448 : 
; 3449 :     //get IPs if possible
; 3450 :     GetSystemIPAddresses(&monIps, bMonIps);

  00b27	8a 95 3f fd ff
	ff		 mov	 dl, BYTE PTR _bMonIps$1$[ebp]
  00b2d	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp]
  00b33	e8 00 00 00 00	 call	 ?GetSystemIPAddresses@@YAXPAVMonitorIPs@@_N@Z ; GetSystemIPAddresses

; 3451 : 
; 3452 :     //get system information
; 3453 :     GetSystemStatus();

  00b38	e8 00 00 00 00	 call	 ?GetSystemStatus@@YAXXZ	; GetSystemStatus

; 3454 : 
; 3455 :     if (bRunWMI || bRunOnce)

  00b3d	80 bd 42 fd ff
	ff 00		 cmp	 BYTE PTR _bRunWMI$1$[ebp], 0
  00b44	75 09		 jne	 SHORT $LN47@WinMain
  00b46	80 bd 41 fd ff
	ff 00		 cmp	 BYTE PTR _bRunOnce$1$[ebp], 0
  00b4d	74 05		 je	 SHORT $LN46@WinMain
$LN47@WinMain:

; 3456 :     {
; 3457 :         //get WMI status information
; 3458 :         GetWMIStatus();

  00b4f	e8 00 00 00 00	 call	 ?GetWMIStatus@@YAXXZ	; GetWMIStatus
$LN46@WinMain:

; 3459 :     }
; 3460 : 
; 3461 :     //Close window
; 3462 :     if (ghWnd)

  00b54	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00b59	85 c0		 test	 eax, eax
  00b5b	74 42		 je	 SHORT $LN643@WinMain

; 3463 :     {
; 3464 :         PostMessage(ghWnd, TERMINATE_WINDOW_MSG, 0, 0);

  00b5d	6a 00		 push	 0
  00b5f	6a 00		 push	 0
  00b61	68 e8 07 00 00	 push	 2024			; 000007e8H
  00b66	50		 push	 eax
  00b67	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageA@16

; 3465 :         Log(LOG_DEBUG, __LINE__, "-- WinMain, Wait ThrdMsg %u", WaitForSingleObject(hThreadMSG, MINUTE));

  00b6d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
  00b73	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00b78	ff b5 0c fd ff
	ff		 push	 DWORD PTR _hThreadMSG$[ebp]
  00b7e	ff d7		 call	 edi
  00b80	50		 push	 eax
  00b81	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DDANBCKI@?9?9?5WinMain?0?5Wait?5ThrdMsg?5?$CFu@
  00b86	68 89 0d 00 00	 push	 3465			; 00000d89H
  00b8b	6a 10		 push	 16			; 00000010H
  00b8d	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00b92	83 c4 10	 add	 esp, 16			; 00000010H

; 3466 :         CloseHandle(hThreadMSG);

  00b95	ff b5 0c fd ff
	ff		 push	 DWORD PTR _hThreadMSG$[ebp]
  00b9b	ff d6		 call	 esi
  00b9d	eb 06		 jmp	 SHORT $LN48@WinMain
$LN643@WinMain:

; 3459 :     }
; 3460 : 
; 3461 :     //Close window
; 3462 :     if (ghWnd)

  00b9f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WaitForSingleObject@8
$LN48@WinMain:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00ba5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00baa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00bb0	2b c1		 sub	 eax, ecx
  00bb2	c1 f8 02	 sar	 eax, 2
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3470 :     if (PendingThreads.size() > 0)

  00bb5	85 c0		 test	 eax, eax
  00bb7	74 74		 je	 SHORT $LN49@WinMain

; 3472 :         for (unsigned int u = 0; u < PendingThreads.size(); u++)

  00bb9	33 f6		 xor	 esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1750 : 		if (size() <= _Pos)

  00bbb	3b c6		 cmp	 eax, esi
  00bbd	0f 86 bc 01 00
	00		 jbe	 $LN631@WinMain
$LN656@WinMain:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3474 :             if (WaitForSingleObject(PendingThreads.at(u), (MILLISECOND * 2)) == WAIT_TIMEOUT)

  00bc3	6a 02		 push	 2
  00bc5	ff 34 b1	 push	 DWORD PTR [ecx+esi*4]
  00bc8	ff d7		 call	 edi
  00bca	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00bcf	75 20		 jne	 SHORT $LN50@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00bd1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00bd6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00bdc	2b c1		 sub	 eax, ecx
  00bde	c1 f8 02	 sar	 eax, 2

; 1750 : 		if (size() <= _Pos)

  00be1	3b c6		 cmp	 eax, esi
  00be3	0f 86 96 01 00
	00		 jbe	 $LN631@WinMain
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3476 :                 EndPendingThread(PendingThreads.at(u));

  00be9	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00bec	e8 00 00 00 00	 call	 ?EndPendingThread@@YAXPAX@Z ; EndPendingThread
$LN50@WinMain:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00bf1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00bf6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00bfc	2b c1		 sub	 eax, ecx
  00bfe	c1 f8 02	 sar	 eax, 2

; 1750 : 		if (size() <= _Pos)

  00c01	3b c6		 cmp	 eax, esi
  00c03	0f 86 76 01 00
	00		 jbe	 $LN631@WinMain
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3478 :             CloseHandle(PendingThreads.at(u));

  00c09	ff 34 b1	 push	 DWORD PTR [ecx+esi*4]
  00c0c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00c12	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3472 :         for (unsigned int u = 0; u < PendingThreads.size(); u++)

  00c17	46		 inc	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00c18	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00c1e	2b c1		 sub	 eax, ecx
  00c20	c1 f8 02	 sar	 eax, 2
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3472 :         for (unsigned int u = 0; u < PendingThreads.size(); u++)

  00c23	3b c6		 cmp	 eax, esi
  00c25	77 9c		 ja	 SHORT $LN656@WinMain
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1592 : 		this->_Mylast() = this->_Myfirst();

  00c27	89 0d 04 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, ecx
$LN49@WinMain:
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3483 :     SetUnhandledExceptionFilter(pPreviousExceptionFilter);

  00c2d	ff b5 08 fd ff
	ff		 push	 DWORD PTR _pPreviousExceptionFilter$1$[ebp]
  00c33	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 3484 :     LogElapsedTime(__LINE__, gTickStart, "SysStatus");

  00c39	ff 35 04 00 00
	00		 push	 DWORD PTR ?gTickStart@@3_KA+4
  00c3f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_09KECABMHK@SysStatus@
  00c44	b9 9c 0d 00 00	 mov	 ecx, 3484		; 00000d9cH
  00c49	ff 35 00 00 00
	00		 push	 DWORD PTR ?gTickStart@@3_KA
  00c4f	e8 00 00 00 00	 call	 ?LogElapsedTime@@YAXK_KPBD@Z ; LogElapsedTime
  00c54	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono

; 800  : 		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot

  00c57	e8 00 00 00 00	 call	 __Query_perf_frequency
  00c5c	8b f8		 mov	 edi, eax
  00c5e	8b f2		 mov	 esi, edx
  00c60	89 bd 20 fd ff
	ff		 mov	 DWORD PTR __Freq$2$[ebp], edi
  00c66	89 b5 08 fd ff
	ff		 mov	 DWORD PTR __Freq$1$[ebp], esi

; 801  : 		const long long _Ctr = _Query_perf_counter();

  00c6c	e8 00 00 00 00	 call	 __Query_perf_counter

; 802  : 		static_assert(period::num == 1, "This assumes period::num == 1.");
; 803  : 		const long long _Whole = (_Ctr / _Freq) * period::den;

  00c71	53		 push	 ebx
  00c72	56		 push	 esi
  00c73	57		 push	 edi
  00c74	52		 push	 edx
  00c75	50		 push	 eax
  00c76	e8 00 00 00 00	 call	 __alldvrm
  00c7b	8b fb		 mov	 edi, ebx
  00c7d	5b		 pop	 ebx
  00c7e	6a 00		 push	 0
  00c80	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c85	52		 push	 edx
  00c86	50		 push	 eax
  00c87	8b f1		 mov	 esi, ecx
  00c89	e8 00 00 00 00	 call	 __allmul

; 804  : 		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;

  00c8e	6a 00		 push	 0
  00c90	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c95	57		 push	 edi
  00c96	56		 push	 esi
  00c97	89 85 38 fd ff
	ff		 mov	 DWORD PTR __end_$1$[ebp], eax
  00c9d	89 95 28 fd ff
	ff		 mov	 DWORD PTR __end_$2$[ebp], edx
  00ca3	e8 00 00 00 00	 call	 __allmul
  00ca8	ff b5 08 fd ff
	ff		 push	 DWORD PTR __Freq$1$[ebp]
  00cae	ff b5 20 fd ff
	ff		 push	 DWORD PTR __Freq$2$[ebp]
  00cb4	52		 push	 edx
  00cb5	50		 push	 eax
  00cb6	e8 00 00 00 00	 call	 __alldiv
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3486 :     auto const _end_ = static_cast<uint64_t>(std::chrono::steady_clock::now().time_since_epoch().count() - _start_);

  00cbb	8b b5 38 fd ff
	ff		 mov	 esi, DWORD PTR __end_$1$[ebp]
  00cc1	2b b5 d4 fc ff
	ff		 sub	 esi, DWORD PTR $T3[ebp]
  00cc7	8b 8d 28 fd ff
	ff		 mov	 ecx, DWORD PTR __end_$2$[ebp]
  00ccd	1b 8d d0 fc ff
	ff		 sbb	 ecx, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono

; 210  : 		: _MyDur(_Other)

  00cd3	03 f0		 add	 esi, eax
  00cd5	13 d1		 adc	 edx, ecx
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3487 :     Log(LOG_MESSAGE, __LINE__, "%.9f s", (static_cast<double>(_end_) / 1'000'000'000));

  00cd7	8b ce		 mov	 ecx, esi
  00cd9	e8 00 00 00 00	 call	 __ultod3
  00cde	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@41cdcd6500000000
  00ce6	83 ec 08	 sub	 esp, 8
  00ce9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00cee	68 00 00 00 00	 push	 OFFSET ??_C@_06EMJDEMAB@?$CF?49f?5s@
  00cf3	68 9f 0d 00 00	 push	 3487			; 00000d9fH
  00cf8	6a 01		 push	 1
  00cfa	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00cff	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\users\giulif\downloads\study\git\sysstatus\monitorips.h

; 55   :     {

  00d02	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 56   :         if (m_hWait) static_cast<void>(UnregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE));

  00d09	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _monIps$[ebp+4]
  00d0f	85 c0		 test	 eax, eax
  00d11	74 09		 je	 SHORT $LN620@WinMain
  00d13	6a ff		 push	 -1
  00d15	50		 push	 eax
  00d16	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterWaitEx@8
$LN620@WinMain:

; 57   :         if (m_o.hEvent) CloseHandle(m_o.hEvent);

  00d1c	8b 85 f0 fc ff
	ff		 mov	 eax, DWORD PTR _monIps$[ebp+24]
  00d22	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseHandle@4
  00d28	85 c0		 test	 eax, eax
  00d2a	74 03		 je	 SHORT $LN621@WinMain
  00d2c	50		 push	 eax
  00d2d	ff d6		 call	 esi
$LN621@WinMain:

; 58   :         if (m_hSync) CloseHandle(m_hSync);

  00d2f	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _monIps$[ebp]
  00d35	85 c0		 test	 eax, eax
  00d37	74 03		 je	 SHORT $LN622@WinMain
  00d39	50		 push	 eax
  00d3a	ff d6		 call	 esi
$LN622@WinMain:

; 59   : 
; 60   :         Log(LOG_DEBUG, __LINE__, "<< MonIPs");

  00d3c	68 00 00 00 00	 push	 OFFSET ??_C@_09CLAHNHIH@?$DM?$DM?5MonIPs@
  00d41	6a 3c		 push	 60			; 0000003cH
  00d43	6a 10		 push	 16			; 00000010H
  00d45	e8 00 00 00 00	 call	 ?Log@@YAXHHPBDZZ	; Log
  00d4a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   :     }

  00d4d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 894  : 		_Tidy();

  00d54	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp+28]
  00d5a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File c:\users\giulif\downloads\study\git\sysstatus\sysstatus.cpp

; 3488 :     return 0;

  00d5f	33 c0		 xor	 eax, eax

; 3489 : }

  00d61	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00d64	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00d6b	59		 pop	 ecx
  00d6c	5f		 pop	 edi
  00d6d	5e		 pop	 esi
  00d6e	5b		 pop	 ebx
  00d6f	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d72	33 cd		 xor	 ecx, ebp
  00d74	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d79	8b e5		 mov	 esp, ebp
  00d7b	5d		 pop	 ebp
  00d7c	c2 10 00	 ret	 16			; 00000010H
$LN631@WinMain:
  00d7f	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xrange
$LN422@WinMain:
  00d84	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN658@WinMain:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d89	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN649@WinMain:
  00d8e	cc		 int	 3
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$_WinMain@16$0:
  00000	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_WinMain@16$1:
  0000b	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_WinMain@16$4:
  00016	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp+28]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$_WinMain@16$2:
  00021	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1MonitorIPs@@QAE@XZ	; MonitorIPs::~MonitorIPs
__unwindfunclet$_WinMain@16$3:
  0002c	8d 8d 44 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_WinMain@16$5:
  00037	8d 8d f4 fc ff
	ff		 lea	 ecx, DWORD PTR _monIps$[ebp+28]
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$_WinMain@16:
  00042	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00046	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00049	8b 8a c4 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-828]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_WinMain@16
  00065	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_WinMain@16 ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ
_TEXT	SEGMENT
?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::data, COMDAT
; _this$ = ecx

; 1609 : 		return (_Unfancy_maybe_null(this->_Myfirst()));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1610 : 		}

  00002	c3		 ret	 0
?data@?$vector@EV?$allocator@E@std@@@std@@QAEPAEXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 3d		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002e	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00030	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00036	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00038	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00040	83 c0 fc	 add	 eax, -4			; fffffffcH
  00043	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00046	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00048	8b c2		 mov	 eax, edx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004a	51		 push	 ecx
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00051	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00054	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005a	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00061	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  00068	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00072	59		 pop	 ecx
  00073	5e		 pop	 esi
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00078	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  0007d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from _Count * _Ty(), optional allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
  00030	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]

; 1873 : 		this->_Myfirst() = pointer();

  00033	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1874 : 		this->_Mylast() = pointer();

  00039	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1875 : 		this->_Myend() = pointer();

  00040	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 1876 : 
; 1877 : 		if (_Newcapacity == 0)

  00047	85 db		 test	 ebx, ebx
  00049	74 6e		 je	 SHORT $LN7@vector

; 1878 : 			{
; 1879 : 			return (false);
; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

  0004b	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00051	0f 87 89 00 00
	00		 ja	 $LN142@vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00057	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0005d	72 25		 jb	 SHORT $LN62@vector

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0005f	8d 43 23	 lea	 eax, DWORD PTR [ebx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00062	83 c9 ff	 or	 ecx, -1
  00065	3b c3		 cmp	 eax, ebx
  00067	0f 46 c1	 cmovbe	 eax, ecx

; 52   : 		return (::operator new(_Bytes));

  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00070	83 c4 04	 add	 esp, 4

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00073	8b c8		 mov	 ecx, eax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00075	85 c9		 test	 ecx, ecx
  00077	74 6c		 je	 SHORT $LN71@vector

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00079	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0007c	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0007f	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00082	eb 09		 jmp	 SHORT $LN61@vector
$LN62@vector:

; 52   : 		return (::operator new(_Bytes));

  00084	53		 push	 ebx
  00085	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0008a	83 c4 04	 add	 esp, 4
$LN61@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  0008d	89 07		 mov	 DWORD PTR [edi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  0008f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00092	03 c3		 add	 eax, ebx
  00094	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 662  : 		if (_Buy(_Count))
; 663  : 			{	// nonzero, fill it
; 664  : 			_TRY_BEGIN

  00097	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 665  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

  0009e	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  000a0	8d 34 18	 lea	 esi, DWORD PTR [eax+ebx]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000a3	53		 push	 ebx
  000a4	6a 00		 push	 0
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 _memset
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 665  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

  000af	89 77 04	 mov	 DWORD PTR [edi+4], esi
  000b2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@vector:

; 671  : 		}

  000b9	8b c7		 mov	 eax, edi
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c5	59		 pop	 ecx
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 08 00	 ret	 8
__catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z$0:

; 666  : 			_CATCH_ALL
; 667  : 			_Tidy();

  000cf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 668  : 			_RERAISE;

  000d7	6a 00		 push	 0
  000d9	6a 00		 push	 0
  000db	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN142@vector:

; 1884 : 			_Xlength();

  000e0	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN71@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000e5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN140@vector:
  000ea	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@EV?$allocator@E@std@@@std@@QAE@IABV?$allocator@E@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@E@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@E@std@@QAE@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@E@std@@QAE@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?at@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z PROC ; std::vector<void *,std::allocator<void *> >::at, COMDAT
; _this$dead$ = ecx

; 1749 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00003	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00008	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  0000e	2b c1		 sub	 eax, ecx

; 1750 : 		if (size() <= _Pos)

  00010	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00013	c1 f8 02	 sar	 eax, 2

; 1750 : 		if (size() <= _Pos)

  00016	3b c2		 cmp	 eax, edx
  00018	76 07		 jbe	 SHORT $LN26@at

; 1753 : 			}
; 1754 : 
; 1755 : 		return (this->_Myfirst()[_Pos]);

  0001a	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 1756 : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN26@at:

; 1751 : 			{
; 1752 : 			_Xrange();

  00021	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xrange
$LN24@at:
  00026	cc		 int	 3
?at@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z PROC ; std::vector<void *,std::allocator<void *> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1737 : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ PROC ; std::vector<void *,std::allocator<void *> >::clear, COMDAT
; _this$dead$ = ecx

; 1590 : 		this->_Orphan_all();
; 1591 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1592 : 		this->_Mylast() = this->_Myfirst();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00005	a3 04 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, eax

; 1593 : 		}

  0000a	c3		 ret	 0
?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::push_back, COMDAT
; _this$dead$ = ecx

; 931  : 		{	// insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1726 : 		return (this->_Myend() != this->_Mylast());

  00003	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00009	39 0d 08 00 00
	00		 cmp	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, ecx

; 917  : 		if (_Has_unused_capacity())

  0000f	74 12		 je	 SHORT $LN4@push_back
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00011	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 905  : 		++this->_Mylast();

  00018	83 05 04 00 00
	00 04		 add	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, 4

; 932  : 		emplace_back(_Val);
; 933  : 		}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN4@push_back:

; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

  00023	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>

; 932  : 		emplace_back(_Val);
; 933  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$emplace_back@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABQAX@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::emplace_back<void * const &>, COMDAT
; _this$dead$ = ecx

; 916  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1726 : 		return (this->_Myend() != this->_Mylast());

  00003	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00009	39 0d 08 00 00
	00		 cmp	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, ecx

; 917  : 		if (_Has_unused_capacity())

  0000f	74 19		 je	 SHORT $LN2@emplace_ba
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00011	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 904  : 		_Ty& _Result = *this->_Mylast();

  00018	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4

; 905  : 		++this->_Mylast();

  0001d	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00020	89 0d 04 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, ecx

; 923  : #if _HAS_CXX17
; 924  : 		return (_Result);
; 925  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 926  : 		(void)_Result;
; 927  : #endif /* _HAS_CXX17 */
; 928  : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@emplace_ba:

; 918  : 			{
; 919  : 			return (_Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...));
; 920  : 			}
; 921  : 
; 922  : 		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), _STD forward<_Valty>(_Val)...);

  0002a	ff 75 08	 push	 DWORD PTR _<_Val_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>

; 923  : #if _HAS_CXX17
; 924  : 		return (_Result);
; 925  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 926  : 		(void)_Result;
; 927  : #endif /* _HAS_CXX17 */
; 928  : 		}

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??$emplace_back@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@ABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::emplace_back<void * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE@ABQAX@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE@ABQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::_Emplace_back_with_unused_capacity<void * const &>, COMDAT
; _this$dead$ = ecx

; 900  : 		{	// insert by perfectly forwarding into element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 904  : 		_Ty& _Result = *this->_Mylast();

  0000f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4

; 905  : 		++this->_Mylast();

  00014	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00017	89 0d 04 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, ecx

; 906  : #if _HAS_CXX17
; 907  : 		return (_Result);
; 908  : #else /* ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv */
; 909  : 		(void)_Result;
; 910  : #endif /* _HAS_CXX17 */
; 911  : 		}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE@ABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Emplace_back_with_unused_capacity<void * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ PROC	; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	85 c0		 test	 eax, eax
  00029	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002e	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00030	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00033	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00039	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00041	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00043	83 c0 fc	 add	 eax, -4			; fffffffcH
  00046	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00049	77 30		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004b	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004d	52		 push	 edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00054	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00057	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005d	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00064	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:

; 895  : 		}

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5e		 pop	 esi
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@vector:
  00080	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ENDP	; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Count$dead$ = 8					; size = 4
__Al$dead$ = 12						; size = 4
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z PROC ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from _Count * _Ty(), optional allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f9		 mov	 edi, ecx
  0002d	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi

; 1873 : 		this->_Myfirst() = pointer();

  00030	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1874 : 		this->_Mylast() = pointer();

  00036	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1875 : 		this->_Myend() = pointer();

  0003d	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 52   : 		return (::operator new(_Bytes));

  00044	68 43 4e 00 00	 push	 20035			; 00004e43H
  00049	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004e	83 c4 04	 add	 esp, 4

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00051	8b c8		 mov	 ecx, eax

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00053	85 c9		 test	 ecx, ecx
  00055	74 55		 je	 SHORT $LN72@vector

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00057	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0005a	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0005d	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00060	89 07		 mov	 DWORD PTR [edi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  00062	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00065	05 20 4e 00 00	 add	 eax, 20000		; 00004e20H
  0006a	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 662  : 		if (_Buy(_Count))
; 663  : 			{	// nonzero, fill it
; 664  : 			_TRY_BEGIN

  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 665  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

  00074	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00076	8d b0 20 4e 00
	00		 lea	 esi, DWORD PTR [eax+20000]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0007c	68 20 4e 00 00	 push	 20000			; 00004e20H
  00081	6a 00		 push	 0
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _memset
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 665  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

  0008c	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0008f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 669  : 			_CATCH_END
; 670  : 			}
; 671  : 		}

  00096	8b c7		 mov	 eax, edi
  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a2	59		 pop	 ecx
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 08 00	 ret	 8
$LN72@vector:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000ac	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
__catch$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z$0:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 667  : 			_Tidy();

  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 668  : 			_RERAISE;

  000b9	6a 00		 push	 0
  000bb	6a 00		 push	 0
  000bd	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN141@vector:
  000c2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@IABV?$allocator@PAX@1@@Z ENDP ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ PROC	; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >, COMDAT
; _this$dead$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A, 0

; 652  : 		}

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A ; PendingThreads

; 390  : 		_Mylast(),

  0000f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, 0

; 391  : 		_Myend()

  00019	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, 0

; 652  : 		}

  00023	c3		 ret	 0
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ENDP	; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@PAX@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAX@std@@QAE@XZ PROC			; std::allocator<void *>::allocator<void *>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@PAX@std@@QAE@XZ ENDP			; std::allocator<void *>::allocator<void *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
;	COMDAT ?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch, COMDAT
; _this$ = ecx

; 222  : 		{	// get duration from epoch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 223  : 		return (_MyDur);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 10		 mov	 DWORD PTR [eax], edx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 224  : 		}

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
?time_since_epoch@?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QBE?AV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_since_epoch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; _this$ = ecx

; 211  : 		{	// construct from a duration

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 210  : 		: _MyDur(_Other)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Other$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 212  : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QAE@ABV?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@12@@Z ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
;	COMDAT ?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ
_TEXT	SEGMENT
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count, COMDAT
; _this$ = ecx

; 104  : 		return (_MyRep);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 105  : 		}

  00005	c3		 ret	 0
?count@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QBE_JXZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at, COMDAT
; _this$ = ecx

; 1749 : 		{	// subscript mutable sequence with checking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00004	8b 31		 mov	 esi, DWORD PTR [ecx]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000e	2b ce		 sub	 ecx, esi
  00010	f7 e9		 imul	 ecx

; 1750 : 		if (size() <= _Pos)

  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00015	c1 fa 02	 sar	 edx, 2
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx

; 1750 : 		if (size() <= _Pos)

  0001f	3b c1		 cmp	 eax, ecx
  00021	76 0b		 jbe	 SHORT $LN26@at

; 1753 : 			}
; 1754 : 
; 1755 : 		return (this->_Myfirst()[_Pos]);

  00023	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00026	8d 04 c6	 lea	 eax, DWORD PTR [esi+eax*8]
  00029	5e		 pop	 esi

; 1756 : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN26@at:

; 1751 : 			{
; 1752 : 			_Xrange();

  0002e	e8 00 00 00 00	 call	 ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
$LN24@at:
  00033	cc		 int	 3
?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1689 : 		return (this->_Mylast());

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1690 : 		}

  00003	c3		 ret	 0
?_Unchecked_end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1679 : 		return (this->_Myfirst());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1680 : 		}

  00002	c3		 ret	 0
?_Unchecked_begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
__Right$ = 8						; size = 4
??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=, COMDAT
; _this$ = ecx

; 1399 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1400 : 		if (this != _STD addressof(_Right))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 0d		 je	 SHORT $LN41@operator

; 1390 : 		_Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0000d	ff 75 08	 push	 DWORD PTR $T1[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	e8 00 00 00 00	 call	 ??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
$LN41@operator:

; 1401 : 			{	// different, assign it
; 1402 : #pragma warning(push)
; 1403 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1404 : 			if (_Alty_traits::propagate_on_container_copy_assignment::value
; 1405 : 				&& this->_Getal() != _Right._Getal())
; 1406 : 				{	// reload array
; 1407 : 				_Tidy();
; 1408 : 				}
; 1409 : #pragma warning(pop)
; 1410 : 
; 1411 : 			this->_Copy_alloc(_Right._Getal());
; 1412 : 
; 1413 : 			assign(_Right._Myfirst(), _Right._Mylast());
; 1414 : 			}
; 1415 : 
; 1416 : 		return (*this);
; 1417 : 		}

  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??4?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 894  : 		_Tidy();

  00022	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 895  : 		}

  00027	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00031	59		 pop	 ecx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 789  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 765  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]

; 389  : 		: _Myfirst(),

  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 390  : 		_Mylast(),

  0000c	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  00013	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 765  : 		this->_Myfirst() = _Right._Myfirst();

  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 01		 mov	 DWORD PTR [ecx], eax

; 766  : 		this->_Mylast() = _Right._Mylast();

  0001e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00021	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 767  : 		this->_Myend() = _Right._Myend();

  00024	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00027	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 790  : 		_Move_from(_STD move(_Right), true_type{});
; 791  : 		}

  0002a	8b c1		 mov	 eax, ecx

; 769  : 		_Right._Myfirst() = pointer();

  0002c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 770  : 		_Right._Mylast() = pointer();

  00032	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 771  : 		_Right._Myend() = pointer();

  00039	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 790  : 		_Move_from(_STD move(_Right), true_type{});
; 791  : 		}

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 1815 : 		if (_Large_string_engaged())

  00004	72 03		 jb	 SHORT $LN14@c_str

; 3280 : 		return (this->_Get_data()._Myptr());

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3281 : 		}

  00008	c3		 ret	 0
$LN14@c_str:

; 3280 : 		return (this->_Get_data()._Myptr());

  00009	8b c1		 mov	 eax, ecx

; 3281 : 		}

  0000b	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Result$1$ = 8						; size = 4
$T1 = 8							; size = 1
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2537 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 2538 : 		auto& _Right_data = _Right._Get_data();
; 2539 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	57		 push	 edi

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0000b	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2538 : 		auto& _Right_data = _Right._Get_data();
; 2539 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0000f	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]

; 1815 : 		if (_Large_string_engaged())

  00012	72 02		 jb	 SHORT $LN8@append
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN8@append:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2572 : 		if (_Count <= _My_data._Myres - _Old_size)

  00016	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  00019	8b c2		 mov	 eax, edx
  0001b	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  0001e	2b c3		 sub	 eax, ebx
  00020	3b f8		 cmp	 edi, eax
  00022	77 35		 ja	 SHORT $LN15@append

; 1803 : 		value_type * _Result = _Bx._Buf;

  00024	89 75 08	 mov	 DWORD PTR __Result$1$[ebp], esi

; 2574 : 			_My_data._Mysize = _Old_size + _Count;

  00027	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0002a	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  0002d	8b c6		 mov	 eax, esi

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0002f	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

  00032	72 05		 jb	 SHORT $LN22@append
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	89 45 08	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN22@append:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00039	57		 push	 edi
  0003a	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2576 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0003b	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2577 : 			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Result$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2577 : 			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004a	03 cf		 add	 ecx, edi

; 2538 : 		auto& _Right_data = _Right._Get_data();
; 2539 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0004c	8b c6		 mov	 eax, esi
  0004e	5f		 pop	 edi

; 2540 : 		}

  0004f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00050	c6 04 19 00	 mov	 BYTE PTR [ecx+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2540 : 		}

  00054	5b		 pop	 ebx
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN15@append:

; 2581 : 		return (_Reallocate_grow_by(_Count,

  00059	57		 push	 edi
  0005a	51		 push	 ecx
  0005b	c6 45 08 00	 mov	 BYTE PTR $T1[ebp], 0
  0005f	8b ce		 mov	 ecx, esi
  00061	ff 75 08	 push	 DWORD PTR $T1[ebp]
  00064	57		 push	 edi
  00065	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
  0006a	5f		 pop	 edi

; 2540 : 		}

  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2526 : 		{	// append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2528 : 		}

  00003	5d		 pop	 ebp

; 2527 : 		return (append(_Ptr));

  00004	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2512 : 		{	// append _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2514 : 		}

  00003	5d		 pop	 ebp

; 2513 : 		return (append(_Right));

  00004	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2497 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2497 : 		{	// assign [_Ptr, <null>)

  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0000f	90		 npad	 1
$LL9@operator:
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	40		 inc	 eax
  00013	84 c9		 test	 cl, cl
  00015	75 f9		 jne	 SHORT $LL9@operator
  00017	2b c7		 sub	 eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00019	8b ce		 mov	 ecx, esi
  0001b	50		 push	 eax
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2498 : 		return (assign(_Ptr));

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 2499 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2183 : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	8b c2		 mov	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2183 : 		{	// construct from [_Ptr, <null>)

  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 462  : 		return (__builtin_strlen(_First));

  0000c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 3976 : 		_My_data._Mysize = 0;

  0000f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00016	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0001d	c6 06 00	 mov	 BYTE PTR [esi], 0
$LL25@basic_stri:

; 462  : 		return (__builtin_strlen(_First));

  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL25@basic_stri
  00027	2b c7		 sub	 eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00029	8b ce		 mov	 ecx, esi
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2184 : 		_Tidy_init();
; 2185 : 		assign(_Ptr);
; 2186 : 		}

  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00046	5e		 pop	 esi
  00047	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  0004d	cc		 int	 3
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Buy@?$vector@EV?$allocator@E@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@EV?$allocator@E@std@@@std@@AAE_NI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy, COMDAT
; _this$ = ecx

; 1872 : 		{	// allocate array with _Newcapacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1873 : 		this->_Myfirst() = pointer();
; 1874 : 		this->_Mylast() = pointer();
; 1875 : 		this->_Myend() = pointer();
; 1876 : 
; 1877 : 		if (_Newcapacity == 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR __Newcapacity$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00010	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00017	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  0001e	85 f6		 test	 esi, esi
  00020	75 08		 jne	 SHORT $LN2@Buy

; 1878 : 			{
; 1879 : 			return (false);

  00022	5f		 pop	 edi
  00023	32 c0		 xor	 al, al

; 1892 : 		}

  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN2@Buy:

; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

  0002a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00030	77 58		 ja	 SHORT $LN97@Buy
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00032	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00038	72 35		 jb	 SHORT $LN44@Buy

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0003a	8d 46 23	 lea	 eax, DWORD PTR [esi+35]

; 94   : 	if (_Block_size <= _Bytes)

  0003d	83 c9 ff	 or	 ecx, -1
  00040	3b c6		 cmp	 eax, esi
  00042	0f 46 c1	 cmovbe	 eax, ecx

; 52   : 		return (::operator new(_Bytes));

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0004b	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  0004d	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00050	85 c9		 test	 ecx, ecx
  00052	74 3b		 je	 SHORT $LN53@Buy

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00054	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00057	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0005a	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  0005d	89 07		 mov	 DWORD PTR [edi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  0005f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00062	03 c6		 add	 eax, esi
  00064	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1890 : 
; 1891 : 		return (true);

  00067	b0 01		 mov	 al, 1
  00069	5f		 pop	 edi

; 1892 : 		}

  0006a	5e		 pop	 esi
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN44@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 52   : 		return (::operator new(_Bytes));

  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00075	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00078	89 07		 mov	 DWORD PTR [edi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  0007a	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  0007d	03 c6		 add	 eax, esi
  0007f	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1890 : 
; 1891 : 		return (true);

  00082	b0 01		 mov	 al, 1
  00084	5f		 pop	 edi

; 1892 : 		}

  00085	5e		 pop	 esi
  00086	5d		 pop	 ebp
  00087	c2 04 00	 ret	 4
$LN97@Buy:

; 1883 : 			{
; 1884 : 			_Xlength();

  0008a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN53@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0008f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN95@Buy:
  00094	cc		 int	 3
?_Buy@?$vector@EV?$allocator@E@std@@@std@@AAE_NI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00007	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000b	57		 push	 edi
  0000c	6a 00		 push	 0
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 1813 : 		}

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?_Udefault@?$vector@EV?$allocator@E@std@@@std@@AAEPAEPAEI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$allocator@PAX@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$allocator@PAX@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$allocator@PAX@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >, COMDAT
; _this$dead$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A, 0

; 423  : 		}

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A ; PendingThreads

; 390  : 		_Mylast(),

  0000f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, 0

; 391  : 		_Myend()

  00019	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, 0

; 423  : 		}

  00023	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEXPAPAX0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$dead$ = 12					; size = 4
?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEXPAPAX0@Z PROC ; std::vector<void *,std::allocator<void *> >::_Orphan_range, COMDAT
; _this$dead$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEXPAPAX0@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xrange@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ PROC ; std::vector<void *,std::allocator<void *> >::_Xrange, COMDAT

; 1931 : 		_Xout_of_range("invalid vector<T> subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xrange:
  0000a	cc		 int	 3
?_Xrange@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXXZ PROC ; std::vector<void *,std::allocator<void *> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00035	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$dead$ = 8					; size = 4
?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE_NI@Z PROC ; std::vector<void *,std::allocator<void *> >::_Buy, COMDAT
; _this$ = ecx

; 1872 : 		{	// allocate array with _Newcapacity elements

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 52   : 		return (::operator new(_Bytes));

  00003	68 43 4e 00 00	 push	 20035			; 00004e43H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1873 : 		this->_Myfirst() = pointer();

  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1874 : 		this->_Mylast() = pointer();

  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1875 : 		this->_Myend() = pointer();

  00015	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 52   : 		return (::operator new(_Bytes));

  0001c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00021	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00023	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00026	85 c9		 test	 ecx, ecx
  00028	74 1c		 je	 SHORT $LN54@Buy

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0002a	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002d	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00030	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00033	89 06		 mov	 DWORD PTR [esi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  00035	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00038	05 20 4e 00 00	 add	 eax, 20000		; 00004e20H
  0003d	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1890 : 
; 1891 : 		return (true);

  00040	b0 01		 mov	 al, 1
  00042	5e		 pop	 esi

; 1892 : 		}

  00043	c2 04 00	 ret	 4
$LN54@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00046	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN96@Buy:
  0004b	cc		 int	 3
?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAE_NI@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX0@Z PROC ; std::vector<void *,std::allocator<void *> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX0@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAXI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?_Udefault@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAXI@Z PROC ; std::vector<void *,std::allocator<void *> >::_Udefault, COMDAT
; _this$dead$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	68 20 4e 00 00	 push	 20000			; 00004e20H
  0000c	6a 00		 push	 0
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memset
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00017	8d 86 20 4e 00
	00		 lea	 eax, DWORD PTR [esi+20000]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  0001d	5e		 pop	 esi

; 1813 : 		}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?_Udefault@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@ABE_NXZ
_TEXT	SEGMENT
?_Has_unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@ABE_NXZ PROC ; std::vector<void *,std::allocator<void *> >::_Has_unused_capacity, COMDAT
; _this$dead$ = ecx

; 1726 : 		return (this->_Myend() != this->_Mylast());

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8
  00005	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  0000b	0f 95 c0	 setne	 al

; 1727 : 		}

  0000e	c3		 ret	 0
?_Has_unused_capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@ABE_NXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 435  : 		_Pocca(_Getal(), _Al);
; 436  : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXABV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange, COMDAT

; 1931 : 		_Xout_of_range("invalid vector<T> subscript");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xrange:
  0000a	cc		 int	 3
?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 64		 je	 SHORT $LN2@Tidy

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00009	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00013	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001b	8b 3e		 mov	 edi, DWORD PTR [esi]

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  0001d	83 c4 04	 add	 esp, 4

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00020	2b cf		 sub	 ecx, edi
  00022	f7 e9		 imul	 ecx
  00024	c1 fa 02	 sar	 edx, 2
  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002c	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002e	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00031	c1 e1 03	 shl	 ecx, 3

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00034	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003a	72 12		 jb	 SHORT $LN74@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0003c	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  0003f	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00042	2b fa		 sub	 edi, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00044	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00047	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004a	77 23		 ja	 SHORT $LN71@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0004c	8b fa		 mov	 edi, edx
$LN74@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0004e	51		 push	 ecx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1919 : 			this->_Mylast() = pointer();

  0005e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00065	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006c	5f		 pop	 edi
$LN2@Tidy:

; 1922 : 		}

  0006d	5e		 pop	 esi
  0006e	c3		 ret	 0
$LN71@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN96@Tidy:
  00074	cc		 int	 3
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Move_from@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_from@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_from, COMDAT
; _this$ = ecx

; 762  : 		{	// move from _Right, stealing its contents

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 763  : 		this->_Swap_all(_Right);
; 764  : 
; 765  : 		this->_Myfirst() = _Right._Myfirst();

  00003	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax

; 766  : 		this->_Mylast() = _Right._Mylast();

  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 767  : 		this->_Myend() = _Right._Myend();

  00010	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 768  : 
; 769  : 		_Right._Myfirst() = pointer();

  00016	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 770  : 		_Right._Mylast() = pointer();

  0001c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 771  : 		_Right._Myend() = pointer();

  00023	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 772  : 		}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Move_from@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Move_from
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAPAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$allocator@E@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEAAV?$allocator@E@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z
_TEXT	SEGMENT
__First$dead$ = 8					; size = 4
__Last$dead$ = 12					; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$dead$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1716 : 		}

  00005	c3		 ret	 0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 27		 jb	 SHORT $LN6@allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0000e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00011	83 ca ff	 or	 edx, -1
  00014	3b c1		 cmp	 eax, ecx
  00016	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001f	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00021	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00024	85 c9		 test	 ecx, ecx
  00026	74 24		 je	 SHORT $LN15@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00028	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0002b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0002e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN6@allocate:

; 188  : 	if (_Bytes != 0)

  00035	85 c9		 test	 ecx, ecx
  00037	74 0d		 je	 SHORT $LN7@allocate

; 52   : 		return (::operator new(_Bytes));

  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003f	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
$LN7@allocate:

; 193  : 	return (nullptr);

  00046	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN15@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN26@allocate:
  00051	cc		 int	 3
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXQAEI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXQAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00009	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000f	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00011	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00014	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00021	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00023	51		 push	 ecx
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8

; 993  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  00036	cc		 int	 3
?deallocate@?$allocator@E@std@@QAEXQAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$allocator@PAX@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$allocator@PAX@2@XZ PROC ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$allocator@PAX@2@XZ ENDP ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABQAPAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAPAPAXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ PROC ; std::vector<void *,std::allocator<void *> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC ; std::vector<void *,std::allocator<void *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z PROC		; std::allocator<void *>::allocate, COMDAT
; _this$dead$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]

; 26   : 	if (_Max_possible < _Count)

  0000d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00012	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00014	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00019	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001f	72 27		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00021	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00024	83 ca ff	 or	 edx, -1
  00027	3b c1		 cmp	 eax, ecx
  00029	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00032	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00034	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00037	85 c9		 test	 ecx, ecx
  00039	74 24		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0003b	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003e	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00041	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	74 0d		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00059	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  00064	cc		 int	 3
?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z ENDP		; std::allocator<void *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAX@std@@QAEXQAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAX@std@@QAEXQAPAXI@Z PROC	; std::allocator<void *>::deallocate, COMDAT
; _this$dead$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00010	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00016	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00018	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001b	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00020	83 c0 fc	 add	 eax, -4			; fffffffcH
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 10		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	83 c4 08	 add	 esp, 8

; 993  : 		}

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003d	cc		 int	 3
?deallocate@?$allocator@PAX@std@@QAEXQAPAXI@Z ENDP	; std::allocator<void *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Swap_all, COMDAT
; _this$dead$ = ecx

; 540  : 		_Get_data()._Swap_all(_Right._Get_data());
; 541  : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAEAAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	83 c8 ff	 or	 eax, -1

; 893  : 		}

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABQAEXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$allocator@E@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$allocator@E@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z
_TEXT	SEGMENT
?max_size@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<void *> >::max_size, COMDAT
; ___formal$dead$ = ecx

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAIABV?$allocator@PAX@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$allocator@PAX@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$allocator@PAX@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBEABV?$allocator@PAX@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$allocator@PAX@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$allocator@PAX@2@XZ PROC ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QBEABV?$allocator@PAX@2@XZ ENDP ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@E@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 588  : 	if constexpr (_Range_verifiable_v<_Iter, _Sentinel>)
; 589  : 		{
; 590  : 		_Verify_range(_First, _Last);
; 591  : 		}
; 592  : 	else
; 593  : 		{
; 594  : 		(void)_First;
; 595  : 		(void)_Last;
; 596  : 		}
; 597  : 	}

  00000	c3		 ret	 0
??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPADAAY0BF@D@Z
_TEXT	SEGMENT
??$end@D$0BF@@std@@YAPADAAY0BF@D@Z PROC			; std::end<char,21>, COMDAT
; __Array$ = ecx

; 1546 : 	return (_Array + _Size);

  00000	8d 41 15	 lea	 eax, DWORD PTR [ecx+21]

; 1547 : 	}

  00003	c3		 ret	 0
??$end@D$0BF@@std@@YAPADAAY0BF@D@Z ENDP			; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
;	COMDAT ??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -52				; size = 4
___$ReturnUdt$ = -48					; size = 4
$T2 = -44						; size = 4
__Buff$ = -40						; size = 21
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z PROC ; std::_Integral_to_string<char,unsigned long>, COMDAT
; ___$ReturnUdt$ = ecx
; __Val$ = edx

; 506  : 	{	// convert _Val to string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b da		 mov	 ebx, edx
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 7d d0	 mov	 DWORD PTR ___$ReturnUdt$[ebp], edi
  00032	89 7d cc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi

; 507  : 	static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 508  : 	using _UTy = make_unsigned_t<_Ty>;
; 509  : 	_Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 510  : 	_Elem* const _Buff_end = _STD end(_Buff);
; 511  : 	_Elem* _RNext = _Buff_end;
; 512  : 	const auto _UVal = static_cast<_UTy>(_Val);
; 513  : 	if (_Val < 0)
; 514  : 		{
; 515  : 		_RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
; 516  : 		*--_RNext = '-';
; 517  : 		}
; 518  : 	else
; 519  : 		_RNext = _UIntegral_to_buff(_RNext, _UVal);

  00035	8d 75 ed	 lea	 esi, DWORD PTR __Buff$[ebp+21]
  00038	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0003f	90		 npad	 1
$LL28@Integral_t:

; 496  : 		*--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  00040	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00045	4e		 dec	 esi
  00046	f7 e3		 mul	 ebx
  00048	c1 ea 03	 shr	 edx, 3
  0004b	8a c2		 mov	 al, dl
  0004d	c0 e0 02	 shl	 al, 2
  00050	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00053	02 c9		 add	 cl, cl
  00055	2a d9		 sub	 bl, cl
  00057	80 c3 30	 add	 bl, 48			; 00000030H
  0005a	88 1e		 mov	 BYTE PTR [esi], bl

; 497  : 		_UVal_trunc /= 10;

  0005c	8b da		 mov	 ebx, edx

; 498  : 		}
; 499  : 	while (_UVal_trunc != 0);

  0005e	85 db		 test	 ebx, ebx
  00060	75 de		 jne	 SHORT $LL28@Integral_t
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  00062	8d 45 ed	 lea	 eax, DWORD PTR __Buff$[ebp+21]

; 3976 : 		_My_data._Mysize = 0;

  00065	89 57 10	 mov	 DWORD PTR [edi+16], edx

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00068	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0006f	88 17		 mov	 BYTE PTR [edi], dl
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  00071	3b f0		 cmp	 esi, eax
  00073	74 0d		 je	 SHORT $LN60@Integral_t

; 2253 : 			{
; 2254 : 			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  00075	8b c8		 mov	 ecx, eax
  00077	2b ce		 sub	 ecx, esi
  00079	51		 push	 ecx
  0007a	56		 push	 esi
  0007b	8b cf		 mov	 ecx, edi
  0007d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN60@Integral_t:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string

; 521  : 	return (basic_string<_Elem>(_RNext, _Buff_end));

  00082	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00089	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00090	8b c7		 mov	 eax, edi

; 522  : 	}

  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a3	33 cd		 xor	 ecx, ebp
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z$0:
  00000	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@Integral_t
  0000c	83 65 d4 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d cc	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@Integral_t:
  00018	c3		 ret	 0
__ehhandler$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Integral_to_string@DK@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@K@Z ENDP ; std::_Integral_to_string<char,unsigned long>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT
; _this$ = ecx

; 89   : 		{	// construct from representation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   : 			: _MyRep(static_cast<_Rep>(_Val))

  00003	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	89 01		 mov	 DWORD PTR [ecx], eax
  0000a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 90   : 		}

  00010	8b c1		 mov	 eax, ecx
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QAE@AB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z PROC ; std::move<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &>, COMDAT
; __Arg$ = ecx

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1590 : 	}

  00002	c3		 ret	 0
??$move@AAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YA$$QAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAV10@@Z ENDP ; std::move<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z
_TEXT	SEGMENT
??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z PROC		; std::_Unfancy_maybe_null<unsigned char>, COMDAT
; __Ptr$ = ecx

; 618  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 619  : 	}

  00002	c3		 ret	 0
??$_Unfancy_maybe_null@E@std@@YAPAEPAE@Z ENDP		; std::_Unfancy_maybe_null<unsigned char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$?0ABV?$allocator@E@std@@X@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@E@std@@X@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > ><std::allocator<unsigned char> const &,void>, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 431  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 431  : 		}

  00016	c2 04 00	 ret	 4
??$?0ABV?$allocator@E@std@@X@?$_Vector_alloc@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > >::_Vector_alloc<std::_Vec_base_types<unsigned char,std::allocator<unsigned char> > ><std::allocator<unsigned char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABQAX@std@@YAABQAXABQAX@Z
_TEXT	SEGMENT
??$forward@ABQAX@std@@YAABQAXABQAX@Z PROC		; std::forward<void * const &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@ABQAX@std@@YAABQAXABQAX@Z ENDP		; std::forward<void * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@PAX@std@@YAPAPAXPAPAX@Z
_TEXT	SEGMENT
??$_Unfancy@PAX@std@@YAPAPAXPAPAX@Z PROC		; std::_Unfancy<void *>, COMDAT
; __Ptr$ = ecx

; 346  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 347  : 	}

  00002	c3		 ret	 0
??$_Unfancy@PAX@std@@YAPAPAXPAPAX@Z ENDP		; std::_Unfancy<void *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PAXABQAX@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@QAPAXABQAX@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAXABQAX@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@QAPAXABQAX@Z PROC ; std::_Default_allocator_traits<std::allocator<void *> >::construct<void *,void * const &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]
  00008	89 02		 mov	 DWORD PTR [edx], eax

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  0000a	5d		 pop	 ebp
  0000b	c3		 ret	 0
??$construct@PAXABQAX@?$_Default_allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@QAPAXABQAX@Z ENDP ; std::_Default_allocator_traits<std::allocator<void *> >::construct<void *,void * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z
_TEXT	SEGMENT
tv856 = -32						; size = 4
__Newsize$1$ = -28					; size = 4
__Newcapacity$ = -24					; size = 4
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
$T3 = 11						; size = 1
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z PROC ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>, COMDAT
; _this$dead$ = ecx

; 942  : 		{	// reallocate and insert by perfectly forwarding _Val at _Whereptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 943  : 			// pre: !_Has_unused_capacity()
; 944  : 		const size_type _Whereoff = static_cast<size_type>(_Whereptr - this->_Myfirst());

  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00031	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00034	8b fb		 mov	 edi, ebx
  00036	2b fa		 sub	 edi, edx
  00038	c1 ff 02	 sar	 edi, 2

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  0003b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  00040	2b c2		 sub	 eax, edx
  00042	c1 f8 02	 sar	 eax, 2

; 945  : 		_Alty& _Al = this->_Getal();
; 946  : 		const size_type _Oldsize = size();
; 947  : 
; 948  : 		if (_Oldsize == max_size())

  00045	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0004a	0f 84 6b 01 00
	00		 je	 $LN278@Emplace_re

; 951  : 			}
; 952  : 
; 953  : 		const size_type _Newsize = _Oldsize + 1;

  00050	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  00053	89 75 e4	 mov	 DWORD PTR __Newsize$1$[ebp], esi

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00056	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8
  0005c	2b ca		 sub	 ecx, edx
  0005e	c1 f9 02	 sar	 ecx, 2

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00061	8b d1		 mov	 edx, ecx
  00063	d1 ea		 shr	 edx, 1
  00065	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0006a	2b c2		 sub	 eax, edx
  0006c	3b c8		 cmp	 ecx, eax
  0006e	76 07		 jbe	 SHORT $LN48@Emplace_re

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  00070	8b c6		 mov	 eax, esi
  00072	89 75 e8	 mov	 DWORD PTR __Newcapacity$[ebp], esi
  00075	eb 0b		 jmp	 SHORT $LN49@Emplace_re
$LN48@Emplace_re:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00077	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0007a	3b c6		 cmp	 eax, esi
  0007c	0f 42 c6	 cmovb	 eax, esi
  0007f	89 45 e8	 mov	 DWORD PTR __Newcapacity$[ebp], eax
$LN49@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  00082	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00089	89 4d e0	 mov	 DWORD PTR tv856[ebp], ecx

; 26   : 	if (_Max_possible < _Count)

  0008c	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00091	76 05		 jbe	 SHORT $LN80@Emplace_re

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00093	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00096	eb 08		 jmp	 SHORT $LN273@Emplace_re
$LN80@Emplace_re:
  00098	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009e	72 27		 jb	 SHORT $LN83@Emplace_re
$LN273@Emplace_re:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  000a0	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  000a3	83 ca ff	 or	 edx, -1
  000a6	3b c1		 cmp	 eax, ecx
  000a8	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000b1	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 04 01 00
	00		 je	 $LN92@Emplace_re

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  000bc	8d 70 23	 lea	 esi, DWORD PTR [eax+35]
  000bf	83 e6 e0	 and	 esi, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c2	89 46 fc	 mov	 DWORD PTR [esi-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000c5	eb 16		 jmp	 SHORT $LN276@Emplace_re
$LN83@Emplace_re:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000c7	85 c9		 test	 ecx, ecx
  000c9	74 10		 je	 SHORT $LN84@Emplace_re

; 52   : 		return (::operator new(_Bytes));

  000cb	51		 push	 ecx
  000cc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d1	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000d4	8b f0		 mov	 esi, eax
  000d6	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  000d9	eb 05		 jmp	 SHORT $LN82@Emplace_re
$LN84@Emplace_re:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000db	33 f6		 xor	 esi, esi
$LN276@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 960  : 		_TRY_BEGIN

  000dd	89 75 ec	 mov	 DWORD PTR $T2[ebp], esi
$LN82@Emplace_re:
  000e0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 961  : 		_Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000e7	8d 3c be	 lea	 edi, DWORD PTR [esi+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  000ea	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000ed	8b 00		 mov	 eax, DWORD PTR [eax]
  000ef	89 07		 mov	 DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 964  : 		if (_Whereptr == this->_Mylast())

  000f1	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  000f7	3b da		 cmp	 ebx, edx
  000f9	75 1d		 jne	 SHORT $LN4@Emplace_re
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  000fb	51		 push	 ecx
  000fc	8d 4d 0b	 lea	 ecx, DWORD PTR $T3[ebp]
  000ff	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ; std::_Ptr_move_cat<void *,void *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00109	2b d0		 sub	 edx, eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0010b	52		 push	 edx
  0010c	50		 push	 eax
  0010d	56		 push	 esi
  0010e	e8 00 00 00 00	 call	 _memmove
  00113	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 968  : 		else

  00116	eb 1d		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 969  : 			{	// provide basic guarantee
; 970  : 			_Umove(this->_Myfirst(), _Whereptr, _Newvec);

  00118	56		 push	 esi
  00119	53		 push	 ebx
  0011a	ff 35 00 00 00
	00		 push	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00120	e8 00 00 00 00	 call	 ?_Umove@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Umove

; 971  : 			_Constructed_first = _Newvec;
; 972  : 			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);

  00125	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00128	50		 push	 eax
  00129	ff 35 04 00 00
	00		 push	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4
  0012f	53		 push	 ebx
  00130	e8 00 00 00 00	 call	 ?_Umove@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Umove
$LN5@Emplace_re:
  00135	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1898 : 		if (this->_Myfirst() != pointer())

  0013c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00141	85 c0		 test	 eax, eax
  00143	74 2f		 je	 SHORT $LN246@Emplace_re

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00145	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8
  0014b	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0014d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00150	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00156	72 12		 jb	 SHORT $LN245@Emplace_re

; 115  : 	_Bytes += _Non_user_size;

  00158	83 c1 23	 add	 ecx, 35			; 00000023H

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0015b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0015e	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00160	83 c0 fc	 add	 eax, -4			; fffffffcH
  00163	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00166	77 58		 ja	 SHORT $LN92@Emplace_re

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00168	8b c2		 mov	 eax, edx
$LN245@Emplace_re:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0016a	51		 push	 ecx
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00171	83 c4 08	 add	 esp, 8
$LN246@Emplace_re:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00174	89 35 00 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A, esi

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0017a	8b 4d e4	 mov	 ecx, DWORD PTR __Newsize$1$[ebp]
  0017d	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]
  00180	89 0d 04 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, ecx

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00186	8b 4d e0	 mov	 ecx, DWORD PTR tv856[ebp]
  00189	03 ce		 add	 ecx, esi
  0018b	89 0d 08 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, ecx

; 978  : 		_CATCH_END
; 979  : 
; 980  : 		_Change_array(_Newvec, _Newsize, _Newcapacity);
; 981  : 		return (this->_Myfirst() + _Whereoff);

  00191	8b c7		 mov	 eax, edi

; 982  : 		}

  00193	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00196	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019d	59		 pop	 ecx
  0019e	5f		 pop	 edi
  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx
  001a1	8b e5		 mov	 esp, ebp
  001a3	5d		 pop	 ebp
  001a4	c2 08 00	 ret	 8
__catch$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z$0:

; 973  : 			}
; 974  : 		_CATCH_ALL
; 975  : 		_Destroy(_Constructed_first, _Constructed_last);
; 976  : 		_Al.deallocate(_Newvec, _Newcapacity);

  001a7	ff 75 e8	 push	 DWORD PTR __Newcapacity$[ebp]
  001aa	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  001ad	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAX@std@@QAEXQAPAXI@Z ; std::allocator<void *>::deallocate

; 977  : 		_RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN278@Emplace_re:

; 949  : 			{
; 950  : 			_Xlength();

  001bb	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAXV?$allocator@PAX@std@@@std@@CAXXZ ; std::vector<void *,std::allocator<void *> >::_Xlength
$LN92@Emplace_re:

; 982  : 		}

  001c0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN275@Emplace_re:
  001c5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAX@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXQAPAXABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Emplace_reallocate<void * const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$?0ABV?$allocator@PAX@std@@X@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@PAX@std@@X@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > ><std::allocator<void *> const &,void>, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 431  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 431  : 		}

  00016	c2 04 00	 ret	 4
??$?0ABV?$allocator@PAX@std@@X@?$_Vector_alloc@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QAE@ABV?$allocator@PAX@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > >::_Vector_alloc<std::_Vec_base_types<void *,std::allocator<void *> > ><std::allocator<void *> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@ABV10@@Z PROC ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >, COMDAT
; __Val$ = ecx

; 330  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 331  : 	}

  00002	c3		 ret	 0
??$addressof@$$CBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@ABV10@@Z ENDP ; std::addressof<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$assign@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
??$assign@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::assign<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,void>, COMDAT
; _this$ = ecx

; 1388 : 		{	// assign [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1389 : 		_Adl_verify_range(_First, _Last);
; 1390 : 		_Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  00003	ff 75 0c	 push	 DWORD PTR $T1[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1391 : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
??$assign@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::assign<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z PROC ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>, COMDAT
; __Arg$ = ecx

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1590 : 	}

  00002	c3		 ret	 0
??$move@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ENDP ; std::move<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void>, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 431  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 431  : 		}

  00016	c2 04 00	 ret	 4
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@QAE@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_alloc<std::_Vec_base_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<unsigned char *,unsigned int,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b fa		 mov	 edi, edx
  00004	8b f1		 mov	 esi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00006	57		 push	 edi
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _memset
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00012	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  00017	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<unsigned char *,unsigned int,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1><>, COMDAT
; _this$dead$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A ; PendingThreads
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  0000f	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, 0

; 391  : 		_Myend()

  00019	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00023	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z PROC ; std::_Destroy_range<std::allocator<void *> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z ENDP ; std::_Destroy_range<std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_value_construct_n@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@@Z PROC ; std::_Uninitialized_value_construct_n<void * *,unsigned int,std::allocator<void *> >, COMDAT
; __First$ = ecx
; __Count$dead$ = edx

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	56		 push	 esi

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00001	68 20 4e 00 00	 push	 20000			; 00004e20H

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00006	8b f1		 mov	 esi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00008	6a 00		 push	 0
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00013	8d 86 20 4e 00
	00		 lea	 eax, DWORD PTR [esi+20000]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00019	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0001a	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@@Z ENDP ; std::_Uninitialized_value_construct_n<void * *,unsigned int,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1081 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1082 : 	_Pocca(_Left, _Right, _Tag);
; 1083 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT
; __Count$ = ecx

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;
; 26   : 	if (_Max_possible < _Count)

  00000	83 ca ff	 or	 edx, -1
  00003	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0000a	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00010	0f 47 c2	 cmova	 eax, edx

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

  00013	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAX@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<void *> >::_Vector_val<std::_Simple_types<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXQAPAXII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXQAPAXII@Z PROC ; std::vector<void *,std::allocator<void *> >::_Change_array, COMDAT
; _this$dead$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00008	85 c0		 test	 eax, eax
  0000a	74 2f		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8
  00012	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00014	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001d	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00022	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00025	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00027	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002d	77 2f		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002f	8b c2		 mov	 eax, edx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00031	51		 push	 ecx
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00038	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00041	89 0d 00 00 00
	00		 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A, ecx
  00047	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004a	a3 04 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+4, eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0004f	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00052	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00055	a3 08 00 00 00	 mov	 DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8, eax

; 1907 : 		}

  0005a	5d		 pop	 ebp
  0005b	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00063	cc		 int	 3
?_Change_array@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXQAPAXII@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEII@Z PROC ; std::vector<void *,std::allocator<void *> >::_Calculate_growth, COMDAT
; _this$dead$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00003	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A+8

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00009	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000e	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?PendingThreads@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00014	c1 f9 02	 sar	 ecx, 2

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00017	8b d1		 mov	 edx, ecx
  00019	d1 ea		 shr	 edx, 1
  0001b	2b c2		 sub	 eax, edx
  0001d	3b c8		 cmp	 ecx, eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00022	77 08		 ja	 SHORT $LN1@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00024	03 ca		 add	 ecx, edx

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00026	3b c8		 cmp	 ecx, eax
  00028	72 02		 jb	 SHORT $LN1@Calculate_

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient
; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient

  0002a	8b c1		 mov	 eax, ecx
$LN1@Calculate_:

; 1869 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAXV?$allocator@PAX@std@@@std@@ABEII@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00@Z PROC ; std::vector<void *,std::allocator<void *> >::_Umove_if_noexcept, COMDAT
; _this$dead$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ; std::_Ptr_move_cat<void *,void *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1845 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAX00@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAX00@Z PROC ; std::vector<void *,std::allocator<void *> >::_Umove, COMDAT
; _this$dead$ = ecx

; 1827 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000a	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ; std::_Ptr_move_cat<void *,void *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  00018	2b f8		 sub	 edi, eax
  0001a	57		 push	 edi
  0001b	50		 push	 eax
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _memmove
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00025	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1828 : 		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 1829 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEPAPAXPAPAX00@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<void *,std::allocator<void *> >::_Umove_if_noexcept1, COMDAT
; _this$dead$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 256  : 	_Seek_wrapped(_Dest,

  00004	51		 push	 ecx
  00005	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ; std::_Ptr_move_cat<void *,void *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00013	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001a	e8 00 00 00 00	 call	 _memmove
  0001f	83 c4 10	 add	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@PAXV?$allocator@PAX@std@@@std@@AAEXPAPAX00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0PADX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD0ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$dead$ = 16						; size = 4
??$?0PADX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD0ABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,void>, COMDAT
; _this$ = ecx

; 2221 : 		{	// construct from [_First, _Last) with optional allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2252 : 		if (_First != _Last)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2221 : 		{	// construct from [_First, _Last) with optional allocator

  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 2252 : 		if (_First != _Last)

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 3976 : 		_My_data._Mysize = 0;

  0000c	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00013	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0001a	c6 06 00	 mov	 BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2252 : 		if (_First != _Last)

  0001d	3b c8		 cmp	 ecx, eax
  0001f	74 0b		 je	 SHORT $LN32@allocator

; 2253 : 			{
; 2254 : 			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  00021	2b c1		 sub	 eax, ecx
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN32@allocator:

; 2222 : 		_Tidy_init();
; 2223 : 		_Adl_verify_range(_First, _Last);
; 2224 : 		_Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2225 : 		}

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
??$?0PADX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD0ABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\string
;	COMDAT ??$_UIntegral_to_buff@DK@std@@YAPADPADK@Z
_TEXT	SEGMENT
??$_UIntegral_to_buff@DK@std@@YAPADPADK@Z PROC		; std::_UIntegral_to_buff<char,unsigned long>, COMDAT
; __RNext$ = ecx
; __UVal$ = edx

; 466  : 	{	// format _UVal into buffer *ending at* _RNext

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b da		 mov	 ebx, edx
  00004	8b f1		 mov	 esi, ecx
$LL9@UIntegral_:

; 467  : 	static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 468  : 
; 469  : #ifdef _WIN64
; 470  : 	auto _UVal_trunc = _UVal;
; 471  : #else /* ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv */
; 472  : 
; 473  : #pragma warning(push)
; 474  : #pragma warning(disable: 4127)	// conditional expression is constant
; 475  : 	if (sizeof(_UTy) > 4)
; 476  : 		{	// For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 477  : 		while (_UVal > 0xFFFFFFFFU)
; 478  : 			{
; 479  : 			auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 480  : 			_UVal /= 1000000000;
; 481  : 
; 482  : 			for (int _Idx = 0; _Idx != 9; ++_Idx)
; 483  : 				{
; 484  : 				*--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 485  : 				_UVal_chunk /= 10;
; 486  : 				}
; 487  : 			}
; 488  : 		}
; 489  : #pragma warning(pop)
; 490  : 
; 491  : 	auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 492  : #endif /* _WIN64 */
; 493  : 
; 494  : 	do
; 495  : 		{
; 496  : 		*--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

  00006	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0000b	4e		 dec	 esi
  0000c	f7 e3		 mul	 ebx
  0000e	c1 ea 03	 shr	 edx, 3
  00011	8a c2		 mov	 al, dl
  00013	c0 e0 02	 shl	 al, 2
  00016	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00019	02 c9		 add	 cl, cl
  0001b	2a d9		 sub	 bl, cl
  0001d	80 c3 30	 add	 bl, 48			; 00000030H
  00020	88 1e		 mov	 BYTE PTR [esi], bl

; 497  : 		_UVal_trunc /= 10;

  00022	8b da		 mov	 ebx, edx

; 498  : 		}
; 499  : 	while (_UVal_trunc != 0);

  00024	85 db		 test	 ebx, ebx
  00026	75 de		 jne	 SHORT $LL9@UIntegral_

; 500  : 	return (_RNext);

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx

; 501  : 	}

  0002c	c3		 ret	 0
??$_UIntegral_to_buff@DK@std@@YAPADPADK@Z ENDP		; std::_UIntegral_to_buff<char,unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z PROC ; std::forward<std::allocator<unsigned char> const &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$allocator@E@std@@@std@@YAABV?$allocator@E@0@ABV10@@Z ENDP ; std::forward<std::allocator<unsigned char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@E@std@@$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@E@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><std::allocator<unsigned char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@PAX@std@@@std@@YAABV?$allocator@PAX@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@PAX@std@@@std@@YAABV?$allocator@PAX@0@ABV10@@Z PROC ; std::forward<std::allocator<void *> const &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$allocator@PAX@std@@@std@@YAABV?$allocator@PAX@0@ABV10@@Z ENDP ; std::forward<std::allocator<void *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABV?$allocator@PAX@std@@$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAX@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@PAX@std@@$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAX@1@@Z PROC ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1><std::allocator<void *> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00016	c2 08 00	 ret	 8
??$?0ABV?$allocator@PAX@std@@$$V@?$_Compressed_pair@V?$allocator@PAX@std@@V?$_Vector_val@U?$_Simple_types@PAX@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAX@1@@Z ENDP ; std::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1>::_Compressed_pair<std::allocator<void *>,std::_Vector_val<std::_Simple_types<void *> >,1><std::allocator<void *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAXABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
??$_Adl_verify_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAXABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Adl_verify_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 588  : 	if constexpr (_Range_verifiable_v<_Iter, _Sentinel>)
; 589  : 		{
; 590  : 		_Verify_range(_First, _Last);
; 591  : 		}
; 592  : 	else
; 593  : 		{
; 594  : 		(void)_First;
; 595  : 		(void)_Last;
; 596  : 		}
; 597  : 	}

  00000	c3		 ret	 0
??$_Adl_verify_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAXABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Adl_verify_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 1341 : 		{	// assign [_First, _Last), forward iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 1235 : 	return (_Last - _First);

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000c	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  0000f	f7 ea		 imul	 edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1341 : 		{	// assign [_First, _Last), forward iterators

  00011	53		 push	 ebx
  00012	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 1235 : 	return (_Last - _First);

  00013	c1 fa 02	 sar	 edx, 2
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00016	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH

; 1341 : 		{	// assign [_First, _Last), forward iterators

  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 1235 : 	return (_Last - _First);

  0001e	8b f2		 mov	 esi, edx
  00020	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00023	03 f2		 add	 esi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00025	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00028	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0002a	f7 e9		 imul	 ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0002c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0002f	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00031	c1 fa 02	 sar	 edx, 2
  00034	8b c2		 mov	 eax, edx
  00036	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00039	03 c2		 add	 eax, edx
  0003b	89 45 fc	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0003e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00043	f7 e9		 imul	 ecx
  00045	c1 fa 02	 sar	 edx, 2
  00048	8b da		 mov	 ebx, edx
  0004a	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  0004d	03 da		 add	 ebx, edx

; 1342 : 		const size_type _Newsize = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 1343 : 
; 1344 : 		this->_Orphan_all();
; 1345 : 
; 1346 : 		const size_type _Oldsize = size();
; 1347 : 		const size_type _Oldcapacity = capacity();
; 1348 : 
; 1349 : 		if (_Newsize > _Oldcapacity)

  0004f	3b f3		 cmp	 esi, ebx
  00051	0f 86 8b 00 00
	00		 jbe	 $LN2@Assign_ran

; 1350 : 			{	// reallocate
; 1351 : 			if (_Newsize > max_size())

  00057	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  0005d	0f 87 e3 00 00
	00		 ja	 $LN213@Assign_ran

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00063	8b cb		 mov	 ecx, ebx
  00065	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH
  0006a	d1 e9		 shr	 ecx, 1
  0006c	2b c1		 sub	 eax, ecx
  0006e	3b d8		 cmp	 ebx, eax
  00070	77 0a		 ja	 SHORT $LN65@Assign_ran

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00072	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00075	3b c6		 cmp	 eax, esi
  00077	0f 42 c6	 cmovb	 eax, esi
  0007a	8b f0		 mov	 esi, eax
$LN65@Assign_ran:

; 1354 : 				}
; 1355 : 
; 1356 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1357 : 
; 1358 : 			if (this->_Myfirst() != pointer())

  0007c	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0007e	85 c9		 test	 ecx, ecx
  00080	74 3c		 je	 SHORT $LN142@Assign_ran

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00082	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008b	8b 07		 mov	 eax, DWORD PTR [edi]
  0008d	8d 0c 5b	 lea	 ecx, DWORD PTR [ebx+ebx*2]
  00090	c1 e1 03	 shl	 ecx, 3
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  00093	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00096	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009c	72 16		 jb	 SHORT $LN141@Assign_ran

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0009e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000a1	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000a4	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a6	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ac	0f 87 99 00 00
	00		 ja	 $LN138@Assign_ran

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000b2	8b c2		 mov	 eax, edx
$LN141@Assign_ran:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000b4	51		 push	 ecx
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000bb	83 c4 08	 add	 esp, 8
$LN142@Assign_ran:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1364 : 			_Buy(_Newcapacity);

  000be	56		 push	 esi
  000bf	8b cf		 mov	 ecx, edi
  000c1	e8 00 00 00 00	 call	 ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy

; 1365 : 
; 1366 : 			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());

  000c6	ff 37		 push	 DWORD PTR [edi]
  000c8	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  000cb	8b cf		 mov	 ecx, edi
  000cd	52		 push	 edx
  000ce	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000d1	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  000d6	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000d9	5f		 pop	 edi

; 1382 : 		}

  000da	5e		 pop	 esi
  000db	5b		 pop	 ebx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Assign_ran:

; 1367 : 			}
; 1368 : 		else if (_Newsize > _Oldsize)

  000e2	8b 45 fc	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  000e5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000e7	51		 push	 ecx
  000e8	3b f0		 cmp	 esi, eax
  000ea	76 30		 jbe	 SHORT $LN6@Assign_ran
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 1208 : 	_Where += _Off;

  000ec	8b 5d 08	 mov	 ebx, DWORD PTR __First$[ebp]
  000ef	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1372 : 			_Copy_unchecked(_First, _Mid, this->_Myfirst());

  000f2	8b cb		 mov	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 1208 : 	_Where += _Off;

  000f4	8d 34 c3	 lea	 esi, DWORD PTR [ebx+eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1372 : 			_Copy_unchecked(_First, _Mid, this->_Myfirst());

  000f7	8b d6		 mov	 edx, esi
  000f9	e8 00 00 00 00	 call	 ??$_Copy_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::_Copy_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1373 : 			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());

  000fe	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00101	83 c4 04	 add	 esp, 4
  00104	8b cf		 mov	 ecx, edi
  00106	ff 77 04	 push	 DWORD PTR [edi+4]
  00109	52		 push	 edx
  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
  00110	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00113	5f		 pop	 edi

; 1382 : 		}

  00114	5e		 pop	 esi
  00115	5b		 pop	 ebx
  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 0c 00	 ret	 12			; 0000000cH
$LN6@Assign_ran:

; 1374 : 			}
; 1375 : 		else
; 1376 : 			{
; 1377 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;
; 1378 : 			_Copy_unchecked(_First, _Last, this->_Myfirst());

  0011c	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0011f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00122	8d 34 c1	 lea	 esi, DWORD PTR [ecx+eax*8]
  00125	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00128	e8 00 00 00 00	 call	 ??$_Copy_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::_Copy_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());

  0012d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00130	8b ce		 mov	 ecx, esi
  00132	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00137	83 c4 04	 add	 esp, 4

; 1379 : 			_Destroy(_Newlast, this->_Mylast());
; 1380 : 			this->_Mylast() = _Newlast;

  0013a	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0013d	5f		 pop	 edi

; 1382 : 		}

  0013e	5e		 pop	 esi
  0013f	5b		 pop	 ebx
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 0c 00	 ret	 12			; 0000000cH
$LN213@Assign_ran:

; 1352 : 				{
; 1353 : 				_Xlength();

  00146	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN138@Assign_ran:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0014b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN211@Assign_ran:
  00150	cc		 int	 3
??$_Assign_range@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Assign_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YA$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Compressed_pair<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1><std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<unsigned char *,unsigned int,std::allocator<unsigned char> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b fa		 mov	 edi, edx
  00004	8b f1		 mov	 esi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00006	57		 push	 edi
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 _memset
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00012	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00015	5f		 pop	 edi
  00016	5e		 pop	 esi

; 337  : 	}

  00017	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAEIV?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<unsigned char *,unsigned int,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<void *> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_value_construct_n1@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<void * *,unsigned int,std::allocator<void *> >, COMDAT
; __First$ = ecx
; __Count$dead$ = edx

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	56		 push	 esi

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00001	68 20 4e 00 00	 push	 20000			; 00004e20H

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00006	8b f1		 mov	 esi, ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00008	6a 00		 push	 0
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00013	8d 86 20 4e 00
	00		 lea	 eax, DWORD PTR [esi+20000]
  00019	5e		 pop	 esi

; 337  : 	}

  0001a	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAPAXIV?$allocator@PAX@std@@@std@@YAPAPAXPAPAXIAAV?$allocator@PAX@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<void * *,unsigned int,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1076 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<unsigned char> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX0PAPAXAAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_move@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX0PAPAXAAV?$allocator@PAX@0@@Z PROC ; std::_Uninitialized_move<void * *,void * *,std::allocator<void *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);
; 254  : 	const auto _ULast = _Get_unwrapped(_Last);
; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 256  : 	_Seek_wrapped(_Dest,

  00006	51		 push	 ecx
  00007	8b f1		 mov	 esi, ecx
  00009	8b fa		 mov	 edi, edx
  0000b	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ; std::_Ptr_move_cat<void *,void *>
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00013	2b fe		 sub	 edi, esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 _memmove
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00023	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi

; 261  : 	}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Uninitialized_move@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX0PAPAXAAV?$allocator@PAX@0@@Z ENDP ; std::_Uninitialized_move<void * *,void * *,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PAPAXPAPAX@std@@YA@ABQAPAX0@Z
_TEXT	SEGMENT
??$_Idl_distance@PAPAXPAPAX@std@@YA@ABQAPAX0@Z PROC	; std::_Idl_distance<void * *,void * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 945  : 	if constexpr (_Is_random_iter_v<_Iter>)
; 946  : 		{
; 947  : 		return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	2b 01		 sub	 eax, DWORD PTR [ecx]
  00004	c1 f8 02	 sar	 eax, 2

; 948  : 		}
; 949  : 	else
; 950  : 		{
; 951  : 		(void)_First;
; 952  : 		(void)_Last;
; 953  : 		return _Distance_unknown{};
; 954  : 		}
; 955  : 	}

  00007	c3		 ret	 0
??$_Idl_distance@PAPAXPAPAX@std@@YA@ABQAPAX0@Z ENDP	; std::_Idl_distance<void * *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 1872 : 		{	// allocate array with _Newcapacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1873 : 		this->_Myfirst() = pointer();
; 1874 : 		this->_Mylast() = pointer();
; 1875 : 		this->_Myend() = pointer();
; 1876 : 
; 1877 : 		if (_Newcapacity == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0000f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00016	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@Buy

; 1878 : 			{
; 1879 : 			return (false);

  00021	32 c0		 xor	 al, al
  00023	5e		 pop	 esi

; 1892 : 		}

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN2@Buy:

; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

  00028	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002d	77 77		 ja	 SHORT $LN99@Buy
  0002f	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  00030	8d 3c 40	 lea	 edi, DWORD PTR [eax+eax*2]
  00033	c1 e7 03	 shl	 edi, 3

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00036	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  0003c	72 35		 jb	 SHORT $LN45@Buy

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0003e	8d 47 23	 lea	 eax, DWORD PTR [edi+35]

; 94   : 	if (_Block_size <= _Bytes)

  00041	83 c9 ff	 or	 ecx, -1
  00044	3b c7		 cmp	 eax, edi
  00046	0f 46 c1	 cmovbe	 eax, ecx

; 52   : 		return (::operator new(_Bytes));

  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0004f	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00051	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00054	85 c9		 test	 ecx, ecx
  00056	74 53		 je	 SHORT $LN54@Buy

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00058	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0005b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0005e	89 48 fc	 mov	 DWORD PTR [eax-4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00061	89 06		 mov	 DWORD PTR [esi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  00063	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00066	03 c7		 add	 eax, edi
  00068	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1890 : 
; 1891 : 		return (true);

  0006b	b0 01		 mov	 al, 1
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 1892 : 		}

  0006f	5d		 pop	 ebp
  00070	c2 04 00	 ret	 4
$LN45@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 188  : 	if (_Bytes != 0)

  00073	85 ff		 test	 edi, edi
  00075	74 1b		 je	 SHORT $LN46@Buy

; 52   : 		return (::operator new(_Bytes));

  00077	57		 push	 edi
  00078	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007d	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00080	89 06		 mov	 DWORD PTR [esi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  00082	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00085	03 c7		 add	 eax, edi
  00087	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1890 : 
; 1891 : 		return (true);

  0008a	b0 01		 mov	 al, 1
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi

; 1892 : 		}

  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
$LN46@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 193  : 	return (nullptr);

  00092	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00094	89 06		 mov	 DWORD PTR [esi], eax

; 1888 : 		this->_Mylast() = this->_Myfirst();

  00096	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  00099	8b c7		 mov	 eax, edi
  0009b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1890 : 
; 1891 : 		return (true);

  0009e	b0 01		 mov	 al, 1
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi

; 1892 : 		}

  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
$LN99@Buy:

; 1883 : 			{
; 1884 : 			_Xlength();

  000a6	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN54@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  000ab	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN97@Buy:
  000b0	cc		 int	 3
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAD0Urandom_access_iterator_tag@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAD0Urandom_access_iterator_tag@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct, COMDAT
; _this$ = ecx

; 2251 : 		{	// initialize from [_First, _Last), pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2252 : 		if (_First != _Last)
; 2253 : 			{
; 2254 : 			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	29 55 0c	 sub	 DWORD PTR __Last$[ebp], edx
  00009	89 55 08	 mov	 DWORD PTR __First$[ebp], edx

; 2255 : 			}
; 2256 : 		}

  0000c	5d		 pop	 ebp

; 2252 : 		if (_First != _Last)
; 2253 : 			{
; 2254 : 			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

  0000d	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXQAD0Urandom_access_iterator_tag@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 1784 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1919 : 		}

  00007	8b c1		 mov	 eax, ecx

; 1785 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1919 : 		}

  00010	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@D@std@@YAPADQAD@Z
_TEXT	SEGMENT
??$_Get_unwrapped@D@std@@YAPADQAD@Z PROC		; std::_Get_unwrapped<char>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@D@std@@YAPADQAD@Z ENDP		; std::_Get_unwrapped<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$distance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
??$distance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1235 : 	return (_Last - _First);

  00000	2b d1		 sub	 edx, ecx
  00002	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00007	f7 ea		 imul	 edx
  00009	c1 fa 02	 sar	 edx, 2
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 1241 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
; 1242 : 	}

  00013	c3		 ret	 0
??$distance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::distance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
__Backout$2 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 1822 : 		{	// copy [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 147  : 		: _First(_Dest),

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]

; 214  : 	_Seek_wrapped(_Dest,

  0002b	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 148  : 		_Last(_Dest),

  0002e	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi
  00031	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi

; 149  : 		_Al(_Al_)

  00034	89 4d f0	 mov	 DWORD PTR __Backout$2[ebp+8], ecx

; 187  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 188  : 	for (; _First != _Last; ++_First)

  0003e	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00041	3b f3		 cmp	 esi, ebx
  00043	74 15		 je	 SHORT $LN23@Ucopy
$LL24@Ucopy:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00045	56		 push	 esi
  00046	8b cf		 mov	 ecx, edi
  00048	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  0004d	83 c7 18	 add	 edi, 24			; 00000018H

; 188  : 	for (; _First != _Last; ++_First)

  00050	83 c6 18	 add	 esi, 24			; 00000018H

; 165  : 		++_Last;

  00053	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi

; 188  : 	for (; _First != _Last; ++_First)

  00056	3b f3		 cmp	 esi, ebx
  00058	75 eb		 jne	 SHORT $LL24@Ucopy
$LN23@Ucopy:

; 170  : 		_First = _Last;

  0005a	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi

; 193  : 	return (_Backout._Release());

  0005d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 		_Destroy_range(_First, _Last, _Al);

  00064	8b d7		 mov	 edx, edi
  00066	51		 push	 ecx
  00067	8b cf		 mov	 ecx, edi
  00069	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006e	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\vector

; 1823 : 		return (_Uninitialized_copy(_First, _Last, _Dest, this->_Getal()));

  00071	8b c7		 mov	 eax, edi

; 1824 : 		}

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$next@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@H@Z
_TEXT	SEGMENT
??$next@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@H@Z PROC ; std::next<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Off$ = edx

; 1208 : 	_Where += _Off;

  00000	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00003	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1255 : 	static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");
; 1256 : 
; 1257 : 	_STD advance(_First, _Off);
; 1258 : 	return (_First);
; 1259 : 	}

  00006	c3		 ret	 0
??$next@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@H@Z ENDP ; std::next<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z PROC ; std::_Copy_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2432 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b da		 mov	 ebx, edx
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 2433 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2434 : 	return (_Copy_unchecked1(_First, _Last, _Dest, _Ptr_copy_cat(_First, _Dest)));

  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]

; 2412 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0000d	3b f3		 cmp	 esi, ebx
  0000f	74 23		 je	 SHORT $LN93@Copy_unche
$LL8@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2467 : 		if (this != _STD addressof(_Right))

  00011	3b fe		 cmp	 edi, esi
  00013	74 15		 je	 SHORT $LN6@Copy_unche

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00015	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00019	8b c6		 mov	 eax, esi

; 1815 : 		if (_Large_string_engaged())

  0001b	72 02		 jb	 SHORT $LN81@Copy_unche
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
$LN81@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2481 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0001f	ff 76 10	 push	 DWORD PTR [esi+16]
  00022	8b cf		 mov	 ecx, edi
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2412 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0002a	83 c6 18	 add	 esi, 24			; 00000018H
  0002d	83 c7 18	 add	 edi, 24			; 00000018H
  00030	3b f3		 cmp	 esi, ebx
  00032	75 dd		 jne	 SHORT $LL8@Copy_unche
$LN93@Copy_unche:

; 2435 : 	}

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Copy_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ENDP ; std::_Copy_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAPAX@std@@YAPAPAXQAPAX0@Z
_TEXT	SEGMENT
??$_Zero_range@PAPAX@std@@YAPAPAXQAPAX0@Z PROC		; std::_Zero_range<void * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	56		 push	 esi
  00001	8b f2		 mov	 esi, edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b c6		 mov	 eax, esi
  00005	2b c1		 sub	 eax, ecx
  00007	50		 push	 eax
  00008	6a 00		 push	 0
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _memset
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi

; 315  : 	}

  00016	c3		 ret	 0
??$_Zero_range@PAPAX@std@@YAPAPAXQAPAX0@Z ENDP		; std::_Zero_range<void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@PAX@std@@YAPAPAXQAPAX@Z
_TEXT	SEGMENT
??$_Get_unwrapped@PAX@std@@YAPAPAXQAPAX@Z PROC		; std::_Get_unwrapped<void *>, COMDAT
; __Ptr$ = ecx

; 663  : 	return (_Ptr);

  00000	8b c1		 mov	 eax, ecx

; 664  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped@PAX@std@@YAPAPAXQAPAX@Z ENDP		; std::_Get_unwrapped<void *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@PAXH$0A@@std@@YAPAPAXQAPAXH@Z
_TEXT	SEGMENT
??$_Get_unwrapped_n@PAXH$0A@@std@@YAPAPAXQAPAXH@Z PROC	; std::_Get_unwrapped_n<void *,int,0>, COMDAT
; __Src$ = ecx
; ___formal$dead$ = edx

; 809  : 	return (_Src);

  00000	8b c1		 mov	 eax, ecx

; 810  : 	}

  00002	c3		 ret	 0
??$_Get_unwrapped_n@PAXH$0A@@std@@YAPAPAXQAPAXH@Z ENDP	; std::_Get_unwrapped_n<void *,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z PROC ; std::_Ptr_move_cat<void *,void *>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 1087 : 	return {};

  00000	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00003	8b c1		 mov	 eax, ecx

; 1088 : 	}

  00005	c3		 ret	 0
??$_Ptr_move_cat@PAXPAX@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAX0@Z ENDP ; std::_Ptr_move_cat<void *,void *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAXPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX00AAV?$allocator@PAX@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_move_al_unchecked@PAXPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX00AAV?$allocator@PAX@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<void *,void *,std::allocator<void *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	2b f9		 sub	 edi, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 245  : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@PAXPAXV?$allocator@PAX@std@@@std@@YAPAPAXQAPAX00AAV?$allocator@PAX@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<void *,void *,std::allocator<void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@PAX@std@@YAXAAPAPAXQAPAX@Z
_TEXT	SEGMENT
??$_Seek_wrapped@PAX@std@@YAXAAPAPAXQAPAX@Z PROC	; std::_Seek_wrapped<void *>, COMDAT
; __It$ = ecx
; __UIt$ = edx

; 872  : 	_It = _UIt;

  00000	89 11		 mov	 DWORD PTR [ecx], edx

; 873  : 	}

  00002	c3		 ret	 0
??$_Seek_wrapped@PAX@std@@YAXAAPAPAXQAPAX@Z ENDP	; std::_Seek_wrapped<void *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00007	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 1785 : 		_Myres(0)

  00009	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00010	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Distance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Distance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z PROC ; std::_Distance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1235 : 	return (_Last - _First);

  00000	2b d1		 sub	 edx, ecx
  00002	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00007	f7 ea		 imul	 edx
  00009	c1 fa 02	 sar	 edx, 2
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 1236 : 	}

  00013	c3		 ret	 0
??$_Distance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Distance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Dest$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 209  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b f1		 mov	 esi, ecx

; 147  : 		: _First(_Dest),

  0002c	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]

; 148  : 		_Last(_Dest),
; 149  : 		_Al(_Al_)

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00032	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi
  00035	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi
  00038	89 45 f0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 187  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 188  : 	for (; _First != _Last; ++_First)

  00042	3b f3		 cmp	 esi, ebx
  00044	74 15		 je	 SHORT $LN17@Uninitiali
$LL18@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00046	56		 push	 esi
  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  0004e	83 c7 18	 add	 edi, 24			; 00000018H

; 188  : 	for (; _First != _Last; ++_First)

  00051	83 c6 18	 add	 esi, 24			; 00000018H

; 165  : 		++_Last;

  00054	89 7d ec	 mov	 DWORD PTR __Backout$2[ebp+4], edi

; 188  : 	for (; _First != _Last; ++_First)

  00057	3b f3		 cmp	 esi, ebx
  00059	75 eb		 jne	 SHORT $LL18@Uninitiali
$LN17@Uninitiali:

; 170  : 		_First = _Last;

  0005b	89 7d e8	 mov	 DWORD PTR __Backout$2[ebp], edi

; 193  : 	return (_Backout._Release());

  0005e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 		_Destroy_range(_First, _Last, _Al);

  00065	8b d7		 mov	 edx, edi
  00067	51		 push	 ecx
  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006f	83 c4 04	 add	 esp, 4

; 210  : 		// note: only called internally from elsewhere in the STL
; 211  : 	const auto _UFirst = _Get_unwrapped(_First);
; 212  : 	const auto _ULast = _Get_unwrapped(_Last);
; 213  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 214  : 	_Seek_wrapped(_Dest,
; 215  : 		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 216  : 			_Ptr_copy_cat(_UFirst, _UDest),
; 217  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));
; 218  : 
; 219  : 	return (_Dest);

  00072	8b c7		 mov	 eax, edi

; 220  : 	}

  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$advance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
??$advance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::advance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1208 : 	_Where += _Off;

  00000	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	01 01		 add	 DWORD PTR [ecx], eax

; 1215 : 		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
; 1216 : 	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
; 1217 : 	}

  00008	c3		 ret	 0
??$advance@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::advance<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_copy_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_copy_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1070 : 	return {};

  00000	32 c0		 xor	 al, al

; 1071 : 	}

  00002	c3		 ret	 0
??$_Ptr_copy_cat@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_copy_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2411 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b da		 mov	 ebx, edx
  00007	8b f1		 mov	 esi, ecx

; 2412 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  00009	3b f3		 cmp	 esi, ebx
  0000b	74 2e		 je	 SHORT $LN88@Copy_unche
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL4@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2467 : 		if (this != _STD addressof(_Right))

  00011	3b fe		 cmp	 edi, esi
  00013	74 15		 je	 SHORT $LN2@Copy_unche

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00015	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00019	8b c6		 mov	 eax, esi

; 1815 : 		if (_Large_string_engaged())

  0001b	72 02		 jb	 SHORT $LN77@Copy_unche
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0001d	8b 06		 mov	 eax, DWORD PTR [esi]
$LN77@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2481 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0001f	ff 76 10	 push	 DWORD PTR [esi+16]
  00022	8b cf		 mov	 ecx, edi
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Copy_unche:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility

; 2412 : 	for (; _First != _Last; ++_Dest, (void)++_First)

  0002a	83 c6 18	 add	 esi, 24			; 00000018H
  0002d	83 c7 18	 add	 edi, 24			; 00000018H
  00030	3b f3		 cmp	 esi, ebx
  00032	75 dd		 jne	 SHORT $LL4@Copy_unche

; 2413 : 		{
; 2414 : 		*_Dest = *_First;
; 2415 : 		}
; 2416 : 
; 2417 : 	return (_Dest);

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 2418 : 	}

  00038	5b		 pop	 ebx
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
$LN88@Copy_unche:

; 2413 : 		{
; 2414 : 		*_Dest = *_First;
; 2415 : 		}
; 2416 : 
; 2417 : 	return (_Dest);

  0003b	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003e	5e		 pop	 esi

; 2418 : 	}

  0003f	5b		 pop	 ebx
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Copy_unchecked1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z PROC	; std::_Copy_memmove<void * *,void * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2399 : 	char const*  const _First_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	char const*  const _Last_ch = const_cast<char const* >(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00004	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	2b f9		 sub	 edi, ecx
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00017	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi

; 2405 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Copy_memmove@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ENDP	; std::_Copy_memmove<void * *,void * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2466 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2467 : 		if (this != _STD addressof(_Right))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f0		 cmp	 esi, eax
  0000b	74 14		 je	 SHORT $LN32@operator

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0000d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2481 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00011	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]

; 1815 : 		if (_Large_string_engaged())

  00014	72 02		 jb	 SHORT $LN26@operator
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00016	8b 00		 mov	 eax, DWORD PTR [eax]
$LN26@operator:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring

; 2481 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00018	51		 push	 ecx
  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN32@operator:

; 2482 : 			}
; 2483 : 
; 2484 : 		return (*this);
; 2485 : 		}

  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 1923 : 		_Pocca(_Getal(), _Al);
; 1924 : 		}

  00000	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
_TEXT	SEGMENT
__Backout$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Dest$ = 8						; size = 4
__Al$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 186  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b da		 mov	 ebx, edx
  0002a	8b f1		 mov	 esi, ecx

; 147  : 		: _First(_Dest),

  0002c	8b 7d 08	 mov	 edi, DWORD PTR __Dest$[ebp]

; 148  : 		_Last(_Dest),
; 149  : 		_Al(_Al_)

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00032	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi
  00035	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi
  00038	89 45 f0	 mov	 DWORD PTR __Backout$[ebp+8], eax

; 187  : 	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 188  : 	for (; _First != _Last; ++_First)

  00042	3b f3		 cmp	 esi, ebx
  00044	74 15		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00046	56		 push	 esi
  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  0004e	83 c7 18	 add	 edi, 24			; 00000018H

; 188  : 	for (; _First != _Last; ++_First)

  00051	83 c6 18	 add	 esi, 24			; 00000018H

; 165  : 		++_Last;

  00054	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi

; 188  : 	for (; _First != _Last; ++_First)

  00057	3b f3		 cmp	 esi, ebx
  00059	75 eb		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 170  : 		_First = _Last;

  0005b	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi

; 189  : 		{
; 190  : 		_Backout._Emplace_back(*_First);
; 191  : 		}
; 192  : 
; 193  : 	return (_Backout._Release());

  0005e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 158  : 		_Destroy_range(_First, _Last, _Al);

  00065	8b d7		 mov	 edx, edi
  00067	51		 push	 ecx
  00068	8b cf		 mov	 ecx, edi
  0006a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006f	83 c4 04	 add	 esp, 4

; 189  : 		{
; 190  : 		_Backout._Emplace_back(*_First);
; 191  : 		}
; 192  : 
; 193  : 	return (_Backout._Release());

  00072	8b c7		 mov	 eax, edi

; 194  : 	}

  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@QAV10@1AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_General_ptr_iterator_tag@0@U_Unused_parameter@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Advance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Advance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,int>, COMDAT
; __Where$ = ecx
; __Off$ = edx

; 1208 : 	_Where += _Off;

  00000	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00003	c1 e0 03	 shl	 eax, 3
  00006	01 01		 add	 DWORD PTR [ecx], eax

; 1209 : 	}

  00008	c3		 ret	 0
??$_Advance1@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance1<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT
; __Val$ = ecx

; 330  : 	return (__builtin_addressof(_Val));

  00000	8b c1		 mov	 eax, ecx

; 331  : 	}

  00002	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1081 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1082 : 	_Pocca(_Left, _Right, _Tag);
; 1083 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Emplace_back@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00004	ff 75 08	 push	 DWORD PTR _<_Vals_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 163  : 		{	// construct a new element at *_Last and increment

  00007	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00009	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory

; 165  : 		++_Last;

  00011	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00015	5e		 pop	 esi

; 166  : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$_Emplace_back@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1076 : 	}

  00000	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00000	8b c1		 mov	 eax, ecx

; 1575 : 	}

  00002	c3		 ret	 0
??$forward@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\professional\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; ___formal$dead$ = ecx
; __Ptr$ = edx

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _<_Args_0>$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@?$_Default_allocator_traits@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@SAXAAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
END
